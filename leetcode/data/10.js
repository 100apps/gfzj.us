{
	"difficulty":"3",
	"submit_num":"738778",
	"show_id":"10",
	"leetcode_id":"10",
	"answers":[
		{
			"lc_ans_id":"5665",
			"view":"72607",
			"top":"0",
			"title":"My concise recursive and DP solutions with full explanation in C++",
			"vote":"248",
			"content":"Please refer to [my blog post][1] if you have any comment. Wildcard matching problem can be solved similarly.\\n\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            if (p.empty())    return s.empty();\\n            \\n            if ('*' == p[1])\\n                // x* matches empty string or at least one character: x* -> xx*\\n                // *s is to ensure s is non-empty\\n                return (isMatch(s, p.substr(2)) || !s.empty() && (s[0] == p[0] || '.' == p[0]) && isMatch(s.substr(1), p));\\n            else\\n                return !s.empty() && (s[0] == p[0] || '.' == p[0]) && isMatch(s.substr(1), p.substr(1));\\n        }\\n    };\\n    \\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            /**\\n             * f[i][j]: if s[0..i-1] matches p[0..j-1]\\n             * if p[j - 1] != '*'\\n             *      f[i][j] = f[i - 1][j - 1] && s[i - 1] == p[j - 1]\\n             * if p[j - 1] == '*', denote p[j - 2] with x\\n             *      f[i][j] is true iff any of the following is true\\n             *      1) \"x*\" repeats 0 time and matches empty: f[i][j - 2]\\n             *      2) \"x*\" repeats >= 1 times and matches \"x*x\": s[i - 1] == x && f[i - 1][j]\\n             * '.' matches any single character\\n             */\\n            int m = s.size(), n = p.size();\\n            vector<vector<bool>> f(m + 1, vector<bool>(n + 1, false));\\n            \\n            f[0][0] = true;\\n            for (int i = 1; i <= m; i++)\\n                f[i][0] = false;\\n            // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is '*' and p[0..j - 3] matches empty\\n            for (int j = 1; j <= n; j++)\\n                f[0][j] = j > 1 && '*' == p[j - 1] && f[0][j - 2];\\n            \\n            for (int i = 1; i <= m; i++)\\n                for (int j = 1; j <= n; j++)\\n                    if (p[j - 1] != '*')\\n                        f[i][j] = f[i - 1][j - 1] && (s[i - 1] == p[j - 1] || '.' == p[j - 1]);\\n                    else\\n                        // p[0] cannot be '*' so no need to check \"j > 1\" here\\n                        f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || '.' == p[j - 2]) && f[i - 1][j];\\n            \\n            return f[m][n];\\n        }\\n    };\\n\\n  [1]: http://xiaohuiliucuriosity.blogspot.com/2014/12/regular-expression-matching.html"
		},
		{
			"lc_ans_id":"5651",
			"view":"62932",
			"top":"1",
			"title":"Easy DP Java Solution with detailed Explanation",
			"vote":"219",
			"content":"This Solution use 2D DP. beat 90% solutions, very simple.\\n\\nHere are some conditions to figure out, then the logic can be very straightforward.\\n\\n    1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];\\n    2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];\\n    3, If p.charAt(j) == '*': \\n       here are two sub conditions:\\n                   1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty\\n                   2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':\\n                                  dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a \\n                               or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a\\n                               or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty\\n\\nHere is the solution\\n\\n    public boolean isMatch(String s, String p) {\\n\\n        if (s == null || p == null) {\\n            return false;\\n        }\\n        boolean[][] dp = new boolean[s.length()+1][p.length()+1];\\n        dp[0][0] = true;\\n        for (int i = 0; i < p.length(); i++) {\\n            if (p.charAt(i) == '*' && dp[0][i-1]) {\\n                dp[0][i+1] = true;\\n            }\\n        }\\n        for (int i = 0 ; i < s.length(); i++) {\\n            for (int j = 0; j < p.length(); j++) {\\n                if (p.charAt(j) == '.') {\\n                    dp[i+1][j+1] = dp[i][j];\\n                }\\n                if (p.charAt(j) == s.charAt(i)) {\\n                    dp[i+1][j+1] = dp[i][j];\\n                }\\n                if (p.charAt(j) == '*') {\\n                    if (p.charAt(j-1) != s.charAt(i) && p.charAt(j-1) != '.') {\\n                        dp[i+1][j+1] = dp[i+1][j-1];\\n                    } else {\\n                        dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }"
		},
		{
			"lc_ans_id":"5647",
			"view":"35336",
			"top":"2",
			"title":"In the given examples, the last one isMatch(\"aab\", \"c*a*b\") \\u2192 true; don't understand why it is true?",
			"vote":"144",
			"content":"In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
		},
		{
			"lc_ans_id":"5659",
			"view":"36605",
			"top":"3",
			"title":"The shortest AC code.",
			"vote":"93",
			"content":"  1.'.' is easy to handle. if p has a '.', it can pass any single character in s except '\\\\0'.\\n\\n2.'*' is a totally different problem. if p has a '*' character, it can pass any length of first-match characters in s including '\\\\0'.\\n\\n\\n\\n      class Solution {\\n        public:\\n        bool matchFirst(const char *s, const char *p){\\n            return (*p == *s || (*p == '.' && *s != '\\\\0'));\\n        }\\n    \\n    bool isMatch(const char *s, const char *p) {\\n    \\tif (*p == '\\\\0') return *s == '\\\\0';\\t//empty\\n    \\n    \\tif (*(p + 1) != '*') {//without *\\n    \\t\\tif(!matchFirst(s,p)) return false;\\n    \\t\\treturn isMatch(s + 1, p + 1);\\n    \\t} else { //next: with a *\\n        \\tif(isMatch(s, p + 2)) return true;    //try the length of 0\\n    \\t\\twhile ( matchFirst(s,p) )       //try all possible lengths \\n    \\t\\t\\tif (isMatch(++s, p + 2))return true;\\n    \\t}\\n    }\\n    };"
		},
		{
			"lc_ans_id":"5684",
			"view":"23051",
			"top":"4",
			"title":"9-lines 16ms C++ DP Solutions with Explanations",
			"vote":"85",
			"content":"This problem has a typical solution using Dynamic Programming. We define the state `P[i][j]` to be `true` if `s[0..i)` matches `p[0..j)` and `false` otherwise. Then the state equations are:\\n\\n 1. `P[i][j] = P[i - 1][j - 1]`, if `p[j - 1] != '*' && (s[i - 1] == p[j - 1] || p[j - 1] == '.')`;\\n 2. `P[i][j] = P[i][j - 2]`, if `p[j - 1] == '*'` and the pattern repeats for `0` times;\\n 3. `P[i][j] = P[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`, if `p[j - 1] == '*'` and the pattern repeats for at least `1` times.\\n\\nPutting these together, we will have the following code.\\n \\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int m = s.length(), n = p.length(); \\n            vector<vector<bool> > dp(m + 1, vector<bool> (n + 1, false));\\n            dp[0][0] = true;\\n            for (int i = 0; i <= m; i++)\\n                for (int j = 1; j <= n; j++)\\n                    if (p[j - 1] == '*')\\n                        dp[i][j] = dp[i][j - 2] || (i > 0 && (s[i - 1] == p[j - 2] || p[j - 2] == '.') && dp[i - 1][j]);\\n                    else dp[i][j] = i > 0 && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.');\\n            return dp[m][n];\\n        }\\n    };"
		},
		{
			"lc_ans_id":"5723",
			"view":"7584",
			"top":"5",
			"title":"My DP approach in Python with comments and unittest",
			"vote":"65",
			"content":"I shared my DP approach with comments and provided some unit tests for it. Some statements in the approach directly affect some corner cases, for example, comment out line 22-23, then the unittest `test_symbol_0` will fail. Hope this script helps us better understand the problem.\\n\\n    import unittest\\n    \\n    \\n    class Solution(object):\\n        def isMatch(self, s, p):\\n            # The DP table and the string s and p use the same indexes i and j, but\\n            # table[i][j] means the match status between p[:i] and s[:j], i.e.\\n            # table[0][0] means the match status of two empty strings, and\\n            # table[1][1] means the match status of p[0] and s[0]. Therefore, when\\n            # refering to the i-th and the j-th characters of p and s for updating\\n            # table[i][j], we use p[i - 1] and s[j - 1].\\n    \\n            # Initialize the table with False. The first row is satisfied.\\n            table = [[False] * (len(s) + 1) for _ in range(len(p) + 1)]\\n    \\n            # Update the corner case of matching two empty strings.\\n            table[0][0] = True\\n    \\n            # Update the corner case of when s is an empty string but p is not.\\n            # Since each '*' can eliminate the charter before it, the table is\\n            # vertically updated by the one before previous. [test_symbol_0]\\n            for i in range(2, len(p) + 1):\\n                table[i][0] = table[i - 2][0] and p[i - 1] == '*'\\n    \\n            for i in range(1, len(p) + 1):\\n                for j in range(1, len(s) + 1):\\n                    if p[i - 1] != \"*\":\\n                        # Update the table by referring the diagonal element.\\n                        table[i][j] = table[i - 1][j - 1] and \\\\\\n                                      (p[i - 1] == s[j - 1] or p[i - 1] == '.')\\n                    else:\\n                        # Eliminations (referring to the vertical element)\\n                        # Either refer to the one before previous or the previous.\\n                        # I.e. * eliminate the previous or count the previous.\\n                        # [test_symbol_1]\\n                        table[i][j] = table[i - 2][j] or table[i - 1][j]\\n    \\n                        # Propagations (referring to the horizontal element)\\n                        # If p's previous one is equal to the current s, with\\n                        # helps of *, the status can be propagated from the left.\\n                        # [test_symbol_2]\\n                        if p[i - 2] == s[j - 1] or p[i - 2] == '.':\\n                            table[i][j] |= table[i][j - 1]\\n    \\n            return table[-1][-1]\\n    \\n    \\n    class TestSolution(unittest.TestCase):\\n        def test_none_0(self):\\n            s = \"\"\\n            p = \"\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n        def test_none_1(self):\\n            s = \"\"\\n            p = \"a\"\\n            self.assertFalse(Solution().isMatch(s, p))\\n    \\n        def test_no_symbol_equal(self):\\n            s = \"abcd\"\\n            p = \"abcd\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n        def test_no_symbol_not_equal_0(self):\\n            s = \"abcd\"\\n            p = \"efgh\"\\n            self.assertFalse(Solution().isMatch(s, p))\\n    \\n        def test_no_symbol_not_equal_1(self):\\n            s = \"ab\"\\n            p = \"abb\"\\n            self.assertFalse(Solution().isMatch(s, p))\\n    \\n        def test_symbol_0(self):\\n            s = \"\"\\n            p = \"a*\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n        def test_symbol_1(self):\\n            s = \"a\"\\n            p = \"ab*\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n        def test_symbol_2(self):\\n            # E.g.\\n            #   s a b b\\n            # p 1 0 0 0\\n            # a 0 1 0 0\\n            # b 0 0 1 0\\n            # * 0 1 1 1\\n            s = \"abb\"\\n            p = \"ab*\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n    \\n    if __name__ == \"__main__\":\\n        unittest.main()"
		},
		{
			"lc_ans_id":"5931",
			"view":"9517",
			"top":"6",
			"title":"Clean Java Solution",
			"vote":"58",
			"content":"    public boolean isMatch(String s, String p) {\\n        if (p.isEmpty()) {\\n            return s.isEmpty();\\n        }\\n\\n        if (p.length() == 1 || p.charAt(1) != '*') {\\n            if (s.isEmpty() || (p.charAt(0) != '.' && p.charAt(0) != s.charAt(0))) {\\n                return false;\\n            } else {\\n                return isMatch(s.substring(1), p.substring(1));\\n            }\\n        }\\n        \\n        //P.length() >=2\\n        while (!s.isEmpty() && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.')) {  \\n            if (isMatch(s, p.substring(2))) { \\n                return true;                     \\n            }                                    \\n            s = s.substring(1);\\n        }\\n\\n        return isMatch(s, p.substring(2));\\n    }"
		},
		{
			"lc_ans_id":"5678",
			"view":"4857",
			"top":"7",
			"title":"Fast Python solution with backtracking and caching + DP solution",
			"vote":"23",
			"content":"Takes about 174ms:\\n\\n     \\n    cache = {}\\n    def isMatch(self, s, p):\\n        if (s, p) in self.cache:\\n            return self.cache[(s, p)]\\n        if not p:\\n            return not s\\n        if p[-1] == '*':\\n            if self.isMatch(s, p[:-2]):\\n                self.cache[(s, p)] = True\\n                return True\\n            if s and (s[-1] == p[-2] or p[-2] == '.') and self.isMatch(s[:-1], p):\\n                self.cache[(s, p)] = True\\n                return True\\n        if s and (p[-1] == s[-1] or p[-1] == '.') and self.isMatch(s[:-1], p[:-1]):\\n            self.cache[(s, p)] = True\\n            return True\\n        self.cache[(s, p)] = False\\n        return False\\n\\n\\nDP version:\\n    \\n    def isMatch(self, s, p):\\n        dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)]\\n        dp[0][0] = True\\n        for i in range(1, len(p)):\\n            dp[i + 1][0] = dp[i - 1][0] and p[i] == '*'\\n        for i in range(len(p)):\\n            for j in range(len(s)):\\n                if p[i] == '*':\\n                    dp[i + 1][j + 1] = dp[i - 1][j + 1] or dp[i][j + 1]\\n                    if p[i - 1] == s[j] or p[i - 1] == '.':\\n                        dp[i + 1][j + 1] |= dp[i + 1][j]\\n                else:\\n                    dp[i + 1][j + 1] = dp[i][j] and (p[i] == s[j] or p[i] == '.')\\n        return dp[-1][-1]"
		},
		{
			"lc_ans_id":"5937",
			"view":"4475",
			"top":"8",
			"title":"My 4ms C++ DP solution (another recursive version also given 72ms)",
			"vote":"20",
			"content":"Just to build a DP table  checked, where checked[i][j] indicates whether s[0..i-1] matches with p[0..j-1]. The recursive relationship is as below:\\nTo match with the empty string s[0..0] (i.e. to make checked[0][j]), P[0..j-1] has to meet: p[j-1]=='*' (to cancel p[j-2]) and checked[0][j-2] == true;\\nTo match with the string s[0..i-1] (i.e. to make checked[i][j]), P[0..j-1] has to meet: \\n\\n 1. if p[j-1] =='*', then j must be larger than 1 (j>1) and\\n \\n - checked[i][j-2] (i.e. p[j-2] cancelled by '*')\\n - checked[i-1][j]    && (s[i-1] ==p[j-2] || p[j-2] =='.')  (s[i-1] matches with p[j-2] or '.', )\\n\\n 2. if p[j-1] !='*',  checked[i-1][j-1] && (s[i-1] ==p[j-1] || p[j-1] =='.')(i.e. s[i-1]  matches with p[j-1] or '.')\\n\\n\\n\\n \\n\\n   class Solution {\\n    \\n        public:\\n            bool isMatch(string s, string p) {\\n                int sSize = s.size(), pSize = p.size(), i, j;\\n                bool checked[sSize+1][pSize+1];\\n        //        fill_n(&matched[0][0], (sSize+1)*(pSize+1), false);\\n                \\n                for(j=2, checked[0][0]=true, checked[0][1]= false; j<=pSize; ++j) // match s[0..0]\\n                    checked[0][j] = p[j-1] == '*'? checked[0][j-2]  : false;\\n                for(i=1; i<=sSize; ++i)\\n                for(j=1, checked[i][0]=false; j<=pSize; ++j)\\n                {\\n                    if(p[j-1]=='*') // case (1)\\n                        checked[i][j] = (j>1) && ( checked[i][j-2]  || ( ( checked[i-1][j]) && (s[i-1]== p[j-2] || p[j-2] == '.')) );\\n                    else // case (2)\\n                        checked[i][j] = checked[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.');        \\n                }\\n                return checked[sSize][pSize];\\n            }\\n        };\\n\\nA recursive version, divide cases into two groups (if the next p char is '*' or not)\\n\\n    class Solution {\\n    private:\\n        bool helper(const string &s, const string &p, int sS, int pS)\\n        {\\n            int sSize = s.size(), pSize = p.size(), i, j; \\n            if(pS==pSize) return sS ==sSize; // if p goes to its end, then only if s also goes to its end to return true;\\n            \\n            if(p[pS+1]!='*')\\n            {\\n               if( sS<sSize && (p[pS]==s[sS] || p[pS] == '.')) return helper(s, p, sS+1, pS+1);\\n            }\\n            else\\n            {\\n                if(helper(s, p, sS,pS+2)) return true;\\n                while(sS<sSize && (p[pS]==s[sS] || p[pS] == '.')) if(helper(s,p, ++sS, pS+2)) return true;\\n            }\\n            return false;\\n        }\\n    \\n    public:\\n        bool isMatch(string s, string p) {\\n           helper(s, p, 0, 0); \\n        }\\n    };"
		},
		{
			"lc_ans_id":"5941",
			"view":"4485",
			"top":"9",
			"title":"My AC DP solution for this problem, asking for improvements.",
			"vote":"20",
			"content":"    public boolean isMatch(String s, String p) {\\n        int m = s.length();\\n        int n = p.length();\\n        \\n        if (s == null || p == null) {\\n            return false;\\n        }\\n        \\n        boolean[][] OPT = new boolean[m+1][n+1];\\n        OPT[0][0] = true;\\n        \\n        for (int i = 1; i <= m; i++) {\\n            OPT[i][0] = false;\\n        }\\n        for (int j = 1; j <= n; j++) {\\n            OPT[0][j] = (p.charAt(j-1) == '*') && (j-2 >= 0) && OPT[0][j-2];\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                OPT[i][j] = ((OPT[i-1][j-1]) && equals(s, p, i-1, j-1))\\n                        ||  ((OPT[i-1][j] || OPT[i][j-1]) \\n                            && (p.charAt(j-1) == '*') \\n                            && equals(s, p, i-1, j-2))\\n                        ||  ((p.charAt(j-1) == '*') && (j-2 >= 0) && OPT[i][j-2]);\\n            }\\n        }\\n        \\n        return OPT[m][n];\\n    }\\n    \\n    private boolean equals(String s, String p, int si, int pi) {\\n        return (s.charAt(si) == p.charAt(pi) || p.charAt(pi) == '.');\\n    }\\n\\nBasically, the OPT[i][j] means preceding substring of length i of s and length j of p. For any two substrings, the value of OPT[i][j] can be from one of following four cases:\\n\\n - case 1: OPT[i-1][j-1] is true, and ith character of s is equal to j th character of p. Or j th character of p is '.'\\n - case 2: OPT[i-1][j] is true, then my pattern now is '*' and preceding character is equal to incoming character of s\\n - case 3: OPT[i][j-1] is true, then my pattern now is '*' which can match an empty string\\n - case 4: OPT[i][j-2] is true, and the pattern like (a*) matches an empty string\\n\\nbase case is the OPT[0][0], OPT[i][0], OPT[0][j]."
		}
	],
	"id":"10",
	"title":"Regular Expression Matching",
	"content":"<p>Implement regular expression matching with support for <code>'.'</code> and <code>'*'</code>.</p>\r\n\r\n<pre>\r\n'.' Matches any single character.\r\n'*' Matches zero or more of the preceding element.\r\n\r\nThe matching should cover the <b>entire</b> input string (not partial).\r\n\r\nThe function prototype should be:\r\nbool isMatch(const char *s, const char *p)\r\n\r\nSome examples:\r\nisMatch(\"aa\",\"a\") &rarr; false\r\nisMatch(\"aa\",\"aa\") &rarr; true\r\nisMatch(\"aaa\",\"aa\") &rarr; false\r\nisMatch(\"aa\", \"a*\") &rarr; true\r\nisMatch(\"aa\", \".*\") &rarr; true\r\nisMatch(\"ab\", \".*\") &rarr; true\r\nisMatch(\"aab\", \"c*a*b\") &rarr; true\r\n</pre>",
	"frequency":"567",
	"ac_num":"179797"
}