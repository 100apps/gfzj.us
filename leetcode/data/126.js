{
	"difficulty":"3",
	"submit_num":"531728",
	"show_id":"126",
	"leetcode_id":"126",
	"answers":[
		{
			"lc_ans_id":"40447",
			"view":"41322",
			"top":"0",
			"title":"Share two similar Java solution that Accpted by OJ.",
			"vote":"85",
			"content":"The solution contains two steps 1 Use BFS to construct a graph. 2. Use DFS to construct the paths from end to start.Both solutions got AC within 1s. \\n\\nThe first step BFS is quite important. I summarized three tricks\\n\\n1) Using a **MAP** to store the min ladder of each word, or use a **SET** to store the words visited in current ladder, when the current ladder was completed, delete the visited words from unvisited. That's why I have two similar solutions. \\n\\n\\n2) Use **Character iteration** to find all possible paths. Do not compare one word to all the other words and check if they only differ by one character.\\n\\n\\n3) One word is allowed to be inserted into the queue only **ONCE**. See my comments.\\n\\n\\n    public class Solution {\\n    \\tMap<String,List<String>> map;\\n    \\tList<List<String>> results;\\n        public List<List<String>> findLadders(String start, String end, Set<String> dict) {   \\t\\n            results= new ArrayList<List<String>>();\\n            if (dict.size() == 0)\\n    \\t\\t\\treturn results;\\n            \\n            int min=Integer.MAX_VALUE;\\n            \\n            Queue<String> queue= new ArrayDeque<String>();\\n            queue.add(start);\\n            \\n    \\t\\tmap = new HashMap<String,List<String>>();\\n    \\t\\t\\n    \\t\\tMap<String,Integer> ladder = new HashMap<String,Integer>();\\n    \\t\\tfor (String string:dict)\\n    \\t\\t    ladder.put(string, Integer.MAX_VALUE);\\n    \\t\\tladder.put(start, 0);\\n    \\t\\t\\t\\t\\n    \\t\\tdict.add(end);\\n    \\t\\t//BFS: Dijisktra search\\n    \\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t   \\n    \\t\\t\\tString word = queue.poll();\\n    \\t\\t\\t\\n    \\t\\t\\tint step = ladder.get(word)+1;//'step' indicates how many steps are needed to travel to one word. \\n    \\t\\t\\t\\n    \\t\\t\\tif (step>min) break;\\n    \\t\\t\\t\\n    \\t\\t\\tfor (int i = 0; i < word.length(); i++){\\n    \\t\\t\\t   StringBuilder builder = new StringBuilder(word); \\n    \\t\\t\\t\\tfor (char ch='a';  ch <= 'z'; ch++){\\n    \\t\\t\\t\\t\\tbuilder.setCharAt(i,ch);\\n    \\t\\t\\t\\t\\tString new_word=builder.toString();\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tif (ladder.containsKey(new_word)) {\\n    \\t\\t\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\t    if (step>ladder.get(new_word))//Check if it is the shortest path to one word.\\n    \\t\\t\\t\\t\\t    \\tcontinue;\\n    \\t\\t\\t\\t\\t    else if (step<ladder.get(new_word)){\\n    \\t\\t\\t\\t\\t    \\tqueue.add(new_word);\\n    \\t\\t\\t\\t\\t    \\tladder.put(new_word, step);\\n    \\t\\t\\t\\t\\t    }else;// It is a KEY line. If one word already appeared in one ladder,\\n    \\t\\t\\t\\t\\t          // Do not insert the same word inside the queue twice. Otherwise it gets TLE.\\n    \\t\\t\\t\\t\\t    \\n    \\t\\t\\t\\t\\t    if (map.containsKey(new_word)) //Build adjacent Graph\\n    \\t\\t\\t\\t\\t    \\tmap.get(new_word).add(word);\\n    \\t\\t\\t\\t\\t    else{\\n    \\t\\t\\t\\t\\t    \\tList<String> list= new LinkedList<String>();\\n    \\t\\t\\t\\t\\t    \\tlist.add(word);\\n    \\t\\t\\t\\t\\t    \\tmap.put(new_word,list);\\n    \\t\\t\\t\\t\\t    \\t//It is possible to write three lines in one:\\n    \\t\\t\\t\\t\\t    \\t//map.put(new_word,new LinkedList<String>(Arrays.asList(new String[]{word})));\\n    \\t\\t\\t\\t\\t    \\t//Which one is better?\\n    \\t\\t\\t\\t\\t    }\\n    \\t\\t\\t\\t\\t    \\n    \\t\\t\\t\\t\\t    if (new_word.equals(end))\\n    \\t\\t\\t\\t\\t    \\tmin=step;\\n    \\n    \\t\\t\\t\\t\\t}//End if dict contains new_word\\n    \\t\\t\\t\\t}//End:Iteration from 'a' to 'z'\\n    \\t\\t\\t}//End:Iteration from the first to the last\\n    \\t\\t}//End While\\n    \\n        \\t//BackTracking\\n    \\t\\tLinkedList<String> result = new LinkedList<String>();\\n    \\t\\tbackTrace(end,start,result);\\n    \\n    \\t\\treturn results;        \\n        }\\n        private void backTrace(String word,String start,List<String> list){\\n        \\tif (word.equals(start)){\\n        \\t\\tlist.add(0,start);\\n        \\t\\tresults.add(new ArrayList<String>(list));\\n        \\t\\tlist.remove(0);\\n        \\t\\treturn;\\n        \\t}\\n        \\tlist.add(0,word);\\n        \\tif (map.get(word)!=null)\\n        \\t\\tfor (String s:map.get(word))\\n        \\t\\t\\tbackTrace(s,start,list);\\n        \\tlist.remove(0);\\n        }\\n    }\\n\\n\\nAnother solution using two sets. This is similar to the answer in the  most viewed thread. While I found my solution more readable and efficient. \\n\\n    public class Solution {\\n    \\tList<List<String>> results;\\n    \\tList<String> list;\\n    \\tMap<String,List<String>> map;\\n    \\t    public List<List<String>> findLadders(String start, String end, Set<String> dict) {\\n    \\t        results= new ArrayList<List<String>>();\\n    \\t        if (dict.size() == 0)\\n    \\t\\t\\t\\treturn results;\\n    \\t        \\n    \\t        int curr=1,next=0;\\t        \\n    \\t        boolean found=false;\\t        \\n    \\t        list = new LinkedList<String>();\\t       \\n    \\t\\t\\tmap = new HashMap<String,List<String>>();\\n    \\t\\t\\t\\n    \\t\\t\\tQueue<String> queue= new ArrayDeque<String>();\\n    \\t\\t\\tSet<String> unvisited = new HashSet<String>(dict);\\n    \\t\\t\\tSet<String> visited = new HashSet<String>();\\n    \\t\\t\\t\\n    \\t\\t\\tqueue.add(start);\\t\\t\\t\\n    \\t\\t\\tunvisited.add(end);\\n    \\t\\t\\tunvisited.remove(start);\\n    \\t\\t\\t//BFS\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t   \\n    \\t\\t\\t\\tString word = queue.poll();\\n    \\t\\t\\t\\tcurr--;\\t\\t\\t\\t\\n    \\t\\t\\t\\tfor (int i = 0; i < word.length(); i++){\\n    \\t\\t\\t\\t   StringBuilder builder = new StringBuilder(word); \\n    \\t\\t\\t\\t\\tfor (char ch='a';  ch <= 'z'; ch++){\\n    \\t\\t\\t\\t\\t\\tbuilder.setCharAt(i,ch);\\n    \\t\\t\\t\\t\\t\\tString new_word=builder.toString();\\t\\n    \\t\\t\\t\\t\\t\\tif (unvisited.contains(new_word)){\\n    \\t\\t\\t\\t\\t\\t\\t//Handle queue\\n    \\t\\t\\t\\t\\t\\t\\tif (visited.add(new_word)){//Key statement,Avoid Duplicate queue insertion\\n    \\t\\t\\t\\t\\t\\t\\t\\tnext++;\\n    \\t\\t\\t\\t\\t\\t\\t\\tqueue.add(new_word);\\n    \\t\\t\\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\t\\t\\tif (map.containsKey(new_word))//Build Adjacent Graph\\n    \\t\\t\\t\\t\\t\\t\\t\\tmap.get(new_word).add(word);\\n    \\t\\t\\t\\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\t\\t\\t\\tList<String> l= new LinkedList<String>();\\n    \\t\\t\\t\\t\\t\\t\\t\\tl.add(word);\\n    \\t\\t\\t\\t\\t\\t\\t\\tmap.put(new_word, l);\\n    \\t\\t\\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\t\\t\\tif (new_word.equals(end)&&!found) found=true;\\t\\t\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\t\\t}\\n    \\n    \\t\\t\\t\\t\\t}//End:Iteration from 'a' to 'z'\\n    \\t\\t\\t\\t}//End:Iteration from the first to the last\\n    \\t\\t\\t\\tif (curr==0){\\n    \\t\\t\\t\\t\\tif (found) break;\\n    \\t\\t\\t\\t\\tcurr=next;\\n    \\t\\t\\t\\t\\tnext=0;\\n    \\t\\t\\t\\t\\tunvisited.removeAll(visited);\\n    \\t\\t\\t\\t\\tvisited.clear();\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}//End While\\n    \\n    \\t\\t\\tbackTrace(end,start);\\n    \\t\\t\\t\\n    \\t\\t\\treturn results;        \\n    \\t    }\\n    \\t    private void backTrace(String word,String start){\\n    \\t    \\tif (word.equals(start)){\\n    \\t    \\t\\tlist.add(0,start);\\n    \\t    \\t\\tresults.add(new ArrayList<String>(list));\\n    \\t    \\t\\tlist.remove(0);\\n    \\t    \\t\\treturn;\\n    \\t    \\t}\\n    \\t    \\tlist.add(0,word);\\n    \\t    \\tif (map.get(word)!=null)\\n    \\t    \\t\\tfor (String s:map.get(word))\\n    \\t    \\t\\t\\tbackTrace(s,start);\\n    \\t    \\tlist.remove(0);\\n    \\t    }\\n    \\t}"
		},
		{
			"lc_ans_id":"40475",
			"view":"23592",
			"top":"1",
			"title":"My concise JAVA solution based on BFS and DFS",
			"vote":"67",
			"content":"**Explanation**\\n\\nThe basic idea is:\\n\\n1). Use BFS to find the shortest distance between start and end, tracing the distance of crossing nodes from start node to end node, and store node's next level neighbors to HashMap;\\n\\n2). Use DFS to output paths with the same distance as the shortest distance from distance HashMap: compare if the distance of the next level node equals the distance of the current node + 1. \\n\\n```\\npublic List<List<String>> findLadders(String start, String end, List<String> wordList) {\\n   HashSet<String> dict = new HashSet<String>(wordList);\\n   List<List<String>> res = new ArrayList<List<String>>();         \\n   HashMap<String, ArrayList<String>> nodeNeighbors = new HashMap<String, ArrayList<String>>();// Neighbors for every node\\n   HashMap<String, Integer> distance = new HashMap<String, Integer>();// Distance of every node from the start node\\n   ArrayList<String> solution = new ArrayList<String>();\\n\\n   dict.add(start);          \\n   bfs(start, end, dict, nodeNeighbors, distance);                 \\n   dfs(start, end, dict, nodeNeighbors, distance, solution, res);   \\n   return res;\\n}\\n\\n// BFS: Trace every node's distance from the start node (level by level).\\nprivate void bfs(String start, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance) {\\n  for (String str : dict)\\n      nodeNeighbors.put(str, new ArrayList<String>());\\n\\n  Queue<String> queue = new LinkedList<String>();\\n  queue.offer(start);\\n  distance.put(start, 0);\\n\\n  while (!queue.isEmpty()) {\\n      int count = queue.size();\\n      boolean foundEnd = false;\\n      for (int i = 0; i < count; i++) {\\n          String cur = queue.poll();\\n          int curDistance = distance.get(cur);                \\n          ArrayList<String> neighbors = getNeighbors(cur, dict);\\n\\n          for (String neighbor : neighbors) {\\n              nodeNeighbors.get(cur).add(neighbor);\\n              if (!distance.containsKey(neighbor)) {// Check if visited\\n                  distance.put(neighbor, curDistance + 1);\\n                  if (end.equals(neighbor))// Found the shortest path\\n                      foundEnd = true;\\n                  else\\n                      queue.offer(neighbor);\\n                  }\\n              }\\n          }\\n\\n          if (foundEnd)\\n              break;\\n      }\\n  }\\n\\n// Find all next level nodes.    \\nprivate ArrayList<String> getNeighbors(String node, Set<String> dict) {\\n  ArrayList<String> res = new ArrayList<String>();\\n  char chs[] = node.toCharArray();\\n\\n  for (char ch ='a'; ch <= 'z'; ch++) {\\n      for (int i = 0; i < chs.length; i++) {\\n          if (chs[i] == ch) continue;\\n          char old_ch = chs[i];\\n          chs[i] = ch;\\n          if (dict.contains(String.valueOf(chs))) {\\n              res.add(String.valueOf(chs));\\n          }\\n          chs[i] = old_ch;\\n      }\\n\\n  }\\n  return res;\\n}\\n\\n// DFS: output all paths with the shortest distance.\\nprivate void dfs(String cur, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance, ArrayList<String> solution, List<List<String>> res) {\\n    solution.add(cur);\\n    if (end.equals(cur)) {\\n       res.add(new ArrayList<String>(solution));\\n    } else {\\n       for (String next : nodeNeighbors.get(cur)) {            \\n            if (distance.get(next) == distance.get(cur) + 1) {\\n                 dfs(next, end, dict, nodeNeighbors, distance, solution, res);\\n            }\\n        }\\n    }           \\n   solution.remove(solution.size() - 1);\\n}\\n```"
		},
		{
			"lc_ans_id":"40477",
			"view":"14536",
			"top":"2",
			"title":"Super fast Java solution (two-end BFS)",
			"vote":"40",
			"content":"Thanks to prime_tang and jianchao.li.fighter!\\n\\n      public List<List<String>> findLadders(String start, String end, Set<String> dict) {\\n        // hash set for both ends\\n        Set<String> set1 = new HashSet<String>();\\n        Set<String> set2 = new HashSet<String>();\\n        \\n        // initial words in both ends\\n        set1.add(start);\\n        set2.add(end);\\n        \\n        // we use a map to help construct the final result\\n        Map<String, List<String>> map = new HashMap<String, List<String>>();\\n        \\n        // build the map\\n        helper(dict, set1, set2, map, false);\\n        \\n        List<List<String>> res = new ArrayList<List<String>>();\\n        List<String> sol = new ArrayList<String>(Arrays.asList(start));\\n        \\n        // recursively build the final result\\n        generateList(start, end, map, sol, res);\\n        \\n        return res;\\n      }\\n      \\n      boolean helper(Set<String> dict, Set<String> set1, Set<String> set2, Map<String, List<String>> map, boolean flip) {\\n        if (set1.isEmpty()) {\\n          return false;\\n        }\\n        \\n        if (set1.size() > set2.size()) {\\n          return helper(dict, set2, set1, map, !flip);\\n        }\\n        \\n        // remove words on current both ends from the dict\\n        dict.removeAll(set1);\\n        dict.removeAll(set2);\\n        \\n        // as we only need the shortest paths\\n        // we use a boolean value help early termination\\n        boolean done = false;\\n        \\n        // set for the next level\\n        Set<String> set = new HashSet<String>();\\n        \\n        // for each string in end 1\\n        for (String str : set1) {\\n          for (int i = 0; i < str.length(); i++) {\\n            char[] chars = str.toCharArray();\\n            \\n            // change one character for every position\\n            for (char ch = 'a'; ch <= 'z'; ch++) {\\n              chars[i] = ch;\\n              \\n              String word = new String(chars);\\n              \\n              // make sure we construct the tree in the correct direction\\n              String key = flip ? word : str;\\n              String val = flip ? str : word;\\n                  \\n              List<String> list = map.containsKey(key) ? map.get(key) : new ArrayList<String>();\\n                  \\n              if (set2.contains(word)) {\\n                done = true;\\n                \\n                list.add(val);\\n                map.put(key, list);\\n              } \\n              \\n              if (!done && dict.contains(word)) {\\n                set.add(word);\\n                \\n                list.add(val);\\n                map.put(key, list);\\n              }\\n            }\\n          }\\n        }\\n        \\n        // early terminate if done is true\\n        return done || helper(dict, set2, set, map, !flip);\\n      }\\n      \\n      void generateList(String start, String end, Map<String, List<String>> map, List<String> sol, List<List<String>> res) {\\n        if (start.equals(end)) {\\n          res.add(new ArrayList<String>(sol));\\n          return;\\n        }\\n        \\n        // need this check in case the diff between start and end happens to be one\\n        // e.g \"a\", \"c\", {\"a\", \"b\", \"c\"}\\n        if (!map.containsKey(start)) {\\n          return;\\n        }\\n        \\n        for (String word : map.get(start)) {\\n          sol.add(word);\\n          generateList(word, end, map, sol, res);\\n          sol.remove(sol.size() - 1);\\n        }\\n      }"
		},
		{
			"lc_ans_id":"40540",
			"view":"18317",
			"top":"3",
			"title":"88ms! Accepted c++ solution with two-end BFS. 68ms for Word Ladder and 88ms for Word Ladder II",
			"vote":"35",
			"content":"In order to reduce the running time, we should use two-end BFS to slove the problem.\\n\\nAccepted 68ms c++ solution for [Word Ladder][1].\\n\\n    class Solution {\\n    public:\\n        int ladderLength(std::string beginWord, std::string endWord, std::unordered_set<std::string> &dict) {\\n    \\t\\tif (beginWord == endWord)\\n    \\t\\t\\treturn 1;\\n            std::unordered_set<std::string> words1, words2;\\n    \\t\\twords1.insert(beginWord);\\n    \\t\\twords2.insert(endWord);\\n            dict.erase(beginWord);\\n            dict.erase(endWord);\\n            return ladderLengthHelper(words1, words2, dict, 1);\\n        }\\n    \\n    private:\\n        int ladderLengthHelper(std::unordered_set<std::string> &words1, std::unordered_set<std::string> &words2, std::unordered_set<std::string> &dict, int level) {\\n    \\t\\tif (words1.empty())\\n                return 0;\\n    \\t\\tif (words1.size() > words2.size())\\n    \\t\\t\\treturn ladderLengthHelper(words2, words1, dict, level);\\n            std::unordered_set<std::string> words3;\\n            for (auto it = words1.begin(); it != words1.end(); ++it) {\\n    \\t\\t\\tstd::string word = *it;\\n    \\t\\t\\tfor (auto ch = word.begin(); ch != word.end(); ++ch) {\\n    \\t\\t\\t\\tchar tmp = *ch;\\n                    for (*ch = 'a'; *ch <= 'z'; ++(*ch))\\n    \\t\\t\\t\\t\\tif (*ch != tmp)\\n    \\t\\t\\t\\t\\t\\tif (words2.find(word) != words2.end())\\n                                return level + 1;\\n    \\t\\t\\t\\t\\t\\telse if (dict.find(word) != dict.end()) {\\n                                dict.erase(word);\\n                                words3.insert(word);\\n                            }\\n    \\t\\t\\t\\t*ch = tmp;\\n                }\\n            }\\n            return ladderLengthHelper(words2, words3, dict, level + 1);\\n        }\\n    };\\n\\nAccepted 88ms c++ solution for [Word Ladder II][2].\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<std::string> > findLadders(std::string beginWord, std::string endWord, std::unordered_set<std::string> &dict) {\\n    \\t\\tstd::vector<std::vector<std::string> > paths;\\n    \\t\\tstd::vector<std::string> path(1, beginWord);\\n    \\t\\tif (beginWord == endWord) {\\n    \\t\\t\\tpaths.push_back(path);\\n    \\t\\t\\treturn paths;\\n    \\t\\t}\\n            std::unordered_set<std::string> words1, words2;\\n    \\t\\twords1.insert(beginWord);\\n    \\t\\twords2.insert(endWord);\\n    \\t\\tstd::unordered_map<std::string, std::vector<std::string> > nexts;\\n    \\t\\tbool words1IsBegin = false;\\n            if (findLaddersHelper(words1, words2, dict, nexts, words1IsBegin))\\n    \\t\\t\\tgetPath(beginWord, endWord, nexts, path, paths);\\n    \\t\\treturn paths;\\n        }\\n    private:\\n        bool findLaddersHelper(\\n    \\t\\tstd::unordered_set<std::string> &words1,\\n    \\t\\tstd::unordered_set<std::string> &words2,\\n    \\t\\tstd::unordered_set<std::string> &dict,\\n    \\t\\tstd::unordered_map<std::string, std::vector<std::string> > &nexts,\\n    \\t\\tbool &words1IsBegin) {\\n    \\t\\twords1IsBegin = !words1IsBegin;\\n    \\t\\tif (words1.empty())\\n                return false;\\n    \\t\\tif (words1.size() > words2.size())\\n    \\t\\t\\treturn findLaddersHelper(words2, words1, dict, nexts, words1IsBegin);\\n    \\t\\tfor (auto it = words1.begin(); it != words1.end(); ++it)\\n    \\t\\t\\tdict.erase(*it);\\n    \\t\\tfor (auto it = words2.begin(); it != words2.end(); ++it)\\n    \\t\\t\\tdict.erase(*it);\\n            std::unordered_set<std::string> words3;\\n    \\t\\tbool reach = false;\\n            for (auto it = words1.begin(); it != words1.end(); ++it) {\\n    \\t\\t\\tstd::string word = *it;\\n    \\t\\t\\tfor (auto ch = word.begin(); ch != word.end(); ++ch) {\\n    \\t\\t\\t\\tchar tmp = *ch;\\n                    for (*ch = 'a'; *ch <= 'z'; ++(*ch))\\n    \\t\\t\\t\\t\\tif (*ch != tmp)\\n    \\t\\t\\t\\t\\t\\tif (words2.find(word) != words2.end()) {\\n    \\t\\t\\t\\t\\t\\t\\treach = true;\\n    \\t\\t\\t\\t\\t\\t\\twords1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it);\\n    \\t\\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\t\\telse if (!reach && dict.find(word) != dict.end()) {\\n    \\t\\t\\t\\t\\t\\t\\twords3.insert(word);\\n    \\t\\t\\t\\t\\t\\t\\twords1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it);\\n                            }\\n    \\t\\t\\t\\t*ch = tmp;\\n                }\\n            }\\n            return reach || findLaddersHelper(words2, words3, dict, nexts, words1IsBegin);\\n        }\\n    \\tvoid getPath(\\n    \\t\\tstd::string beginWord,\\n    \\t\\tstd::string &endWord,\\n    \\t\\tstd::unordered_map<std::string, std::vector<std::string> > &nexts,\\n    \\t\\tstd::vector<std::string> &path,\\n    \\t\\tstd::vector<std::vector<std::string> > &paths) {\\n    \\t\\tif (beginWord == endWord)\\n    \\t\\t\\tpaths.push_back(path);\\n    \\t\\telse\\n    \\t\\t\\tfor (auto it = nexts[beginWord].begin(); it != nexts[beginWord].end(); ++it) {\\n    \\t\\t\\t\\tpath.push_back(*it);\\n    \\t\\t\\t\\tgetPath(*it, endWord, nexts, path, paths);\\n    \\t\\t\\t\\tpath.pop_back();\\n    \\t\\t\\t}\\n    \\t}\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/word-ladder/\\n  [2]: https://leetcode.com/problems/word-ladder-ii/"
		},
		{
			"lc_ans_id":"40591",
			"view":"9904",
			"top":"4",
			"title":"The fastest C++ Solution, 56ms!!",
			"vote":"33",
			"content":"Treat each word as a node of a tree. There are two trees. One tree's root node is \"beginWord\", and the other tree's root node is \"endWord\".\\n\\nThe root node can yield all his children node, and they are the second layer of the tree. The second layer can yield all their children, then we get the third layer of the tree, ... , and so on.\\n\\nWhen one tree yield a new child, we search it in the last layer of the other tree. If we find an identical node in that tree, then we get some ladders connect two roots(\"beginWord\" -> ... -> \"endWord\").\\n\\nAnother thing should be considered is: two(or more) different nodes may yield an identical child. That means the child may have two(or more) parents. For example, \"hit\" and \"hot\" can both yield \"hat\", means \"hat\" has two parents.\\n\\nSo, the data struct of tree-node is:\\n\\n    class Node {\\n    public: \\n        string word;\\n        vectror<Node*> parents;\\n        Node(string w) : word(w) {}\\n    }\\n\\nNote: we don't need a `children` field for `Node` class, because we won't use it.\\n\\nTwo nodes are considered equal when their `word` field are equal. So we introduce an compare function:\\n\\n    bool nodecmp(Node* pa, Node* pb)\\n    {\\n        return pa->word < pb->word;\\n    }\\n\\nThen we use `nodecmp` as the compare function to build a node set.\\n\\n    typedef bool (*NodeCmper) (Node*, Node*);\\n    typedef set<Node*, NodeCmper> NodeSet;\\n    NodeSet layer(nodecmp);\\n\\nThen we can store/search pointers of nodes in node set `layer`.  For example:\\n\\n    Node node1(\"hit\"), node2(\"hot\"), node3(\"hat\");    \\n    layer.insert(&node1);\\n    layer.insert(&node2);\\n    layer.insert(&node3);\\n    auto itr = layer.find(new Node(\"hot\"));\\n    cout << (*itr)->word; // output: hot\\n\\nUsing these data structures, we can solve this problem with bi-direction BFS algorithm. Below is the AC code, and it is very very fast.\\n\\n    class Node;\\n    \\n    typedef vector<string> Ladder;\\n    typedef unordered_set<string> StringSet;\\n    typedef bool (*NodeCmper) (Node*, Node*);\\n    typedef set<Node*, NodeCmper> NodeSet;\\n    \\n    class Node\\n    {\\n    public:\\n        string word;\\n        vector<Node*> parents;\\n    \\n        Node(string w) : word(w) {}\\n        void addparent(Node* parent) { parents.push_back(parent); }\\n    \\n        // Yield all children of this node, and:\\n        //   1) If the child is found in $targetlayer, which means we found ladders that\\n        //      connect BEGIN-WORD and END-WORD, then we get all paths through this node\\n        //      to its ROOT node, and all paths through the target child node to its ROOT\\n        //      node, and combine the two group of paths to a group of ladders, and append\\n        //      these ladders to $ladders.\\n        //   2) Elif the $ladders is empty:\\n        //       2.1) If the child is found in $nextlayer, then get that child, and add\\n        //            this node to its parents.\\n        //       2.2) Else, add the child to nextlayer, and add this node to its parents.\\n        //   3) Else, do nothing.\\n        void yieldchildren(NodeSet& nextlayer, StringSet& wordlist, NodeSet& targetlayer,\\n                           vector<Ladder>& ladders, bool forward)\\n        {\\n            string nextword = word;\\n            for (int i = 0, n = nextword.length(); i < n; i++) {\\n                char oldchar = nextword[i];\\n                for (nextword[i] = 'a'; nextword[i] <= 'z'; nextword[i]++) {\\n                    if (wordlist.count(nextword)) {\\n                        // now we found a valid child-word, let's yield a child.\\n                        Node* child = new Node(nextword);\\n                        yield1(child, nextlayer, targetlayer, ladders, forward);\\n                    }\\n                }\\n                nextword[i] = oldchar;\\n            }\\n        }\\n    \\n        // yield one child, see comment of function `yieldchildren`\\n        void yield1(Node* child, NodeSet& nextlayer, NodeSet& targetlayer,\\n                    vector<Ladder>& ladders, bool forward) {\\n            auto itr = targetlayer.find(child);\\n            if (itr != targetlayer.end()) {\\n                for (Ladder path1 : this->getpaths()) {\\n                    for (Ladder path2 : (*itr)->getpaths()) {\\n                        if (forward) {\\n                            ladders.push_back(path1);\\n                            ladders.back().insert(ladders.back().end(), path2.rbegin(), path2.rend());\\n                        } else {\\n                            ladders.push_back(path2);\\n                            ladders.back().insert(ladders.back().end(), path1.rbegin(), path1.rend());\\n                        }\\n                    }\\n                }\\n            } else if (ladders.empty()) {\\n                auto itr = nextlayer.find(child);\\n                if (itr != nextlayer.end()) {\\n                    (*itr)->addparent(this);\\n                } else {\\n                    child->addparent(this);\\n                    nextlayer.insert(child);\\n                }\\n            }\\n        }\\n    \\n        vector<Ladder> getpaths()\\n        {\\n            vector<Ladder> ladders;\\n            if (parents.empty()) {\\n                ladders.push_back(Ladder(1, word));\\n            } else {\\n                for (Node* parent : parents) {\\n                    for (Ladder ladder : parent->getpaths()) {\\n                        ladders.push_back(ladder);\\n                        ladders.back().push_back(word);\\n                    }\\n                }\\n            }\\n            return ladders;\\n        }\\n    };\\n    \\n    bool nodecmp(Node* pa, Node* pb)\\n    {\\n        return pa->word < pb->word;\\n    }\\n    \\n    class Solution {\\n    public:\\n        vector<Ladder> findLadders(string begin, string end, StringSet& wordlist) {\\n            vector<Ladder> ladders;\\n            Node headroot(begin), tailroot(end);\\n            NodeSet frontlayer(nodecmp), backlayer(nodecmp);\\n            NodeSet *ptr_layerA = &frontlayer, *ptr_layerB = &backlayer;\\n            bool forward = true;\\n    \\n            if (begin == end) {\\n                ladders.push_back(Ladder(1, begin));\\n                return ladders;\\n            }\\n    \\n            frontlayer.insert(&headroot);\\n            backlayer.insert(&tailroot);\\n            wordlist.insert(end);\\n            while (!ptr_layerA->empty() && !ptr_layerB->empty() && ladders.empty()) {\\n                NodeSet nextlayer(nodecmp);\\n                if (ptr_layerA->size() > ptr_layerB->size()) {\\n                    swap(ptr_layerA, ptr_layerB);\\n                    forward = ! forward;\\n                }\\n                for (Node* node : *ptr_layerA) {\\n                    wordlist.erase(node->word);\\n                }\\n                for (Node* node : *ptr_layerA) {\\n                    node->yieldchildren(nextlayer, wordlist, *ptr_layerB, ladders, forward);\\n                }\\n                swap(*ptr_layerA, nextlayer);\\n            }\\n    \\n            return ladders;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"40458",
			"view":"4545",
			"top":"5",
			"title":"Use defaultdict for traceback and easy writing, 20 lines python code",
			"vote":"30",
			"content":"    class Solution:\\n    # @param start, a string\\n    # @param end, a string\\n    # @param dict, a set of string\\n    # @return a list of lists of string\\n    def findLadders(self, start, end, dic):\\n        dic.add(end)\\n        level = {start}\\n        parents = collections.defaultdict(set)\\n        while level and end not in parents:\\n            next_level = collections.defaultdict(set)\\n            for node in level:\\n                for char in string.ascii_lowercase:\\n                    for i in range(len(start)):\\n                        n = node[:i]+char+node[i+1:]\\n                        if n in dic and n not in parents:\\n                            next_level[n].add(node)\\n            level = next_level\\n            parents.update(next_level)\\n        res = [[end]]\\n        while res and res[0][0] != start:\\n            res = [[p]+r for r in res for p in parents[r[0]]]\\n        return res\\n\\nEvery level we use the defaultdict to get rid of the duplicates"
		},
		{
			"lc_ans_id":"40435",
			"view":"4898",
			"top":"6",
			"title":"Clean but the best-submission (68ms) in C++, well-commented",
			"vote":"21",
			"content":"    class Solution \\n    {\\n        public:\\n            vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &dict) {\\n                vector<vector<string> > paths;\\n                vector<string> path(1, beginWord);\\n                if (beginWord == endWord)  //corner case;\\n                {\\n                    paths.push_back(path);\\n                    return paths;\\n                }\\n                unordered_set<string> forward, backward;\\n                forward.insert(beginWord);\\n                backward.insert(endWord);\\n                unordered_map<string, vector<string> > tree;\\n                bool reversed = false; //make sure the tree generating direction is consistent, since we have to start from the smaller set to accelerate;\\n                if (buildTree(forward, backward, dict, tree, reversed))\\n                    getPath(beginWord, endWord, tree, path, paths);\\n                return paths;\\n            }\\n        private:\\n            bool buildTree(unordered_set<string> &forward, unordered_set<string> &backward, unordered_set<string> &dict, unordered_map<string, vector<string> > &tree, bool reversed) \\n            {\\n                if (forward.empty()) return false;\\n                if (forward.size() > backward.size()) \\n                    return buildTree(backward, forward, dict, tree, !reversed);\\n                for (auto &word: forward) dict.erase(word);\\n                for (auto &word: backward) dict.erase(word);\\n                unordered_set<string> nextLevel;\\n                bool done = false; //in case of invalid further searching;\\n                for (auto &it: forward) //traverse each word in the forward -> the current level of the tree;\\n                {\\n                    string word = it;\\n                    for (auto &c: word) \\n                    {\\n                        char c0 = c; //store the original;\\n                        for (c = 'a'; c <= 'z'; ++c) //try each case;\\n                        {\\n                            if (c != c0) //avoid futile checking;\\n                            {\\n                                if (backward.count(word))  //using count is an accelerating method;\\n                                {\\n                                    done = true;\\n                                    !reversed ? tree[it].push_back(word) : tree[word].push_back(it); //keep the tree generation direction consistent;\\n                                }\\n                                else if (!done && dict.count(word))\\n                                {\\n                                    nextLevel.insert(word);\\n                                    !reversed ? tree[it].push_back(word) : tree[word].push_back(it);\\n                                }\\n                            }\\n                        }\\n                        c = c0; //restore the word;\\n                    }\\n                }\\n                return done || buildTree(nextLevel, backward, dict, tree, reversed);\\n            }\\n    \\n            void getPath(string &beginWord, string &endWord, unordered_map<string, vector<string> > &tree, vector<string> &path, vector<vector<string> > &paths) //using reference can accelerate;\\n            {\\n                if (beginWord == endWord) paths.push_back(path); //till the end;\\n                else\\n                {\\n                    for (auto &it: tree[beginWord]) \\n                    {\\n                        path.push_back(it);\\n                        getPath(it, endWord, tree, path, paths); //DFS retrieving the path;\\n                        path.pop_back();\\n                    }\\n                }\\n            }\\n    };"
		},
		{
			"lc_ans_id":"40434",
			"view":"1036",
			"top":"7",
			"title":"C++ solution using standard BFS method, no DFS or backtracking",
			"vote":"19",
			"content":"I have struggled with this problem for a long time because nearly all the solution on the web is too long or too tricky and can hardly be remembered during the interview.\\n\\nIn fact, this problem can be solved with a very standard BFS process, whose structure could haven been written by you for many many times (using while loop and a queue).\\nThe following code is written in a very standard BFS method, which is easy to memorize. \\n\\nThe only tricky thing you need to remember is this is a BFS of paths not words!\\nSo the element is the queue is a vector. That's it.\\n\\n```\\n    vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &wordList) {\\n        //very interesting problem\\n        //It can be solved with standard BFS. The tricky idea is doing BFS of paths instead of words!\\n        //Then the queue becomes a queue of paths.\\n        vector<vector<string>> ans;\\n        queue<vector<string>> paths;\\n        wordList.insert(endWord);\\n        paths.push({beginWord});\\n        int level = 1;\\n        int minLevel = INT_MAX;\\n        \\n        //\"visited\" records all the visited nodes on this level\\n        //these words will never be visited again after this level \\n        //and should be removed from wordList. This is guaranteed\\n        // by the shortest path.\\n        unordered_set<string> visited; \\n        \\n        while (!paths.empty()) {\\n            vector<string> path = paths.front();\\n            paths.pop();\\n            if (path.size() > level) {\\n                //reach a new level\\n                for (string w : visited) wordList.erase(w);\\n                visited.clear();\\n                if (path.size() > minLevel)\\n                    break;\\n                else\\n                    level = path.size();\\n            }\\n            string last = path.back();\\n            //find next words in wordList by changing\\n            //each element from 'a' to 'z'\\n            for (int i = 0; i < last.size(); ++i) {\\n                string news = last;\\n                for (char c = 'a'; c <= 'z'; ++c) {\\n                    news[i] = c;\\n                    if (wordList.find(news) != wordList.end()) {\\n                    //next word is in wordList\\n                    //append this word to path\\n                    //path will be reused in the loop\\n                    //so copy a new path\\n                        vector<string> newpath = path;\\n                        newpath.push_back(news);\\n                        visited.insert(news);\\n                        if (news == endWord) {\\n                            minLevel = level;\\n                            ans.push_back(newpath);\\n                        }\\n                        else\\n                            paths.push(newpath);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```"
		},
		{
			"lc_ans_id":"40549",
			"view":"4602",
			"top":"8",
			"title":"FAST AND CLEAN Python/C++ Solution using Double BFS, beats 98%",
			"vote":"18",
			"content":"If we know source and destination, we can build the word tree by going forward in one direction and backwards in the other. We stop when we have found that a word in the next level of BFS is in the other level, but first we need to update the tree for the words in the current level.\\n\\nThen we build the result by doing a DFS on the tree constructed by the BFS.\\n\\nThe difference between normal and double BFS is that the search changes from `O(k^d)` to `O(k^(d/2) + k^(d/2))`. Same complexity class, right? Yeah, tell it to the Facebook guys that have to search in graphs with hundreds of thousands of nodes. \\n\\n```\\nclass Solution(object):\\n\\n    # Solution using double BFS\\n\\n    def findLadders(self, begin, end, words_list):\\n        \\n        def construct_paths(source, dest, tree):\\n            if source == dest: \\n                return [[source]]\\n            return [[source] + path for succ in tree[source]\\n                                    for path in construct_paths(succ, dest, tree)]\\n\\n        def add_path(tree, word, neigh, is_forw):\\n            if is_forw: tree[word]  += neigh,\\n            else:       tree[neigh] += word,\\n\\n        def bfs_level(this_lev, oth_lev, tree, is_forw, words_set):\\n            if not this_lev: return False\\n            if len(this_lev) > len(oth_lev):\\n                return bfs_level(oth_lev, this_lev, tree, not is_forw, words_set)\\n            for word in (this_lev | oth_lev):\\n                words_set.discard(word)\\n            next_lev, done = set(), False\\n            while this_lev:\\n                word = this_lev.pop()\\n                for c in string.ascii_lowercase:\\n                    for index in range(len(word)):\\n                        neigh = word[:index] + c + word[index+1:]\\n                        if neigh in oth_lev:\\n                            done = True\\n                            add_path(tree, word, neigh, is_forw)                \\n                        if not done and neigh in words_set:\\n                            next_lev.add(neigh)\\n                            add_path(tree, word, neigh, is_forw)\\n            return done or bfs_level(next_lev, oth_lev, tree, is_forw, words_set)\\n                            \\n        tree, path, paths = collections.defaultdict(list), [begin], []\\n        is_found = bfs_level(set([begin]), set([end]), tree, True, words_list)\\n        return construct_paths(begin, end, tree)\\n```\\n\\n\\nC++ code:\\n\\n```\\nvoid add_to_tree(map<string, vector<string>>& tree, \\n              string word, \\n              string neigh, \\n              bool forward) {\\n    if (forward) tree[word].push_back(neigh);\\n    else         tree[neigh].push_back(word);\\n\\n}\\n\\nvector<vector<string>> construct_paths(map<string, \\n                                       vector<string>>& tree, \\n                                       string start, \\n                                       string dest) {\\n    if (start == dest) {\\n        vector<string> res = {start};\\n        vector<vector<string>> arr = {res};\\n        return arr;\\n    }\\n    vector<vector<string>> result;\\n\\n    for (auto succ: tree[start]) {\\n        for (auto path: construct_paths(tree, succ, dest)) {\\n            path.insert(path.begin(), start);\\n            result.push_back(path);\\n        }\\n    }\\n    return result;\\n}\\n\\nbool bfs_levels(unordered_set<string>& now, \\n                unordered_set<string>& oth, \\n                bool& forward, \\n                map<string, vector<string>>& tree, \\n                unordered_set<string>& words_list,\\n                vector<char>& alphabet) {\\n\\n    if (not now.size()) return false;\\n    if (now.size() > oth.size()){\\n        forward = not forward;\\n        return bfs_levels(oth, now, forward, tree, words_list, alphabet);\\n    }\\n    for (auto word: now) words_list.erase(word);\\n    for (auto word: oth) words_list.erase(word);\\n    \\n    bool done = false; unordered_set<string> next;\\n\\n    for (string word: now) {\\n        for (int i = 0; i < word.size(); i++) {\\n            for (char c: alphabet) {\\n                auto neigh = word.substr(0, i) + c + word.substr(i+1);\\n                if (oth.count(neigh) > 0) {\\n                    done = true;\\n                    add_to_tree(tree, word, neigh, forward);\\n                }\\n                else {\\n                    if (not done and words_list.count(neigh) > 0) {\\n                        next.insert(neigh);\\n                        add_to_tree(tree, word, neigh, forward);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    forward = not forward;\\n    return done or bfs_levels(oth, next, forward, tree, words_list, alphabet);\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, \\n                                       string endWord, \\n                                       unordered_set<string> &wordList) {\\n\\n        vector<char> alphabet(26);\\n        std::iota(alphabet.begin(), alphabet.end(), 'a');\\n        unordered_set<string> now = {beginWord}, oth = {endWord};\\n        map<string, vector<string>> tree; bool forward = true;\\n        auto is_found = bfs_levels(now, oth, forward, tree, wordList, alphabet);\\n        return construct_paths(tree, beginWord, endWord);    \\n                                           \\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"40487",
			"view":"2261",
			"top":"9",
			"title":"Java Solution with Iteration",
			"vote":"14",
			"content":"Code is about 40 lines, put explanation in comments.\\n\\n    /**\\n     * we are essentially building a graph, from start, BF.\\n     * and at each level we find all reachable words from parent.\\n     * we stop if the current level contains end,\\n     * we return any path whose last node is end.\\n     * \\n     * to achieve BFT, use a deuqe;\\n     * a key improvement is to remove all the words we already reached\\n     * in PREVIOUS LEVEL; we don't need to try visit them again\\n     * in subsequent level, that is guaranteed to be non-optimal solution.\\n     * at each new level, we will removeAll() words reached in previous level from dict.\\n     */\\n    public List<List<String>> findLadders(String start, String end, Set<String> dict) {\\n        List<List<String>> results = new ArrayList<List<String>>();\\n        dict.add(end);\\n        // instead of storing words we are at, we store the paths.\\n        Deque<List<String>> paths = new LinkedList<List<String>>();\\n        List<String> path0 = new LinkedList<String>();\\n        path0.add(start);\\n        paths.add(path0);\\n        // if we found a path ending at 'end', we will set lastLevel,\\n        // use this data to stop iterating further.\\n        int level = 1, lastLevel = Integer.MAX_VALUE;\\n        Set<String> wordsPerLevel = new HashSet<String>();\\n        while (!paths.isEmpty()) {\\n            List<String> path = paths.pollFirst();\\n            if (path.size() > level) {\\n                dict.removeAll(wordsPerLevel);\\n                wordsPerLevel.clear();\\n                level = path.size();\\n                if (level > lastLevel)\\n                    break; // stop and return\\n            }\\n            //  try to find next word to reach, continuing from the path\\n            String last = path.get(level - 1);\\n            char[] chars = last.toCharArray();\\n            for (int index = 0; index < last.length(); index++) {\\n                char original = chars[index];\\n                for (char c = 'a'; c <= 'z'; c++) {\\n                    chars[index] = c;\\n                    String next = new String(chars);\\n                    if (dict.contains(next)) {\\n                        wordsPerLevel.add(next);\\n                        List<String> nextPath = new LinkedList<String>(path);\\n                        nextPath.add(next);\\n                        if (next.equals(end)) {\\n                            results.add(nextPath);\\n                            lastLevel = level; // curr level is the last level\\n                        } else\\n                            paths.addLast(nextPath);\\n                    }\\n                }\\n                chars[index] = original;\\n            }\\n        }\\n        \\n        return results;\\n    }"
		}
	],
	"id":"126",
	"title":"Word Ladder II",
	"content":"<p>\r\nGiven two words (<i>beginWord</i> and <i>endWord</i>), and a dictionary's word list, find all shortest transformation sequence(s) from <i>beginWord</i> to <i>endWord</i>, such that:\r\n</p>\r\n<ol>\r\n<li>Only one letter can be changed at a time</li>\r\n<li>Each transformed word must exist in the word list. Note that <i>beginWord</i> is <i>not</i> a transformed word.</li>\r\n</ol>\r\n\r\n<p>\r\nFor example,\r\n</p>\r\n<p>\r\nGiven:<br />\r\n<i>beginWord</i> = <code>\"hit\"</code><br />\r\n<i>endWord</i> = <code>\"cog\"</code><br />\r\n<i>wordList</i> = <code>[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]</code><br />\r\n</p>\r\n<p>\r\nReturn<br />\r\n<pre>\r\n  [\r\n    [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],\r\n    [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\r\n  ]\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b><br />\r\n<ul>\r\n<li>Return an empty list if there is no such transformation sequence.</li>\r\n<li>All words have the same length.</li>\r\n<li>All words contain only lowercase alphabetic characters.</li>\r\n<li>You may assume no duplicates in the word list.</li>\r\n<li>You may assume <i>beginWord</i> and <i>endWord</i> are non-empty and are not the same.</li>\r\n</ul>\r\n</p>\r\n\r\n<p>\r\n<b><font color=\"red\">UPDATE (2017/1/20):</font></b><br />\r\nThe <i>wordList</i> parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\r\n</p>",
	"frequency":"346",
	"ac_num":"78050"
}