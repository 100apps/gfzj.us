{
	"difficulty":"2",
	"submit_num":"763708",
	"show_id":"127",
	"leetcode_id":"127",
	"answers":[
		{
			"lc_ans_id":"40707",
			"view":"47431",
			"top":"0",
			"title":"Easy 76ms C++ Solution using BFS",
			"vote":"113",
			"content":"Well, this problem has a nice BFS structure.\\n\\nLet's see the example in the problem statement.\\n\\n`start = \"hit\"`\\n\\n`end = \"cog\"`\\n\\n`dict = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\"]`\\n\\nSince only one letter can be changed at a time, if we start from `\"hit\"`, we can only change to those words which have only one different letter from it, like `\"hot\"`. Putting in graph-theoretic terms, we can say that `\"hot\"` is a neighbor of `\"hit\"`.\\n\\nThe idea is simpy to begin from `start`, then visit its neighbors, then the non-visited neighbors of its neighbors... Well, this is just the typical BFS structure.\\n\\nTo simplify the problem, we insert `end` into `dict`. Once we meet `end` during the BFS, we know we have found the answer. We maintain a variable `dist` for the current distance of the transformation and update it by `dist++` after we finish a round of BFS search (note that it should fit the definition of the distance in the problem statement). Also, to avoid visiting a word for more than once, we erase it from `dict` once it is visited.\\n\\nThe code is as follows.\\n\\n    class Solution {\\n    public:\\n        int ladderLength(string beginWord, string endWord, unordered_set<string>& wordDict) {\\n            wordDict.insert(endWord);\\n            queue<string> toVisit;\\n            addNextWords(beginWord, wordDict, toVisit);\\n            int dist = 2;\\n            while (!toVisit.empty()) {\\n                int num = toVisit.size();\\n                for (int i = 0; i < num; i++) {\\n                    string word = toVisit.front();\\n                    toVisit.pop();\\n                    if (word == endWord) return dist;\\n                    addNextWords(word, wordDict, toVisit);\\n                }\\n                dist++;\\n            }\\n        }\\n    private:\\n        void addNextWords(string word, unordered_set<string>& wordDict, queue<string>& toVisit) {\\n            wordDict.erase(word);\\n            for (int p = 0; p < (int)word.length(); p++) {\\n                char letter = word[p];\\n                for (int k = 0; k < 26; k++) { \\n                    word[p] = 'a' + k;\\n                    if (wordDict.find(word) != wordDict.end()) {\\n                        toVisit.push(word);\\n                        wordDict.erase(word);\\n                    }\\n                }\\n                word[p] = letter;\\n            } \\n        } \\n    };\\n\\nThe above code can still be speeded up if we also begin from `end`. Once we meet the same word from `start` and `end`, we know we are done. [This link][1] provides a nice two-end search solution. I rewrite the code below for better readability. Note that the use of two pointers `phead` and `ptail` save a lot of time. At each round of BFS, depending on the relative size of `head` and `tail`, we point `phead` to the smaller set to reduce the running time.\\n\\n    class Solution {\\n    public:\\n        int ladderLength(string beginWord, string endWord, unordered_set<string>& wordDict) {\\n            unordered_set<string> head, tail, *phead, *ptail;\\n            head.insert(beginWord);\\n            tail.insert(endWord);\\n            int dist = 2;\\n            while (!head.empty() && !tail.empty()) {\\n                if (head.size() < tail.size()) {\\n                    phead = &head;\\n                    ptail = &tail;\\n                }\\n                else {\\n                    phead = &tail; \\n                    ptail = &head;\\n                }\\n                unordered_set<string> temp; \\n                for (auto itr = phead -> begin(); itr != phead -> end(); itr++) {\\n                    string word = *itr;\\n                    wordDict.erase(word);\\n                    for (int p = 0; p < (int)word.length(); p++) {\\n                        char letter = word[p];\\n                        for (int k = 0; k < 26; k++) {\\n                            word[p] = 'a' + k;\\n                            if (ptail -> find(word) != ptail -> end())\\n                                return dist;\\n                            if (wordDict.find(word) != wordDict.end()) {\\n                                temp.insert(word);\\n                                wordDict.erase(word);\\n                            }\\n                        }\\n                        word[p] = letter;\\n                    }\\n                }\\n                dist++;\\n                swap(*phead, temp);\\n            }\\n            return 0; \\n        }\\n    };\\n\\n  [1]: https://leetcode.com/discuss/28573/share-my-two-end-bfs-in-c-80ms"
		},
		{
			"lc_ans_id":"40711",
			"view":"53927",
			"top":"1",
			"title":"Two-end BFS in Java 31ms.",
			"vote":"104",
			"content":"Modified from **[Share my two-end BFS in C++ 80ms.][1]** \\n\\n    public class Solution {\\n\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\\n\\t\\tSet<String> beginSet = new HashSet<String>(), endSet = new HashSet<String>();\\n\\n\\t\\tint len = 1;\\n\\t\\tint strLen = beginWord.length();\\n\\t\\tHashSet<String> visited = new HashSet<String>();\\n\\t\\t\\n\\t\\tbeginSet.add(beginWord);\\n\\t\\tendSet.add(endWord);\\n\\t\\twhile (!beginSet.isEmpty() && !endSet.isEmpty()) {\\n\\t\\t\\tif (beginSet.size() > endSet.size()) {\\n\\t\\t\\t\\tSet<String> set = beginSet;\\n\\t\\t\\t\\tbeginSet = endSet;\\n\\t\\t\\t\\tendSet = set;\\n\\t\\t\\t}\\n\\n\\t\\t\\tSet<String> temp = new HashSet<String>();\\n\\t\\t\\tfor (String word : beginSet) {\\n\\t\\t\\t\\tchar[] chs = word.toCharArray();\\n\\n\\t\\t\\t\\tfor (int i = 0; i < chs.length; i++) {\\n\\t\\t\\t\\t\\tfor (char c = 'a'; c <= 'z'; c++) {\\n\\t\\t\\t\\t\\t\\tchar old = chs[i];\\n\\t\\t\\t\\t\\t\\tchs[i] = c;\\n\\t\\t\\t\\t\\t\\tString target = String.valueOf(chs);\\n\\n\\t\\t\\t\\t\\t\\tif (endSet.contains(target)) {\\n\\t\\t\\t\\t\\t\\t\\treturn len + 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif (!visited.contains(target) && wordList.contains(target)) {\\n\\t\\t\\t\\t\\t\\t\\ttemp.add(target);\\n\\t\\t\\t\\t\\t\\t\\tvisited.add(target);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tchs[i] = old;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tbeginSet = temp;\\n\\t\\t\\tlen++;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn 0;\\n\\t}\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/28573/share-my-two-end-bfs-in-c-80ms"
		},
		{
			"lc_ans_id":"40708",
			"view":"21584",
			"top":"2",
			"title":"Share my two-end BFS in C++ 80ms.",
			"vote":"61",
			"content":"\\n\\n\\n    //BFS\\uff0c two-end method\\n    //traverse the path simultaneously from start node and end node, and merge in the middle\\n    //the speed will increase (logN/2)^2 times compared with one-end method\\n    int ladderLength(string start, string end, unordered_set<string> &dict) {\\n        unordered_set<string> begSet, endSet, *set1, *set2;\\n        begSet.insert(start);\\n        endSet.insert(end);\\n        int h=1, K=start.size();\\n        while(!begSet.empty()&&!endSet.empty()){\\n            if(begSet.size()<=endSet.size()){   //Make the size of two sets close for optimization\\n                set1=&begSet;\\t//set1 is the forward set\\n                set2=&endSet;\\t//set2 provides the target node for set1 to search\\n            }\\n            else{\\n                set1=&endSet;\\n                set2=&begSet;\\n            }\\n            unordered_set<string> itmSet;\\t//intermediate Set\\n            h++;\\n            for(auto i=set1->begin();i!=set1->end();i++){\\n            \\tstring cur=*i;\\n            \\tfor(int k=0;k<K;k++){\\t//iterate the characters in string cur\\n            \\t\\tchar temp=cur[k];\\n            \\t\\tfor(int l=0;l<26;l++){\\t//try all 26 alphabets\\n            \\t\\t\\tcur[k]='a'+l;\\n            \\t\\t\\tauto f=set2->find(cur);\\n            \\t\\t\\tif(f!=set2->end())return h;\\n            \\t\\t\\tf=dict.find(cur);\\n            \\t\\t\\tif(f!=dict.end()){\\n            \\t\\t\\t\\titmSet.insert(cur);\\n            \\t\\t\\t\\tdict.erase(f);\\n            \\t\\t\\t}\\n            \\t\\t}\\n            \\t\\tcur[k]=temp;\\n            \\t}\\n            }\\n            swap(*set1, itmSet);\\n        }\\n        return 0;\\n    }"
		},
		{
			"lc_ans_id":"40704",
			"view":"27494",
			"top":"3",
			"title":"Java Solution using BFS, with explanation",
			"vote":"55",
			"content":"```\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordDict) {\\n        Set<String> reached = new HashSet<String>();\\n        reached.add(beginWord);\\n        wordDict.add(endWord);\\n        int distance = 1;\\n        while (!reached.contains(endWord)) {\\n            Set<String> toAdd = new HashSet<String>();\\n            for (String each : reached) {\\n                for (int i = 0; i < each.length(); i++) {\\n                    char[] chars = each.toCharArray();\\n                    for (char ch = 'a'; ch <= 'z'; ch++) {\\n                        chars[i] = ch;\\n                        String word = new String(chars);\\n                        if (wordDict.contains(word)) {\\n                            toAdd.add(word);\\n                            wordDict.remove(word);\\n                        }\\n                    }\\n                }\\n            }\\n            distance++;\\n            if (toAdd.size() == 0) return 0;\\n            reached = toAdd;\\n        }\\n        return distance;\\n    }\\n```\\n\\n**Basically I keep two sets of words, one set reached that represents the borders that have been reached with \"distance\" steps; another set wordDict that has not been reached. In the while loop, for each word in the reached set, I give all variations and check if it matches anything from wordDict, if it has a match, I add that word into toAdd set, which will be my \"reached\" set in the next loop, and remove the word from wordDict because I already reached it in this step. And at the end of while loop, I check the size of toAdd, which means that if I can't reach any new String from wordDict, I won't be able to reach the endWord, then just return 0. Finally if the endWord is in reached set, I return the current steps \"distance\".**\\n\\n**The idea is that reached always contain only the ones we just reached in the last step, and wordDict always contain the ones that haven't been reached. This is pretty much what Dijkstra's algorithm does, or you can see this as some variation of BFS.**\\n\\n\\nps: I get TLE at the first two submissions, because when I check if wordDict has any matches with reached set, I use two for loops and determine if any pair of words differ by one. That's a huge slow-down because it'll takes m (size of reached) * n (size of wordDict) * l (length of words) time, while in this solution, it takes 26 * l * m time. So when n is huge, this solution will be (n/26) times faster."
		},
		{
			"lc_ans_id":"40710",
			"view":"9314",
			"top":"4",
			"title":"Share my two Python solutions: a very concise one (12 lines, ~160ms) and an optimized solution(~100ms)",
			"vote":"53",
			"content":"The idea behind the first solution is to use character flopping plus bidirectional BFS. Use set operations as much as possible.\\n\\n    class Solution:\\n        # @param {string} beginWord\\n        # @param {string} endWord\\n        # @param {set<string>} wordDict\\n        # @return {integer}\\n        def ladderLength(self, beginWord, endWord, wordDict):\\n            length = 2\\n            front, back = set([beginWord]), set([endWord])\\n            wordDict.discard(beginWord)\\n            while front:\\n                # generate all valid transformations\\n                front = wordDict & (set(word[:index] + ch + word[index+1:] for word in front \\n                                    for index in range(len(beginWord)) for ch in 'abcdefghijklmnopqrstuvwxyz'))\\n                if front & back:\\n                    # there are common elements in front and back, done\\n                    return length\\n                length += 1\\n                if len(front) > len(back):\\n                    # swap front and back for better performance (fewer choices in generating nextSet)\\n                    front, back = back, front\\n                # remove transformations from wordDict to avoid cycle\\n                wordDict -= front\\n            return 0\\n\\nThe optimizations:\\n\\n-- Generating next set\\n\\n  An alternative is to immediately add a candidate to next set if it is in the dictionary.\\n\\n   Another way to generate next set: for each word in the current set, check if a word in the dictionary can be transformed to it. If it can, add it to the next set. The time complexity of the two methods is analyzed below, assuming word length is L, size of current set and dictionary are M and N, respectively.\\n\\na. character flopping:\\n\\nLoop over current set, character of word, alphabet, the flopping itself is O(L). Time complexity is O(26ML^2)\\n\\nb. verify transformation:\\n\\nLoop over current set, dictionary, character of word. Time complexity is O(MNL)\\n\\nFor b) to be faster, the switching point is N = 26L. This scale can be adjusted.\\n\\nSince the size of dictionary shrinks during the process, it is beneficial to switch to b) in the late stage, or use it for a small dictionary.\\n\\n-- Removing current word set from dictionary\\n\\nIt seems natural to use difference_update for this job since size of dictionary is bigger than that of current word set. But is it so? Note that here we are sure that every word in current set does exist in the dictionary.\\n\\na. S.difference_update(T) or S -= T\\n\\nFor every key (entry) in T, if it is in S, remove it from T. There are len(T) removes and len(T) peeks.\\n\\nb. S.difference(T) or S - T\\n\\nCreate a new empty set. For every key (entry) in S, if it is not in T, add it to new set. There are len(S)-len(T) adds and len(S) peeks.\\n\\nIf the sizes of current word set and dictionary are close, using difference_update means we will remove almost everything from dictionary. If we use difference, only a handful of adds. I use size of dictionary is twice that of current word set as the switching point. This threshold can be adjusted too.\\nThe following optimized code takes ~100ms.\\n\\n    class Solution:\\n        # @param {string} beginWord\\n        # @param {string} endWord\\n        # @param {set<string>} wordDict\\n        # @return {integer}\\n        def ladderLength(self, beginWord, endWord, wordDict):\\n            def generateNextSet1(current, wordDict, wordLen):\\n                nextSet = set()\\n                for word in current:\\n                    for index in range(wordLen):\\n                        for ch in 'abcdefghijklmnopqrstuvwxyz':\\n                            nextWord = word[:index] + ch + word[index+1:]\\n                            if nextWord in wordDict:\\n                                nextSet.add(nextWord)\\n                return nextSet\\n    \\n            def generateNextSet2(current, wordDict):\\n                nextSet = set()\\n                for word in current:\\n                    for nextWord in wordDict:\\n                        index = 0\\n                        try:\\n                            while word[index] == nextWord[index]:\\n                                index += 1\\n                            if word[index+1:] == nextWord[index+1:]:\\n                                nextSet.add(nextWord)\\n                        except:\\n                            continue\\n                return nextSet\\n    \\n            steps, wordLen = 2, len(beginWord)\\n            front, back = set([beginWord]), set([endWord])\\n            wordDict.discard(beginWord)\\n            switchThreshold = 26*wordLen\\n            while front:\\n                # get all valid transformations\\n                if len(wordDict) >= switchThreshold:\\n                    front = generateNextSet1(front, wordDict, wordLen)\\n                else:\\n                    front = generateNextSet2(front, wordDict)\\n                if front & back:\\n                    # there are common elements in front and back, done\\n                    return steps\\n                steps += 1\\n                if len(front) >= len(back):\\n                    # swap front and back for better performance (smaller nextSet)\\n                    front, back = back, front\\n                # remove transformations from wordDict to avoid cycles\\n                if (len(wordDict)>>1) >= len(front):\\n                    # s.difference_update(t): O(len(t))\\n                    wordDict -= front\\n                else:\\n                    # s.difference(t): O(len(s))\\n                    wordDict = wordDict - front\\n            return 0"
		},
		{
			"lc_ans_id":"40717",
			"view":"24149",
			"top":"5",
			"title":"Another accepted Java solution (BFS)",
			"vote":"50",
			"content":"    public int ladderLength(String start, String end, Set<String> dict) {\\n      // Use queue to help BFS\\n      Queue<String> queue = new LinkedList<String>();\\n      queue.add(start);\\n      queue.add(null);\\n      \\n      // Mark visited word\\n      Set<String> visited = new HashSet<String>();\\n      visited.add(start);\\n      \\n      int level = 1;\\n      \\n      while (!queue.isEmpty()) {\\n        String str = queue.poll();\\n        \\n        if (str != null) {\\n          // Modify str's each character (so word distance is 1)\\n          for (int i = 0; i < str.length(); i++) {\\n            char[] chars = str.toCharArray();\\n            \\n            for (char c = 'a'; c <= 'z'; c++) {\\n              chars[i] = c;\\n              \\n              String word = new String(chars);\\n              \\n              // Found the end word\\n              if (word.equals(end)) return level + 1;\\n              \\n              // Put it to the queue\\n              if (dict.contains(word) && !visited.contains(word)) {\\n                queue.add(word);\\n                visited.add(word);\\n              }\\n            }\\n          }\\n        } else {\\n          level++;\\n          \\n          if (!queue.isEmpty()) { \\n            queue.add(null);\\n          }\\n        }\\n      }\\n      \\n      return 0;\\n    }"
		},
		{
			"lc_ans_id":"40723",
			"view":"5325",
			"top":"6",
			"title":"Simple to understand Python solution using list preprocessing and BFS, beats 95%",
			"vote":"39",
			"content":"    from collections import deque\\n    \\n    \\n    class Solution(object):\\n        def ladderLength(self, beginWord, endWord, wordList):\\n            \\n            def construct_dict(word_list):\\n                d = {}\\n                for word in word_list:\\n                    for i in range(len(word)):\\n                        s = word[:i] + \"_\" + word[i+1:]\\n                        d[s] = d.get(s, []) + [word]\\n                return d\\n                \\n            def bfs_words(begin, end, dict_words):\\n                queue, visited = deque([(begin, 1)]), set()\\n                while queue:\\n                    word, steps = queue.popleft()\\n                    if word not in visited:\\n                        visited.add(word)\\n                        if word == end:\\n                            return steps\\n                        for i in range(len(word)):\\n                            s = word[:i] + \"_\" + word[i+1:]\\n                            neigh_words = dict_words.get(s, [])\\n                            for neigh in neigh_words:\\n                                if neigh not in visited:\\n                                    queue.append((neigh, steps + 1))\\n                return 0\\n            \\n            d = construct_dict(wordList | set([beginWord, endWord]))\\n            return bfs_words(beginWord, endWord, d)"
		},
		{
			"lc_ans_id":"40729",
			"view":"3664",
			"top":"7",
			"title":"Compact Python solution",
			"vote":"38",
			"content":"    class Solution(object):\\n        def ladderLength(self, beginWord, endWord, wordList):\\n            wordList.add(endWord)\\n            queue = collections.deque([[beginWord, 1]])\\n            while queue:\\n                word, length = queue.popleft()\\n                if word == endWord:\\n                    return length\\n                for i in range(len(word)):\\n                    for c in 'abcdefghijklmnopqrstuvwxyz':\\n                        next_word = word[:i] + c + word[i+1:]\\n                        if next_word in wordList:\\n                            wordList.remove(next_word)\\n                            queue.append([next_word, length + 1])\\n            return 0"
		},
		{
			"lc_ans_id":"40728",
			"view":"6272",
			"top":"8",
			"title":"Simple Java BFS solution with explanation",
			"vote":"36",
			"content":"The first intuition for this problem is to build a graph whose nodes represent strings and edges connect strings that are only 1 character apart, and then we apply BFS from the startWord node. If we find the endWord, we return the level count of the bfs. This intuition is correct, but there are some places that we can save time.\\n\\n1. When we build adjacency list graph, we don't use two loops to check every pair of string to see if they are 1 character apart. Instead, we make changes to current string to obtain all the strings we can reach from current node, and see if it is in the wordList. Thus, there are currentString.length() * 25 case we need to check for every node. This is faster when the wordList set is large, since the check-every-pair method need wordList.size() * currentString.length() for each node. Otherwise, your may exceed the running time limit.\\n\\n2. For the strings we visited, we remove it from the wordList. This way we don't need to mark visited using another HashSet or something. \\n\\n\\n3. Actually, we don't even need to build the adjacency list graph explicitly using a HashMap<String, ArrayList<String>>, since we keep all the nodes we can reach in the queue of each level of BFS. This can be seen as the keys of the HashMap are the strings that in the queue, and values are the strings that satisfy the 1 character apart in the wordList. Thus, we avoid the time cost of build map for those nodes we don't need to visit. \\n\\n\\npublic class Solution {\\n\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\\n        wordList.add(endWord);\\n        Queue<String> queue = new LinkedList<String>();\\n        queue.add(beginWord);\\n        int level = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                String cur = queue.remove();\\n                if(cur.equals(endWord)){ return level + 1;}\\n                for(int j = 0; j < cur.length(); j++){\\n                    char[] word = cur.toCharArray();\\n                    for(char ch = 'a'; ch < 'z'; ch++){\\n                        word[j] = ch;\\n                        String check = new String(word);\\n                        if(!check.equals(cur) && wordList.contains(check)){\\n                            queue.add(check);\\n                            wordList.remove(check);\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n}"
		},
		{
			"lc_ans_id":"40808",
			"view":"5196",
			"top":"9",
			"title":"Why the output of \"a\", \"c\", [\"a\",\"b\",\"c\"] is 2?",
			"vote":"27",
			"content":"Shouldn't the output of the test case below be 1? Because \"a\" could directly be changed to \"c\", which needs only once edit.\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
		}
	],
	"id":"127",
	"title":"Word Ladder",
	"content":"<p>\r\nGiven two words (<i>beginWord</i> and <i>endWord</i>), and a dictionary's word list, find the length of shortest transformation sequence from <i>beginWord</i> to <i>endWord</i>, such that:\r\n</p>\r\n<ol>\r\n<li>Only one letter can be changed at a time.</li>\r\n<li>Each transformed word must exist in the word list. Note that <i>beginWord</i> is <i>not</i> a transformed word.</li>\r\n</ol>\r\n\r\n<p>\r\nFor example,\r\n</p>\r\n<p>\r\nGiven:<br />\r\n<i>beginWord</i> = <code>\"hit\"</code><br />\r\n<i>endWord</i> = <code>\"cog\"</code><br />\r\n<i>wordList</i> = <code>[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]</code><br />\r\n</p>\r\n<p>\r\nAs one shortest transformation is <code>\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"</code>,<br />\r\nreturn its length <code>5</code>.\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b><br />\r\n<ul>\r\n<li>Return 0 if there is no such transformation sequence.</li>\r\n<li>All words have the same length.</li>\r\n<li>All words contain only lowercase alphabetic characters.</li>\r\n<li>You may assume no duplicates in the word list.</li>\r\n<li>You may assume <i>beginWord</i> and <i>endWord</i> are non-empty and are not the same.</li>\r\n</ul>\r\n</p>\r\n\r\n<p>\r\n<b><font color=\"red\">UPDATE (2017/1/20):</font></b><br />\r\nThe <i>wordList</i> parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\r\n</p>",
	"frequency":"436",
	"ac_num":"151563"
}