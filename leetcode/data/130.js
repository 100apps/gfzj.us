{
	"difficulty":"2",
	"submit_num":"496937",
	"show_id":"130",
	"leetcode_id":"130",
	"answers":[
		{
			"lc_ans_id":"41612",
			"view":"34663",
			"top":"0",
			"title":"A really simple and readable C++ solution\\uff0conly cost 12ms",
			"vote":"153",
			"content":" - First, check the four border of the matrix. If there is a element is\\n   'O', alter it and all its neighbor 'O' elements to '1'.\\n   \\n   \\n - Then ,alter all the 'O' to 'X'\\n - At last,alter all the '1' to 'O'\\n\\nFor example:\\n\\n             X X X X           X X X X             X X X X\\n             X X O X  ->       X X O X    ->       X X X X\\n             X O X X           X 1 X X             X O X X\\n             X O X X           X 1 X X             X O X X\\n        \\n\\n    class Solution {\\n    public:\\n    \\tvoid solve(vector<vector<char>>& board) {\\n            int i,j;\\n            int row=board.size();\\n            if(!row)\\n            \\treturn;\\n            int col=board[0].size();\\n\\n    \\t\\tfor(i=0;i<row;i++){\\n    \\t\\t\\tcheck(board,i,0,row,col);\\n    \\t\\t\\tif(col>1)\\n    \\t\\t\\t\\tcheck(board,i,col-1,row,col);\\n    \\t\\t}\\n    \\t\\tfor(j=1;j+1<col;j++){\\n    \\t\\t\\tcheck(board,0,j,row,col);\\n    \\t\\t\\tif(row>1)\\n    \\t\\t\\t\\tcheck(board,row-1,j,row,col);\\n    \\t\\t}\\n    \\t\\tfor(i=0;i<row;i++)\\n    \\t\\t\\tfor(j=0;j<col;j++)\\n    \\t\\t\\t\\tif(board[i][j]=='O')\\n    \\t\\t\\t\\t\\tboard[i][j]='X';\\n    \\t\\tfor(i=0;i<row;i++)\\n    \\t\\t\\tfor(j=0;j<col;j++)\\n    \\t\\t\\t\\tif(board[i][j]=='1')\\n    \\t\\t\\t\\t\\tboard[i][j]='O';\\n        }\\n    \\tvoid check(vector<vector<char> >&vec,int i,int j,int row,int col){\\n    \\t\\tif(vec[i][j]=='O'){\\n    \\t\\t\\tvec[i][j]='1';\\n    \\t\\t\\tif(i>1)\\n    \\t\\t\\t\\tcheck(vec,i-1,j,row,col);\\n    \\t\\t\\tif(j>1)\\n    \\t\\t\\t\\tcheck(vec,i,j-1,row,col);\\n    \\t\\t\\tif(i+1<row)\\n    \\t\\t\\t\\tcheck(vec,i+1,j,row,col);\\n    \\t\\t\\tif(j+1<col)\\n    \\t\\t\\t\\tcheck(vec,i,j+1,row,col);\\n    \\t\\t}\\n    \\t}\\n    };"
		},
		{
			"lc_ans_id":"41630",
			"view":"10641",
			"top":"1",
			"title":"9 lines, Python 148 ms",
			"vote":"93",
			"content":"Phase 1: \"Save\" every O-region touching the border, changing its cells to 'S'.  \\nPhase 2: Change every 'S' on the board to 'O' and everything else to 'X'.\\n\\n    def solve(self, board):\\n        if not any(board): return\\n    \\n        m, n = len(board), len(board[0])\\n        save = [ij for k in range(m+n) for ij in ((0, k), (m-1, k), (k, 0), (k, n-1))]\\n        while save:\\n            i, j = save.pop()\\n            if 0 <= i < m and 0 <= j < n and board[i][j] == 'O':\\n                board[i][j] = 'S'\\n                save += (i, j-1), (i, j+1), (i-1, j), (i+1, j)\\n\\n        board[:] = [['XO'[c == 'S'] for c in row] for row in board]\\n\\nIn case you don't like my last line, you could do this instead:\\n\\n        for row in board:\\n            for i, c in enumerate(row):\\n                row[i] = 'XO'[c == 'S']"
		},
		{
			"lc_ans_id":"41617",
			"view":"23242",
			"top":"2",
			"title":"Solve it using Union Find",
			"vote":"91",
			"content":" \\n\\n    class UF\\n    {\\n    private:\\n    \\tint* id;     // id[i] = parent of i\\n    \\tint* rank;  // rank[i] = rank of subtree rooted at i (cannot be more than 31)\\n    \\tint count;    // number of components\\n    public:\\n    \\tUF(int N)\\n    \\t{\\n    \\t\\tcount = N;\\n    \\t\\tid = new int[N];\\n    \\t\\trank = new int[N];\\n    \\t\\tfor (int i = 0; i < N; i++) {\\n    \\t\\t\\tid[i] = i;\\n    \\t\\t\\trank[i] = 0;\\n    \\t\\t}\\n    \\t}\\n    \\t~UF()\\n    \\t{\\n    \\t\\tdelete [] id;\\n    \\t\\tdelete [] rank;\\n    \\t}\\n    \\tint find(int p) {\\n    \\t\\twhile (p != id[p]) {\\n    \\t\\t\\tid[p] = id[id[p]];    // path compression by halving\\n    \\t\\t\\tp = id[p];\\n    \\t\\t}\\n    \\t\\treturn p;\\n    \\t}\\n    \\tint getCount() {\\n    \\t\\treturn count;\\n    \\t}\\n    \\tbool connected(int p, int q) {\\n    \\t\\treturn find(p) == find(q);\\n    \\t}\\n    \\tvoid connect(int p, int q) {\\n    \\t\\tint i = find(p);\\n    \\t\\tint j = find(q);\\n    \\t\\tif (i == j) return;\\n    \\t\\tif (rank[i] < rank[j]) id[i] = j;\\n    \\t\\telse if (rank[i] > rank[j]) id[j] = i;\\n    \\t\\telse {\\n    \\t\\t\\tid[j] = i;\\n    \\t\\t\\trank[i]++;\\n    \\t\\t}\\n    \\t\\tcount--;\\n    \\t}\\n    };\\n    \\n    class Solution {\\n    public:\\n        void solve(vector<vector<char>> &board) {\\n            int n = board.size();\\n            if(n==0)    return;\\n            int m = board[0].size();\\n            UF uf = UF(n*m+1);\\n            \\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if((i==0||i==n-1||j==0||j==m-1)&&board[i][j]=='O') // if a 'O' node is on the boundry, connect it to the dummy node\\n                        uf.connect(i*m+j,n*m);\\n                    else if(board[i][j]=='O') // connect a 'O' node to its neighbour 'O' nodes\\n                    {\\n                        if(board[i-1][j]=='O')\\n                            uf.connect(i*m+j,(i-1)*m+j);\\n                        if(board[i+1][j]=='O')\\n                            uf.connect(i*m+j,(i+1)*m+j);\\n                        if(board[i][j-1]=='O')\\n                            uf.connect(i*m+j,i*m+j-1);\\n                        if(board[i][j+1]=='O')\\n                            uf.connect(i*m+j,i*m+j+1);\\n                    }\\n                }\\n            }\\n            \\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(!uf.connected(i*m+j,n*m)){ // if a 'O' node is not connected to the dummy node, it is captured\\n                        board[i][j]='X';\\n                    }\\n                }\\n            }\\n        }\\n    };\\n\\nHi. So here is my accepted code using **Union Find** data structure. The idea comes from the observation that if a region is NOT captured, it is connected to the boundry. So if we connect all the 'O' nodes on the boundry to a dummy node, and then connect each 'O' node to its neighbour 'O' nodes, then we can tell directly whether a 'O' node is captured by checking whether it is connected to the dummy node.\\nFor more about Union Find, the first assignment in the algo1 may help:\\nhttps://www.coursera.org/course/algs4partI"
		},
		{
			"lc_ans_id":"41649",
			"view":"21806",
			"top":"3",
			"title":"My BFS solution (C++ 28ms)",
			"vote":"66",
			"content":"The algorithm is quite simple: Use BFS starting from 'O's on the boundary and mark them as 'B', then iterate over the whole board and mark  'O' as 'X' and 'B' as 'O'. \\n\\n\\n\\n    void bfsBoundary(vector<vector<char> >& board, int w, int l)\\n    {\\n        int width = board.size();\\n        int length = board[0].size();\\n        deque<pair<int, int> > q;\\n        q.push_back(make_pair(w, l));\\n        board[w][l] = 'B';\\n        while (!q.empty()) {\\n            pair<int, int> cur = q.front();\\n            q.pop_front();\\n            pair<int, int> adjs[4] = {{cur.first-1, cur.second}, \\n                {cur.first+1, cur.second}, \\n                {cur.first, cur.second-1},\\n                {cur.first, cur.second+1}};\\n            for (int i = 0; i < 4; ++i)\\n            {\\n                int adjW = adjs[i].first;\\n                int adjL = adjs[i].second;\\n                if ((adjW >= 0) && (adjW < width) && (adjL >= 0)\\n                        && (adjL < length) \\n                        && (board[adjW][adjL] == 'O')) {\\n                    q.push_back(make_pair(adjW, adjL));\\n                    board[adjW][adjL] = 'B';\\n                }\\n            }\\n        }\\n    }\\n    \\n    void solve(vector<vector<char> > &board) {\\n        int width = board.size();\\n        if (width == 0) //Add this to prevent run-time error!\\n            return;\\n        int length = board[0].size();\\n        if  (length == 0) // Add this to prevent run-time error!\\n            return;\\n    \\n        for (int i = 0; i < length; ++i)\\n        {\\n            if (board[0][i] == 'O')\\n                bfsBoundary(board, 0, i);\\n    \\n            if (board[width-1][i] == 'O')\\n                bfsBoundary(board, width-1, i);\\n        }\\n    \\n        for (int i = 0; i < width; ++i)\\n        {\\n            if (board[i][0] == 'O')\\n                bfsBoundary(board, i, 0);\\n            if (board[i][length-1] == 'O')\\n                bfsBoundary(board, i, length-1);\\n        }\\n    \\n        for (int i = 0; i < width; ++i)\\n        {\\n            for (int j = 0; j < length; ++j)\\n            {\\n                if (board[i][j] == 'O')\\n                    board[i][j] = 'X';\\n                else if (board[i][j] == 'B')\\n                    board[i][j] = 'O';\\n            }\\n        }\\n    }\\n\\nNote that one of the test cases is when the board is empty. So if you don't check it in your code, you will encounter an run-time error."
		},
		{
			"lc_ans_id":"41633",
			"view":"18258",
			"top":"4",
			"title":"Java DFS + boundary cell turning solution, simple and clean code, commented.",
			"vote":"54",
			"content":"   \\tpublic void solve(char[][] board) {\\n\\t\\tif (board.length == 0 || board[0].length == 0)\\n\\t\\t\\treturn;\\n\\t\\tif (board.length < 2 || board[0].length < 2)\\n\\t\\t\\treturn;\\n\\t\\tint m = board.length, n = board[0].length;\\n\\t\\t//Any 'O' connected to a boundary can't be turned to 'X', so ...\\n\\t\\t//Start from first and last column, turn 'O' to '*'.\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tif (board[i][0] == 'O')\\n\\t\\t\\t\\tboundaryDFS(board, i, 0);\\n\\t\\t\\tif (board[i][n-1] == 'O')\\n\\t\\t\\t\\tboundaryDFS(board, i, n-1);\\t\\n\\t\\t}\\n\\t\\t//Start from first and last row, turn '0' to '*'\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (board[0][j] == 'O')\\n\\t\\t\\t\\tboundaryDFS(board, 0, j);\\n\\t\\t\\tif (board[m-1][j] == 'O')\\n\\t\\t\\t\\tboundaryDFS(board, m-1, j);\\t\\n\\t\\t}\\n\\t\\t//post-prcessing, turn 'O' to 'X', '*' back to 'O', keep 'X' intact.\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (board[i][j] == 'O')\\n\\t\\t\\t\\t\\tboard[i][j] = 'X';\\n\\t\\t\\t\\telse if (board[i][j] == '*')\\n\\t\\t\\t\\t\\tboard[i][j] = 'O';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t//Use DFS algo to turn internal however boundary-connected 'O' to '*';\\n\\tprivate void boundaryDFS(char[][] board, int i, int j) {\\n\\t\\tif (i < 0 || i > board.length - 1 || j <0 || j > board[0].length - 1)\\n\\t\\t\\treturn;\\n\\t\\tif (board[i][j] == 'O')\\n\\t\\t\\tboard[i][j] = '*';\\n\\t\\tif (i > 1 && board[i-1][j] == 'O')\\n\\t\\t\\tboundaryDFS(board, i-1, j);\\n\\t\\tif (i < board.length - 2 && board[i+1][j] == 'O')\\n\\t\\t\\tboundaryDFS(board, i+1, j);\\n\\t\\tif (j > 1 && board[i][j-1] == 'O')\\n\\t\\t\\tboundaryDFS(board, i, j-1);\\n\\t\\tif (j < board[i].length - 2 && board[i][j+1] == 'O' )\\n\\t\\t\\tboundaryDFS(board, i, j+1);\\n\\t}"
		},
		{
			"lc_ans_id":"41825",
			"view":"4320",
			"top":"5",
			"title":"Simple BFS solution - easy to understand",
			"vote":"30",
			"content":"The idea is to first find all 'O's on the edge, and do BFS from these 'O's. Keep adding 'O's into the queue in the BFS, and mark it as '+'. Since these 'O's are found by doing BFS from the 'O's on the edge, it means they are connected to the edge 'O's. so they are the 'O's that will remain as 'O' in the result. \\n\\nAfter BFS, there are some 'O's can not be reached, they are the 'O's that need to be turned as 'X'.\\n\\n\\n\\n\\n\\n    public class Solution {\\n        public void solve(char[][] board) {\\n            if (board.length == 0) return;\\n            \\n            int rowN = board.length;\\n            int colN = board[0].length;\\n            Queue<Point> queue = new LinkedList<Point>();\\n           \\n           //get all 'O's on the edge first\\n            for (int r = 0; r< rowN; r++){\\n            \\tif (board[r][0] == 'O') {\\n            \\t\\tboard[r][0] = '+';\\n                    queue.add(new Point(r, 0));\\n            \\t}\\n            \\tif (board[r][colN-1] == 'O') {\\n            \\t\\tboard[r][colN-1] = '+';\\n                    queue.add(new Point(r, colN-1));\\n            \\t}\\n            \\t}\\n            \\n            for (int c = 0; c< colN; c++){\\n            \\tif (board[0][c] == 'O') {\\n            \\t\\tboard[0][c] = '+';\\n                    queue.add(new Point(0, c));\\n            \\t}\\n            \\tif (board[rowN-1][c] == 'O') {\\n            \\t\\tboard[rowN-1][c] = '+';\\n                    queue.add(new Point(rowN-1, c));\\n            \\t}\\n            \\t}\\n            \\n    \\n            //BFS for the 'O's, and mark it as '+'\\n            while (!queue.isEmpty()){\\n            \\tPoint p = queue.poll();\\n            \\tint row = p.x;\\n            \\tint col = p.y;\\n            \\tif (row - 1 >= 0 && board[row-1][col] == 'O') {board[row-1][col] = '+'; queue.add(new Point(row-1, col));}\\n            \\tif (row + 1 < rowN && board[row+1][col] == 'O') {board[row+1][col] = '+'; queue.add(new Point(row+1, col));}\\n            \\tif (col - 1 >= 0 && board[row][col - 1] == 'O') {board[row][col-1] = '+'; queue.add(new Point(row, col-1));}\\n                if (col + 1 < colN && board[row][col + 1] == 'O') {board[row][col+1] = '+'; queue.add(new Point(row, col+1));}        \\t      \\n            }\\n            \\n    \\n            //turn all '+' to 'O', and 'O' to 'X'\\n            for (int i = 0; i<rowN; i++){\\n            \\tfor (int j=0; j<colN; j++){\\n            \\t\\tif (board[i][j] == 'O') board[i][j] = 'X';\\n            \\t\\tif (board[i][j] == '+') board[i][j] = 'O';\\n            \\t}\\n            }\\n           \\n            \\n        }\\n    }"
		},
		{
			"lc_ans_id":"41673",
			"view":"5489",
			"top":"6",
			"title":"My Java O(n^2) accepted solution",
			"vote":"26",
			"content":"The idea is pretty simple: a 'O' marked cell cannot be captured whether:\\n\\n1. It is in contact with the border of the board or\\n2. It is adjacent to an unflippable cell.\\n\\nSo the algorithm is straightforward:\\n\\n 1. Go around the border of the board\\n 2. When a 'O' cell is found mark it with 'U' and perform a DFS on its adjacent cells looking for other 'O' marked cells.\\n 3. When the entire border is processed scan again the board\\n- If a cell is marked as 'O' it wasn't connected to unflippable cell. Hence capture it with 'X'\\n- If a cell is marked as 'X' nothing must be done.\\n- If a cell is marked as 'U' mark it as 'O' because it was an original 'O' marked cell which satisfied one of the above conditions.\\n\\nOn a technical side regarding the code:\\n\\n- In the problem statement it's not specified that the board is rectangular. So different checks must performed when scanning the border.\\n- Since a pure recursive search causes stack overflow it's necessary to make the DFS iterative using a stack to simulate recursion.\\n\\n\\npublic class Solution {\\n\\n    static class Pair {\\n        public int first;\\n        public int second;\\n        public Pair(int f, int s) {\\n            first = f;\\n            second = s;\\n        }\\n    }\\n\\n    public void solve(char[][] board) {\\n        if(board == null || board.length == 0) {\\n            return ;\\n        }\\n        for(int i = 0; i < board[0].length; ++i) {\\n            if(board[0][i] == 'O') {\\n                markUnflippable(board,0,i);\\n            }\\n        }\\n        for(int i = 0; i < board[board.length-1].length; ++i) {\\n            if(board[board.length-1][i] == 'O') {\\n                markUnflippable(board,board.length-1,i);\\n            }\\n        }\\n        for(int i = 0 ; i < board.length; ++i) {\\n            if(board[i][0] == 'O') {\\n                markUnflippable(board,i,0);\\n            }\\n        }\\n        for(int i =0; i < board.length; ++i) {\\n            if(board[i][board[i].length-1] == 'O') {\\n                markUnflippable(board,i,board[i].length-1);\\n            }\\n        }\\n        \\n        // modify the board\\n        for(int i = 0; i < board.length; ++i) {\\n            for(int j = 0; j < board[i].length; ++j) {\\n                if(board[i][j] == 'O') {\\n                    board[i][j] = 'X';\\n                } else if(board[i][j] == 'U') {\\n                    board[i][j] = 'O';\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void markUnflippable(char[][] board, int r, int c) {\\n        int[] dirX = {-1,0,1,0};\\n        int[] dirY = {0,1,0,-1};\\n        ArrayDeque<Pair> stack = new ArrayDeque<>();\\n        stack.push(new Pair(r,c));\\n        while(!stack.isEmpty()) {\\n            Pair p = stack.pop();\\n            board[p.first][p.second] = 'U';\\n            for(int i = 0; i < dirX.length; ++i) {\\n                if(p.first + dirX[i] >= 0 && p.first + dirX[i] < board.length && p.second + dirY[i] >= 0 && p.second +dirY[i] < board[p.first + dirX[i]].length && board[p.first+dirX[i]][p.second+dirY[i]] == 'O') {\\n                    stack.push(new Pair(p.first+dirX[i],p.second+dirY[i]));\\n                }\\n            }\\n        }\\n    }\\n}"
		},
		{
			"lc_ans_id":"41895",
			"view":"3312",
			"top":"7",
			"title":"Share my clean Java Code",
			"vote":"20",
			"content":"    public class Solution {\\n        public void solve(char[][] board) {\\n            int rown = board.length;\\n            if (rown==0) return;\\n            int coln = board[0].length;\\n            for (int row=0; row<rown; ++row) {\\n                for (int col=0; col<coln; ++col) {\\n                    if (row==0 || row==rown-1 || col==0 || col==coln-1) {\\n                        if (board[row][col]=='O') {\\n                            Queue<Integer> q = new LinkedList<>();\\n                            board[row][col]='1';\\n                            q.add(row*coln+col);\\n                            while (!q.isEmpty()) {\\n                                int cur = q.poll();\\n                                int x = cur/coln;\\n                                int y = cur%coln;\\n                                if (y+1<coln && board[x][y+1]=='O') {\\n                                    q.add(cur+1);\\n                                    board[x][y+1] = '1';\\n                                }\\n                                if (x+1<rown && board[x+1][y]=='O') {\\n                                    q.add(cur+coln);\\n                                    board[x+1][y] = '1';\\n                                }\\n                                if (y-1>=0 && board[x][y-1]=='O') {\\n                                    q.add(cur-1);\\n                                    board[x][y-1] = '1';\\n                                }\\n                                if (x-1>=0 && board[x-1][y]=='O') {\\n                                    q.add(cur-coln);\\n                                    board[x-1][y] = '1';\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            for (int i=0; i<rown; ++i) {\\n                for (int j=0; j<coln; ++j) {\\n                    if (board[i][j]=='O') {\\n                        board[i][j]='X';\\n                    } else if (board[i][j]=='1') {\\n                        board[i][j]='O';\\n                    }\\n                }\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"41652",
			"view":"1788",
			"top":"8",
			"title":"Python short BFS solution.",
			"vote":"17",
			"content":"        \\n    # BFS\\n    def solve(self, board):\\n        queue = collections.deque([])\\n        for r in xrange(len(board)):\\n            for c in xrange(len(board[0])):\\n                if (r in [0, len(board)-1] or c in [0, len(board[0])-1]) and board[r][c] == \"O\":\\n                    queue.append((r, c))\\n        while queue:\\n            r, c = queue.popleft()\\n            if 0<=r<len(board) and 0<=c<len(board[0]) and board[r][c] == \"O\":\\n                board[r][c] = \"D\"\\n                queue.append((r-1, c)); queue.append((r+1, c))\\n                queue.append((r, c-1)); queue.append((r, c+1))\\n            \\n        for r in xrange(len(board)):\\n            for c in xrange(len(board[0])):\\n                if board[r][c] == \"O\":\\n                    board[r][c] = \"X\"\\n                elif board[r][c] == \"D\":\\n                    board[r][c] = \"O\""
		},
		{
			"lc_ans_id":"41708",
			"view":"2856",
			"top":"9",
			"title":"JAVA-----------Easy Version To UnderStand!!!!!!!!!!!!",
			"vote":"14",
			"content":"----------\\n## Use BFS.This problem is similar to Number of Islands. In this problem, only the cells on the boarders can not be surrounded. So we can first merge those O's on the boarders like in Number of Islands and replace O's with 'B', and then scan the board and replace all O's left (if any). ##\\n\\n    class Point {\\n\\tint x;\\n\\tint y;\\n\\tPoint(int x, int y) {\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n}\\n\\n    public static void solve(char[][] board) {\\n\\t\\tif (board == null || board.length == 0)\\n\\t\\t\\treturn;\\n\\t\\tint rows = board.length, columns = board[0].length;\\n\\t\\tint[][] direction = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\\n\\t\\tfor (int i = 0; i < rows; i++)\\n\\t\\t\\tfor (int j = 0; j < columns; j++) {\\n\\t\\t\\t\\tif ((i == 0 || i == rows - 1 || j == 0 || j == columns - 1) && board[i][j] == 'O') {\\n\\t\\t\\t\\t\\tQueue<Point> queue = new LinkedList<>();\\n\\t\\t\\t\\t\\tboard[i][j] = 'B';\\n\\t\\t\\t\\t\\tqueue.offer(new Point(i, j));\\n\\t\\t\\t\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t\\t\\t\\tPoint point = queue.poll();\\n\\t\\t\\t\\t\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\t\\t\\tint x = direction[k][0] + point.x;\\n\\t\\t\\t\\t\\t\\t\\tint y = direction[k][1] + point.y;\\n\\t\\t\\t\\t\\t\\t\\tif (x >= 0 && x < rows && y >= 0 && y < columns && board[x][y] == 'O') {\\n\\t\\t\\t\\t\\t\\t\\t\\tboard[x][y] = 'B';\\n\\t\\t\\t\\t\\t\\t\\t\\tqueue.offer(new Point(x, y));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\tfor (int i = 0; i < rows; i++)\\n\\t\\t\\tfor (int j = 0; j < columns; j++) {\\n\\t\\t\\t\\tif (board[i][j] == 'B')\\n\\t\\t\\t\\t\\tboard[i][j] = 'O';\\n\\t\\t\\t\\telse if (board[i][j] == 'O')\\n\\t\\t\\t\\t\\tboard[i][j] = 'X';\\n\\t\\t\\t}\\n\\n\\t}"
		}
	],
	"id":"130",
	"title":"Surrounded Regions",
	"content":"<p>\r\nGiven a 2D board containing <code>'X'</code> and <code>'O'</code> (the <b>letter</b> O), capture all regions surrounded by <code>'X'</code>.</p>\r\n\r\n<p>A region is captured by flipping all <code>'O'</code>s into <code>'X'</code>s in that surrounded region.\r\n</p>\r\n\r\n<p>\r\nFor example,<br />\r\n<pre>\r\nX X X X\r\nX O O X\r\nX X O X\r\nX O X X\r\n</pre>\r\n</p>\r\n\r\n<p>\r\nAfter running your function, the board should be:\r\n<pre>\r\nX X X X\r\nX X X X\r\nX X X X\r\nX O X X\r\n</pre>\r\n</p>",
	"frequency":"294",
	"ac_num":"95735"
}