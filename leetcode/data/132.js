{
	"difficulty":"3",
	"submit_num":"316681",
	"show_id":"132",
	"leetcode_id":"132",
	"answers":[
		{
			"lc_ans_id":"42198",
			"view":"39877",
			"top":"0",
			"title":"My solution does not need a table for palindrome, is it right ? It uses only O(n) space.",
			"vote":"527",
			"content":"    class Solution {\\n    public:\\n        int minCut(string s) {\\n            int n = s.size();\\n            vector<int> cut(n+1, 0);  // number of cuts for the first k characters\\n            for (int i = 0; i <= n; i++) cut[i] = i-1;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome\\n                    cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);\\n    \\n                for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome\\n                    cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);\\n            }\\n            return cut[n];\\n        }\\n    };"
		},
		{
			"lc_ans_id":"42199",
			"view":"20814",
			"top":"1",
			"title":"My DP Solution ( explanation and code)",
			"vote":"102",
			"content":"Calculate and maintain 2 DP states: \\n\\n 1. pal[i][j] , which is whether s[i..j] forms a pal\\n \\n 2.  d[i], which\\n        is the minCut for s[i..n-1]\\n\\nOnce we comes to a pal[i][j]==true:\\n\\n - if j==n-1, the string s[i..n-1] is a Pal, minCut is 0, d[i]=0; \\n - else: the current cut num (first cut s[i..j] and then cut the rest\\n   s[j+1...n-1]) is 1+d[j+1], compare it to the exisiting minCut num\\n   d[i], repalce if smaller.\\n\\nd[0] is the answer.\\n\\n     class Solution {\\n        public:\\n            int minCut(string s) {\\n                if(s.empty()) return 0;\\n                int n = s.size();\\n                vector<vector<bool>> pal(n,vector<bool>(n,false));\\n                vector<int> d(n);\\n                for(int i=n-1;i>=0;i--)\\n                {\\n                    d[i]=n-i-1;\\n                    for(int j=i;j<n;j++)\\n                    {\\n                        if(s[i]==s[j] && (j-i<2 || pal[i+1][j-1]))\\n                        {\\n                           pal[i][j]=true;\\n                           if(j==n-1)\\n                               d[i]=0;\\n                           else if(d[j+1]+1<d[i])\\n                               d[i]=d[j+1]+1;\\n                        }\\n                    }\\n                }\\n                return d[0];\\n            }\\n        };"
		},
		{
			"lc_ans_id":"42213",
			"view":"11579",
			"top":"2",
			"title":"Easiest Java DP Solution (97.36%)",
			"vote":"94",
			"content":"This can be solved by two points:\\n\\n 1. `cut[i]` is the minimum of `cut[j - 1] + 1 (j <= i)`, if `[j, i]` is palindrome.\\n 2. If  `[j, i]` is palindrome, `[j + 1, i - 1]` is palindrome, and `c[j]  == c[i]`.\\n\\nThe 2nd point reminds us of using dp (caching).\\n\\n    a   b   a   |   c  c\\n                    j  i\\n           j-1  |  [j, i] is palindrome\\n       cut(j-1) +  1\\n\\n\\nHope it helps!\\n\\n    public int minCut(String s) {\\n        char[] c = s.toCharArray();\\n        int n = c.length;\\n        int[] cut = new int[n];\\n        boolean[][] pal = new boolean[n][n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            int min = i;\\n            for(int j = 0; j <= i; j++) {\\n                if(c[j] == c[i] && (j + 1 > i - 1 || pal[j + 1][i - 1])) {\\n                    pal[j][i] = true;  \\n                    min = j == 0 ? 0 : Math.min(min, cut[j - 1] + 1);\\n                }\\n            }\\n            cut[i] = min;\\n        }\\n        return cut[n - 1];\\n    }"
		},
		{
			"lc_ans_id":"42212",
			"view":"6361",
			"top":"3",
			"title":"Two C++ versions given (one DP 28ms, one Manancher-like algorithm 10 ms)",
			"vote":"53",
			"content":"One typical solution is DP based. Such solution first constructs a two-dimensional bool array isPalin to indicate whether the sub-string s[i..j] is palindrome. To get such array, we need O(N^2) time complexity. Moreover, to get the minimum cuts, we need another array minCuts to do DP and minCuts[i] saves the minimum cuts found for the sub-string s[0..i-1]. minCuts[i] is initialized to i-1, which is the maximum cuts needed (cuts the string into one-letter characters) and minCuts[0] initially sets to -1, which is needed in the case that s[0..i-1] is a palindrome. When we construct isPalin array, we update minCuts everytime we found a palindrome sub-string, i.e. if s[i..j] is a palindrome, then minCuts[j+1] will be updated to the minimum of the current minCuts[j+1] and minCut[i]+1(i.e. cut s[0..j] into s[0,i-1] and s[i,j]). At last, we return minCuts[N]. \\nSo the complexity is O(N^2). However, it can be further improved since as described above, we only update minCuts when we find a palindrome substring, while the DP algorithm spends lots of time to calculate isPalin, most of which is false (i.e. not a palindrome substring). If we can reduce such unnecessary calculation, then we can speed up the algorithm. This can be achieved with a Manancher-like solution, which is also given as following. \\n\\n    // DP solution\\n        class Solution {\\n        public:\\n            int minCut(string s) {\\n                const int N = s.size();\\n                if(N<=1) return 0;\\n                int i,j;\\n                bool isPalin[N][N];\\n                fill_n(&isPalin[0][0], N*N, false);\\n                int minCuts[N+1];\\n                for(i=0; i<=N; ++i) minCuts[i] = i-1;\\n                \\n                for(j=1; j<N; ++j)\\n                {\\n                    for(i=j; i>=0; --i)\\n                    {\\n                        if( (s[i] == s[j]) && ( ( j-i < 2 ) || isPalin[i+1][j-1] ) )\\n                        {\\n                            isPalin[i][j] = true;\\n                            minCuts[j+1] = min(minCuts[j+1], 1 + minCuts[i]);    \\n                        }\\n                    }\\n                }\\n                return minCuts[N];\\n                \\n            }\\n        };\\n\\nThe Manancher-like solution scan the array from left to right (for i loop) and only check those sub-strings centered at s[i]; once a non-palindrome string is found, it will stop and move to i+1. Same as the DP solution, minCUTS[i] is used to save the minimum cuts for s[0:i-1]. For each i, we do two for loops (for j loop) to check if the substrings s[i-j .. i+j] (odd-length substring) and s[i-j-1.. i+j] (even-length substring) are palindrome. By increasing j from 0, we can find all the palindrome sub-strings centered at i and update minCUTS accordingly. Once we meet one non-palindrome sub-string, we stop for-j loop since we know there no further palindrome substring centered at i. This helps us avoid unnecessary palindrome substring checks, as we did in the DP algorithm. Therefore, this version is faster. \\n\\n    //Manancher-like solution\\n    class Solution {\\n    public:\\n        int minCut(string s) {\\n            const int N = s.size();\\n            if(N<=1) return 0;\\n            \\n            int i, j, minCUTS[N+1];\\n            for(i=0; i<=N; ++i) minCUTS[i] = i-1;\\n            \\n            for(i=1;i<N;i++)\\n            {\\n                for(j=0;(i-j)>=0 && (i+j)<N && s[i-j]== s[i+j]; ++j) // odd-length substrings \\n                    minCUTS[i+j+1] = min(minCUTS[i+j+1], 1 + minCUTS[i-j]);\\n    \\n                for(j=0;(i-j-1)>=0 && (i+j)<N && s[i-j-1]== s[i+j]; ++j) // even-length substrings\\n                    minCUTS[i+j+1] = min(minCUTS[i+j+1], 1 + minCUTS[i-j-1]);\\n            }\\n            return minCUTS[N];\\n        }\\n    };"
		},
		{
			"lc_ans_id":"42277",
			"view":"5537",
			"top":"4",
			"title":"DP solution & some thoughts",
			"vote":"22",
			"content":"Some thoughts:\\n\\n1. return the mininum cut of the partition s => optimization => DP\\n2. try to divide & conqure => \\n\\n public int minCutRecur(String s){\\n        int n = s.length;\\n        \\n        //base case\\n        if(s < 2 || isPalindr(s)) return 0;\\n        int min = n - 1;\\n        for(int i = 1; i <= n - 1; i++){\\n            if(isPalindr(s)){\\n                min = Math.min(min, 1 + minCutRecur(s.substring(i)));\\n            }\\n        }\\n        \\n        return min;\\n }\\n\\nHowever, sub problem overlapped (are not independent with each other). \\n\\n3. Use DP to build the solution from bottom up.\\n\\n    public int minCut(String s) {\\n            int n = s.length(); \\n            \\n            boolean[][] isPalindr = new boolean[n + 1][n + 1]; //isPalindr[i][j] = true means s[i:j) is a valid palindrome\\n            int[] dp = new int[n + 1]; //dp[i] means the minCut for s[0:i) to be partitioned \\n    \\n            for(int i = 0; i <= n; i++) dp[i] = i - 1;//initialize the value for each dp state.\\n            \\n            for(int i = 2; i <= n; i++){\\n                for(int j = i - 1; j >= 0; j--){\\n                    //if(isPalindr[j][i]){\\n                    if(s.charAt(i - 1) == s.charAt(j) && (i - 1 - j < 2 || isPalindr[j + 1][i - 1])){\\n                        isPalindr[j][i] = true;\\n                        dp[i] = Math.min(dp[i], dp[j] + 1);\\n                    }\\n                }\\n            }\\n            \\n            return dp[n];\\n    }\\n\\nSeveral optimizations include: \\n\\n 1. No need to check if a string is a palindrome or not inside the loop by adjusting the order of getting of solution of the sub problems. \\n 2. assign dp[0] to be -1 so that when s[0:i) is a palindrome by itself, dp[i] is 0. This is for the consistency of the code.\\n\\nThe time complexity and the space complexity are both O(n ^ 2)."
		},
		{
			"lc_ans_id":"42257",
			"view":"3128",
			"top":"5",
			"title":"Solved by shortest path algorithm, clear and straightforward, O(n^2)",
			"vote":"12",
			"content":"1) Build the directed acyclic graph: if substring s[i, .., j] is a palindrome, then there is an edge from i to j+1.\\n2) Find the shortest path d from 0 to n. Then d - 1 is the mincut.\\n\\n    class Solution {\\n     public:\\n      int minCut(string s) {\\n        int n = s.size();\\n        if (n <= 0) return 0;\\n    \\n        vector<vector<bool> > lut(n, vector<bool>(n, true));\\n        vector<vector<int> > adjList(n+1, vector<int>());\\n    \\n        // build the palindrome look up table, O(n^2)\\n        for (int k = 1; k <= n-1; ++k) {\\n          int i = 0, j = k;\\n          while (j < n) {\\n            lut[i][j] = (s[i] == s[j] && lut[i+1][j-1]);\\n            ++i;\\n            ++j;\\n          }\\n        }\\n    \\n        // build the graph, O(n^2);\\n        for (int i = 0; i < n; ++i) {\\n          for (int j = i; j < n; ++j) {\\n            if (lut[i][j] == true) {\\n              adjList[i].push_back(j+1);\\n            }\\n          }\\n        }\\n    \\n        // Use bfs to find shortest path from 0 to n, O(|E|)\\n        // |E| is the number of edges, at most O(n^2)\\n        vector<int> dist(n+1, -1);\\n        queue<int> q;\\n    \\n        dist[0] = 0;\\n        q.push(0);\\n    \\n        while (!q.empty()) {\\n          int u = q.front();\\n          q.pop();\\n    \\n          if (u == n) break;\\n    \\n          vector<int>& neighbors = adjList[u];\\n\\n          // Greedy strategy, in reversed order so that furthest nodes are explored first.\\n          for (auto it = neighbors.rbegin(); it != neighbors.rend(); ++it) {\\n            int v = *it;\\n            if (dist[v] == -1) {\\n              q.push(v);\\n              dist[v] = dist[u] + 1;\\n            }\\n          }\\n        }\\n    \\n        return dist[n] - 1;\\n      }\\n    \\n    };"
		},
		{
			"lc_ans_id":"42205",
			"view":"2080",
			"top":"6",
			"title":"56 ms python with explanation",
			"vote":"10",
			"content":"Algorithm (460 ms) credits go to:\\n[https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space][1]\\n\\nThe main algorithm idea is if s[i,j] is a palindrome, then the minCut(s[:j]) is **at most** minCut(s[:i-1])+1. This literally needs to find out all possible palindromes in the list. The above post provides an efficient search algorithm. O(n) space and O(n^2) time complexity.\\n\\nFurther acceleration (460 ms -> 56 ms) credits go to:\\n[https://leetcode.com/discuss/43950/python-100ms-extra-dealing-super-cases-reduces-576ms-100ms][2]\\n\\nThe main idea for acceleration is to quickly check and exclude a few long palindrome tests..\\n\\n    def minCut(self, s):\\n        # acceleration\\n        if s == s[::-1]: return 0\\n        for i in range(1, len(s)):\\n            if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]:\\n                return 1\\n        # algorithm\\n        cut = [x for x in range(-1,len(s))]  # cut numbers in worst case (no palindrome)\\n        for i in range(len(s)):\\n            r1, r2 = 0, 0\\n            # use i as origin, and gradually enlarge radius if a palindrome exists\\n            # odd palindrome\\n            while i-r1 >= 0 and i+r1 < len(s) and s[i-r1] == s[i+r1]:\\n                cut[i+r1+1] = min(cut[i+r1+1], cut[i-r1]+1)\\n                r1 += 1\\n            # even palindrome\\n            while i-r2 >= 0 and i+r2+1 < len(s) and s[i-r2] == s[i+r2+1]:\\n                cut[i+r2+2] = min(cut[i+r2+2], cut[i-r2]+1)\\n                r2 += 1\\n        return cut[-1]\\n\\nThe following code simply implements the algorithm without any optimization (1800 ms), and should be easier to understand. O(n) space and O(n^3) time complexity.\\n\\n    def minCut(self, s):\\n        cut = [x for x in range(-1,len(s))]\\n        for i in range(0,len(s)):\\n            for j in range(i,len(s)):\\n                if s[i:j] == s[j:i:-1]:\\n                    cut[j+1] = min(cut[j+1],cut[i]+1)\\n        return cut[-1]\\n\\n\\n  [1]: https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space\\n  [2]: https://leetcode.com/discuss/43950/python-100ms-extra-dealing-super-cases-reduces-576ms-100ms"
		},
		{
			"lc_ans_id":"42241",
			"view":"1415",
			"top":"7",
			"title":"My accepted Java solution",
			"vote":"6",
			"content":"I've solved the problem some time ago (with DP, of course), and I thought I would share it:\\n \\n  \\n\\n     public class Solution {\\n            int[] cost;\\n            public int minCut(String s) {\\n                if (s == null || s.length() < 2) return 0;\\n                int N = s.length();\\n                cost = new int[N]; \\n                for (int i = 0; i < N; i++)\\n                    cost[i] = Integer.MAX_VALUE;\\n                cut(s);\\n                return cost[N-1];\\n            }\\n            \\n            private void cut (String s) {\\n                if (s.length() > 0) cost[0] = 0;\\n                if (s.length() > 1) cost[1] = s.charAt(1) == s.charAt(0) ? 0 : 1;\\n                int k = 0, l = 0, ni = 0;\\n                for (int i = 2; i < s.length(); i++) {\\n                    if (cost[i] == Integer.MAX_VALUE) cost[i] = cost[i-1]+1;\\n                    for (int j = 1; j <= 2; j++) {\\n                        for (k = i-j, l = i;\\n                            k >= 0 && l <= s.length()-1 && s.charAt(k) == s.charAt(l);\\n                            k--, l++) {\\n                            int c = k == 0 ? 0 : cost[k-1]+1;\\n                            if (cost[l] > c) cost[l] = c;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n## Explanation ##\\nSo my thought process was go through the string, char by char starting from the left. The current character would be the center of the palindrome and expand as much as I can. After it ceases to be a palindrome (e.g no longer matching end chars or reached the boundary of the string), the cost would be \\n\"1 + the cost of the substring I already processed to the left of the current palindrome I am on\". I compare this cost under the index of the last char of my current palindrome. If it is less than what was previously recorded, the I record this new cost.\\n\\nFor example, let's take 'abb':\\n\\n - Start with 'a'. Obviously a cost of 0 (base case)\\n - Now we go to 'b' (index 1). Since we haven't visited 'b', let's assign an initial cost to it, which is 1 + cost[0]. So cost[1] = 0+1 = 1. This makes sense since you only need a 1 cut to get two palindromes: 'a' and 'b'\\n - Let's try to expand 'b'\\n<ul><li> 'ab': It's not a palindrome so do nothing</li>\\n<li>'abb': Not a palindrome either</li></ul></li>\\nAfter expansion, cost[1] remains 1.\\n - Now we go to 'b' (index 2). Initial cost[2] = cost[1]+1 = 2. Expanding...\\n<ul><li> 'bb': Hey, a palindrome! So I will compute a cost of cost[0]+1 = 1 (remember \"1 + cost of substring to the left...). Is 1 less than what I initially have in cost[2]? Yup, it is. So I record it: cost[2] = 1</li></ul></li>\\nAfter expansion, cost[2] was changed from 2 to 1, and rightfully so because that is the minimum cut we can do to get all substrings as palindromes: 'a' and 'bb'.\\n\\nAnother example but we'll go faster this time: 'xccx'\\n\\n - 'x': cost[0] = 0. Base case.\\n - 'c' (index 1): Init cost[1] = 1. Expanding...\\n<ul><li> 'xc': Nope</li>\\n<li>'xcc': Nope</li></ul></li>\\n - 'c': Init cost[2] = 2. Expanding...\\n<ul><li> 'cc->xccx': Yes. Since we reached start of string, this is a base case. So new cost = 0. Is 0 > cost[3] = Integer.MAX_VALUE? Yes, so cost[3] = 0</li>\\n<li>'ccx': Nope</li></ul></li>\\n - 'x': Since cost[3] was previously entered a cost, we don't need to init. Expanding...\\n<ul><li> 'cx': Nope</li></ul></li>\\n - Cost to cut entire string: cost[3] = 0\\n\\nSo there you go. With this method, you are assured that remaining substring (or 'previous state') to the left of the current palindrome is the minimum at that point because you already computed it earlier. You just need to +1 to the cost and see if you have a new minimum cost for the state you are currently in (the last character of the current palindrome).\\n\\nSorry for the lengthy explanation :|"
		},
		{
			"lc_ans_id":"42267",
			"view":"797",
			"top":"8",
			"title":"24ms c++ solution with BFS, no dp",
			"vote":"5",
			"content":"Of course you can use dp or dp+bfs while it won't work well in the situation that the string has many duplicates(e.g.,\"aa\\u2026aa\"). The function ispal() looks simple and crude. But it is more efficient than you think, because of the characters of palindromic strings. \\n\\n\\n    class Solution {\\n    public:\\n    \\tint minCut(string s) {\\n    \\t\\tqueue<int> node;\\n    \\t\\tnode.push(0);\\n    \\t\\tint cuts = 0;\\n    \\t\\t//bfs\\n    \\t\\tvector<bool> visited(s.size(), false);\\n    \\t\\twhile (true){\\n    \\t\\t\\tqueue<int> tmp;\\n    \\t\\t\\twhile (!node.empty()){\\n    \\t\\t\\t\\tint cur = node.front();\\n    \\t\\t\\t\\tnode.pop();\\n    \\t\\t\\t\\tfor (int i = s.size() - 1; i >= cur; i--){\\n    \\t\\t\\t\\t\\tif (visited[i]==false&&ispal(s, cur, i)){\\n    \\t\\t\\t\\t\\t\\tif (i == s.size() - 1)\\n    \\t\\t\\t\\t\\t\\t\\treturn cuts;\\n    \\t\\t\\t\\t\\t\\ttmp.push(i+1);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tvisited[cur] = true;\\n    \\t\\t\\t}\\n    \\t\\t\\tcuts++;\\n    \\t\\t\\tnode = tmp;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\tbool ispal(string& s, int pre, int post){\\n    \\t\\twhile (pre < post){\\n    \\t\\t\\tif (s[pre++] != s[post--])\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\treturn true;\\n    \\t}\\n    };"
		},
		{
			"lc_ans_id":"42251",
			"view":"2218",
			"top":"9",
			"title":"My accepted O(n^2) DP solution in Java",
			"vote":"5",
			"content":"    public class Solution {\\n        public int minCut(String s) {\\n             if(s==null)\\n                return 0;\\n             int i,j,n=s.length();\\n             int cuts[]=new int[n];   //cuts[i] will store the minimum no. of cuts required for substring [0...i];\\n             boolean dp[][]=new boolean[n][n];   // dp[i][j]=true if substring [i...j] can be partitioned into list of palindromes.\\n            \\n            for(i=0;i<n;i++)\\n            {\\n                /*since every single character is a palindrome, maximum no. of cuts for substring [0...i] will be i\\n                 hence initiating cuts[i] with maximum possible value. */        \\n                 \\n                cuts[i]=i; \\n                for(j=0;j<=i;j++)\\n                { \\n                    if(j == i)\\n                       dp[j][i] = true;\\n                    else\\n                    {\\n                      if(s.charAt(i)!= s.charAt(j))\\n                      continue;\\n                      if(j==i-1)\\n                      \\n                      dp[j][i]=true;\\n                      else\\n                      dp[j][i]=dp[j+1][i-1] ;\\n                    }\\n                    \\n                  if(dp[j][i])\\n                  {\\n                      if(j==0)\\n                      cuts[i]=0;\\n                      else\\n                      cuts[i]=Math.min(cuts[j-1]+1,cuts[i]);  \\n                     /*since dp[j][i] is a palindrome, cuts[j]+1 equals no. of cuts required in [0...i] if we include the current  word [j..i]; New cuts[i] will be equal to min of previous cuts[i] and the newly calculated cuts[i] i.e. cuts[j]+1 */\\n                  }\\n                  \\n                  \\n                }\\n            }\\n            return cuts[n-1];\\n            \\n        }\\n    }"
		}
	],
	"id":"132",
	"title":"Palindrome Partitioning II",
	"content":"<p>\r\nGiven a string <i>s</i>, partition <i>s</i> such that every substring of the partition is a palindrome.\r\n</p>\r\n<p>\r\nReturn the minimum cuts needed for a palindrome partitioning of <i>s</i>.\r\n</p>\r\n<p>\r\nFor example, given <i>s</i> = <code>\"aab\"</code>,<br />\r\nReturn <code>1</code> since the palindrome partitioning <code>[\"aa\",\"b\"]</code> could be produced using 1 cut.\r\n</p>",
	"frequency":"283",
	"ac_num":"78152"
}