{
	"difficulty":"2",
	"submit_num":"305526",
	"show_id":"137",
	"leetcode_id":"137",
	"answers":[
		{
			"lc_ans_id":"43294",
			"view":"97427",
			"top":"0",
			"title":"Challenge me , thx",
			"vote":"551",
			"content":"    public int singleNumber(int[] A) {\\n        int ones = 0, twos = 0;\\n        for(int i = 0; i < A.length; i++){\\n            ones = (ones ^ A[i]) & ~twos;\\n            twos = (twos ^ A[i]) & ~ones;\\n        }\\n        return ones;\\n    }"
		},
		{
			"lc_ans_id":"43295",
			"view":"41280",
			"top":"1",
			"title":"Detailed explanation and generalization of the bitwise operation method for single numbers",
			"vote":"440",
			"content":"---\\n`I -- Statement of our problem`\\n\\n\"Given an array of integers, every element appears `k` (`k > 1`) times except for one, which appears `p` times (`p >= 1, p % k != 0`). Find that single one.\" \\n\\n---\\n\\n`II -- Special case with 1-bit numbers`\\n\\nAs others pointed out, in order to apply the bitwise operations, we should rethink how integers are represented in computers -- by bits. To start, let's consider only one bit for now. Suppose we have an array of **1-bit** numbers (which can only be `0` or `1`), we'd like to count the number of `1`'s in the array such that whenever the counted number of `1` reaches a certain value, say `k`, the count returns to zero and starts over (in case you are curious, this `k` will be the same as the one in the problem statement above). To keep track of how many `1`'s we have encountered so far, we need a counter. Suppose the counter has `m` bits in binary form: `xm, ..., x1` (from most significant bit to least significant bit). We can conclude at least the following four properties of the counter:\\n\\n1. There is an initial state of the counter, which for simplicity is zero;\\n2. For each input from the array, if we hit a `0`, the counter should remain unchanged;\\n3. For each input from the array, if we hit a `1`, the counter should increase by one;\\n4. In order to cover `k` counts, we require `2^m >= k`, which implies `m >= logk`.\\n\\nHere is the key part: how each bit in the counter (`x1` to `xm`) changes as we are scanning the array. Note we are prompted to use bitwise operations. In order to satisfy the second property, recall what bitwise operations will not change the operand if the other operand is `0`? Yes, you got it: `x = x | 0` and `x = x ^ 0`. \\n\\nOkay, we have an expression now: `x = x | i`  or  `x = x ^ i`, where `i` is the scanned element from the array. Which one is better?  We don't know yet. So, let's just do the actual counting.\\n\\nAt the beginning, all bits of the counter is initialized to zero, i.e., `xm = 0, ..., x1 = 0`.  Since we are gonna choose bitwise operations that guarantee all bits of the counter remain unchanged if we hit `0`'s, the counter will be `0` until we hit the first `1` in the array. After we hit the first `1`, we got:  `xm = 0,  ...,x2 = 0, x1 = 1`. Let's continue until we hit the second `1`, after which we have:  `xm = 0, ..., x2 = 1, x1 = 0`. Note that `x1` changed from `1` to `0`. For `x1 = x1 | i`, after the second count, `x1` will still be `1`. So it's clear we should use `x1 = x1 ^ i`. What about `x2, ..., xm`? The idea is to find the condition under which `x2, ..., xm` will change their values. Take `x2` as an example. If we hit a `1` and need to change the value of `x2`, what must be the value of `x1` right before we do the change? The answer is: `x1` must be `1` otherwise we shouldn't change `x2` because changing `x1` from `0` to `1` will do the job. So `x2` will change value only if `x1` and `i` are both `1`, or mathematically, `x2 = x2 ^ (x1 & i)`.  Similarly `xm` will change value only when `xm-1, ..., x1` and `i` are all `1`: `xm = xm ^ (xm-1 & ... &  x1 & i)`. Bingo, we've found the bitwise operations! \\n\\nHowever, you may notice that the bitwise operations found above will count from `0` until `2^m - 1`, instead of `k`. If `k < 2^m - 1`, we need some \"cutting\" mechanism to reinitialize the counter to `0` when the count reaches `k`. To this end, we apply bitwise **AND** to `xm,..., x1` with some variable called `mask`, i.e., `xm = xm & mask,  ...,  x1 = x1 & mask`. If we can make sure that `mask` will be `0` only when the count reaches `k` and be `1` for all other count cases, then we are done. How do we achieve that? Try to think what distinguishes the case with `k` count from all other count cases. Yes, it's the count of `1`'s! For each count, we have unique values for each bit of the counter, which can be regarded as its state. If we write `k` in its binary form: `km,..., k1`, we can construct `mask` as follows:\\n\\n`mask = ~(y1 & y2 & ... & ym)`,  where `yj = xj`  if `kj = 1`, and  `yj = ~xj`  if `kj = 0` (`j = 1` to `m`). \\n\\nLet's do some examples:\\n\\n`k = 3: k1 = 1, k2 = 1, mask = ~(x1 & x2)`;\\n\\n`k = 5: k1 = 1, k2 = 0, k3 = 1, mask = ~(x1 & ~x2 & x3)`;\\n\\nIn summary, our algorithm will go like this (`nums` is the input array):\\n```\\nfor (int i : nums) {\\n    xm ^= (xm-1 & ... & x1 & i);\\n    xm-1 ^= (xm-2 & ... & x1 & i);\\n    .....\\n    x1 ^= i;\\n    \\n    mask = ~(y1 & y2 & ... & ym) where yj = xj if kj = 1, and yj = ~xj if kj = 0 (j = 1 to m).\\n\\n    xm &= mask;\\n    ......\\n    x1 &= mask;\\n}\\n```\\n\\n---\\n`III -- General case with 32-bit numbers`\\n\\nNow it's time to generalize our results from 1-bit number case to 32-bit integers. One straightforward way would be creating `32` counters for each bit in the integer. You've probably already seen this in other posted [solutions](https://discuss.leetcode.com/topic/455/constant-space-solution/4). However, if we take advantage of bitwise operations, we may be able to manage all the `32` counters \"collectively\". By saying \"collectively\", we mean using `m` **32-bit** integers instead of `32` **m-bit** counters, where `m` is the minimum integer that satisfies `m >= logk`. The reason is that bitwise operations apply only to each bit so operations on different bits are independent of each other (kind obvious, right?). This allows us to group the corresponding bits of the `32` counters into one 32-bit integer. Here is a schematic diagram showing how this is done. \\n\\n![0_1510941016426_137. Single Number II .png](/assets/uploads/files/1510941017203-137.single-number-ii-resized.png) \\n\\nThe top row is the 32-bit integer, where for each bit, we have a corresponding m-bit counter (shown by the column below the upward arrow). Since bitwise operations on each of the `32` bits are independent of each other, we can group, say the `m-th` bit of all counters, into one 32-bit number (shown by the orange box). All bits in this 32-bit number (denoted as `xm`) will follow the same bitwise operations. Since each counter has `m` bits, we end up with `m` 32-bit numbers, which correspond to `x1, ..., xm` defined in part `II`, but now they are 32-bit integers instead of 1-bit numbers. Therefore, in the algorithm developed above, we just need to regard `x1` to `xm` as 32-bit integers instead of 1-bit numbers. Everything else will be the same and we are done. Easy, hum?\\n\\n---\\n`IV -- What to return`\\n\\nThe last thing is what value we should return, or equivalently which one of `x1` to `xm` will equal the single element. To get the correct answer, we need to understand what the `m` 32-bit integers `x1` to `xm` represent. Take `x1` as an example. `x1` has `32` bits and let's label them as `r` (`r = 1` to `32`). After we are done scanning the input array, the value for the `r-th` bit of `x1` will be determined by the `r-th` bit of all the elements in the array (more specifically, suppose the total count of `1` for the `r-th` bit of all the elements in the array is `q`, `q' = q % k` and in its binary form: `q'm,...,q'1`, then by definition the `r-th` bit of `x1` will be equal to `q'1`). Now you can ask yourself this question: what does it imply if the `r-th` bit of `x1` is `1`?\\n\\nThe answer is to find what can contribute to this `1`. Will an element that appears `k` times contribute? No. Why? Because for an element to contribute, it has to satisfy at least two conditions at the same time: the `r-th` bit of this element is `1` and the number of appearance of this `1` is not an integer multiple of `k`. The first condition is trivial. The second comes from the fact that whenever the number of `1` hit is `k`, the counter will go back to zero, which means the corresponding bit in `x1` will be reset to `0`. For an element that appears `k` times, it's impossible to meet these two conditions simultaneously so it won't contribute. At last, only the single element which appears `p` (`p % k != 0`) times will contribute. If `p > k`, then the first `k * [p/k]` (`[p/k]`denotes the integer part of `p/k`) single elements won't contribute either. So we can always set `p' = p % k` and say the single element appears effectively `p'` times.\\n\\nLet's write `p'` in its binary form: `p'm, ..., p'1` (note that `p' < k`, so it will fit into `m` bits). Here I **claim the condition** for `xj` to equal the single element is `p'j = 1` (`j = 1` to `m`), with a quick proof given below.\\n\\nIf the `r-th` bit of `xj` is `1`, we can safely say the `r-th` bit of the single element is also `1` (otherwise nothing can make the `r-th` bit of `xj` to be `1`). We are left to prove that if the `r-th` bit of `xj` is `0`, then the `r-th` bit of the single element can only be `0`. Just suppose in this case the `r-th` bit of the single element is `1`, let's see what will happen. At the end of the scan, this `1` will be counted `p'` times. By definition the `r-th` bit of `xj` will be equal to `p'j`, which is `1`. This contradicts with the presumption that the `r-th` bit of `xj` is `0`. Therefore we conclude the `r-th` bit of `xj` will always be the same as the `r-th` bit of the single number as long as `p'j = 1`. Since this is true for all bits in `xj` (i.e., true for `r = 1` to `32`), we conclude `xj` will equal the single element as long as `p'j = 1`. \\n\\nSo now it's clear what we should return. Just express `p' = p % k` in its binary form and return any of the corresponding `xj` as long as `p'j = 1`. In total, the algorithm will run in `O(n * logk)` time and `O(logk)` space.\\n\\n---\\n**Side note**: There is a general formula relating each bit of `xj` to `p'j` and each bit of the single number `s`, which is given by `(xj)_r = s_r & p'j`, with `(xj)_r` and `s_r` denoting respectively the `r-th` bit of `xj` and the single number `s`. From this formula, it's easy to see that `(xj)_r = s_r` if `p'j = 1`, that is, `xj = s` as long as `p'j = 1`, as shown above. Furthermore, we have `(xj)_r = 0` if `p'j = 0`, regardless of the value of the single number, that is, `xj = 0` as long as `p'j = 0`. So in summary we obtain: `xj = s` if `p'j = 1`, and `xj = 0` if `p'j = 0`. This implies the expression (`x1 | x2 | ... | xm`) will also be evaluated to the single number `s`, since the expression will essentially take the `OR` operations of the single number with itself and some `0`s, which boils down to the single number eventually.\\n\\n---\\n`V -- Quick examples`\\n\\nHere is a list of few quick examples to show how the algorithm works (you can easily come up with other examples):\\n\\n1. `k = 2, p = 1`\\n`k` is `2`, then `m = 1`, we need only one 32-bit integer (`x1`) as the counter. And `2^m = k` so we do not even need a mask! A complete java program will look like:\\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0;\\n         \\n        for (int i : nums) {\\n            x1 ^= i;\\n        }\\n         \\n        return x1;\\n    }\\n```\\n\\n2. `k = 3, p = 1`\\n`k` is `3`, then `m = 2`, we need two 32-bit integers(`x2`, `x1`) as the counter. And `2^m > k` so we do need a mask. Write `k` in its binary form: `k = '11'`, then `k1 = 1`, `k2 = 1`, so we have `mask = ~(x1 & x2)`. A complete java program will look like:\\n\\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0, x2 = 0, mask = 0;\\n         \\n        for (int i : nums) {\\n            x2 ^= x1 & i;\\n            x1 ^= i;\\n            mask = ~(x1 & x2);\\n            x2 &= mask;\\n            x1 &= mask;\\n        }\\n\\n        return x1;  // Since p = 1, in binary form p = '01', then p1 = 1, so we should return x1. \\n                    // If p = 2, in binary form p = '10', then p2 = 1, and we should return x2.\\n                    // Or alternatively we can simply return (x1 | x2).\\n    }\\n```\\n\\n3. `k = 5, p = 3`\\n`k` is `5`, then `m = 3`, we need three 32-bit integers(`x3`, `x2`, `x1`) as the counter. And `2^m > k` so we need a mask. Write `k` in its binary form: `k = '101'`, then `k1 = 1`, `k2 = 0`, `k3 = 1`, so we have `mask = ~(x1 & ~x2 & x3)`. A complete java program will look like:\\n\\n```\\n    public int singleNumber(int[] nums) {\\n        int x1 = 0, x2 = 0, x3  = 0, mask = 0;\\n   \\n        for (int i : nums) {\\n            x3 ^= x2 & x1 & i;\\n            x2 ^= x1 & i;\\n            x1 ^= i;\\n            mask = ~(x1 & ~x2 & x3);\\n            x3 &= mask;\\n            x2 &= mask;\\n            x1 &= mask;\\n        }\\n        \\n        return x1;  // Since p = 3, in binary form p = '011', then p1 = p2 = 1, so we can return either x1 or x2. \\n                    // If p = 4, in binary form p = '100', only p3 = 1, which implies we can only return x3.\\n                    // Or alternatively we can simply return (x1 | x2 | x3).\\n    }\\n```\\n\\nLastly I would like to thank those for providing feedbacks to make this post better. Hope it helps and happy coding!"
		},
		{
			"lc_ans_id":"43296",
			"view":"36846",
			"top":"2",
			"title":"An General Way to Handle All this sort of questions.",
			"vote":"247",
			"content":"this kind of question the key idea is design a counter that record state. the problem can be every one occurs K times except one occurs M times. for this question, K =3 ,M = 1(or 2) .\\nso to represent 3 state, we need two bit. let say it is a and b, and c is the incoming bit.\\nthen we can design a table to implement the state move.\\n\\n    current   incoming  next\\n    a b            c    a b\\n    0 0            0    0 0\\n    0 1            0    0 1\\n    1 0            0    1 0\\n    0 0            1    0 1\\n    0 1            1    1 0\\n    1 0            1    0 0\\n\\nlike circuit design, we can find out what the next state will be with the incoming bit.( we only need find the ones)\\nthen we have for a to be 1, we have \\n\\n        current   incoming  next\\n        a b            c    a b\\n        1 0            0    1 0\\n        0 1            1    1 0\\n and this is can be represented by \\n\\n    a=a&~b&~c + ~a&b&c\\n\\nand b can do the same  we , and we find that \\n\\n    b= ~a&b&~c+~a&~b&c\\nand this is the final formula of a and b and just one of the result set, because for different state move table definition, we can generate different formulas, and this one is may not the most optimised. as you may see other's answer that have a much simple formula, and that formula also corresponding to specific state move table. (if you like ,you can reverse their formula to a state move table, just using the same way but reversely) \\n\\nfor this questions we need to find the except one \\nas the question don't say if the one appears one time or two time ,\\nso for ab both \\n\\n    01 10 => 1\\n    00 => 0\\nwe should return a|b;\\nthis is the key idea , we can design any based counter and find the occurs any times except one .\\nhere is my code. with comment.\\n\\n    public class Solution {\\n        \\n        public int singleNumber(int[] nums) {\\n            //we need to implement a tree-time counter(base 3) that if a bit appears three time ,it will be zero.\\n            //#curent  income  ouput\\n            //# ab      c/c       ab/ab\\n            //# 00      1/0       01/00\\n            //# 01      1/0       10/01\\n            //# 10      1/0       00/10\\n            // a=~abc+a~b~c;\\n            // b=~a~bc+~ab~c;\\n            int a=0;\\n            int b=0;\\n            for(int c:nums){\\n                int ta=(~a&b&c)|(a&~b&~c);\\n                b=(~a&~b&c)|(~a&b&~c);\\n                a=ta;\\n            }\\n            //we need find the number that is 01,10 => 1, 00 => 0.\\n            return a|b;\\n            \\n        }\\n    }\\nthis is a general solution . and it comes from the Circuit Design on course digital logic."
		},
		{
			"lc_ans_id":"43297",
			"view":"19971",
			"top":"3",
			"title":"Java O(n) easy to understand solution, easily extended to any times of occurance",
			"vote":"212",
			"content":"The usual bit manipulation code is bit hard to get and replicate.  I like to think about the number in 32 bits and just count how many 1s are there in each bit, and `sum %= 3` will clear it once it reaches 3.  After running for all the numbers for each bit, if we have a 1, then that 1 belongs to the single number, we can simply move it back to its spot by doing `ans |= sum << i;`  \\n\\nThis has complexity of O(32n), which is essentially O(n) and very easy to think and implement.  Plus, you get a general solution for any times of occurrence.  Say all the numbers have 5 times, just do `sum %= 5`.\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int sum = 0;\\n            for(int j = 0; j < nums.length; j++) {\\n                if(((nums[j] >> i) & 1) == 1) {\\n                    sum++;\\n                    sum %= 3;\\n                }\\n            }\\n            if(sum != 0) {\\n                ans |= sum << i;\\n            }\\n        }\\n        return ans;\\n    }"
		},
		{
			"lc_ans_id":"43302",
			"view":"14431",
			"top":"4",
			"title":"Accepted code with proper Explaination. Does anyone have a better idea?",
			"vote":"119",
			"content":"   \\n The code makes use of 2 variables. \\n\\nones - At any point of time, this variable holds XOR of all the elements which have \\nappeared \"only\" once. \\ntwos - At any point of time, this variable holds XOR of all the elements which have \\nappeared \"only\" twice. \\n\\nSo if at any point time, \\n\\n1. A new number appears - It gets XOR'd to the variable \"ones\". \\n2. A number gets repeated(appears twice) - It is removed from \"ones\" and XOR'd to the \\nvariable \"twos\". \\n3. A number appears for the third time - It gets removed from both \"ones\" and \"twos\". \\n\\nThe final answer we want is the value present in \"ones\" - coz, it holds the unique element. \\n\\nSo if we explain how steps 1 to 3 happens in the code, we are done. \\nBefore explaining above 3 steps, lets look at last three lines of the code, \\n\\ncommon_bit_mask = ~(ones & twos) \\n\\nones & = common_bit_mask\\n\\ntwos & = common_bit_mask \\n\\nAll it does is, common 1's between \"ones\" and \"twos\" are converted to zero. \\n\\nFor simplicity, in all the below explanations - consider we have got only 4 elements in the array (one unique element and 3 repeated elements - in any order). \\n\\nExplanation for step 1 \\n------------------------ \\nLets say a new element(x) appears. \\n\\nCURRENT SITUATION - Both variables - \"ones\" and \"twos\" has not recorded \"x\". \\n\\nObserve the statement \"twos| = ones & x\". \\nSince bit representation of \"x\" is not present in \"ones\", AND condition yields nothing. So \"twos\" does not get bit representation of \"x\". \\nBut, in next step \"ones ^= x\" - \"ones\" ends up adding bits of \"x\". Thus new element gets recorded in \"ones\" but not in \"twos\". \\n\\nThe last 3 lines of code as explained already, converts common 1's b/w \"ones\" and \"twos\" to zeros. \\nSince as of now, only \"ones\" has \"x\" and not \"twos\" - last 3 lines does nothing. \\n\\nExplanation for step 2. \\n------------------------ \\nLets say an element(x) appears twice. \\n\\nCURRENT SITUATION - \"ones\" has recorded \"x\" but not \"twos\". \\n\\nNow due to the statement, \"twos| = ones & x\" - \"twos\" ends up getting bits of x. \\nBut due to the statement, \"ones ^ = x\" - \"ones\" removes \"x\" from its binary representation. \\n\\nAgain, last 3 lines of code does nothing. \\nSo ultimately, \"twos\" ends up getting bits of \"x\" and \"ones\" ends up losing bits of \"x\". \\n\\nExplanation for step 3. \\n------------------------- \\nLets say an element(x) appears for the third time. \\n\\nCURRENT SITUATION - \"ones\" does not have bit representation of \"x\" but \"twos\" has. \\n\\nThough \"ones & x\" does not yield nothing .. \"twos\" by itself has bit representation of \"x\". So after this statement, \"two\" has bit representation of \"x\". \\nDue to \"ones^=x\", after this step, \"one\" also ends up getting bit representation of \"x\". \\n\\nNow last 3 lines of code removes common 1's of \"ones\" and \"twos\" - which is the bit representation of \"x\".\\nThus both \"ones\" and \"twos\" ends up losing bit representation of \"x\".\\n\\n\\n\\n\\n\\n\\n\\n\\n     class Solution {\\n        public:\\n        // Let us take the example of {3, 3, 2, 3} to understand this\\n            int singleNumber(int A[], int n) {\\n                int ones=0, twos =0;\\n                int common_bit_mask;\\n                for(int i=0; i<n;i++)\\n                {\\n                     /* The expression \"one & arr[i]\" gives the bits that are\\n                   there in both 'ones' and new element from arr[].  We\\n                   add these bits to 'twos' using bitwise OR\\n         \\n                   Value of 'twos' will be set as 0, 3, 3 and 1 after 1st,\\n                   2nd, 3rd and 4th iterations respectively */\\n                   \\n                    twos= twos|(ones&A[i]);\\n                    /* XOR the new bits with previous 'ones' to get all bits\\n                   appearing odd number of times\\n         \\n                   Value of 'ones' will be set as 3, 0, 2 and 3 after 1st,\\n                   2nd, 3rd and 4th iterations respectively */\\n                    ones=ones^A[i];\\n                     /* The common bits are those bits which appear third time\\n                   So these bits should not be there in both 'ones' and 'twos'.\\n                   common_bit_mask contains all these bits as 0, so that the bits can \\n                   be removed from 'ones' and 'twos'   \\n         \\n                   Value of 'common_bit_mask' will be set as 00, 00, 01 and 10\\n                   after 1st, 2nd, 3rd and 4th iterations respectively */\\n                    common_bit_mask= ~(ones&twos);\\n                    /* Remove common bits (the bits that appear third time) from 'ones'\\n                     \\n                   Value of 'ones' will be set as 3, 0, 0 and 2 after 1st,\\n                   2nd, 3rd and 4th iterations respectively */\\n                    ones &=common_bit_mask;\\n                    /* Remove common bits (the bits that appear third time) from 'twos'\\n         \\n                   Value of 'twos' will be set as 0, 3, 1 and 0 after 1st,\\n                   2nd, 3rd and 4th itearations respectively */\\n                    twos &=common_bit_mask;\\n                }\\n                return ones;\\n            }\\n        };"
		},
		{
			"lc_ans_id":"43313",
			"view":"8257",
			"top":"5",
			"title":"A general C++ solution for these type problems",
			"vote":"84",
			"content":"There are so many brilliant solutions for this problem used \"| & ^ ~\", and I have learned a lot from these solutions. Here is a general solution for who not familiar with \"| & ^ ~\".\\n\\nQ: Most elements appeared k times, except one. Find this \"one\".\\n\\n  \\n\\n       int singleNumber(vector<int>& s) \\n        {\\n        \\tvector<int> t(32);////Made a array contain 32 elements.\\n        \\tint sz = s.size();\\n        \\tint i, j, n;\\n        \\tfor (i = 0; i < sz; ++i)\\n        \\t{\\n        \\t\\tn = s[i];\\n        \\t\\tfor (j = 31; j >= 0; --j)\\n        \\t\\t{\\n        \\t\\t\\tt[j] += n & 1;//Find the last digit.\\n        \\t\\t\\tn >>= 1;\\n        \\t\\t\\tif (!n)\\n        \\t\\t\\t\\tbreak;\\n        \\t    }\\n            }\\n    \\tint res = 0;\\n    \\tfor (j = 31; j >= 0; --j)\\n    \\t{\\n    \\t\\tn = t[j] % 3;//\"3\" represents k times. \\n    \\t\\tif (n)\\n    \\t\\t\\tres += 1 << (31 - j);\\n    \\t}\\n    \\treturn res;\\n    }"
		},
		{
			"lc_ans_id":"43332",
			"view":"5175",
			"top":"6",
			"title":"My own explanation of bit manipulation method, might be easier to understand",
			"vote":"63",
			"content":"Consider the following fact:\\n\\nWrite all numbers in binary form, then for any bit 1 that appeared 3*n times (n is an integer), the bit can only present in numbers that appeared 3 times\\n\\ne.g. 0010 0010 0010 1011 1011 1011 1000 (assuming 4-bit integers)\\n2(0010) and 11(1011) appeared 3 times, and digit counts are:\\n\\n> **Digits**             3 2 1 0 \\n> \\n> **Counts**           4 0 6 3\\n> \\n> **Counts%3**     1 0 0 0\\n\\nCounts on 2,1,0 are all times of 3, the only digit index that has Counts % 3 != 0 is 3\\n\\nTherefore, to find the number that appeared only 1 or 2 times, we only need to extract all bits that has Counts %3 != 0\\n\\nNow consider how we could do this by bit manipulation\\n\\nsince counts % 3 has only 3 states: 0(00),1(01),2(10)\\nwe could use a TWO BIT COUNTER (Two, One) to represent Counts % 3, now we could do a little research on state transitions, for each bit, let B be the input bit, we can enumerate the all possible state transitions, Two+, One+ is the new state of Two, One. (here we need to use some knowledge in Digital Logic Design)\\n\\n-----------------------\\n\\n> Two One B Two+ One+\\n>\\n> 0    0  0    0   0\\n> \\n> 0    0  1    0   1\\n> \\n> 0    1  0    0   1\\n> \\n> 0    1  1    1   0\\n> \\n> 1    0  0    1   0\\n> \\n> 1    0  1    0   0\\n> \\n> 1    1  0    X   X (X represents we don't care)\\n> \\n> 1    1  1    X   X\\n\\n\\nWe could then draw the **Karnaugh map** to analyze the logic (https://en.wikipedia.org/wiki/Karnaugh_map), and then we get:\\n\\n> One+ = (One ^ B) & (~Two)\\n> \\n> Two+ = (~One+) & (Two ^ B)\\n\\nNow for int_32, we need only 2 int_32 two represent Two and One for each bit and update Two and One using the rules derived above\\n\\nCode is here (C++):\\n\\n    class Solution {\\n      public:\\n        int singleNumber(vector<int>& nums) {\\n            int counterOne = 0;\\n            int counterTwo = 0;\\n            \\n            for (int i = 0; i < nums.size(); i++){\\n                counterOne = (~counterTwo) & (counterOne ^ nums[i]);\\n                counterTwo = (~counterOne) & (counterTwo ^ nums[i]);\\n            }\\n            return counterOne;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"43360",
			"view":"6807",
			"top":"7",
			"title":"The simplest solution ever with clear explanation",
			"vote":"43",
			"content":"The key to solve this problem is the count of 1s of each bit of all numbers.\\n\\nTake one bit number for example: nums = [1, 1, 1, 0, 0, 0, ..., x] . All numbers are 0 or 1.\\n\\nWe know that every number appears three times except for just one number. So, if the count of 1s in nums is 0, 3, 6, ..., 3 * n, then the single number is 0. And if the count of 1s in nums is 1, 4, 7, ..., 3*n+1, then the single number is 1.\\n\\nSo, for an array \" nums \" that contains only 0 or 1, the code to find the single number are:\\n\\n    count = 0\\n    for num in nums:\\n        count = (count + num) % 3\\n    return count\\n\\nTo make \"count\" less than 3, mod \"count\" with 3 in every loop.\\n\\nBelow is the procedure for finding the single number in [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]:\\n\\n    Table 1:\\n    ++=======++===+===+===+===+===+===+===+===+===+===+===+===+===+====++\\n    || num   ||   | 1 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0  ||\\n    ++-------++---+---+---+---+---+---+---+---+---+---+---+---+---+----++\\n    || count || 0 | 1 | 1 | 2 | 0 | 0 | 1 | 1 | 2 | 2 | 0 | 0 | 1 | 1* ||\\n    ++=======++===+===+===+===+===+===+===+===+===+===+===+===+===+====++\\n\\nSo the single number is 1.\\n\\nWe can write the calculate table for expression \"count' = (count + num) % 3\":\\n\\n    Table 2:\\n    ++=======+=====+========++\\n    || count | num | count' ||\\n    ++-------+-----+--------++\\n    ||   0   |  0  |   0    ||\\n    ++-------+-----+--------++\\n    ||   1   |  0  |   1    ||\\n    ++-------+-----+--------++\\n    ||   2   |  0  |   2    ||\\n    ++-------+-----+--------++\\n    ||   0   |  1  |   1    ||\\n    ++-------+-----+--------++\\n    ||   1   |  1  |   2    ||\\n    ++-------+-----+--------++\\n    ||   2   |  1  |   0    ||\\n    ++-------+-----+--------++\\n\\nTo extend this algorithm to 32bits number. We need to rewrite these code to bit operation expressions. \\n\\nAnd the key is rewriting the expression \" count' = (count + num) % 3 \" to bit operation expressions.\\n\\nWrite binary numbers of \" count \" and \" count' \" in \"Table 2\". And split their bits into two column:\\n\\n    Table 3:\\n    ++=======+============+=====+============+========++\\n    ||       |    count   | num |   count'   |        ||\\n    || count |    (bin)   |     |   (bin)    | count' ||\\n    || (dec) ++=====+=====+=====+=====+=====++ (dec)  ||\\n    ||       || b1  | b0  | num | b1' | b0' ||        ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   0   ||  0  |  0  |  0  |  0  |  0  ||   0    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   1   ||  0  |  1  |  0  |  0  |  1  ||   1    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   2   ||  1  |  0  |  0  |  1  |  0  ||   2    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   0   ||  0  |  0  |  1  |  0  |  1  ||   1    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   1   ||  0  |  1  |  1  |  1  |  0  ||   2    ||\\n    ++-------++-----+-----+-----+-----+-----++--------++\\n    ||   2   ||  1  |  0  |  1  |  0  |  0  ||   0    ||\\n    ++=======++===========+=====+===========++========++\\n\\nHere comes the hardest part of this solution. \\n\\n\"Table 3\" is a truth table, we need to use it to find the formulas to calculate \" b0' \" and \" b1' \":\\n    \\n    b0' = f(b1, b0, num)\\n    b1' = g(b1, b0, num)\\n\\nWith observations, guesses, experiments and even some luck. Finally I got two simple and elegant formulas:\\n    \\n    b0' = (b0 ^ num) & (~b1)\\n    b1' = (b1 ^ num) & (~b0')\\n\\nThe AC code:\\n\\n    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def singleNumber(self, nums):\\n            b1, b0 = 0, 0\\n            for num in nums:\\n                b0 = (b0 ^ num) & (~b1)\\n                b1 = (b1 ^ num) & (~b0)\\n            return b0"
		},
		{
			"lc_ans_id":"43417",
			"view":"3747",
			"top":"8",
			"title":"My C++ code (12ms, one iteration, 3 int variables (b0, b1, reset)) with algorithm description",
			"vote":"36",
			"content":"    /*\\n    The basic idea is to implement a modulo-3 counter (to count how many times \"1\" occurs) for each bit position.\\n    Such modulo-3 counter needs two bits (B1,B0) to represent. \\n    (B1,B0): \\n    (0, 0) : '1' occurs zero times after last resetting,\\n    (0, 1) : '1' occurs one times after last resetting,\\n    (1, 0) : '1' occurs two times after last resetting,\\n    (1, 1) : '1' occurs three times after last resetting, then we need to reset the counter to (0,0)\\n    So to implement such modulo-3 counters, we need three variables (b0, b1, reset)\\n    The n-th bit of b0 is the B0 bit of the modulo-3 counter for the n-th bit (n=0..31 assuming int is 32 bit)\\n    The n-th bit of b1 is the B1 bit of the modulo-3 counter for the n-th bit (n=0..31 assuming int is 32 bit)\\n    The n-th bit of reset is the reset flag of the modulo-3 counter for the n-th bit (n=0..31 assuming int is 32 bit), \\n    \\n    - b0: can be easily implemented with XOR bit operation,  as b0 = b0^ A[i]\\n    - b1: B1 will only be set to 1, when B0 (of the n-th bit counter) =1 and the n-th bit of A[i] = 1, and stay '1' until it is reseted. So b1 |=  b0 & A[i]; \\n    - The reset flag is set when (B1, B0) = (1,1). So, reset = b0 & b1;\\n    - The reset operation can be done by b0 = b0 ^ reset and b1 = b1 ^ reset;\\n    \\n    After updating the b0, b1, reset with all A[], the b0 will be the final result since if the n-th bit of the to-be-found element is 1, then the times of '1' occurs on the n-th bit is 3*x+1, which is 1 after the modulo 3 opertation.   \\n    */\\n    class Solution {\\n    public:\\n    \\n        int singleNumber(int A[], int n) {\\n            int b0=0, b1=0, reset=0;\\n            int i;\\n            \\n            if(n>0)\\n            {\\n            for(i = 0; i<n; i++)\\n            {\\n                b1 |= (b0 & A[i]);\\n                b0 = b0 ^ A[i];\\n                reset = b1 & b0;\\n                b1 = b1 ^ reset;\\n                b0 = b0 ^ reset;\\n            }\\n            \\n            return b0;\\n            }\\n        }\\n    //------------------------------------------------------------------------------------------------------------\\n    /*\\n    //--  Another version with explicit modulo-3 counters implemented, just for reference-----//\\n        const int int_bitwidth = 32;\\n        int singleNumber(int A[], int n) {\\n            int mod3Counter[int_bitwidth];\\n            int i,j;\\n            unsigned int temp = 0;\\n            \\n            if(n>0)\\n            {\\n                for(i=0; i<int_bitwidth; i++) mod3Counter[i] = 0;\\n                \\n                for(i=0; i<n; i++)\\n                {\\n                    temp = (unsigned int) A[i];\\n                    for(j=0; j<int_bitwidth; j++)\\n                    {\\n                        if(temp & 0x1)\\n                        {\\n                            mod3Counter[j] = (mod3Counter[j] + 1) % 3;\\n                        }\\n                        temp = temp>>1;\\n                    }\\n                    \\n                    temp =0;\\n                    for(j=0; j<int_bitwidth; j++)\\n                    {\\n                        temp = temp << 1;\\n                        if(mod3Counter[int_bitwidth - 1 -j]) \\n                        {\\n                            temp = temp | 0x1;\\n                        }\\n                    }\\n                }\\n                return (int)temp;\\n    \\n            }\\n        }\\n    */\\n        \\n    };"
		},
		{
			"lc_ans_id":"43368",
			"view":"27735",
			"top":"9",
			"title":"Constant space solution",
			"vote":"29",
			"content":"Has anybody solved this problem by using constant space? My solution uses a map to keep track of the counts of each element in the array."
		}
	],
	"id":"137",
	"title":"Single Number II",
	"content":"<p>\r\nGiven an array of integers, every element appears <i>three</i> times except for one, which appears exactly once. Find that single one.\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b><br>\r\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\r\n</p>",
	"frequency":"552",
	"ac_num":"129358"
}