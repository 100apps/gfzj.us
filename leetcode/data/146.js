{
	"difficulty":"3",
	"submit_num":"821989",
	"show_id":"146",
	"leetcode_id":"146",
	"answers":[
		{
			"lc_ans_id":"45911",
			"view":"66024",
			"top":"0",
			"title":"[Java] Hashtable + Double linked list (with a touch of pseudo nodes)",
			"vote":"220",
			"content":"The problem can be solved with a hashtable that keeps track of the keys and its values in the double linked list. One interesting property about double linked list is that the node can remove itself without other reference. In addition, it takes constant time to add and remove nodes from the head or tail.\\n\\nOne particularity about the double linked list that I implemented is that I create a pseudo head and tail to mark the boundary, so that we don't need to check the NULL node during the update. This makes the code more concise and clean, and also it is good for the performance as well. \\n\\nVoila, here is the code. \\n\\n    class DLinkedNode {\\n\\t\\tint key;\\n\\t\\tint value;\\n\\t\\tDLinkedNode pre;\\n\\t\\tDLinkedNode post;\\n\\t}\\n\\t\\n\\t/**\\n\\t * Always add the new node right after head;\\n\\t */\\n\\tprivate void addNode(DLinkedNode node){\\n\\t\\tnode.pre = head;\\n\\t\\tnode.post = head.post;\\n\\t\\t\\n\\t\\thead.post.pre = node;\\n\\t\\thead.post = node;\\n\\t}\\n\\t\\n\\t/**\\n\\t * Remove an existing node from the linked list.\\n\\t */\\n\\tprivate void removeNode(DLinkedNode node){\\n\\t\\tDLinkedNode pre = node.pre;\\n\\t\\tDLinkedNode post = node.post;\\n\\t\\t\\n\\t\\tpre.post = post;\\n\\t\\tpost.pre = pre;\\n\\t}\\n\\t\\n\\t/**\\n\\t * Move certain node in between to the head.\\n\\t */\\n\\tprivate void moveToHead(DLinkedNode node){\\n\\t\\tthis.removeNode(node);\\n\\t\\tthis.addNode(node);\\n\\t}\\n\\t\\n\\t// pop the current tail. \\n\\tprivate DLinkedNode popTail(){\\n\\t\\tDLinkedNode res = tail.pre;\\n\\t\\tthis.removeNode(res);\\n\\t\\treturn res;\\n\\t}\\n\\t\\n\\tprivate Hashtable<Integer, DLinkedNode> \\n\\t\\tcache = new Hashtable<Integer, DLinkedNode>();\\n\\tprivate int count;\\n\\tprivate int capacity;\\n\\tprivate DLinkedNode head, tail;\\n\\t\\n    public LRUCache(int capacity) {\\n    \\tthis.count = 0;\\n    \\tthis.capacity = capacity;\\n    \\n    \\thead = new DLinkedNode();\\n    \\thead.pre = null;\\n    \\t\\n    \\ttail = new DLinkedNode();\\n    \\ttail.post = null;\\n    \\t\\n    \\thead.post = tail;\\n    \\ttail.pre = head;\\n    }\\n    \\n    public int get(int key) {\\n        \\n    \\tDLinkedNode node = cache.get(key);\\n    \\tif(node == null){\\n    \\t\\treturn -1; // should raise exception here.\\n    \\t}\\n    \\t\\n    \\t// move the accessed node to the head;\\n    \\tthis.moveToHead(node);\\n    \\t\\n    \\treturn node.value;\\n    }\\n    \\n    \\n    public void set(int key, int value) {\\n    \\tDLinkedNode node = cache.get(key);\\n    \\t\\n    \\tif(node == null){\\n    \\t\\t\\n\\t\\t\\tDLinkedNode newNode = new DLinkedNode();\\n\\t\\t\\tnewNode.key = key;\\n\\t\\t\\tnewNode.value = value;\\n\\t\\t\\t\\n\\t\\t\\tthis.cache.put(key, newNode);\\n\\t\\t\\tthis.addNode(newNode);\\n\\t\\t\\t\\n\\t\\t\\t++count;\\n\\t\\t\\t\\n    \\t\\tif(count > capacity){\\n    \\t\\t\\t// pop the tail\\n    \\t\\t\\tDLinkedNode tail = this.popTail();\\n    \\t\\t\\tthis.cache.remove(tail.key);\\n    \\t\\t\\t--count;\\n    \\t\\t}\\n    \\t}else{\\n    \\t\\t// update the value.\\n    \\t\\tnode.value = value;\\n    \\t\\tthis.moveToHead(node);\\n    \\t}\\n    \\t\\n    }"
		},
		{
			"lc_ans_id":"45976",
			"view":"28601",
			"top":"1",
			"title":"C++11 code 74ms - Hash table + List",
			"vote":"83",
			"content":"There is a similar example in Java, but I wanted to share my solution using the new C++11 unordered\\\\_map and a list. The good thing about lists is that iterators are never invalidated by modifiers (unless erasing the element itself). This way, we can store the iterator to the corresponding LRU queue in the values of the hash map. Since using erase on a list with an iterator takes constant time, all operations of the LRU cache run in constant time.\\n\\n    class LRUCache {\\n    public:\\n        LRUCache(int capacity) : _capacity(capacity) {}\\n        \\n        int get(int key) {\\n            auto it = cache.find(key);\\n            if (it == cache.end()) return -1;\\n            touch(it);\\n            return it->second.first;\\n        }\\n        \\n        void set(int key, int value) {\\n            auto it = cache.find(key);\\n            if (it != cache.end()) touch(it);\\n            else {\\n    \\t\\t\\tif (cache.size() == _capacity) {\\n    \\t\\t\\t\\tcache.erase(used.back());\\n    \\t\\t\\t\\tused.pop_back();\\n    \\t\\t\\t}\\n                used.push_front(key);\\n            }\\n            cache[key] = { value, used.begin() };\\n        }\\n        \\n    private:\\n        typedef list<int> LI;\\n        typedef pair<int, LI::iterator> PII;\\n        typedef unordered_map<int, PII> HIPII;\\n        \\n        void touch(HIPII::iterator it) {\\n            int key = it->first;\\n            used.erase(it->second.second);\\n            used.push_front(key);\\n            it->second.second = used.begin();\\n        }\\n        \\n        HIPII cache;\\n        LI used;\\n        int _capacity;\\n    };"
		},
		{
			"lc_ans_id":"45939",
			"view":"17639",
			"top":"2",
			"title":"Laziest implementation: Java's LinkedHashMap takes care of everything",
			"vote":"75",
			"content":"This is the laziest implementation using Java's LinkedHashMap. In the real interview, however, it is definitely not what interviewer expected.\\n```\\n    import java.util.LinkedHashMap;\\n    public class LRUCache {\\n        private LinkedHashMap<Integer, Integer> map;\\n        private final int CAPACITY;\\n        public LRUCache(int capacity) {\\n            CAPACITY = capacity;\\n            map = new LinkedHashMap<Integer, Integer>(capacity, 0.75f, true){\\n                protected boolean removeEldestEntry(Map.Entry eldest) {\\n                    return size() > CAPACITY;\\n                }\\n            };\\n        }\\n        public int get(int key) {\\n            return map.getOrDefault(key, -1);\\n        }\\n        public void set(int key, int value) {\\n            map.put(key, value);\\n        }\\n    }\\n```\\nSeveral points to mention:<br>\\n1. In the constructor, the third boolean parameter specifies the ordering mode. If we set it to true, it will be in access order. (https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html#LinkedHashMap-int-float-boolean-)<br>\\n2. By overriding removeEldestEntry in this way, we do not need to take care of it ourselves. It will automatically remove the least recent one when the size of map exceeds the specified capacity.(https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html#removeEldestEntry-java.util.Map.Entry-)\\n\\nBelow is a \"normal\" HashMap + doubly-linked list implementation:\\n```\\npublic class LRUCache {\\n    private class Node{\\n        int key, value;\\n        Node prev, next;\\n        Node(int k, int v){\\n            this.key = k;\\n            this.value = v;\\n        }\\n        Node(){\\n            this(0, 0);\\n        }\\n    }\\n    private int capacity, count;\\n    private Map<Integer, Node> map;\\n    private Node head, tail;\\n    \\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.count = 0;\\n        map = new HashMap<>();\\n        head = new Node();\\n        tail = new Node();\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        Node n = map.get(key);\\n        if(null==n){\\n            return -1;\\n        }\\n        update(n);\\n        return n.value;\\n    }\\n    \\n    public void set(int key, int value) {\\n        Node n = map.get(key);\\n        if(null==n){\\n            n = new Node(key, value);\\n            map.put(key, n);\\n            add(n);\\n            ++count;\\n        }\\n        else{\\n            n.value = value;\\n            update(n);\\n        }\\n        if(count>capacity){\\n            Node toDel = tail.prev;\\n            remove(toDel);\\n            map.remove(toDel.key);\\n            --count;\\n        }\\n    }\\n    \\n    private void update(Node node){\\n        remove(node);\\n        add(node);\\n    }\\n    private void add(Node node){\\n        Node after = head.next;\\n        head.next = node;\\n        node.prev = head;\\n        node.next = after;\\n        after.prev = node;\\n    }\\n    \\n    private void remove(Node node){\\n        Node before = node.prev, after = node.next;\\n        before.next = after;\\n        after.prev = before;\\n    }\\n}"
		},
		{
			"lc_ans_id":"45922",
			"view":"27305",
			"top":"3",
			"title":"JAVA-----------Easy Version To Understand!!!!",
			"vote":"65",
			"content":"1.The key to solve this problem is using a double linked list which enables us to quickly move nodes.\\n2.The LRU cache is a hash table of keys and double linked nodes. The hash table makes the time of get() to be O(1). The list of double linked nodes make the nodes adding/removal operations O(1).\\n\\nclass Node {\\n\\tint key;\\n\\tint value;\\n\\tNode pre;\\n\\tNode next;\\n\\n\\tpublic Node(int key, int value) {\\n\\t\\tthis.key = key;\\n\\t\\tthis.value = value;\\n\\t}\\n}\\npublic class LRUCache {\\n    \\n HashMap<Integer, Node> map;\\n\\tint capicity, count;\\n\\tNode head, tail;\\n\\n\\tpublic LRUCache(int capacity) {\\n\\t\\tthis.capicity = capacity;\\n\\t\\tmap = new HashMap<>();\\n\\t\\thead = new Node(0, 0);\\n\\t\\ttail = new Node(0, 0);\\n\\t\\thead.next = tail;\\n\\t\\ttail.pre = head;\\n\\t\\thead.pre = null;\\n\\t\\ttail.next = null;\\n\\t\\tcount = 0;\\n\\t}\\n\\n\\tpublic void deleteNode(Node node) {\\n\\t\\tnode.pre.next = node.next;\\n\\t\\tnode.next.pre = node.pre;\\n\\t}\\n\\n\\tpublic void addToHead(Node node) {\\n\\t\\tnode.next = head.next;\\n\\t\\tnode.next.pre = node;\\n\\t\\tnode.pre = head;\\n\\t\\thead.next = node;\\n\\t}\\n\\n\\tpublic int get(int key) {\\n\\t\\tif (map.get(key) != null) {\\n\\t\\t\\tNode node = map.get(key);\\n\\t\\t\\tint result = node.value;\\n\\t\\t\\tdeleteNode(node);\\n\\t\\t\\taddToHead(node);\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic void set(int key, int value) {\\n\\t\\tif (map.get(key) != null) {\\n\\t\\t\\tNode node = map.get(key);\\n\\t\\t\\tnode.value = value;\\n\\t\\t\\tdeleteNode(node);\\n\\t\\t\\taddToHead(node);\\n\\t\\t} else {\\n\\t\\t\\tNode node = new Node(key, value);\\n\\t\\t\\tmap.put(key, node);\\n\\t\\t\\tif (count < capicity) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\taddToHead(node);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.remove(tail.pre.key);\\n\\t\\t\\t\\tdeleteNode(tail.pre);\\n\\t\\t\\t\\taddToHead(node);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n}"
		},
		{
			"lc_ans_id":"45912",
			"view":"11910",
			"top":"4",
			"title":"Clean Short Standard C++ solution -- NOT writing C in C++ like all other lengthy ones",
			"vote":"59",
			"content":"I saw so many (or all) \"C++\" solutions posted here were not written in C++ at all. For those 200-line solutions, I don't see the point in implementing a double-linked-list by themselves. \\n\\n**If you are writing C++, please use STL!** \\n\\nThe code below is way cleaner, shorter and easier to read than most other C++ solutions posted here.\\nAnd above all, it was written in a standard C++ way.\\n\\n    class LRUCache{\\n        size_t m_capacity;\\n        unordered_map<int,  list<pair<int, int>>::iterator> m_map; //m_map_iter->first: key, m_map_iter->second: list iterator;\\n        list<pair<int, int>> m_list;                               //m_list_iter->first: key, m_list_iter->second: value;\\n    public:\\n        LRUCache(size_t capacity):m_capacity(capacity) {\\n        }\\n        int get(int key) {\\n            auto found_iter = m_map.find(key);\\n            if (found_iter == m_map.end()) //key doesn't exist\\n                return -1;\\n            m_list.splice(m_list.begin(), m_list, found_iter->second); //move the node corresponding to key to front\\n            return found_iter->second->second;                         //return value of the node\\n        }\\n        void set(int key, int value) {\\n            auto found_iter = m_map.find(key);\\n            if (found_iter != m_map.end()) //key exists\\n            {\\n                m_list.splice(m_list.begin(), m_list, found_iter->second); //move the node corresponding to key to front\\n                found_iter->second->second = value;                        //update value of the node\\n                return;\\n            }\\n            if (m_map.size() == m_capacity) //reached capacity\\n            {\\n               int key_to_del = m_list.back().first; \\n               m_list.pop_back();            //remove node in list;\\n               m_map.erase(key_to_del);      //remove key in map\\n            }\\n            m_list.emplace_front(key, value);  //create new node in list\\n            m_map[key] = m_list.begin();       //create correspondence between key and node\\n        }\\n    };"
		},
		{
			"lc_ans_id":"45926",
			"view":"6091",
			"top":"5",
			"title":"Python Dict + Double LinkedList",
			"vote":"59",
			"content":"    class Node:\\n    def __init__(self, k, v):\\n        self.key = k\\n        self.val = v\\n        self.prev = None\\n        self.next = None\\n\\n    class LRUCache:\\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.dic = dict()\\n        self.head = Node(0, 0)\\n        self.tail = Node(0, 0)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def get(self, key):\\n        if key in self.dic:\\n            n = self.dic[key]\\n            self._remove(n)\\n            self._add(n)\\n            return n.val\\n        return -1\\n\\n    def set(self, key, value):\\n        if key in self.dic:\\n            self._remove(self.dic[key])\\n        n = Node(key, value)\\n        self._add(n)\\n        self.dic[key] = n\\n        if len(self.dic) > self.capacity:\\n            n = self.head.next\\n            self._remove(n)\\n            del self.dic[n.key]\\n\\n    def _remove(self, node):\\n        p = node.prev\\n        n = node.next\\n        p.next = n\\n        n.prev = p\\n\\n    def _add(self, node):\\n        p = self.tail.prev\\n        p.next = node\\n        self.tail.prev = node\\n        node.prev = p\\n        node.next = self.tail"
		},
		{
			"lc_ans_id":"46055",
			"view":"10138",
			"top":"6",
			"title":"Probably the \"best\" Java solution - extend LinkedHashMap",
			"vote":"33",
			"content":"I didn't check all 9 pages that are in this forum already, so it's likely someone already posted a solution like this. The easiest solution and maybe most elegant is to just use the LinkedHashMap with the access-order flag set to true. The official documentation on it even mentions LRU caches and offers a method to overwrite specifically for a purpose like this. \\n\\n\\n    import java.util.LinkedHashMap;\\n    \\n    public class LRUCache {\\n        \\n        private Map<Integer, Integer> map;\\n        \\n        public LRUCache(int capacity) {\\n            map = new LinkedCappedHashMap<>(capacity);\\n        }\\n        \\n        public int get(int key) {\\n            if(!map.containsKey(key)) { return -1; }\\n            return map.get(key);\\n        }\\n        \\n        public void set(int key, int value) {\\n            map.put(key,value);\\n        }\\n    \\n        private static class LinkedCappedHashMap<K,V> extends LinkedHashMap<K,V> {\\n            \\n            int maximumCapacity;\\n            \\n            LinkedCappedHashMap(int maximumCapacity) {\\n                super(16, 0.75f, true);\\n                this.maximumCapacity = maximumCapacity;\\n            }\\n            \\n            protected boolean removeEldestEntry(Map.Entry eldest) {\\n                return size() > maximumCapacity;\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"46148",
			"view":"5235",
			"top":"7",
			"title":"Accepted C++ solution, 296 ms",
			"vote":"30",
			"content":"Solution is unusual - combination of 2 data structures - hash map and linked list.\\nAlgorithm:\\n\\n 1. hash map holds iterators to linked list\\n 2. linked list holds key and value, key to access hash map items\\n 3. when item is accessed, it's promoted - moved to the tail of the list - O(1) operation\\n 4. when item should be removed, we remove head of the list - O(1) operation\\n 5. when item is not promoted long time, it's moved to the head of the list automatically\\n 6. get() - O(1) performance, set() - O(1) performance\\n\\n       {\\n    \\n        class LRUCache{\\n        private:\\n        \\tstruct item_t{\\n        \\t\\tint key, val;\\n        \\t\\titem_t(int k, int v) :key(k), val(v){}\\n        \\t};\\n        \\ttypedef list<item_t> list_t;\\n        \\ttypedef unordered_map<int, list_t::iterator> map_t;\\n        \\n        \\tmap_t   m_map;\\n        \\tlist_t  m_list;\\n        \\tint     m_capacity;\\n        public:\\n        \\tLRUCache(int capacity) : m_capacity(capacity) {\\n        \\t}\\n        \\tint get(int key) {\\n        \\t\\tmap_t::iterator i = m_map.find(key);\\n        \\t\\tif (i == m_map.end()) return -1;\\n        \\t\\tm_map[key] = promote(i->second);\\n        \\t\\treturn m_map[key]->val;\\n        \\t}\\n        \\tvoid set(int key, int value) {\\n        \\t\\tmap_t::iterator i = m_map.find(key);\\n        \\t\\tif (i != m_map.end()){\\n        \\t\\t\\tm_map[key] = promote(i->second);\\n        \\t\\t\\tm_map[key]->val = value;\\n        \\t\\t}\\n        \\t\\telse {\\n        \\t\\t\\tif (m_map.size() < m_capacity){\\n        \\t\\t\\t\\tm_map[key] = m_list.insert(m_list.end(), item_t(key, value));\\n        \\t\\t\\t}\\n        \\t\\t\\telse {\\n        \\t\\t\\t\\tm_map.erase(m_list.front().key);\\n        \\t\\t\\t\\tm_list.pop_front();\\n        \\t\\t\\t\\tm_map[key] = m_list.insert(m_list.end(), item_t(key, value));\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tlist_t::iterator promote(list_t::iterator i){\\n        \\t\\tlist_t::iterator inew = m_list.insert(m_list.end(), *i);\\n        \\t\\tm_list.erase(i);\\n        \\t\\treturn inew;\\n        \\t}\\n        };\\n    }\\n\\n\\nbtw LeetCode, it was really hard to insert this code, after pressing {} button, class was improperly formatted. I inserted additional braces around class."
		},
		{
			"lc_ans_id":"46223",
			"view":"3890",
			"top":"8",
			"title":"O(1) unordered_map + list + splice",
			"vote":"28",
			"content":"    class LRUCache {\\n    private:\\n        // A list of (key, value) pairs\\n        list<pair<int, int>> items;\\n        // Map items to iterators (pointers) to list nodes\\n        unordered_map<int, list<pair<int, int>>::iterator> cache;\\n        // The capacity of the list\\n        int capacity;\\n\\n    public:\\n        LRUCache(int capacity) : capacity(capacity) {}\\n\\n        int get(int key) {\\n            // If key is not found in hash map, return -1\\n            if (cache.find(key) == cache.end())\\n                return -1;\\n            // Move the (key, value) pair to the beginning of the list\\n            items.splice(items.begin(), items, cache[key]);\\n            return cache[key]->second;\\n        }\\n\\n        void set(int key, int value) {\\n            // The key is not in the hash table\\n            if (cache.find(key) == cache.end()) {\\n                // If the cache is full then delete the least recently\\n                // used item, which is at the end of the list\\n                if (items.size() == capacity) {\\n                    cache.erase(items.back().first);\\n                    items.pop_back();\\n                }\\n                items.push_front(make_pair(key, value));\\n                cache[key] = items.begin();\\n            } else {\\n                // Update the value associated with the key\\n                cache[key]->second = value;\\n                // Move the (key, value) pair to the beginning of the list\\n                items.splice(items.begin(), items, cache[key]);\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"46117",
			"view":"3097",
			"top":"9",
			"title":"\"Least Recently Used\", let's pay attention to the word \"Recently\", don't be confused.",
			"vote":"26",
			"content":"Just want to emphasize the word \"Recently\". It is not the most visited. So thinking using priority queue or double linked list can be helpful. Don't waste time implementing codes based on wrong understanding... like me...\\nFor example,\\n\\n    capacity = 2\\n    set(2,1)\\n    set(2,2)\\n    get(2)\\n    set(1,1)\\n    set(4,1)\\n    get(2)\\n\\nSo what happened when set(4,1) is executed?\\n2 is deleted, 1 is still there, because 1 is more \"Recently\" than 2.\\n\\nHope this can help someone has misunderstanding on this problem."
		}
	],
	"id":"146",
	"title":"LRU Cache",
	"content":"<p>\r\nDesign and implement a data structure for <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\" target=\"_blank\">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.\r\n</p>\r\n\r\n<p>\r\n<code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>\r\n<code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\r\n</p>\r\n\r\n<p><b>Follow up:</b><br />\r\nCould you do both operations in <b>O(1)</b> time complexity?</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nLRUCache cache = new LRUCache( 2 /* capacity */ );\r\n\r\ncache.put(1, 1);\r\ncache.put(2, 2);\r\ncache.get(1);       // returns 1\r\ncache.put(3, 3);    // evicts key 2\r\ncache.get(2);       // returns -1 (not found)\r\ncache.put(4, 4);    // evicts key 1\r\ncache.get(1);       // returns -1 (not found)\r\ncache.get(3);       // returns 3\r\ncache.get(4);       // returns 4\r\n</pre>\r\n</p>",
	"frequency":"596",
	"ac_num":"157993"
}