{
	"difficulty":"2",
	"submit_num":"419197",
	"show_id":"148",
	"leetcode_id":"148",
	"answers":[
		{
			"lc_ans_id":"46714",
			"view":"40266",
			"top":"0",
			"title":"Java merge sort solution",
			"vote":"164",
			"content":"    public class Solution {\\n      \\n      public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null)\\n          return head;\\n            \\n        // step 1. cut the list to two halves\\n        ListNode prev = null, slow = head, fast = head;\\n        \\n        while (fast != null && fast.next != null) {\\n          prev = slow;\\n          slow = slow.next;\\n          fast = fast.next.next;\\n        }\\n        \\n        prev.next = null;\\n        \\n        // step 2. sort each half\\n        ListNode l1 = sortList(head);\\n        ListNode l2 = sortList(slow);\\n        \\n        // step 3. merge l1 and l2\\n        return merge(l1, l2);\\n      }\\n      \\n      ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode l = new ListNode(0), p = l;\\n        \\n        while (l1 != null && l2 != null) {\\n          if (l1.val < l2.val) {\\n            p.next = l1;\\n            l1 = l1.next;\\n          } else {\\n            p.next = l2;\\n            l2 = l2.next;\\n          }\\n          p = p.next;\\n        }\\n        \\n        if (l1 != null)\\n          p.next = l1;\\n        \\n        if (l2 != null)\\n          p.next = l2;\\n        \\n        return l.next;\\n      }\\n    \\n    }"
		},
		{
			"lc_ans_id":"46712",
			"view":"13860",
			"top":"1",
			"title":"Bottom-to-up(not recurring)  with o(1) space complextity and o(nlgn) time complextity",
			"vote":"103",
			"content":"this problem can be easily solved using recurrence and divide-and-conquer. But it consumes program stack to store the recurring function stack frame, actually it consumes o(lgn) space complexity. Recursion use up-to-bottom strategy , why not try the opposite way--bottom-to-up, luckily it works, it only consumes 0(1) space complexity and o(nlgn) time complextity.\\n\\n    /**\\n     * Merge sort use bottom-up policy, \\n     * so Space Complexity is O(1)\\n     * Time Complexity is O(NlgN)\\n     * stable sort\\n    */\\n    class Solution {\\n    public:\\n    \\tListNode *sortList(ListNode *head) {\\n    \\t\\tif(!head || !(head->next)) return head;\\n    \\t\\t\\n    \\t\\t//get the linked list's length\\n    \\t\\tListNode* cur = head;\\n    \\t\\tint length = 0;\\n    \\t\\twhile(cur){\\n    \\t\\t\\tlength++;\\n    \\t\\t\\tcur = cur->next;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tListNode dummy(0);\\n    \\t\\tdummy.next = head;\\n    \\t\\tListNode *left, *right, *tail;\\n    \\t\\tfor(int step = 1; step < length; step <<= 1){\\n    \\t\\t\\tcur = dummy.next;\\n    \\t\\t\\ttail = &dummy;\\n    \\t\\t\\twhile(cur){\\n    \\t\\t\\t\\tleft = cur;\\n    \\t\\t\\t\\tright = split(left, step);\\n    \\t\\t\\t\\tcur = split(right,step);\\n    \\t\\t\\t\\ttail = merge(left, right, tail);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn dummy.next;\\n    \\t}\\n    private:\\n    \\t/**\\n    \\t * Divide the linked list into two lists,\\n         * while the first list contains first n ndoes\\n    \\t * return the second list's head\\n    \\t */\\n    \\tListNode* split(ListNode *head, int n){\\n    \\t\\t//if(!head) return NULL;\\n    \\t\\tfor(int i = 1; head && i < n; i++) head = head->next;\\n    \\t\\t\\n    \\t\\tif(!head) return NULL;\\n    \\t\\tListNode *second = head->next;\\n    \\t\\thead->next = NULL;\\n    \\t\\treturn second;\\n    \\t}\\n    \\t/**\\n    \\t  * merge the two sorted linked list l1 and l2,\\n    \\t  * then append the merged sorted linked list to the node head\\n    \\t  * return the tail of the merged sorted linked list\\n    \\t */\\n    \\tListNode* merge(ListNode* l1, ListNode* l2, ListNode* head){\\n    \\t\\tListNode *cur = head;\\n    \\t\\twhile(l1 && l2){\\n    \\t\\t\\tif(l1->val > l2->val){\\n    \\t\\t\\t\\tcur->next = l2;\\n    \\t\\t\\t\\tcur = l2;\\n    \\t\\t\\t\\tl2 = l2->next;\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tcur->next = l1;\\n    \\t\\t\\t\\tcur = l1;\\n    \\t\\t\\t\\tl1 = l1->next;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tcur->next = (l1 ? l1 : l2);\\n    \\t\\twhile(cur->next) cur = cur->next;\\n    \\t\\treturn cur;\\n    \\t}\\n    };"
		},
		{
			"lc_ans_id":"46772",
			"view":"24270",
			"top":"2",
			"title":"I have a pretty good MergeSort method. Can anyone speed up the run time or reduce the memory usage?",
			"vote":"95",
			"content":"    /**\\n     * Definition for singly-linked list.\\n     * class ListNode {\\n     *     int val;\\n     *     ListNode next;\\n     *     ListNode(int x) {\\n     *         val = x;\\n     *         next = null;\\n     *     }\\n     * }\\n     */\\n    public class Solution {\\n        public ListNode sortList(ListNode head) {\\n            if (head == null || head.next == null)\\n                return head;\\n            ListNode f = head.next.next;\\n            ListNode p = head;\\n            while (f != null && f.next != null) {\\n                p = p.next;\\n                f =  f.next.next;\\n            }\\n            ListNode h2 = sortList(p.next);\\n            p.next = null;\\n            return merge(sortList(head), h2);\\n        }\\n        public ListNode merge(ListNode h1, ListNode h2) {\\n            ListNode hn = new ListNode(Integer.MIN_VALUE);\\n            ListNode c = hn;\\n            while (h1 != null && h2 != null) {\\n                if (h1.val < h2.val) {\\n                    c.next = h1;\\n                    h1 = h1.next;\\n                }\\n                else {\\n                    c.next = h2;\\n                    h2 = h2.next;\\n                }\\n                c = c.next;\\n            }\\n            if (h1 != null)\\n                c.next = h1;\\n            if (h2 != null)\\n                c.next = h2;\\n            return hn.next;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"46721",
			"view":"21561",
			"top":"3",
			"title":"My O(n log n) time, O(1) space solution",
			"vote":"52",
			"content":"Nice problem. I use a non-recurisve way to write merge sort.\\nFor example, the size of ListNode is 8,\\n\\nRound #1  block_size = 1\\n\\n(a1, a2), (a3, a4), (a5, a6), (a7, a8)\\n\\nCompare a1 with a2,   a3 with a4 ...\\n\\nRound #2  block_size = 2\\n\\n(a1, a2, a3, a4), (a5, a6, a7, a8)\\n\\nmerge two sorted arrays (a1, a2) and (a3, a4),  then merge tow sorted arrays(a5, a6) and (a7, a8)\\n\\nRound #3  block_size = 4\\n\\n(a1, a2, a3, a4, a5, a6, a7, a8)\\n\\nmerge two sorted arrays (a1, a2, a3, a4), and (a5, a6, a7, a8)\\n\\nNo need for round #4 cause block_size = 8 >= n = 8\\n\\n    class Solution {\\n    public:\\n        int count_size(ListNode *node){\\n            int n = 0;\\n            while (node != NULL){\\n                node = node->next;\\n                ++n;\\n            }\\n            return n;\\n        }\\n        ListNode *sortList(ListNode *head) {\\n            int block_size = 1, n = count_size(head), iter = 0, i = 0, a = 0, b = 0;\\n            ListNode virtual_head(0);\\n            ListNode *last = NULL, *it = NULL, *A = NULL, *B = NULL, *tmp = NULL;\\n            virtual_head.next = head;\\n            while (block_size < n){\\n                iter = 0;\\n                last = &virtual_head;\\n                it = virtual_head.next;\\n                while (iter <  n){\\n                    a = min(n - iter, block_size);\\n                    b = min(n - iter - a, block_size);\\n                    \\n                    A = it;\\n                    if (b != 0){\\n                        for (i = 0; i < a - 1; ++i) it = it->next;\\n                        B = it->next;\\n                        it->next = NULL;\\n                        it = B;\\n                        \\n                        for (i = 0; i < b - 1; ++i) it = it->next;\\n                        tmp = it->next;\\n                        it->next = NULL;\\n                        it = tmp;\\n                    }\\n                    \\n                    while (A || B){\\n                        if (B == NULL || (A != NULL && A->val <= B->val)){\\n                            last->next = A;\\n                            last = last->next;\\n                            A = A->next;\\n                        } else {\\n                            last->next = B;\\n                            last = last->next;\\n                            B = B->next;\\n                        }\\n                    }\\n                    last->next = NULL;\\n                    iter += a + b;\\n                }\\n                block_size <<= 1;\\n            }\\n            return virtual_head.next;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"46716",
			"view":"11887",
			"top":"4",
			"title":"Basically, it seems like merge sort problem(Really easy understand)",
			"vote":"50",
			"content":"Each time divided the given list into two sub list. Merge sub list after bottom case return.\\nHere is the code:\\n\\n    public class Solution {\\n        \\n        //merge two sorted list, return result head\\n        public ListNode merge(ListNode h1, ListNode h2){\\n            if(h1 == null){\\n                return h2;\\n            }\\n            if(h2 == null){\\n                return h1;\\n            }\\n            \\n            if(h1.val < h2.val){\\n                h1.next = merge(h1.next, h2);\\n                return h1;\\n            }\\n            else{\\n                h2.next = merge(h1, h2.next);\\n                return h2;\\n            }\\n            \\n        }\\n        \\n        public ListNode sortList(ListNode head) {\\n            //bottom case\\n            if(head == null){\\n                return head;\\n            }\\n            if(head.next == null){\\n                return head;\\n            }\\n            \\n            //p1 move 1 step every time, p2 move 2 step every time, pre record node before p1\\n            ListNode p1 = head;\\n            ListNode p2 = head;\\n            ListNode pre = head;\\n            \\n            while(p2 != null && p2.next != null){\\n                pre = p1;\\n                p1 = p1.next;\\n                p2 = p2.next.next;\\n            }\\n            //change pre next to null, make two sub list(head to pre, p1 to p2)\\n            pre.next = null;\\n            \\n            //handle those two sub list\\n            ListNode h1 = sortList(head);\\n            ListNode h2 = sortList(p1);\\n            \\n            return merge(h1, h2);\\n            \\n        }\\n        \\n    }"
		},
		{
			"lc_ans_id":"46710",
			"view":"4743",
			"top":"5",
			"title":"Clean python code",
			"vote":"37",
			"content":"    class Solution(object):\\n        def merge(self, h1, h2):\\n            dummy = tail = ListNode(None)\\n            while h1 and h2:\\n                if h1.val < h2.val:\\n                    tail.next, tail, h1 = h1, h1, h1.next\\n                else:\\n                    tail.next, tail, h2 = h2, h2, h2.next\\n        \\n            tail.next = h1 or h2\\n            return dummy.next\\n        \\n        def sortList(self, head):\\n            if not head or not head.next:\\n                return head\\n        \\n            pre, slow, fast = None, head, head\\n            while fast and fast.next:\\n                pre, slow, fast = slow, slow.next, fast.next.next\\n            pre.next = None\\n\\n            return self.merge(*map(self.sortList, (head, slow)))"
		},
		{
			"lc_ans_id":"46767",
			"view":"5250",
			"top":"6",
			"title":"Java solution with strict O(1) auxiliary space complexity",
			"vote":"31",
			"content":"First of all, allow me to explain the meaning of **strict O(1) auxiliary space complexity**. \\n\\nIt means the **maximum** number of memory used by the program, except the memory taken by the input data, doesn't change with the input size.\\nThis indicates that, strictly speaking, any solution that involves recursion can never have a strict O(1) auxiliary space complexity. Because the maximum recursion level depends on the the input size and each recursion call consumes memory on stack, thus the maximum number of memory used depends on the input size.\\n\\n\\n----------\\nSecondly, allow me to explain my solution based on merge sort.\\n\\nAssume the length of list is n, which is unknown at the beginning.\\n\\n      level log(n)         [ A0, A2, A3, ... , An-2, An-1 ]\\n      ...\\n      level 2        [ A0, A1, A2,  A3 ], [A4, A5, A6, A7] ,... , [ ..., An-2, An-1 ]\\n      level 1        [ A0, A1], [A2,  A3 ], [A4, A5], [A6, A7] ,... , [An-2, An-1]\\n      level 0        [ A0 ], [ A1] , [ A2 ],  [ A3 ],... , [ An-2 ], [ An-1 ]\\n\\nAt each level, each group only contains at maximum 2^level elements. Merge-sort theses groups pair by pair. Then level ++. Stop until 2^level > n.\\nAssume the original input is :\\n\\n      level 0        5, 3, 6, 1, 4, 2, 7\\nAfter level 0, we got the length of the list and the list become:\\n\\n      level 1        3, 5,   1, 6,    2, 4,    7\\nNow each group contains 2 elements. After level 1, the list become:\\n\\n      level 2        1, 3, 5, 6,    2, 4, 7\\n\\nNow each group contains 2^2 = 4 elements. After level 2, the list become:\\n\\n      level 3        1, 2, 3, 4, 5, 6, 7\\nNow, 2^3 > 7, stop.\\n\\nTime complexity:\\nIn each level, each node is visited by at maximum twice. And there are log(n) level. Thus the time complexity is O(2n* log n ) => O( n* log n )\\n\\n\\nHere is the code:\\n\\n    public class Solution {\\n    private class MergeHelper {\\n            public ListNode newHead;\\n            public ListNode newTail;\\n    }\\n    public ListNode sortList(ListNode head) {\\n        if ( head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode dummyHeadOne = new ListNode(0);\\n        ListNode dummyHeadTwo = new ListNode(0);\\n        ListNode dummySortedHead = new ListNode(0);\\n        ListNode dummySortedLast = dummySortedHead;\\n        ListNode unvisitedNode = head;\\n        MergeHelper mergeRst = new MergeHelper();\\n        \\n        int listLength = 0;\\n        int level = 0;\\n        while ( unvisitedNode != null && unvisitedNode.next != null ) {\\n            unvisitedNode = addNode ( dummyHeadOne, unvisitedNode, 1<<level);\\n            unvisitedNode = addNode ( dummyHeadTwo, unvisitedNode, 1<<level);\\n            merge ( dummyHeadOne.next, dummyHeadTwo.next, mergeRst);\\n            dummySortedLast.next = mergeRst.newHead;\\n            dummySortedLast = mergeRst.newTail;\\n            listLength += 2;\\n        }\\n        if (unvisitedNode != null) {\\n            dummySortedLast.next = unvisitedNode;\\n            listLength ++;\\n        }\\n        level ++;\\n        \\n        while ( listLength > 1 << level) {\\n            dummySortedLast = dummySortedHead;\\n            unvisitedNode = dummySortedHead.next;\\n            while (unvisitedNode != null) {\\n                unvisitedNode = addNode ( dummyHeadOne, unvisitedNode, 1<<level);\\n                unvisitedNode = addNode ( dummyHeadTwo, unvisitedNode, 1<<level);\\n                merge ( dummyHeadOne.next, dummyHeadTwo.next, mergeRst);\\n                dummySortedLast.next = mergeRst.newHead;\\n                dummySortedLast = mergeRst.newTail;\\n            }\\n            level ++;\\n        }\\n        \\n        return dummySortedHead.next;\\n    }\\n    \\n    /* merge listOne and listTwo. \\n    Save the sorted list head into rst.newHead\\n    Save the last node of the sorted list into rst.newTail\\n    */\\n    private void merge (ListNode listOne, ListNode listTwo, MergeHelper rst) {\\n        ListNode dummyHead = new ListNode (0);\\n        ListNode lastNode = dummyHead;\\n        while (listOne != null && listTwo != null) {\\n            if ( listOne.val < listTwo.val ) {\\n                lastNode.next = listOne;\\n                listOne = listOne.next;\\n            } else {\\n                lastNode.next = listTwo;\\n                listTwo = listTwo.next;\\n            }\\n            lastNode = lastNode.next;\\n        }\\n        \\n        while (listOne != null) {\\n            lastNode.next = listOne;\\n            listOne = listOne.next;\\n            lastNode = lastNode.next;\\n        }\\n        while ( listTwo != null ) {\\n            lastNode.next = listTwo;\\n            listTwo = listTwo.next;\\n            lastNode = lastNode.next;\\n        }\\n        rst.newHead = dummyHead.next;\\n        rst.newTail = lastNode;\\n    }\\n    \\n    /*\\n     add at max #\"count\" nodes into \"head\" from \"source\"\\n     return the new position of source after adding.\\n    */\\n    private ListNode addNode ( ListNode head, ListNode source, int count ) {\\n        while (count > 0 && source != null) {\\n            head.next = source;\\n            head = head.next;\\n            source = source.next;\\n            count --;\\n        }\\n        head.next = null;\\n        return source;\\n    }}\\n\\nSpace complexity:\\nThere are no recursion calls in this solution. Thus the maximum number of function calls is constant.\\nThe number of dummy nodes is constant.\\nThus the auxiliary space complexity is O(1)."
		},
		{
			"lc_ans_id":"46857",
			"view":"4230",
			"top":"7",
			"title":"Clean and short  Merge sort Solution in c++",
			"vote":"24",
			"content":"    class Solution {\\n    public:\\n        ListNode* merge( ListNode* head1 , ListNode * head2){\\n            ListNode* d = new ListNode (0);            // dummy node\\n            ListNode* e = d;\\n            while(head1||head2){\\n                if(head1 && (!head2 || head1->val <= head2 -> val) ){\\n                    e=e->next= head1 ; \\n                    head1 = head1 -> next;\\n                }\\n                if(head2 && (!head1 || head2->val < head1 -> val) ){\\n                    e=e->next= head2 ; \\n                    head2 = head2 -> next;\\n                }\\n            }\\n            e->next = NULL;\\n            return d->next;\\n        }\\n       ListNode* sortList(ListNode* head) {\\n            if(!head || !head->next) return head;\\n            ListNode* slow = head;\\n            ListNode* fast =head->next;\\n             while(fast && fast->next){         // to find middle node     \\n                fast= fast->next->next;\\n                slow = slow->next;\\n            }\\n            ListNode* headb = slow->next;     // headb is start of 2nd half of list\\n            slow->next = NULL;                 \\n            return merge(sortList(head) , sortList(headb));\\n            }\\n    };"
		},
		{
			"lc_ans_id":"46720",
			"view":"2575",
			"top":"8",
			"title":"Share my C++ concise solutions,easy to understand",
			"vote":"20",
			"content":"    class Solution {\\n    public:\\n        ListNode* sortList(ListNode* head) {\\n            if (head == NULL || head->next == NULL)\\n                return head;\\n            \\n            ListNode* slow = head;\\n            ListNode* fast = head->next;\\n            \\n            while (fast != NULL && fast->next != NULL)\\n            {\\n                slow = slow->next;\\n                fast = fast->next->next;\\n            }\\n            //divide the list into two parts \\n            fast = slow->next;\\n            slow->next = NULL;\\n            \\n            return merge(sortList(head), sortList(fast));\\n        }\\n        \\n        ListNode* merge(ListNode* l1, ListNode* l2)\\n        {\\n            ListNode dump(0);\\n            ListNode* cur = &dump;\\n            \\n            while (l1 != NULL && l2 != NULL)\\n            {\\n                if (l1->val < l2->val)\\n                {\\n                    cur->next = l1;\\n                    l1 = l1->next;\\n                }\\n                else\\n                {\\n                    cur->next = l2;\\n                    l2 = l2->next;\\n                }\\n                    \\n                cur = cur->next;\\n            }\\n            \\n            if (l1 != NULL)\\n                cur->next = l1;\\n            else\\n                cur->next = l2;\\n                \\n            return dump.next;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"46937",
			"view":"3344",
			"top":"9",
			"title":"56ms C++ Solutions using Quicksort with Explanations",
			"vote":"18",
			"content":"There are many merge-sort solutions at the forum, but very few quicksort solutions. So I post my accepted quicksort solution here.\\n\\nWell, after reading the problem statement, I intuitively select quicksort since it is able to give an in-place solution and thus costs only constant space. Also, it is `O(nlogn)` in the expected case though it may become `O(n^2)` in the worst case.\\n\\nThen I implement my quicksort solution and test it. I then submit it to the online judge. However, the annoying TLE error occurred. I check for the forums and some people suggested to use random pivoting or duplicate skipping. However, implementing random pivoting is a little costly, I lazily tried to skip the duplicates. And it works! So now comes the following solution . Note that each time I choose the first node as the pivot. Moreover, I create a `new_head` that points to `head` for convenience.\\n\\nOf course, this solution passes the online judge luckily. If the linked list is like: `100000 -> 99999 -> 99998 -> ... -> 1`, it will fail since the subproblems only decrease by 1 at each recursion. However, it seems that the LeetCode OJ does not have this kind of test cases.\\n\\n        void sortListHelper(ListNode* head, ListNode* tail) {\\n        \\tif (head -> next == tail) return;\\n        \\t/* Partition the list. */\\n        \\tListNode* pre = head;\\n        \\tListNode* cur = head -> next; \\n        \\tListNode* pivot = cur;\\n        \\twhile (cur -> next && cur -> next != tail) {\\t\\t\\n        \\t\\tif (pivot -> val > cur -> next -> val) {\\n        \\t\\t\\tListNode* temp = pre -> next;\\n        \\t\\t\\tpre -> next = cur -> next;\\n        \\t\\t\\tcur -> next = cur -> next -> next;\\n        \\t\\t\\tpre -> next -> next = temp;\\n        \\t\\t}\\n        \\t\\telse cur = cur -> next;\\n        \\t}\\n        \\tsortListHelper(head, pivot);\\n        \\t/* Here is the trick. */\\n        \\twhile (pivot -> next != tail && pivot -> next -> val == pivot -> val)\\n        \\t    pivot = pivot -> next;\\n        \\tif (pivot -> next != tail) sortListHelper(pivot, tail);\\n        } \\n        \\n        ListNode* sortList(ListNode* head) {\\n        \\tListNode* new_head = new ListNode(0);\\n        \\tnew_head -> next = head;\\n        \\tsortListHelper(new_head, NULL);\\n        \\treturn new_head -> next;\\n        }"
		}
	],
	"id":"148",
	"title":"Sort List",
	"content":"<p>Sort a linked list in <i>O</i>(<i>n</i> log <i>n</i>) time using constant space complexity.</p>",
	"frequency":"585",
	"ac_num":"123789"
}