{
	"difficulty":"3",
	"submit_num":"582809",
	"show_id":"149",
	"leetcode_id":"149",
	"answers":[
		{
			"lc_ans_id":"47113",
			"view":"48813",
			"top":"0",
			"title":"A java solution with notes",
			"vote":"122",
			"content":"  \\n\\n      /*\\n         *  A line is determined by two factors,say y=ax+b\\n         *  \\n         *  If two points(x1,y1) (x2,y2) are on the same line(Of course). \\n\\n         *  Consider the gap between two points.\\n\\n         *  We have (y2-y1)=a(x2-x1),a=(y2-y1)/(x2-x1) a is a rational, b is canceled since b is a constant\\n\\n         *  If a third point (x3,y3) are on the same line. So we must have y3=ax3+b\\n\\n         *  Thus,(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a\\n\\n         *  Since a is a rational, there exists y0 and x0, y0/x0=(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a\\n\\n         *  So we can use y0&x0 to track a line;\\n         */\\n        \\n        public class Solution{\\n            public int maxPoints(Point[] points) {\\n            \\tif (points==null) return 0;\\n            \\tif (points.length<=2) return points.length;\\n            \\t\\n            \\tMap<Integer,Map<Integer,Integer>> map = new HashMap<Integer,Map<Integer,Integer>>();\\n            \\tint result=0;\\n            \\tfor (int i=0;i<points.length;i++){ \\n            \\t\\tmap.clear();\\n            \\t\\tint overlap=0,max=0;\\n            \\t\\tfor (int j=i+1;j<points.length;j++){\\n            \\t\\t\\tint x=points[j].x-points[i].x;\\n            \\t\\t\\tint y=points[j].y-points[i].y;\\n            \\t\\t\\tif (x==0&&y==0){\\n            \\t\\t\\t\\toverlap++;\\n            \\t\\t\\t\\tcontinue;\\n            \\t\\t\\t}\\n            \\t\\t\\tint gcd=generateGCD(x,y);\\n            \\t\\t\\tif (gcd!=0){\\n            \\t\\t\\t\\tx/=gcd;\\n            \\t\\t\\t\\ty/=gcd;\\n            \\t\\t\\t}\\n            \\t\\t\\t\\n            \\t\\t\\tif (map.containsKey(x)){\\n            \\t\\t\\t\\tif (map.get(x).containsKey(y)){\\n            \\t\\t\\t\\t\\tmap.get(x).put(y, map.get(x).get(y)+1);\\n            \\t\\t\\t\\t}else{\\n            \\t\\t\\t\\t\\tmap.get(x).put(y, 1);\\n            \\t\\t\\t\\t}   \\t\\t\\t\\t\\t\\n            \\t\\t\\t}else{\\n            \\t\\t\\t\\tMap<Integer,Integer> m = new HashMap<Integer,Integer>();\\n            \\t\\t\\t\\tm.put(y, 1);\\n            \\t\\t\\t\\tmap.put(x, m);\\n            \\t\\t\\t}\\n            \\t\\t\\tmax=Math.max(max, map.get(x).get(y));\\n            \\t\\t}\\n            \\t\\tresult=Math.max(result, max+overlap+1);\\n            \\t}\\n            \\treturn result;\\n            \\t\\n            \\t\\n            }\\n            private int generateGCD(int a,int b){\\n        \\n            \\tif (b==0) return a;\\n            \\telse return generateGCD(b,a%b);\\n            \\t\\n            }\\n        }"
		},
		{
			"lc_ans_id":"47117",
			"view":"22087",
			"top":"1",
			"title":"Sharing my simple solution with explanation",
			"vote":"78",
			"content":"    int maxPoints(vector<Point> &points) {\\n        int result = 0;\\n        for(int i = 0; i < points.size(); i++){\\n            int samePoint = 1;\\n            unordered_map<double, int> map;\\n            for(int j = i + 1; j < points.size(); j++){\\n                if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                    samePoint++;\\n                }\\n                else if(points[i].x == points[j].x){\\n                    map[INT_MAX]++;\\n                }\\n                else{\\n                    double slope = double(points[i].y - points[j].y) / double(points[i].x - points[j].x);\\n                    map[slope]++;\\n                }\\n            }\\n            int localMax = 0;\\n            for(auto it = map.begin(); it != map.end(); it++){\\n                localMax = max(localMax, it->second);\\n            }\\n            localMax += samePoint;\\n            result = max(result, localMax);\\n        }\\n        return result;\\n    }\\n\\nFirst, let's talk about mathematics.\\n\\nHow to determine if three points are on the same line?\\n\\nThe answer is to see if slopes of arbitrary two pairs are the same.\\n\\nSecond, let's see what the minimum time complexity can be.\\n\\nDefinitely, O(n^2). It's because you have to calculate all slopes between any two points. \\n\\nThen let's go back to the solution of this problem.\\n\\nIn order to make this discussion simpler, let's pick a random point A as an example.\\n\\nGiven point A, we need to calculate all slopes between A and other points. There will be three cases:\\n\\n1. Some other point is the same as point A.\\n\\n2. Some other point has the same x coordinate as point A, which will result to a positive infinite slope.\\n\\n3. General case. We can calculate slope.\\n\\nWe can store all slopes in a hash table. And we find which slope shows up mostly. Then add the number of same points to it. Then we know the maximum number of points on the same line for point A.\\n\\nWe can do the same thing to point B, point C...\\n\\nFinally, just return the maximum result among point A, point B, point C..."
		},
		{
			"lc_ans_id":"47098",
			"view":"21306",
			"top":"2",
			"title":"Accepted Java solution, easy to understand.",
			"vote":"70",
			"content":"        /**\\n     * Definition for a point.\\n     * class Point {\\n     *     int x;\\n     *     int y;\\n     *     Point() { x = 0; y = 0; }\\n     *     Point(int a, int b) { x = a; y = b; }\\n     * }\\n     */\\n    public class Solution {\\n        public int maxPoints(Point[] points) {\\n            if(points.length <= 0) return 0;\\n            if(points.length <= 2) return points.length;\\n            int result = 0;\\n            for(int i = 0; i < points.length; i++){\\n                HashMap<Double, Integer> hm = new HashMap<Double, Integer>();\\n                int samex = 1;\\n                int samep = 0;\\n                for(int j = 0; j < points.length; j++){\\n                    if(j != i){\\n                        if((points[j].x == points[i].x) && (points[j].y == points[i].y)){\\n                            samep++;\\n                        }\\n                        if(points[j].x == points[i].x){\\n                            samex++;\\n                            continue;\\n                        }\\n                        double k = (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x);\\n                        if(hm.containsKey(k)){\\n                            hm.put(k,hm.get(k) + 1);\\n                        }else{\\n                            hm.put(k, 2);\\n                        }\\n                        result = Math.max(result, hm.get(k) + samep);\\n                    }\\n                }\\n                result = Math.max(result, samex);\\n            }\\n            return result;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"47106",
			"view":"15217",
			"top":"3",
			"title":"C++ O(n^2) solution for your reference",
			"vote":"60",
			"content":"Hint by @stellari\\n\\n\"For each point pi, calculate the slope of each line it forms with all other points with greater indices, i.e. pi+1, pi+2, ..., and use a map to record how many lines have the same slope (If two lines have the same slope and share a common point, then the two lines must be the same one). By doing so, you can easily find how many points are on the same line that ends at pi in O(n). Thus the amortized running time of the whole algorithm is O(n^2).\"\\n\\nIn order to avoid using double type(the slope k) as map key, I used pair (int a, int b) as the key where a=pj.x-pi.x, b=pj.y-pi.y, and k=b/a. Using greatest common divider of a and b to divide both a, b ensures that lines with same slope have the same key. \\n\\nI also handled two special cases: (1) when two points are on a vertical line (2) when two points are the same.\\n\\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            \\n            if(points.size()<2) return points.size();\\n            \\n            int result=0;\\n            \\n            for(int i=0; i<points.size(); i++) {\\n                \\n                map<pair<int, int>, int> lines;\\n                int localmax=0, overlap=0, vertical=0;\\n                \\n                for(int j=i+1; j<points.size(); j++) {\\n                    \\n                    if(points[j].x==points[i].x && points[j].y==points[i].y) {\\n                        \\n                        overlap++;\\n                        continue;\\n                    }\\n                    else if(points[j].x==points[i].x) vertical++;\\n                    else {\\n                        \\n                        int a=points[j].x-points[i].x, b=points[j].y-points[i].y;\\n                        int gcd=GCD(a, b);\\n                        \\n                        a/=gcd;\\n                        b/=gcd;\\n                        \\n                        lines[make_pair(a, b)]++;\\n                        localmax=max(lines[make_pair(a, b)], localmax);\\n                    }\\n    \\n                    localmax=max(vertical, localmax);\\n                }\\n                \\n                result=max(result, localmax+overlap+1);\\n            }\\n            \\n            return result;\\n        }\\n    \\n    private:\\n        int GCD(int a, int b) {\\n            \\n            if(b==0) return a;\\n            else return GCD(b, a%b);\\n        }\\n    };"
		},
		{
			"lc_ans_id":"47102",
			"view":"10163",
			"top":"4",
			"title":"20-line C++ O(n^2) Hashing Solution",
			"vote":"33",
			"content":"The idea is straight forward. Calculate each slope between two points and handle two special cases: 1. vertical, 2. duplicate. \\n\\n\\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point>& points) \\n        {\\n            if(points.size()<=2) return points.size();\\n            int res=0;\\n            for(int i=0;i<points.size()-1;i++) {\\n                int numVertical=1,local=1,duplicate=0;\\n                unordered_map<double,int> map;\\n                for(int j=i+1;j<points.size();j++) \\n                    if(points[i].x==points[j].x) // special cases\\n                        if(points[i].y==points[j].y) // duplicate \\n                            duplicate++;\\n                        else // vertical\\n                            numVertical++;\\n                    else {\\n                        double slope=(points[i].y-points[j].y)*1.0/(points[i].x-points[j].x);\\n                        map[slope]==0?map[slope]=2:map[slope]++;\\n                        local=max(local,map[slope]);\\n                    }\\n                local=max(local+duplicate,numVertical+duplicate);\\n                res=max(res,local);\\n            }\\n            return res;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"47124",
			"view":"2768",
			"top":"5",
			"title":"16ms/28ms C++ Solutions with Explanations",
			"vote":"29",
			"content":"This problem has a naive idea, which is to traverse all possible pairs of two points and see how many other points fall in the line determined by them. This idea is of `O(n^3)` time complexity and will meet TLE.\\n\\nWell, let's focus on lines instead of pairs of points. Could we just find out how many points fall in all possible lines? The answer is yes. Remember that a line is determined by its slope and intercept. In fact, if two lines with the same slope share a common point, then they are just the same line. So to determine a line, we need its slope and a point.\\n\\nNow comes the idea to solve this problem. We start from a specific point `p`, and compute all the slopes of the lines between `p` and the remaining points. Then those with the same slopes will be the same line. We can find out the maximum number of points fall on a line containing `p`. We exhaust all possible `p`'s and record the largest number we have seen. This number is just answer. \\n\\nWell, there are still two special cases to handle:\\n\\n 1. Duplicate points: a pair of duplicate points give no determined line, so we just count the number of duplicates and add them to the result.  \\n 2. Vertical lines: the slope of these lines is infinity mathematically. We simply set it to be `INT_MAX` in the following code.\\n\\nNow we have the following code, using an `unordered_map<float, int> slopes` to record how many points fall in the line of a specific slope and containing `points[i]`. Since all the operations of `unordered_map` is `O(1)`, this code is of `O(n^2)` complexity.\\n\\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point>& points) {\\n            unordered_map<float, int> slopes;\\n            int maxp = 0, n = points.size();\\n            for (int i = 0; i < n; i++) {\\n                slopes.clear();\\n                int duplicate = 1;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (points[j].x == points[i].x && points[j].y == points[i].y) {\\n                        duplicate++;\\n                        continue;\\n                    }\\n                    float slope = (points[j].x == points[i].x) ? INT_MAX : \\n                                  (float)(points[j].y - points[i].y) / (points[j].x - points[i].x);\\n                    slopes[slope]++;\\n                }\\n                maxp = max(maxp, duplicate);\\n                for (auto slope : slopes)\\n                    if (slope.second + duplicate > maxp) \\n                        maxp = slope.second + duplicate; \\n            }\\n            return maxp;\\n        }\\n    };\\n\\nWell, since the representation of floating point numbers is sometimes inaccurate, we may use a more safer way to represent the slope (`dy / dx`), which is to record `dx` and `dy` in a `pair<int, int>`. However, once we use `pair<int, int>` for the key of the map, we cannot use an `unordered_map` since `pair<int, int>` is unhashable. We now change to `map` and the time complexity becomes `O(n^2logn)`. Also, since `dy = 4, dx = 2` and `dy = 8, dx = 4` represents the same slope, we need to divide both of them by their gcd first.\\n\\nThe code is as follows. The logic is the same of the one above, just introducing `pair` and `gcd`.\\n\\n    class Solution { \\n    public: \\n        int maxPoints(vector<Point>& points) {\\n            map<pair<int, int>, int> slopes;\\n            int maxp = 0, n = points.size();\\n            for (int i = 0; i < n; i++) {\\n                slopes.clear();\\n                int duplicate = 1;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (points[j].x == points[i].x && points[j].y == points[i].y) {\\n                        duplicate++;\\n                        continue;\\n                    }\\n                    int dx = points[j].x - points[i].x;\\n                    int dy = points[j].y - points[i].y;\\n                    int dvs = gcd(dx, dy);\\n                    slopes[make_pair(dx / dvs, dy / dvs)]++;\\n                }\\n                maxp = max(maxp, duplicate); \\n                for (auto slope : slopes)\\n                    if (slope.second + duplicate > maxp)\\n                        maxp = slope.second + duplicate;\\n            } \\n            return maxp;\\n        }\\n    private:\\n        int gcd(int num1, int num2) {\\n            while (num2) {\\n                int temp = num2; \\n                num2 = num1 % num2;\\n                num1 = temp;\\n            }\\n            return num1;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"47108",
			"view":"4094",
			"top":"6",
			"title":"Python 68 ms code",
			"vote":"17",
			"content":"        def maxPoints(self, points):\\n            l = len(points)\\n            m = 0\\n            for i in range(l):\\n                dic = {'i': 1}\\n                same = 0\\n                for j in range(i+1, l):\\n                    tx, ty = points[j].x, points[j].y\\n                    if tx == points[i].x and ty == points[i].y: \\n                        same += 1\\n                        continue\\n                    if points[i].x == tx: slope = 'i'\\n                    else:slope = (points[i].y-ty) * 1.0 /(points[i].x-tx)\\n                    if slope not in dic: dic[slope] = 1\\n                    dic[slope] += 1\\n                m = max(m, max(dic.values()) + same)\\n        return m"
		},
		{
			"lc_ans_id":"47169",
			"view":"4435",
			"top":"7",
			"title":"My java accepted solution for your reference (only using array).",
			"vote":"14",
			"content":"        public class Solution \\n        {\\n            public int maxPoints(Point[] points) \\n            {\\n                int n=points.length;\\n                if (n<2) return n;\\n                int currentL=0,maxL=2,x=0,y=0,dx=0,dy=0,overlap=0,upperB=n;\\n                for(int i=0; i<upperB; i++)\\n                {\\n                    for(int j=i+1; j<n; j++)\\n                    {\\n                        currentL=1; \\n    /*\\n     * Given two points: (a,b) and (c,d), the corresponding normal vector is (b-d,c-a)\\n     * If another point (s,t) is in the same line uniquely defined by (a,b) and (c,d),\\n     * then (s-a,t-b) dot (b-d,c-a) = 0\\n     */\\n                        x=points[i].y-points[j].y;\\n                        y=points[j].x-points[i].x;\\n    \\n    /* If two points are the same, there is no need to check further, \\n     * since a line has to be defined by exactly two distinct points.\\n     */\\n                        if(x==0 && y==0) \\n                            overlap++;\\n    \\n    /* Well, it might be the case that duplicates are not consecutive, \\n     * but as long as we can have a non-trivial normal vector, it won't matter.\\n     */ \\n                        else \\n                        {\\n                            currentL++;\\n    \\n    /*  Explaining (currentL+n-k>maxL):\\n     *  no further checking is necessary when there isn't enough left to make it surpass maxL. \\n     */ \\n                            for(int k=j+1; k<n && currentL+n-k>maxL; k++)\\n                            {\\n                                dx=points[k].x-points[i].x;\\n                                dy=points[k].y-points[i].y;\\n                                if(x*dx+y*dy==0)\\n                                    currentL++;\\n                            }\\n                        }\\n                        maxL=Math.max(currentL+overlap,maxL);\\n                    }\\n    \\n    /* Explaining (upperB=n-maxL): \\n     * it would be crystal clear as soon as you draw a table for combinations of case n>3.\\n     */\\n                    upperB=n-maxL;\\n                    overlap=0;\\n                }\\n                return maxL;\\n            }\\n        }"
		},
		{
			"lc_ans_id":"47243",
			"view":"8343",
			"top":"8",
			"title":"Have an O(n^2) accepted solution but feel terrible about it. What do others think?",
			"vote":"12",
			"content":"My submission:\\n\\n    import java.util.Map;\\n    import java.util.HashMap;\\n    \\n    /**\\n     * Definition for a point.\\n     * class Point {\\n     *     int x;\\n     *     int y;\\n     *     Point() { x = 0; y = 0; }\\n     *     Point(int a, int b) { x = a; y = b; }\\n     * }\\n     */\\n    public class Solution {\\n        public int maxPoints(Point[] points) {\\n            int maxLine = 0;\\n            \\n            for (int i=0; i<(points.length-maxLine); i++) {\\n                int coincident = 0;\\n                Map<Double, Integer> pointCounts = new HashMap<Double, Integer>();\\n                for (int j=i+1; j<points.length; j++) {\\n                    Double slope;\\n                    if (points[i].x==points[j].x && points[i].y==points[j].y) {\\n                        coincident++;\\n                        continue;\\n                    } else if (points[i].x == points[j].x) {\\n                        slope = Math.PI;\\n                    } else if (points[i].y == points[j].y) {\\n                        slope = 0.0; // logically we don't need this, but in practice i find that we do\\n                    } else {\\n                        slope = new Double((double)(points[i].y-points[j].y) / (double)(points[i].x-points[j].x));\\n                    }\\n                    \\n                    if (pointCounts.containsKey(slope))\\n                        pointCounts.put(slope, pointCounts.get(slope)+1);\\n                    else\\n                        pointCounts.put(slope, new Integer(1));\\n                }\\n                maxLine = Math.max(maxLine, 1+coincident+maxValue(pointCounts));\\n            }\\n            \\n            return maxLine;\\n        }\\n        \\n        private int maxValue(Map<Double, Integer> doubleIntMap) {\\n            int max = 0;\\n            Set<Double> keys = doubleIntMap.keySet();\\n            Iterator iter = keys.iterator();\\n            while (iter.hasNext())\\n                max = Math.max(max, doubleIntMap.get(iter.next()));\\n            return max;\\n        }\\n    }\\nMy Algorithm was the following:\\n\\n    for every point i from 0 to points.length - maxColinearPointsFoundSoFar {\\n        for every j from i+1 to points.length-1 {\\n            ithPointHashTable[slope] += 1;\\n        } \\n        find max value in ithPointHashTable and update maxColinearPointsFoundSoFar;\\n    }\\n\\nHere are the reasons that combine to make me feel terrible:\\n\\nWhenever I use a hash table to achieve O(some runtime) having to assume hash table insertion is O(1), I don't feel great. hash tables also use extra memory which we are also watching our algorithms for.\\n\\nThis might've been the first time ever for me attempting to use a Double as a map key. Through this exercise I've discovered that its not a good idea. For instance (double) (0/1) and (double) (0/-1) evaluates to two different things. That's one thing the test cases uncovered. There might be more cases where mathematically expressions should evaluate to the same thing but in above code they don't.\\n\\nMore along those lines, for two points that have infinite slope, I inesrt them into the hashMap with a key of Math.PI. Mathematically no two points with integer coordinates should have an irrational slope, however in practice because of computer precision. But could there be a case where two points with integer coordinates have a slope between them that creates an equivalent map key as Math.PI? Although its not very likely, the probability might not be 0."
		},
		{
			"lc_ans_id":"47268",
			"view":"1130",
			"top":"9",
			"title":"Two concise python solutions.",
			"vote":"9",
			"content":"The first solution uses slope directly as the key for the dictionary. Python can handle it. The second solution uses a tuple of integer (dx, dy) as the key.\\n\\nSolution 1:\\n\\n    def maxPoints(self, points):\\n        if len(points) <= 2: return len(points)\\n        d = collections.defaultdict(int) # slope : count\\n        result = 0\\n        for i in range(len(points)):\\n            d.clear()\\n            overlap, curmax = 0, 0\\n            for j in range(i+1, len(points)):\\n                dx, dy = points[j].x - points[i].x, points[j].y - points[i].y\\n                if dx == 0 and dy == 0:\\n                    overlap += 1\\n                    continue\\n                slope = dy * 1.0 / dx if dx != 0 else 'infinity'\\n                d[slope] += 1\\n                curmax = max(curmax, d[slope])\\n            result = max(result, curmax+overlap+1)\\n        return result\\n\\n\\nSolution 2:\\n\\n    def maxPoints(self, points):\\n        if len(points) <= 2: return len(points)\\n        d = collections.defaultdict(int) # (x,y) : count\\n        result = 0\\n        for i in range(len(points)):\\n            d.clear()\\n            overlap = 0\\n            curmax = 0\\n            for j in range(i+1, len(points)):\\n                dx = points[j].x - points[i].x\\n                dy = points[j].y - points[i].y\\n                if dx == 0 and dy == 0:\\n                    overlap += 1\\n                    continue\\n                gcd = self.getGcd(dx, dy)\\n                dx //= gcd\\n                dy //= gcd\\n                d[(dx,dy)] += 1\\n                curmax = max(curmax, d[(dx,dy)])\\n            result = max(result, curmax+overlap+1)\\n        return result\\n    \\n    def getGcd(self, a, b):\\n        if b == 0: return a\\n        return self.getGcd(b, a%b)"
		}
	],
	"id":"149",
	"title":"Max Points on a Line",
	"content":"<p>Given <i>n</i> points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>",
	"frequency":"561",
	"ac_num":"88682"
}