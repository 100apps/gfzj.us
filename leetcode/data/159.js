{
	"difficulty":"3",
	"submit_num":"80974",
	"show_id":"159",
	"leetcode_id":"159",
	"answers":[
		{
			"lc_ans_id":"49759",
			"view":"7031",
			"top":"0",
			"title":"Share my c++ solution",
			"vote":"58",
			"content":"This question belong to the same category as those such as \"longest substring without repeating characters\", \"minimum window substring\", and \"substring with concatenation of all words\". To solve this kind of question we can use two pointers and a hash table. When the key of the hash table is char, we can simply use an array as the hash table. The most important idea in solving this kind of questions is \"how to update the \"start\" pointer\" and the solution to these questions seem usually differ only in this respect. \\n\\n    int lengthOfLongestSubstringTwoDistinct(string s) {\\n        if(s.empty()) return 0;\\n        \\n        int dict[256]; \\n        fill_n(dict,256,0);\\n        int start = 0, len = 1, count = 0;\\n        for(int i=0; i<s.length(); i++) {\\n            dict[s[i]]++;\\n            if(dict[s[i]] == 1) { // new char\\n                count++;\\n                while(count > 2) {\\n                    dict[s[start]]--;\\n                    if(dict[s[start]] == 0) count--; \\n                    start++;\\n                }\\n            }\\n            if(i-start+1 > len) len = i-start+1;\\n        }\\n        return len;\\n    }"
		},
		{
			"lc_ans_id":"49682",
			"view":"10593",
			"top":"1",
			"title":"Simple O(n) java solution - easily extend to k characters",
			"vote":"57",
			"content":"The main idea is to maintain a sliding window with 2 unique characters. The key is to store the last occurrence of each character as the value in the hashmap. This way, whenever the size of the hashmap exceeds 2, we can traverse through the map to find the character with the left most index, and remove 1 character from our map. Since the range of characters is constrained, we should be able to find the left most index in constant time. \\n\\n    public class Solution {\\n        public int lengthOfLongestSubstringTwoDistinct(String s) {\\n            if(s.length() < 1) return 0;\\n            HashMap<Character,Integer> index = new HashMap<Character,Integer>();\\n            int lo = 0;\\n            int hi = 0;\\n            int maxLength = 0;\\n            while(hi < s.length()) {\\n                if(index.size() <= 2) {\\n                    char c = s.charAt(hi);\\n                    index.put(c, hi);\\n                    hi++;\\n                }\\n                if(index.size() > 2) {\\n                    int leftMost = s.length();\\n                    for(int i : index.values()) {\\n                        leftMost = Math.min(leftMost,i);\\n                    }\\n                    char c = s.charAt(leftMost);\\n                    index.remove(c);\\n                    lo = leftMost+1;\\n                }\\n                maxLength = Math.max(maxLength, hi-lo);\\n            }\\n            return maxLength;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"49708",
			"view":"3435",
			"top":"2",
			"title":"Sliding Window algorithm template to solve all the Leetcode substring search problem.",
			"vote":"26",
			"content":"**Among all leetcode questions, I find that there are at least 5 substring search problem which could be solved by the sliding window algorithm.** \\nso I sum up the algorithm template here. wish it will help you!\\n\\n1) ***the template***:\\n```\\npublic class Solution {\\n    public List<Integer> slidingWindowTemplateByHarryChaoyangHe(String s, String t) {\\n        //init a collection or int value to save the result according the question.\\n        List<Integer> result = new LinkedList<>();\\n        if(t.length()> s.length()) return result;\\n        \\n        //create a hashmap to save the Characters of the target substring.\\n        //(K, V) = (Character, Frequence of the Characters)\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        //maintain a counter to check whether match the target string.\\n        int counter = map.size();//must be the map size, NOT the string size because the char may be duplicate.\\n        \\n        //Two Pointers: begin - left pointer of the window; end - right pointer of the window\\n        int begin = 0, end = 0;\\n        \\n        //the length of the substring which match the target string.\\n        int len = Integer.MAX_VALUE; \\n        \\n        //loop at the begining of the source string\\n        while(end < s.length()){\\n            \\n            char c = s.charAt(end);//get a character\\n            \\n            if( map.containsKey(c) ){\\n                map.put(c, map.get(c)-1);// plus or minus one\\n                if(map.get(c) == 0) counter--;//modify the counter according the requirement(different condition).\\n            }\\n            end++;\\n            \\n            //increase begin pointer to make it invalid/valid again\\n            while(counter == 0 /* counter condition. different question may have different condition */){\\n                \\n                char tempc = s.charAt(begin);//***be careful here: choose the char at begin pointer, NOT the end pointer\\n                if(map.containsKey(tempc)){\\n                    map.put(tempc, map.get(tempc) + 1);//plus or minus one\\n                    if(map.get(tempc) > 0) counter++;//modify the counter according the requirement(different condition).\\n                }\\n                \\n                /* save / update(min/max) the result if find a target*/\\n                // result collections or result int value\\n                \\n                begin++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n````\\n\\n1) Firstly, here is my sliding solution this question. I will sum up the template below this code.\\n\\n\\n**2) the similar questions are:**\\n\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/longest-substring-without-repeating-characters/\\u2028https://leetcode.com/problems/substring-with-concatenation-of-all-words/\\nhttps://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/\\nhttps://leetcode.com/problems/find-all-anagrams-in-a-string/\\n\\n**3) I will give my solution for these questions use the above template one by one** \\n\\n**Minimum-window-substring**\\nhttps://leetcode.com/problems/minimum-window-substring/\\n```\\npublic class Solution {\\n    public String minWindow(String s, String t) {\\n        if(t.length()> s.length()) return \"\";\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0) + 1);\\n        }\\n        int counter = map.size();\\n        \\n        int begin = 0, end = 0;\\n        int head = 0;\\n        int len = Integer.MAX_VALUE;\\n        \\n        while(end < s.length()){\\n            char c = s.charAt(end);\\n            if( map.containsKey(c) ){\\n                map.put(c, map.get(c)-1);\\n                if(map.get(c) == 0) counter--;\\n            }\\n            end++;\\n            \\n            while(counter == 0){\\n                char tempc = s.charAt(begin);\\n                if(map.containsKey(tempc)){\\n                    map.put(tempc, map.get(tempc) + 1);\\n                    if(map.get(tempc) > 0){\\n                        counter++;\\n                    }\\n                }\\n                if(end-begin < len){\\n                    len = end - begin;\\n                    head = begin;\\n                }\\n                begin++;\\n            }\\n            \\n        }\\n        if(len == Integer.MAX_VALUE) return \"\";\\n        return s.substring(head, head+len);\\n    }\\n}\\n````\\nyou may find that I only change a little code above to solve the question \"Find All Anagrams in a String\":\\nchange \\n```\\n                if(end-begin < len){\\n                    len = end - begin;\\n                    head = begin;\\n                }\\n````\\nto\\n```\\n                if(end-begin == t.length()){\\n                    result.add(begin);\\n                }\\n````\\n\\n**longest substring without repeating characters**\\nhttps://leetcode.com/problems/longest-substring-without-repeating-characters/\\u2028\\n```\\npublic class Solution {\\n    public int lengthOfLongestSubstring(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int begin = 0, end = 0, counter = 0, d = 0;\\n\\n        while (end < s.length()) {\\n            // > 0 means repeating character\\n            //if(map[s.charAt(end++)]-- > 0) counter++;\\n            char c = s.charAt(end);\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n            if(map.get(c) > 1) counter++;\\n            end++;\\n            \\n            while (counter > 0) {\\n                //if (map[s.charAt(begin++)]-- > 1) counter--;\\n                char charTemp = s.charAt(begin);\\n                if (map.get(charTemp) > 1) counter--;\\n                map.put(charTemp, map.get(charTemp)-1);\\n                begin++;\\n            }\\n            d = Math.max(d, end - begin);\\n        }\\n        return d;\\n    }\\n}\\n````\\n**Longest Substring with At Most Two Distinct Characters**\\nhttps://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/\\n```\\npublic class Solution {\\n    public int lengthOfLongestSubstringTwoDistinct(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        int start = 0, end = 0, counter = 0, len = 0;\\n        while(end < s.length()){\\n            char c = s.charAt(end);\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n            if(map.get(c) == 1) counter++;//new char\\n            end++;\\n            while(counter > 2){\\n                char cTemp = s.charAt(start);\\n                map.put(cTemp, map.get(cTemp) - 1);\\n                if(map.get(cTemp) == 0){\\n                    counter--;\\n                }\\n                start++;\\n            }\\n            len = Math.max(len, end-start);\\n        }\\n        return len;\\n    }\\n}\\n````\\n\\n**Substring with Concatenation of All Words**\\nhttps://leetcode.com/problems/substring-with-concatenation-of-all-words/\\n```\\npublic class Solution {\\n    public List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> res = new LinkedList<>();\\n        if (L.length == 0 || S.length() < L.length * L[0].length())   return res;\\n        int N = S.length();\\n        int M = L.length; // *** length\\n        int wl = L[0].length();\\n        Map<String, Integer> map = new HashMap<>(), curMap = new HashMap<>();\\n        for (String s : L) {\\n            if (map.containsKey(s))   map.put(s, map.get(s) + 1);\\n            else                      map.put(s, 1);\\n        }\\n        String str = null, tmp = null;\\n        for (int i = 0; i < wl; i++) {\\n            int count = 0;  // remark: reset count \\n            int start = i;\\n            for (int r = i; r + wl <= N; r += wl) {\\n                str = S.substring(r, r + wl);\\n                if (map.containsKey(str)) {\\n                    if (curMap.containsKey(str))   curMap.put(str, curMap.get(str) + 1);\\n                    else                           curMap.put(str, 1);\\n                    \\n                    if (curMap.get(str) <= map.get(str))    count++;\\n                    while (curMap.get(str) > map.get(str)) {\\n                        tmp = S.substring(start, start + wl);\\n                        curMap.put(tmp, curMap.get(tmp) - 1);\\n                        start += wl;\\n                        \\n                        //the same as https://leetcode.com/problems/longest-substring-without-repeating-characters/\\n                        if (curMap.get(tmp) < map.get(tmp)) count--;\\n                        \\n                    }\\n                    if (count == M) {\\n                        res.add(start);\\n                        tmp = S.substring(start, start + wl);\\n                        curMap.put(tmp, curMap.get(tmp) - 1);\\n                        start += wl;\\n                        count--;\\n                    }\\n                }else {\\n                    curMap.clear();\\n                    count = 0;\\n                    start = r + wl;//not contain, so move the start\\n                }\\n            }\\n            curMap.clear();\\n        }\\n        return res;\\n    }\\n}\\n````\\n\\n**Find All Anagrams in a String**\\nhttps://leetcode.com/problems/find-all-anagrams-in-a-string/\\n```\\npublic class Solution {\\n    public List<Integer> findAnagrams(String s, String t) {\\n        List<Integer> result = new LinkedList<>();\\n        if(t.length()> s.length()) return result;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        int counter = map.size();\\n        \\n        int begin = 0, end = 0;\\n        int head = 0;\\n        int len = Integer.MAX_VALUE;\\n        \\n        \\n        while(end < s.length()){\\n            char c = s.charAt(end);\\n            if( map.containsKey(c) ){\\n                map.put(c, map.get(c)-1);\\n                if(map.get(c) == 0) counter--;\\n            }\\n            end++;\\n            \\n            while(counter == 0){\\n                char tempc = s.charAt(begin);\\n                if(map.containsKey(tempc)){\\n                    map.put(tempc, map.get(tempc) + 1);\\n                    if(map.get(tempc) > 0){\\n                        counter++;\\n                    }\\n                }\\n                if(end-begin == t.length()){\\n                    result.add(begin);\\n                }\\n                begin++;\\n            }\\n            \\n        }\\n        return result;\\n    }\\n}\\n````"
		},
		{
			"lc_ans_id":"49687",
			"view":"4923",
			"top":"3",
			"title":"Clean 11 lines AC answer, O(1) space, O(n) time.",
			"vote":"26",
			"content":"I submitted this solution two months ago and I can't even remember whether I wrote myself or copied from others. I don't understand it now but find it AC and much shorter than other posts here. \\n\\n    int lengthOfLongestSubstringTwoDistinct(string s) {\\n            int i = 0, j = -1;\\n            int maxLen = 0;\\n            for (int k = 1; k < s.size(); k++) {\\n                if (s[k] == s[k-1]) continue;\\n                if (j > -1 && s[k] != s[j]) {\\n                    maxLen = max(maxLen, k - i);\\n                    i = j + 1;\\n                }\\n                j = k - 1;\\n            }\\n            return maxLen > (s.size() - i) ? maxLen : s.size() - i;\\n        }"
		},
		{
			"lc_ans_id":"49778",
			"view":"1866",
			"top":"4",
			"title":"O(n) time and O(1) space solution without using HashMap",
			"vote":"8",
			"content":"The basic idea is to store the two characters and keep track of last indices of them. When third character comes, we set the start_point to 1 + smaller index, in that way we can always throw away one character. And the length is given by current_index - start_point.\\n\\n    public class Solution {\\n            public int lengthOfLongestSubstringTwoDistinct(String s) {\\n            if(s == null || s.length() == 0){\\n                return 0;\\n            }\\n            char charOne = s.charAt(0);\\n            int charOneIndex = 0;\\n            while(charOneIndex+1 < s.length() && s.charAt(charOneIndex+1) == charOne){ // in case of \"aaa\"\\n                charOneIndex++;\\n            }\\n            if(charOneIndex == s.length()-1){\\n                return s.length();\\n            }\\n            char charTwo = s.charAt(charOneIndex+1);\\n            int charTwoIndex = charOneIndex+1;\\n            int startIndex = 0;\\n            int maxLen = charTwoIndex+1;\\n            for(int i=charTwoIndex+1; i<s.length(); i++){\\n                char c = s.charAt(i);\\n                if(c != charOne && c != charTwo){ //new character comes, update index and char\\n                    startIndex = Math.min(charOneIndex, charTwoIndex)+1;\\n                    charOneIndex = Math.max(charOneIndex, charTwoIndex);\\n                    charOne = charOneIndex == charTwoIndex ? charTwo : charOne;\\n                    charTwoIndex = i;\\n                    charTwo = c;\\n                }\\n                else{ //same character comes, update max length\\n                    if(c == charOne){\\n                        charOneIndex = i;\\n                    }\\n                    else{\\n                        charTwoIndex = i;\\n                    }\\n                    if(i - startIndex + 1 > maxLen){\\n                        maxLen = i - startIndex + 1;\\n                    }\\n                }\\n            }\\n            return maxLen;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"49747",
			"view":"1025",
			"top":"5",
			"title":"C++ One scan solution. easy understanding.",
			"vote":"6",
			"content":"\\n\\n      // 0. using a idx_start to remember the current start\\n     // 1. using a map<char, int> cand remember how many times char occurs\\n    // 2. once the map has two elements. caculate the len \\n    //3. then move the idx_start and minus the count in map\\n    int lengthOfLongestSubstringTwoDistinct(string s) {\\n        const int size_s = s.size();\\n        unordered_map<char, int> cand;\\n        int idx_start = 0, long_len = 0;\\n        for (int i = 0; i < size_s; i++) {\\n            cand[s[i]]++;\\n            while (cand.size() > 2) {\\n                if (--cand[s[idx_start]] == 0) cand.erase(s[idx_start]);\\n                idx_start++;\\n            }\\n            long_len = max(long_len, i - idx_start + 1);\\n        }\\n        return long_len;\\n    }"
		},
		{
			"lc_ans_id":"49745",
			"view":"1633",
			"top":"6",
			"title":"4ms Java Two pointers solution beat 100%",
			"vote":"4",
			"content":"    public int lengthOfLongestSubstringTwoDistinct(String s) {\\n        if (s.isEmpty()) return 0;\\n        int max = 1;\\n        int p1 = 0, p2 = 0;\\n        int last = 1;\\n        char[] chars = s.toCharArray();\\n        for (int i = 1; i < chars.length; i++) {\\n            if (p1 != p2 && chars[i] != chars[p1] && chars[i] != chars[p2]) {\\n                if (last > max) max = last;\\n                \\n                last = i - p1;\\n                p1 = p2;\\n                p2 = i;\\n            } else {\\n                if (chars[i] == chars[p1]) {\\n                    p1 = p1 == p2 ? i : p2;\\n                }\\n                last++;\\n                p2 = i;\\n            }\\n        }\\n        \\n        if (last > max) max = last;\\n        return max;\\n    }"
		},
		{
			"lc_ans_id":"49735",
			"view":"1393",
			"top":"7",
			"title":"Python simple O(n) solution with comments",
			"vote":"4",
			"content":"Idea is simple. Maintain left to right window. If third char encountered, remove the char which has the lowest position value and update left pointer to the lowest position + 1.\\nThis solution can be easily extend to k distinct chars.\\n\\n    class Solution(object):\\n    def lengthOfLongestSubstringTwoDistinct(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        distinct = {}  # char: pos\\n        maxlen = 0\\n        left = 0\\n        \\n        for right, char in enumerate(s):\\n            if len(distinct) == 2 and char not in distinct:\\n                left = min(distinct.values()) + 1\\n                self.remove_lowest_char(distinct)\\n            distinct[char] = right\\n            maxlen = max(maxlen, right - left + 1)\\n        return maxlen\\n    \\n    def remove_lowest_char(self, distinct):\\n        lowest_pos = min(distinct.values())\\n        for k, pos in distinct.items():\\n            if pos == lowest_pos:\\n                char = k\\n        distinct.pop(char)"
		},
		{
			"lc_ans_id":"49695",
			"view":"146",
			"top":"8",
			"title":"Short and simple 10 lines Python O(n) solution",
			"vote":"2",
			"content":"```\\nclass Solution(object):\\n    def lengthOfLongestSubstringTwoDistinct(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        left, longest, d = 0, 0, {}\\n        maximum_distinct = 2\\n        for index, char in list(enumerate(s)):\\n            d[char] = index\\n            if len(d.keys()) == maximum_distinct + 1:\\n                index_to_remove = min([d[char] for char in d.keys()])\\n                d.pop(s[index_to_remove], None)\\n                left = index_to_remove + 1\\n            longest = max(longest, index - left + 1)\\n        return longest\\n                \\n```\\n\\nI used a hash to store a mapping of the character to its latest position within the string. When the hash has K+1 different characters, the key is here to find the character with the smallest (left-most) position and eliminate it from the hash. The left pointer then starts from the next character after the eliminated character."
		},
		{
			"lc_ans_id":"49741",
			"view":"490",
			"top":"9",
			"title":"Java-- Two pointers O(n) Very easy to understand",
			"vote":"2",
			"content":"This solution uses two pointers to traverse the array. Be careful of the size of helper array.\\n\\n    public class Solution {\\n        public int lengthOfLongestSubstringTwoDistinct(String s) {\\n            if (s == null || s.length() == 0) {\\n                return 0;\\n            }\\n            int[] set = new int[256];\\n            int size = 1;\\n            int i = 0, j = 1;\\n            int max = 1;\\n            set[s.charAt(i)] = 1;\\n            while (j < s.length()) {\\n                char c = s.charAt(j);\\n                if (set[c] != 0) {\\n                    max = Math.max(max,j-i+1);\\n                    set[c]++;\\n                    j++;\\n                } else {\\n                    if (size == 2) {\\n                        set[s.charAt(i)]--;\\n                        if (set[s.charAt(i)] == 0) {\\n                            set[c]++;\\n                            j++;\\n                        }\\n                        i++;\\n                    } else {\\n                        max = Math.max(max,j-i+1);\\n                        set[c]++;\\n                        size++;\\n                        j++;\\n                    }\\n                }\\n            }\\n            return max;\\n        }\\n    }"
		}
	],
	"id":"159",
	"title":"Longest Substring with At Most Two Distinct Characters",
	"content":"<p>\nGiven a string, find the length of the longest substring T that contains at most 2 distinct characters.\n</p>\n\n<p>\nFor example,\n\nGiven s = <code>“eceba”</code>,\n</p>\n\n<p>\nT is \"ece\" which its length is 3.\n</p>",
	"frequency":"239",
	"ac_num":"34387"
}