{
	"difficulty":"3",
	"submit_num":"178886",
	"show_id":"164",
	"leetcode_id":"164",
	"answers":[
		{
			"lc_ans_id":"50643",
			"view":"38668",
			"top":"0",
			"title":"[bucket sort] JAVA solution with explanation, O(N) time and space",
			"vote":"214",
			"content":"Suppose there are N elements in the array, the min value is ***min*** and the max value is ***max***. Then the maximum gap will be no smaller than ceiling[(***max*** - ***min*** ) / (N - 1)].\\n\\nLet gap = ceiling[(***max*** - ***min*** ) / (N - 1)]. We divide all numbers in the array into n-1 buckets, where k-th bucket contains all numbers in [***min***  + (k-1)gap, ***min***  + k*gap). Since there are n-2 numbers that are not equal ***min***  or ***max*** and there are n-1 buckets, at least one of the buckets are empty. We only need to store the largest number and the smallest number in each bucket. \\n\\nAfter we put all the numbers into the buckets. We can scan the buckets sequentially and get the max gap.\\n[my blog for this problem][1]\\n\\n    public class Solution {\\n    public int maximumGap(int[] num) {\\n        if (num == null || num.length < 2)\\n            return 0;\\n        // get the max and min value of the array\\n        int min = num[0];\\n        int max = num[0];\\n        for (int i:num) {\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n        }\\n        // the minimum possibale gap, ceiling of the integer division\\n        int gap = (int)Math.ceil((double)(max - min)/(num.length - 1));\\n        int[] bucketsMIN = new int[num.length - 1]; // store the min value in that bucket\\n        int[] bucketsMAX = new int[num.length - 1]; // store the max value in that bucket\\n        Arrays.fill(bucketsMIN, Integer.MAX_VALUE);\\n        Arrays.fill(bucketsMAX, Integer.MIN_VALUE);\\n        // put numbers into buckets\\n        for (int i:num) {\\n            if (i == min || i == max)\\n                continue;\\n            int idx = (i - min) / gap; // index of the right position in the buckets\\n            bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]);\\n            bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]);\\n        }\\n        // scan the buckets for the max gap\\n        int maxGap = Integer.MIN_VALUE;\\n        int previous = min;\\n        for (int i = 0; i < num.length - 1; i++) {\\n            if (bucketsMIN[i] == Integer.MAX_VALUE && bucketsMAX[i] == Integer.MIN_VALUE)\\n                // empty bucket\\n                continue;\\n            // min value minus the previous value is the current gap\\n            maxGap = Math.max(maxGap, bucketsMIN[i] - previous);\\n            // update previous bucket value\\n            previous = bucketsMAX[i];\\n        }\\n        maxGap = Math.max(maxGap, max - previous); // updata the final max value gap\\n        return maxGap;\\n    }\\n}\\n\\n\\n  [1]: http://zkfairytale.blogspot.ca/2014/12/maximum-gap.html"
		},
		{
			"lc_ans_id":"50642",
			"view":"11141",
			"top":"1",
			"title":"Radix sort solution in Java with explanation",
			"vote":"59",
			"content":"You can look at radix sort visualization here before reading the code:\\nhttps://www.cs.usfca.edu/~galles/visualization/RadixSort.html\\n\\n    public class Solution {\\n    public int maximumGap(int[] nums) {\\n        if (nums == null || nums.length < 2) {\\n            return 0;\\n        }\\n        \\n        // m is the maximal number in nums\\n        int m = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            m = Math.max(m, nums[i]);\\n        }\\n        \\n        int exp = 1; // 1, 10, 100, 1000 ...\\n        int R = 10; // 10 digits\\n\\n        int[] aux = new int[nums.length];\\n        \\n        while (m / exp > 0) { // Go through all digits from LSB to MSB\\n            int[] count = new int[R];\\n            \\n            for (int i = 0; i < nums.length; i++) {\\n                count[(nums[i] / exp) % 10]++;\\n            }\\n            \\n            for (int i = 1; i < count.length; i++) {\\n                count[i] += count[i - 1];\\n            }\\n            \\n            for (int i = nums.length - 1; i >= 0; i--) {\\n                aux[--count[(nums[i] / exp) % 10]] = nums[i];\\n            }\\n            \\n            for (int i = 0; i < nums.length; i++) {\\n                nums[i] = aux[i];\\n            }\\n            exp *= 10;\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i < aux.length; i++) {\\n            max = Math.max(max, aux[i] - aux[i - 1]);\\n        }\\n         \\n        return max;\\n    }\\n}\\n\\n 1. The first step is to find the maximum value in nums array, it will\\n     be the threshold to end while loop.    \\n 2. Then use the radix sort algorithm to sort based on each digit from Least Significant Bit\\n        (LSB) to Most Significant Bit (MSB), that's exactly what's showing\\n        in the link.\\n 3. `(nums[i] / exp) % 10` is used to get the digit, for each digit, basically the digit itself serves as the index to\\n    access the count array. Count array stores the index to access aux\\n    array which stores the numbers after sorting based on the current\\n    digit.\\n 4. Finally, find the maximum gap from sorted array.\\n\\nTime and space complexities are both O(n). (Actually time is O(10n) at worst case for Integer.MAX_VALUE 2147483647)"
		},
		{
			"lc_ans_id":"50644",
			"view":"9442",
			"top":"2",
			"title":"Pigeon hole principle",
			"vote":"50",
			"content":"Suppose you have n pigeons with labels and you put them into m holes based on their label with each hole of the same size. Why bother putting pigeons into holes? Because you want to disregard the distance between pigeons **within** each one hole. \\n\\nOnly when at least one hole is empty can we disregard the distance between pigeons within each one hole and compute the maximum gap solely by the distance between pigeons **in adjacent holes**. We make sure that at least one hole is empty by using m=n-1 (i.e. n-2 pigeons in n-1 holes => at least one hole is empty).\\n\\n    int maximumGap(vector<int>& nums) {\\n            const int n = nums.size();\\n            if(n<=1) return 0;\\n            int maxE = *max_element(nums.begin(),nums.end());\\n            int minE = *min_element(nums.begin(),nums.end());\\n            double len = double(maxE-minE)/double(n-1);\\n            vector<int> maxA(n,INT_MIN);\\n            vector<int> minA(n,INT_MAX);\\n            for(int i=0; i<n; i++) {\\n                int index = (nums[i]-minE)/len;\\n                maxA[index] = max(maxA[index],nums[i]);\\n                minA[index] = min(minA[index],nums[i]);\\n            }\\n            int gap = 0, prev = maxA[0];\\n            for(int i=1; i<n; i++) {\\n                if(minA[i]==INT_MAX) continue;\\n                gap = max(gap,minA[i]-prev);\\n                prev = maxA[i];\\n            }\\n            return gap;\\n        }"
		},
		{
			"lc_ans_id":"50725",
			"view":"8302",
			"top":"3",
			"title":"My C++ code (12 ms, \"bucket sort\", O(n) time and space)",
			"vote":"22",
			"content":"The key is to use the fact that the lower bound of the gap is (maxV - minV )/ (sSize - 1). With such in mind, we can put all the num elements into different bucket with size (maxV - minV )/ (sSize - 1) (please note when such size is less than 1, then use 1 instead) and in such way, we only need to consider the min and max of each bucket and don't need to worry the numbers in between of each bucket since the gaps among those elements are smaller than the bucket size, and then the lower bound of the gap, so they can not achieve the max gap.\\n\\nclass Solution {\\npublic:\\n    int maximumGap(vector<int> &num) {\\n        int sSize = num.size();\\n        int i, res =0;\\n        int minV, maxV;\\n        int bucket_size, bucket_num, bucket_id;\\n        int maxGap = INT_MIN;\\n        int last_max;\\n        \\n        if(sSize>1)\\n        {\\n            minV =  maxV = num[0];\\n            for(i=1; i<sSize; i++)\\n            {\\n                if(minV > num[i]) minV = num[i];\\n                else if(maxV < num[i]) maxV = num[i];\\n            }\\n            \\n            bucket_size = max(1, (maxV - minV )/ (sSize - 1)));\\n            bucket_num  = (maxV - minV)/bucket_size + 1;\\n\\n            if(bucket_num <=1) return (maxV - minV); \\n            vector<int> bucket_max(bucket_num, INT_MIN);\\n            vector<int> bucket_min(bucket_num, INT_MAX);\\n            vector<int> bucket_count(bucket_num, 0);\\n            \\n            for(i=0; i<sSize; i++)\\n            {\\n                bucket_id = (num[i] - minV)/bucket_size;\\n                bucket_count[bucket_id]++;\\n                bucket_min[bucket_id] = bucket_min[bucket_id] > num[i]? num[i]:bucket_min[bucket_id];\\n                bucket_max[bucket_id] = bucket_max[bucket_id] < num[i]? num[i]:bucket_max[bucket_id];\\n            }\\n            \\n            last_max = minV;\\n            for(i=0; i<bucket_num; i++)\\n            {\\n                if(bucket_count[i]>0)\\n                {\\n                    maxGap = max(maxGap, bucket_min[i]- last_max);\\n                    last_max = bucket_max[i];\\n                }\\n            }\\n            return maxGap;\\n        }\\n        return 0;\\n    }\\n};"
		},
		{
			"lc_ans_id":"50669",
			"view":"3144",
			"top":"4",
			"title":"Beat 99.81% java coder",
			"vote":"20",
			"content":"    public class Solution {\\n    public int maximumGap(int[] nums) {\\n        int n = nums.length;\\n        if(n < 2) return 0;\\n        int min = nums[0];\\n        int max = nums[0];\\n        for(int i = 1;i < n;i++){\\n            if(min > nums[i]) min = nums[i];\\n            if(max < nums[i]) max = nums[i];\\n        }\\n        \\n        int gap = (max-min)/(n-1);\\n        if(gap == 0) gap++;\\n        int len = (max-min)/gap+1;\\n        int [] tmax = new int [len];\\n        int [] tmin = new int [len];\\n        \\n        for(int i = 0;i < n;i++){\\n            int index = (nums[i]-min)/gap;\\n            if(nums[i] > tmax[index]) tmax[index] = nums[i];\\n            if(tmin[index] == 0 || nums[i] < tmin[index]) tmin[index] = nums[i];\\n        }\\n        int myMax = 0;\\n        for(int i = 0;i < len;i++){\\n            if(myMax < tmin[i]-min) myMax = tmin[i]-min;\\n            if(tmax[i] != 0) min = tmax[i];\\n        }\\n        return myMax;\\n    }\\n}"
		},
		{
			"lc_ans_id":"50647",
			"view":"10894",
			"top":"5",
			"title":"I solved it using radix sort",
			"vote":"19",
			"content":"Since linear time and space is required and all nums are non-negative, radix sort seems to be fit.\\nHere is the implementation.\\n\\nAny better ideas?\\n\\n    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def maximumGap(self, num):\\n            if len(num) < 2:\\n                return 0\\n            num = self.radixSort(num)\\n            res = 0\\n            for i in range(1, len(num)):\\n                res = max(num[i] - num[i - 1], res)\\n            return res\\n        \\n        def radixSort(self, num):\\n            for i in range(31):\\n                onebucket = []\\n                zerobucket = []\\n                needle = 1 << i\\n                for j in range(len(num)):\\n                    if num[j] & needle != 0:\\n                        onebucket.append(num[j])\\n                    else:\\n                        zerobucket.append(num[j])\\n                num = []\\n                num += zerobucket\\n                num += onebucket\\n            return num"
		},
		{
			"lc_ans_id":"50694",
			"view":"3924",
			"top":"6",
			"title":"12ms C++ Suggested Solution",
			"vote":"17",
			"content":"This problem has a naive solution using `sort` and linear scan. The suggested solution uses the idea of **bucket sort**. The following is a C++ implementation of the suggested solution. \\n\\nSuppose all the `n` elements in `nums` fall within `[l, u]`, the maximum gap will not be smaller than `gap = (u - l) / (n - 1)`. However, this `gap` may become `0` and so we take the maximum of it with `1` to guarantee that the gap used to create the buckets is meaningful.\\n\\nThen there will be at most `m = (u - l) / gap + 1` buckets. For each number `num`, it will fall in the `k = (num - l) / gap` bucket. After putting all elements of `nums` in the corresponding buckets, we can just scan the buckets to compute the maximum gap. \\n\\nThe maximum gap is only dependent on the maximum number of the current bucket and the minimum number of the next neighboring bucket (the bucket should not be empty). So we only store the minimum and the maximum of each bucket. Each bucket is initialized as `{minimum = INT_MAX, maximum = INT_MIN}` and then updated while updating the buckets. \\n\\nPutting these together, we can have the following solution, barely a straight-forward implementation of the suggested solution.\\n\\n    class Solution {\\n    public:\\n        int maximumGap(vector<int>& nums) {\\n            int n = nums.size();\\n            if (n < 2) return 0;\\n            auto lu = minmax_element(nums.begin(), nums.end());\\n            int l = *lu.first, u = *lu.second;\\n            int gap = max((u - l) / (n - 1), 1);\\n            int m = (u - l) / gap + 1;\\n            vector<int> bucketsMin(m, INT_MAX);\\n            vector<int> bucketsMax(m, INT_MIN);\\n            for (int num : nums) {\\n                int k = (num - l) / gap;\\n                if (num < bucketsMin[k]) bucketsMin[k] = num;\\n                if (num > bucketsMax[k]) bucketsMax[k] = num;\\n            }\\n            int i = 0, j; \\n            gap = bucketsMax[0] - bucketsMin[0];\\n            while (i < m) {\\n                j = i + 1;\\n                while (j < m && bucketsMin[j] == INT_MAX && bucketsMax[j] == INT_MIN)\\n                    j++;\\n                if (j == m) break;\\n                gap = max(gap, bucketsMin[j] - bucketsMax[i]);\\n                i = j;\\n            }\\n            return gap;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"50690",
			"view":"1649",
			"top":"7",
			"title":"Clean C++ implementation of 3 linear-time-sort-alg with detailed explaination",
			"vote":"12",
			"content":"As we can see, we should grasp all the 3 typical linear-time-sorting algorithm implementation. \\nAll the following 3 implementations have been modified from the GeeksForGeeks.\\nI have change the counting sort implementation to support negative numbers.\\nAnd the bucket support any float array input.\\n\\n> counting sort    [ stable ]       [ support:+/- intergers ]\\n> \\n> radix sort        [ use counting sort as sub-routine]   [ support only\\n> positive intergers]\\n> \\n> bucket sort     [support float : we need to change the array to in the\\n> range [0, 1)  ]\\n\\n\\n    #include <iostream>\\n    #include <vector>\\n    #include <algorithm>\\n    using namespace std;\\n    \\n\\n>     /* counting sort  Time O(N)  Space O(N+range) */\\n>     /* \\n>        support : positive / negative arrays\\n>        the last travese the array X : \\n>              FORWARD->not stable  \\n>     \\t\\t BACKWARD->stable\\n>     */\\n\\n    void countingSort(vector<int>& X){\\n    \\tint len = X.size();\\n    \\tint start = INT_MAX, end = INT_MIN;\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tstart = min(start, X[i]);\\n    \\t\\tend = max(end, X[i]);\\n    \\t}\\n    \\tint range = end - start + 1;\\n    \\tvector<int> count(range, 0);\\n    \\tvector<int> result(len, 0);\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tcount[X[i]-start]++;\\n    \\t}\\n    \\tfor (int i = 1; i < range; i++){\\n    \\t\\tcount[i]=count[i-1]+count[i];\\n    \\t}\\n    \\t//for-ward traverse is not stable sorting\\n    \\t//for (int i = 0; i < len; i++)\\n    \\t//back-ward traverse is stable sorting\\n    \\tfor (int i = len-1; i >= 0; i--){\\n    \\t\\t//as we know that the count array recorded element should '-1' to get the index\\n    \\t\\tresult[count[X[i] - start]-1] = X[i];\\n    \\t\\tcount[X[i] - start]--;\\n    \\t}\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tX[i] = result[i];\\n    \\t}\\n    }\\n    \\n    \\n    \\n\\n>     /* Radix sort  Time O(log(base,MAX)*(N+base))  Space O(constant)  default:base=10 */\\n>     /* \\n>        support : only positive interger \\n>        can only deal with positive integers or change the float number \\n>        of the specified precision to intergers by multiplying 10^n \\n>     */\\n\\n    \\n    void countingSort(vector<int>& X, int exp, int base){\\n    \\tint len = X.size();\\n    \\tint start = INT_MAX, end = INT_MIN;\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tstart = min(start, (X[i] / exp)%base);\\n    \\t\\tend = max(end, (X[i] / exp) % base);\\n    \\t}\\n    \\tint range = end - start + 1;\\n    \\tvector<int> count(range, 0);\\n    \\tvector<int> result(len, 0);\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tcount[(X[i] / exp) % base -start]++;\\n    \\t}\\n    \\tfor (int i = 1; i < range; i++){\\n    \\t\\tcount[i] = count[i - 1] + count[i];\\n    \\t}\\n    \\t//back-ward traverse is stable sorting\\n    \\tfor (int i = len - 1; i >= 0; i--){\\n    \\t\\t//as we know that the count array recorded element should '-1' to get the index\\n    \\t\\tresult[count[(X[i] / exp) % base -start] - 1] = X[i];\\n    \\t\\tcount[(X[i] / exp) % base - start]--;\\n    \\t}\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tX[i] = result[i];\\n    \\t}\\n    }\\n    \\n    void radixSort(vector<int> &X){\\n    \\tint len = X.size();\\n    \\tint max_val = INT_MIN;\\n    \\tint base = 10;\\n    \\tfor (int i = 0; i < len; i++) max_val = max(X[i], max_val);\\n    \\tfor (int exp = 1; max_val / exp>0; exp *= base){\\n    \\t\\tcountingSort(X, exp, base);\\n    \\t}\\n    }\\n    \\n    \\n\\n>     /* bubble sort  Time   Space */\\n>     /*\\n>       support : any float & int numbers\\n>       sort a large set of floating nubmers in range from 0.0 to 1.0\\n>       uniformly distributed across the range \\n>       the key idea is : \\n>             the insertion sort for all individual bucket is O(N)\\n>     */\\n\\n    void bucketSort(vector<float>& X){\\n    \\tint len = X.size();\\n    \\tfloat max_val = X[0], min_val = X[0];;\\n    \\tfor (int i = 1; i < len; i++) {\\n    \\t\\tmax_val = max(max_val, X[i]);\\n    \\t\\tmin_val = min(min_val, X[i]);\\n    \\t}\\n    \\tmax_val++;\\n    \\n    \\tvector<vector<float>> bucket(len, vector<float>());\\n    \\tfor (int i = 0; i < len; i++){\\n    \\t\\tint index = len*(X[i]-min_val)/(max_val-min_val);\\n    \\t\\tbucket[index].push_back(X[i]);\\n    \\t}\\n    \\n    \\tfor (int i = 0; i < len; i++)\\tsort(bucket[i].begin(), bucket[i].end());\\n    \\n    \\tint index = 0;\\n    \\tfor (int i = 0; i < len; i++)\\n    \\t\\tfor (int j = 0; j < bucket[i].size(); j++)\\n    \\t\\t\\tX[index++] = bucket[i][j];\\n    }\\n    \\n\\n>  /*   test all the 3-linear-sorting-implementation  */\\n\\n    int main(){\\n    \\tvector<int> test1 = { 11, -200, 14, -2000, 30, 400, 10, 22, 456 };\\n    \\tcountingSort(test1);\\n    \\tcout << endl<<\"counting Sort result: \";\\n    \\tfor (int i = 0; i < test1.size(); i++)\\t cout << test1[i] <<\" - \";\\n    \\tvector<int> test2 = { 11, 200, 14, 2000, 30, 400, 10, 22, 456 };\\n    \\tradixSort(test2);\\n    \\tcout << endl << \"radix Sort result: \";\\n    \\tfor (int i = 0; i < test2.size(); i++)\\t cout << test2[i] << \" - \";\\n    \\tvector<float> test3 = { 11, -200, 14, -2000, 30, 400, 10, 22, 456 };\\n    \\tbucketSort(test3);\\t\\n    \\tcout << endl << \"bucket Sort result: \";\\n    \\tfor (int i = 0; i < test3.size(); i++)\\t cout << test3[i] << \" - \";\\n    \\treturn 0;\\n    }"
		},
		{
			"lc_ans_id":"50724",
			"view":"2785",
			"top":"8",
			"title":"My concise and short c++ code with comment explanation",
			"vote":"11",
			"content":"    int maximumGap(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 2 ) return 0;\\n        int maxE = *max_element(nums.begin(),nums.end());\\n        int minE = *min_element(nums.begin(),nums.end());\\n        \\n        int len = maxE - minE;\\n        if( len <= 1 ) return len;\\n        vector<int> buck_max(n, INT_MIN);\\n        vector<int> buck_min(n, INT_MAX);\\n        \\n        for(int i = 0; i < n; i++) {\\n            // note the divide and multiply order and the double cast\\n            // it's used to avoid the overflow and underflow during calculation\\n            int index = (double)( nums[i] - minE )  / len * ( n - 1 );\\n            buck_max[index] = max(buck_max[index], nums[i]);\\n            buck_min[index] = min(buck_min[index], nums[i]);\\n        }\\n        \\n        int gap = 0, pre = buck_max[0];\\n        for(int i = 1; i < n; i++) {\\n            if( buck_max[i] == INT_MIN ) continue;\\n            gap = max(gap, buck_min[i] - pre);\\n            pre = buck_max[i];\\n        }\\n        return gap;\\n    }"
		},
		{
			"lc_ans_id":"50723",
			"view":"1051",
			"top":"9",
			"title":"Bad question description. I think it should say \"difference between 2 adjacent elements\".",
			"vote":"8",
			"content":"The description \"maximum difference between the successive elements\" confuses me, because the successive elements could mean more than 2 elements that are successive."
		}
	],
	"id":"164",
	"title":"Maximum Gap",
	"content":"<p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>\r\n\r\n<p>Try to solve it in linear time/space.</p>\r\n\r\n<p>Return 0 if the array contains less than 2 elements.</p>\r\n\r\n<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://oj.leetcode.com/discuss/user/porker2008\">@porker2008</a> for adding this problem and creating all test cases.</p>",
	"frequency":"487",
	"ac_num":"53501"
}