{
	"difficulty":"2",
	"submit_num":"336530",
	"show_id":"166",
	"leetcode_id":"166",
	"answers":[
		{
			"lc_ans_id":"51106",
			"view":"25111",
			"top":"0",
			"title":"My clean Java solution",
			"vote":"176",
			"content":"The important thing is to consider all edge cases while thinking this problem through, including: negative integer, possible overflow, etc.\\n\\nUse HashMap to store a remainder and its associated index while doing the division so that whenever a same remainder comes up, we know there is a repeating fractional part.\\n\\nPlease comment if you see something wrong or can be improved. Cheers!\\n\\n    public class Solution {\\n        public String fractionToDecimal(int numerator, int denominator) {\\n            if (numerator == 0) {\\n                return \"0\";\\n            }\\n            StringBuilder res = new StringBuilder();\\n            // \"+\" or \"-\"\\n            res.append(((numerator > 0) ^ (denominator > 0)) ? \"-\" : \"\");\\n            long num = Math.abs((long)numerator);\\n            long den = Math.abs((long)denominator);\\n            \\n            // integral part\\n            res.append(num / den);\\n            num %= den;\\n            if (num == 0) {\\n                return res.toString();\\n            }\\n            \\n            // fractional part\\n            res.append(\".\");\\n            HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n            map.put(num, res.length());\\n            while (num != 0) {\\n                num *= 10;\\n                res.append(num / den);\\n                num %= den;\\n                if (map.containsKey(num)) {\\n                    int index = map.get(num);\\n                    res.insert(index, \"(\");\\n                    res.append(\")\");\\n                    break;\\n                }\\n                else {\\n                    map.put(num, res.length());\\n                }\\n            }\\n            return res.toString();\\n        }\\n    }"
		},
		{
			"lc_ans_id":"51109",
			"view":"17371",
			"top":"1",
			"title":"Accepted cpp solution, with explainations",
			"vote":"139",
			"content":"    // upgraded parameter types\\n    string fractionToDecimal(int64_t n, int64_t d) {\\n        // zero numerator\\n        if (n == 0) return \"0\";\\n    \\n        string res;\\n        // determine the sign\\n        if (n < 0 ^ d < 0) res += '-';\\n    \\n        // remove sign of operands\\n        n = abs(n), d = abs(d);\\n    \\n        // append integral part\\n        res += to_string(n / d);\\n    \\n        // in case no fractional part\\n        if (n % d == 0) return res;\\n    \\n        res += '.';\\n    \\n        unordered_map<int, int> map;\\n    \\n        // simulate the division process\\n        for (int64_t r = n % d; r; r %= d) {\\n    \\n            // meet a known remainder\\n            // so we reach the end of the repeating part\\n            if (map.count(r) > 0) {\\n                res.insert(map[r], 1, '(');\\n                res += ')';\\n                break;\\n            }\\n    \\n            // the remainder is first seen\\n            // remember the current position for it\\n            map[r] = res.size();\\n    \\n            r *= 10;\\n    \\n            // append the quotient digit\\n            res += to_string(r / d);\\n        }\\n    \\n        return res;\\n    }"
		},
		{
			"lc_ans_id":"51140",
			"view":"7935",
			"top":"2",
			"title":"Short Java solution",
			"vote":"56",
			"content":"    public String fractionToDecimal(int numerator, int denominator) {\\n        StringBuilder result = new StringBuilder();\\n        String sign = (numerator < 0 == denominator < 0 || numerator == 0) ? \"\" : \"-\";\\n        long num = Math.abs((long) numerator);\\n        long den = Math.abs((long) denominator);\\n        result.append(sign);\\n        result.append(num / den);\\n        long remainder = num % den;\\n        if (remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        HashMap<Long, Integer> hashMap = new HashMap<Long, Integer>();\\n        while (!hashMap.containsKey(remainder)) {\\n            hashMap.put(remainder, result.length());\\n            result.append(10 * remainder / den);\\n            remainder = 10 * remainder % den;\\n        }\\n        int index = hashMap.get(remainder);\\n        result.insert(index, \"(\");\\n        result.append(\")\");\\n        return result.toString().replace(\"(0)\", \"\");\\n    }"
		},
		{
			"lc_ans_id":"51160",
			"view":"7942",
			"top":"3",
			"title":"0ms C++ Solution with Detailed Explanations",
			"vote":"51",
			"content":"Well, the key to this problem is on how to identify the recurring parts. After doing some examples using pen and paper, you may find that for the decimal parts to recur, **the remainders should recur**. So we need to maintain the remainders we have seen. Once we see a repeated remainder, we know that we have reached the end of the recurring parts and should enclose it with a `)`. However, we still need to insert the `(` to the correct position. So we maintain a mapping from each remainder to the position of the corresponding quotient digit of it in the recurring parts. Then we use this mapping to retrieve the starting position of the recurring parts.\\n\\nNow we have solved the trickiest part of this problem.\\n\\nThere are some remaining problems to solve to achieve a bug-free solution.\\n\\n 1. Pay attention to the sign of the result;\\n 2. Handle cases that may cause overflow like `numerator = -2147483648, denominator = -1` appropriately by using `long long`; \\n 3. Handle all the cases of (1) no fractional part; (2) fractional part does not recur; and (3) fractional part recurs respectively.\\n\\nTo handle problem 3, we divide the division process into the integral part and the fractional part. For the fractional part, if it does not recur, then the remainder will become `0` at some point and we could return. If it does recur, the method metioned in the first paragraph has already handled it.\\n\\nTaking all these into considerations, we have the following code, which takes 0 ms :-)\\n\\n    class Solution {\\n    public:\\n        string fractionToDecimal(int numerator, int denominator) {\\n            if (!numerator) return \"0\";\\n            string res;\\n            if (numerator < 0 ^ denominator < 0) res += '-';\\n            long numer = numerator < 0 ? (long)numerator * (-1) : (long)numerator;\\n            long denom = denominator < 0 ? (long)denominator * (-1) : (long)denominator;\\n            long integral = numer / denom;\\n            res += to_string(integral);\\n            long rmd = numer % denom;\\n            if (!rmd) return res;\\n            res += '.';\\n            rmd *= 10;\\n            unordered_map<long, long> mp; \\n            while (rmd) {\\n                long quotient = rmd / denom;\\n                if (mp.find(rmd) != mp.end()) { \\n                    res.insert(mp[rmd], 1, '(');\\n                    res += ')';\\n                    break;\\n                }\\n                mp[rmd] = res.size();\\n                res += to_string(quotient);\\n                rmd = (rmd % denom) * 10;\\n            }\\n            return res;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"51107",
			"view":"3969",
			"top":"4",
			"title":"Accepted Clean Java Solution",
			"vote":"34",
			"content":"I don't understand why so many people tends to write \"short\" java solutions over \"clear\" java solution when performance stays the same.\\nIn order to be a good teammate, one should always write clean code instead of hacky code if performance stays the same.\\n\\n        \\n      public String fractionToDecimal(int numerator, int denominator) {\\n            boolean isNegative = (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) ? true : false;\\n            long numeratorL = Math.abs((long) numerator);\\n            long denominatorL = Math.abs((long) denominator);\\n            Map<Long, Integer> previousRemains = new HashMap<Long, Integer>();\\n            StringBuilder sb = new StringBuilder();\\n            long quotian = numeratorL / denominatorL;\\n            sb.append(quotian);\\n            \\n            numeratorL %= denominatorL;\\n        \\n            if (numeratorL != 0) {\\n                sb.append(\".\");\\n            }\\n            \\n            int quotianIndex = 0;\\n            while (numeratorL != 0) {\\n                numeratorL *= 10;\\n                quotian = Math.abs(numeratorL / denominatorL);\\n                if (!previousRemains.containsKey(numeratorL)) {\\n                    sb.append(quotian);\\n                    previousRemains.put(numeratorL, quotianIndex++);\\n                } else {\\n                    int firstIndex = 1 + previousRemains.get(numeratorL) + sb.indexOf(\".\");\\n                    sb.insert(firstIndex, '(');\\n                    sb.append(\")\");\\n                    break;\\n                }\\n                numeratorL %= denominatorL;\\n            }\\n            \\n            if (isNegative) {\\n                sb.insert(0, \"-\");\\n            }\\n            return sb.toString();\\n        }"
		},
		{
			"lc_ans_id":"51110",
			"view":"3233",
			"top":"5",
			"title":"Do not use python as cpp, here's a short version python code",
			"vote":"22",
			"content":"Though python is slow, It is easy to write\\n\\n    class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = '-' if numerator*denominator < 0 else ''\\n        result = [sign+str(n), '.']\\n        stack = []\\n        while remainder not in stack:\\n            stack.append(remainder)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            result.append(str(n))\\n\\n        idx = stack.index(remainder)\\n        result.insert(idx+2, '(')\\n        result.append(')')\\n        return ''.join(result).replace('(0)', '').rstrip('.')\\n\\nand there's no overflow"
		},
		{
			"lc_ans_id":"51128",
			"view":"1347",
			"top":"6",
			"title":"Simple and Short Solution in JAVA",
			"vote":"12",
			"content":"    public String fractionToDecimal(int numerator, int denominator) {\\n        if (denominator == 0) return \"\";\\n        StringBuilder str = new StringBuilder();\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        if (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) {\\n            str.append('-');\\n        }\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long n = num/den;\\n        long reminder = num % den;\\n        str.append(n);\\n        if (reminder == 0) return str.toString();\\n        else str.append('.');\\n        while(!map.containsKey(reminder)) {\\n            map.put(reminder,str.length());\\n            n = reminder*10/den;\\n            reminder = reminder*10%den;\\n            if (reminder != 0 || reminder == 0 && !map.containsKey(reminder)) {\\n                str.append(n);\\n            }\\n        }\\n        if (reminder != 0) {\\n            str.insert(map.get(reminder),\"(\");\\n            str.append(')');            \\n        }\\n        return str.toString();\\n    }"
		},
		{
			"lc_ans_id":"51114",
			"view":"2000",
			"top":"7",
			"title":"Python solution",
			"vote":"11",
			"content":"    class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        res=\"\"\\n        if numerator/denominator<0:\\n            res+=\"-\"\\n        if numerator%denominator==0:\\n            return str(numerator/denominator)\\n        numerator=abs(numerator)\\n        denominator=abs(denominator)\\n        res+=str(numerator/denominator)\\n        res+=\".\"\\n        numerator%=denominator\\n        i=len(res)\\n        table={}\\n        while numerator!=0:\\n            if numerator not in table.keys():\\n                table[numerator]=i\\n            else:\\n                i=table[numerator]\\n                res=res[:i]+\"(\"+res[i:]+\")\"\\n                return res\\n            numerator=numerator*10\\n            res+=str(numerator/denominator)\\n            numerator%=denominator\\n            i+=1\\n        return res\\n\\nIdea is to put every remainder into the hash table as a key, and the current length of the result string as the value. When the same remainder shows again, it's circulating from the index of the value in the table."
		},
		{
			"lc_ans_id":"51131",
			"view":"1288",
			"top":"8",
			"title":"An intuitive solution in C beating 100% submissions, well-explained",
			"vote":"8",
			"content":"Beating 100% submission, why? no one ever submitted the C version so far. Here is my solution:\\n\\n - determine the sign of the result;\\n - retrieve the integer part of the result - numerator/denominator;\\n - get all the decimals by the remainder -> numerator%denominator just as we do division in mathematics; but along with it we should record the remainder value and the corresponding string index collecting string (once we find the same remainder, we will know that we will run in a circle since the denominator is always the same, so then we have to <font color=\"#ff0000\">bracket the inner digits up</font>) and return;\\n\\n> B.T.W. there is a customised hash-map structure to store the remainder and the string index\\n\\nBang! End of story.\\n\\n----------\\n    \\n    #define LEN 10000\\n    struct MyListNode\\n    {\\n        long long key;\\n        int val;\\n        struct MyListNode *next;\\n    };\\n    \\n    void push(struct MyListNode* head, long long key, int val)\\n    {\\n        struct MyListNode *p = head;\\n        while(p->next)\\n            p = p->next;\\n        struct MyListNode *t = (struct MyListNode*)malloc(sizeof(struct MyListNode));\\n        t->key = key;\\n        t->val = val;\\n        p->next = t;\\n    }\\n    \\n    int pop(struct MyListNode* head, long long key)\\n    {\\n        struct MyListNode *p = head->next;\\n        while(p)\\n        {\\n            if(p->key == key)\\n                return p->val;\\n            p = p->next;\\n        }\\n        return 0;\\n    }\\n    \\n    char* fractionToDecimal(int n, int d)\\n    {\\n        if(n == 0) return \"0\";\\n        char *s = (char*)malloc(sizeof(char)*LEN);\\n        int index = 0;\\n        if((n<0 && d>0) || (n>0 && d<0)) s[index++] = '-'; //get the sign part;\\n        long long numerator = (n==INT_MIN)? -1*(long long)n : abs(n); //get the positive format of numerator;\\n        long long denominator = (d==INT_MIN)? -1*(long long)d : abs(d); //get the positive format of denominator;\\n        long long integer = numerator/denominator; //collecting the integer part;\\n        if(integer == 0)\\n            s[index++] = '0';\\n        else\\n        {\\n            char *t = (char*)malloc(sizeof(char)*LEN); //used to store the integer part in reverse order;\\n            int index0 = 0;\\n            while(integer)\\n            {\\n                t[index0++] = integer%10+'0';\\n                integer /= 10;\\n            }\\n            for(int i = index0-1; i > -1; i--) //reverse it again, then s will store the integer part in normal sequence;\\n                s[index++] = t[i];\\n        }\\n        long long remainder = numerator%denominator; //get the remainder by mod operator;\\n        if(remainder == 0) \\n        {\\n            s[index] = '\\\\0';\\n            return s;\\n        }\\n        s[index++] = '.'; //there are decimals;\\n        struct MyListNode *head = (struct MyListNode*)malloc(sizeof(struct MyListNode)); //used to store the remainder digit index in string for recurring;\\n        while(remainder)\\n        {\\n            int pre = pop(head, remainder);\\n            if(pre) //check if this digit has already occurred, if so, add brackets;\\n            {\\n                for(int i = index; i > pre; i--)\\n                    s[i] = s[i-1];\\n                index++;\\n                s[pre] = '(';\\n                s[index++] = ')';\\n                break;\\n            }\\n            push(head, remainder, index);\\n            remainder *= 10; //imitating division process here, retrieving the high decimal digit;\\n            s[index++] = remainder/denominator+'0';\\n            remainder %= denominator;\\n        }\\n        s[index] = '\\\\0';\\n        return s;\\n    }"
		},
		{
			"lc_ans_id":"51205",
			"view":"1457",
			"top":"9",
			"title":"A clean C++ solution with 3ms",
			"vote":"7",
			"content":"    class Solution\\n    {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator)\\n    \\t{\\n    \\t\\tif(0 == numerator) return \"0\";// If the numerator is 0, the final result must be 0.\\n    \\n    \\t\\tlong long num = numerator;// One of the test case is denominator = 0x80000000, thus we must save its opposite\\n    \\t\\tlong long den = denominator; // number in a long long variable.\\n    \\n    \\t\\tbool b1 = num < 0;\\n    \\t\\tbool b2 = den < 0;\\n    \\n    \\t\\tif(b1) num = - num;\\t// We convert both numerator and denominator into positive numbers.\\n    \\t\\tif(b2) den = -den;\\n    \\n    \\t\\tstring res = \"\";\\n    \\t\\tif(b1^b2) res += \"-\"; // Add a \"-\" if the numerator is positive and the denominator is negative or vice versa.\\n    \\n    \\t\\tlong long quo = num/den;\\n    \\t\\tlong long rem = num%den;\\n    \\n    \\t\\t//Calculate the integral part of the final result.\\n    \\t\\tif(quo > 0)\\n    \\t\\t{\\n    \\t\\t\\tostringstream oss;\\n    \\t\\t\\toss << quo;\\n    \\t\\t\\tres += oss.str();\\n    \\t\\t}\\n    \\t\\telse \\n    \\t\\t{\\n    \\t\\t\\tres += \"0\";\\n    \\t\\t}\\n    \\n    \\t\\tif(0 == rem) return res; // That the remainder is 0 means there isn't a fractional part of the result, \\n    \\t\\t//so we return the integral part.\\n    \\n    \\t\\t/*\\n    \\t\\tIn the following, we record the numerator to be divided by the denominator and the length of the temporary result.\\n    \\t\\tIf a numerator has been met before, circulation happens, so we stop the computation and insert a parathesis, and return \\n    \\t\\tthe result.\\n    \\t\\t*/\\n    \\t\\tnum = rem;\\n    \\n    \\t\\tunordered_map<long long, int> m;\\n    \\t\\tm[num] = res.size();\\n    \\n    \\t\\tnum *= 10;\\n    \\t\\tres.append(\".\");\\n    \\t\\tm[num] = res.size();\\n    \\n    \\t\\twhile(num > 0)\\n    \\t\\t{\\n    \\t\\t\\tif(num < den)\\n    \\t\\t\\t{// If the numerator is less than the denominator, we multiply the numerator with 10, and append a 'o'\\n    \\t\\t\\t\\t// to the result. And we record the numerator and the temporary size of the result.\\n    \\t\\t\\t\\tnum *= 10;\\n    \\t\\t\\t\\tres.append(\"0\");\\n    \\t\\t\\t\\tm[num] = res.size();\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\tif(num > den)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tchar ch = '0' + num/den; // Compute the quotient and push the quotient to the result.\\n    \\t\\t\\t\\tres.push_back(ch);\\n    \\t\\t\\t\\tnum %= den; // Compute the remainder; \\n    \\t\\t\\t\\tnum *= 10; // multiply the remainder with 10, and it will be the new numerator.\\n    \\t\\t\\t\\tif(m.end() == m.find(num)) // This numerator occurs for the first time, so we record it.\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tm[num] = res.size();\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse // Circulation happens, so we return the result.\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tstring temp = res.substr(0, m[num]) + \"(\" + res.substr(m[num], string::npos) + \")\";\\n    \\t\\t\\t\\t\\tres = temp;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    };"
		}
	],
	"id":"166",
	"title":"Fraction to Recurring Decimal",
	"content":"<p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>\r\n\r\n<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>\r\n<p>\r\nFor example,\r\n<ul>\r\n<li>Given numerator = 1, denominator = 2, return \"0.5\".</li>\r\n<li>Given numerator = 2, denominator = 1, return \"2\".</li>\r\n<li>Given numerator = 2, denominator = 3, return \"0.(6)\".</li>\r\n</ul>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://oj.leetcode.com/discuss/user/Shangrila\">@Shangrila</a> for adding this problem and creating all test cases.</p>",
	"frequency":"392",
	"ac_num":"60421"
}