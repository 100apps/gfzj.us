{
	"difficulty":"2",
	"submit_num":"527156",
	"show_id":"18",
	"leetcode_id":"18",
	"answers":[
		{
			"lc_ans_id":"8547",
			"view":"47413",
			"top":"0",
			"title":"7ms java code win over 100%",
			"vote":"133",
			"content":"The first time win over 100%. Basic idea is using subfunctions for 3sum and 2sum, and keeping throwing all impossible cases. O(n^3) time complexity, O(1) extra space complexity.\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\t\\t\\tArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tif (nums == null || len < 4)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\tint max = nums[len - 1];\\n\\t\\t\\tif (4 * nums[0] > target || 4 * max < target)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tint i, z;\\n\\t\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\t\\tz = nums[i];\\n\\t\\t\\t\\tif (i > 0 && z == nums[i - 1])// avoid duplicate\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (z + 3 * max < target) // z is too small\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (4 * z > target) // z is too large\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (4 * z == target) { // z is the boundary\\n\\t\\t\\t\\t\\tif (i + 3 < len && nums[i + 3] == z)\\n\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(z, z, z, z));\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthreeSumForFourSum(nums, target - z, i + 1, len - 1, res, z);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Find all possible distinguished three numbers adding up to the target\\n\\t\\t * in sorted array nums[] between indices low and high. If there are,\\n\\t\\t * add all of them into the ArrayList fourSumList, using\\n\\t\\t * fourSumList.add(Arrays.asList(z1, the three numbers))\\n\\t\\t */\\n\\t\\tpublic void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,\\n\\t\\t\\t\\tint z1) {\\n\\t\\t\\tif (low + 1 >= high)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint max = nums[high];\\n\\t\\t\\tif (3 * nums[low] > target || 3 * max < target)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint i, z;\\n\\t\\t\\tfor (i = low; i < high - 1; i++) {\\n\\t\\t\\t\\tz = nums[i];\\n\\t\\t\\t\\tif (i > low && z == nums[i - 1]) // avoid duplicate\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (z + 2 * max < target) // z is too small\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (3 * z > target) // z is too large\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tif (3 * z == target) { // z is the boundary\\n\\t\\t\\t\\t\\tif (i + 1 < high && nums[i + 2] == z)\\n\\t\\t\\t\\t\\t\\tfourSumList.add(Arrays.asList(z1, z, z, z));\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttwoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Find all possible distinguished two numbers adding up to the target\\n\\t\\t * in sorted array nums[] between indices low and high. If there are,\\n\\t\\t * add all of them into the ArrayList fourSumList, using\\n\\t\\t * fourSumList.add(Arrays.asList(z1, z2, the two numbers))\\n\\t\\t */\\n\\t\\tpublic void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,\\n\\t\\t\\t\\tint z1, int z2) {\\n\\n\\t\\t\\tif (low >= high)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif (2 * nums[low] > target || 2 * nums[high] < target)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint i = low, j = high, sum, x;\\n\\t\\t\\twhile (i < j) {\\n\\t\\t\\t\\tsum = nums[i] + nums[j];\\n\\t\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\t\\tfourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j]));\\n\\n\\t\\t\\t\\t\\tx = nums[i];\\n\\t\\t\\t\\t\\twhile (++i < j && x == nums[i]) // avoid duplicate\\n\\t\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\t\\tx = nums[j];\\n\\t\\t\\t\\t\\twhile (i < --j && x == nums[j]) // avoid duplicate\\n\\t\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (sum > target)\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}"
		},
		{
			"lc_ans_id":"8549",
			"view":"24159",
			"top":"1",
			"title":"My 16ms c++ code",
			"vote":"96",
			"content":"    class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>> total;\\n            int n = nums.size();\\n            if(n<4)  return total;\\n            sort(nums.begin(),nums.end());\\n            for(int i=0;i<n-3;i++)\\n            {\\n                if(i>0&&nums[i]==nums[i-1]) continue;\\n                if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\\n                if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;\\n                for(int j=i+1;j<n-2;j++)\\n                {\\n                    if(j>i+1&&nums[j]==nums[j-1]) continue;\\n                    if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;\\n                    if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\\n                    int left=j+1,right=n-1;\\n                    while(left<right){\\n                        int sum=nums[left]+nums[right]+nums[i]+nums[j];\\n                        if(sum<target) left++;\\n                        else if(sum>target) right--;\\n                        else{\\n                            total.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});\\n                            do{left++;}while(nums[left]==nums[left-1]&&left<right);\\n                            do{right--;}while(nums[right]==nums[right+1]&&left<right);\\n                        }\\n                    }\\n                }\\n            }\\n            return total;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"8575",
			"view":"21297",
			"top":"2",
			"title":"Clean accepted java O(n^3) solution based on 3sum",
			"vote":"88",
			"content":"    public class Solution {\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n        ArrayList<List<Integer>> ans = new ArrayList<>();\\n        if(num.length<4)return ans;\\n        Arrays.sort(num);\\n        for(int i=0; i<num.length-3; i++){\\n            if(num[i]+num[i+1]+num[i+2]+num[i+3]>target)break; //first candidate too large, search finished\\n            if(num[i]+num[num.length-1]+num[num.length-2]+num[num.length-3]<target)continue; //first candidate too small\\n            if(i>0&&num[i]==num[i-1])continue; //prevents duplicate result in ans list\\n            for(int j=i+1; j<num.length-2; j++){\\n                if(num[i]+num[j]+num[j+1]+num[j+2]>target)break; //second candidate too large\\n                if(num[i]+num[j]+num[num.length-1]+num[num.length-2]<target)continue; //second candidate too small\\n                if(j>i+1&&num[j]==num[j-1])continue; //prevents duplicate results in ans list\\n                int low=j+1, high=num.length-1;\\n                while(low<high){\\n                    int sum=num[i]+num[j]+num[low]+num[high];\\n                    if(sum==target){\\n                        ans.add(Arrays.asList(num[i], num[j], num[low], num[high]));\\n                        while(low<high&&num[low]==num[low+1])low++; //skipping over duplicate on low\\n                        while(low<high&&num[high]==num[high-1])high--; //skipping over duplicate on high\\n                        low++; \\n                        high--;\\n                    }\\n                    //move window\\n                    else if(sum<target)low++; \\n                    else high--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\nupdated with optimizations and comments"
		},
		{
			"lc_ans_id":"8545",
			"view":"13994",
			"top":"3",
			"title":"Python 140ms beats 100%, and works for N-sum (N>=2)",
			"vote":"72",
			"content":"The core is to implement a fast 2-pointer to solve 2-sum, and recursion to reduce the N-sum to 2-sum. Some optimization was be made knowing the list is sorted.\\n\\n    def fourSum(self, nums, target):\\n        nums.sort()\\n        results = []\\n        self.findNsum(nums, target, 4, [], results)\\n        return results\\n    \\n    def findNsum(self, nums, target, N, result, results):\\n        if len(nums) < N or N < 2: return\\n    \\n        # solve 2-sum\\n        if N == 2:\\n            l,r = 0,len(nums)-1\\n            while l < r:\\n                if nums[l] + nums[r] == target:\\n                    results.append(result + [nums[l], nums[r]])\\n                    l += 1\\n                    r -= 1\\n                    while l < r and nums[l] == nums[l - 1]:\\n                        l += 1\\n                    while r > l and nums[r] == nums[r + 1]:\\n                        r -= 1\\n                elif nums[l] + nums[r] < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        else:\\n            for i in range(0, len(nums)-N+1):   # careful about range\\n                if target < nums[i]*N or target > nums[-1]*N:  # take advantages of sorted list\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]:  # recursively reduce N\\n                    self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\\n        return\\n\\n\\nJust revisited and clean the code\\n\\n\\n    def fourSum(self, nums, target):\\n        def findNsum(nums, target, N, result, results):\\n            if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:  # early termination\\n                return\\n            if N == 2: # two pointers solve sorted 2-sum problem\\n                l,r = 0,len(nums)-1\\n                while l < r:\\n                    s = nums[l] + nums[r]\\n                    if s == target:\\n                        results.append(result + [nums[l], nums[r]])\\n                        l += 1\\n                        while l < r and nums[l] == nums[l-1]:\\n                            l += 1\\n                    elif s < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n            else: # recursively reduce N\\n                for i in range(len(nums)-N+1):\\n                    if i == 0 or (i > 0 and nums[i-1] != nums[i]):\\n                        findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\\n\\n        results = []\\n        findNsum(sorted(nums), target, 4, [], results)\\n        return results"
		},
		{
			"lc_ans_id":"8714",
			"view":"17574",
			"top":"4",
			"title":"4Sum C++ solution with explanation and comparison with 3Sum problem. Easy to understand.",
			"vote":"58",
			"content":"For the reference, please have a look at my explanation of `3Sum` problem because the algorithm are exactly the same. The link is as blow.\\n\\n[My 3Sum problem answer][1]\\n\\nThe key idea is to downgrade the problem to a `2Sum` problem eventually. And the same algorithm can be expand to `NSum` problem.\\n\\nAfter you had a look at my explanation of `3Sum`, the code below will be extremely easy to understand.\\n\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > fourSum(vector<int> &num, int target) {\\n        \\n            vector<vector<int> > res;\\n        \\n            if (num.empty())\\n                return res;\\n        \\n            std::sort(num.begin(),num.end());\\n        \\n            for (int i = 0; i < num.size(); i++) {\\n            \\n                int target_3 = target - num[i];\\n            \\n                for (int j = i + 1; j < num.size(); j++) {\\n                \\n                    int target_2 = target_3 - num[j];\\n                \\n                    int front = j + 1;\\n                    int back = num.size() - 1;\\n                \\n                    while(front < back) {\\n                    \\n                        int two_sum = num[front] + num[back];\\n                    \\n                        if (two_sum < target_2) front++;\\n                    \\n                        else if (two_sum > target_2) back--;\\n                    \\n                        else {\\n                        \\n                            vector<int> quadruplet(4, 0);\\n                            quadruplet[0] = num[i];\\n                            quadruplet[1] = num[j];\\n                            quadruplet[2] = num[front];\\n                            quadruplet[3] = num[back];\\n                            res.push_back(quadruplet);\\n                        \\n                            // Processing the duplicates of number 3\\n                            while (front < back && num[front] == quadruplet[2]) ++front;\\n                        \\n                            // Processing the duplicates of number 4\\n                            while (front < back && num[back] == quadruplet[3]) --back;\\n                    \\n                        }\\n                    }\\n                    \\n                    // Processing the duplicates of number 2\\n                    while(j + 1 < num.size() && num[j + 1] == num[j]) ++j;\\n                }\\n            \\n                // Processing the duplicates of number 1\\n                while (i + 1 < num.size() && num[i + 1] == num[i]) ++i;\\n            \\n            }\\n        \\n            return res;\\n        \\n        }\\n    };\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/23595/share-my-solution-around-50ms-with-explanation-and-comments"
		},
		{
			"lc_ans_id":"8565",
			"view":"8072",
			"top":"5",
			"title":"Lower bound n^3",
			"vote":"54",
			"content":"Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
		},
		{
			"lc_ans_id":"8609",
			"view":"3676",
			"top":"6",
			"title":"My solution generalized for kSums in JAVA",
			"vote":"38",
			"content":"#### General Idea\\nIf you have already read and implement the 3sum and 4sum by using the sorting approach: reduce them into 2sum at the end, you might already got the feeling that, all ksum problem can be divided into two problems: \\n1. 2sum Problem\\n2. Reduce K sum problem to K \\u2013 1 sum Problem\\n\\nTherefore, the ideas is simple and straightforward. We could use recursive to solve this problem. Time complexity is O(N^(K-1)).\\n\\n```JAVA\\n    public class Solution {\\n        int len = 0;\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            len = nums.length;\\n            Arrays.sort(nums);\\n            return kSum(nums, target, 4, 0);\\n        }\\n       private ArrayList<List<Integer>> kSum(int[] nums, int target, int k, int index) {\\n            ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n            if(index >= len) {\\n                return res;\\n            }\\n            if(k == 2) {\\n            \\tint i = index, j = len - 1;\\n            \\twhile(i < j) {\\n                    //find a pair\\n            \\t    if(target - nums[i] == nums[j]) {\\n            \\t    \\tList<Integer> temp = new ArrayList<>();\\n                    \\ttemp.add(nums[i]);\\n                    \\ttemp.add(target-nums[i]);\\n                        res.add(temp);\\n                        //skip duplication\\n                        while(i<j && nums[i]==nums[i+1]) i++;\\n                        while(i<j && nums[j-1]==nums[j]) j--;\\n                        i++;\\n                        j--;\\n                    //move left bound\\n            \\t    } else if (target - nums[i] > nums[j]) {\\n            \\t        i++;\\n                    //move right bound\\n            \\t    } else {\\n            \\t        j--;\\n            \\t    }\\n            \\t}\\n            } else{\\n                for (int i = index; i < len - k + 1; i++) {\\n                    //use current number to reduce ksum into k-1sum\\n                    ArrayList<List<Integer>> temp = kSum(nums, target - nums[i], k-1, i+1);\\n                    if(temp != null){\\n                        //add previous results\\n                        for (List<Integer> t : temp) {\\n                            t.add(0, nums[i]);\\n                        }\\n                        res.addAll(temp);\\n                    }\\n                    while (i < len-1 && nums[i] == nums[i+1]) {\\n                        //skip duplicated numbers\\n                        i++;\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```"
		},
		{
			"lc_ans_id":"8628",
			"view":"7713",
			"top":"7",
			"title":"My C++ solution using hashtable",
			"vote":"29",
			"content":"My idea is to sort num first, then build a hashtable with the key as the sum of the pair and the value as a  vector storing all pairs of index of num that having the same sum. In this way, all elements stored in hashtable has a order that duplicate pairs are neighbors. Therefore scanning the vector in the hashtable we only put non duplicate elements into the final answer vvi.\\n\\nIs this method O(n^2) ? or Does anyone can improve it to O(n^2);\\n\\n\\n\\n        class Solution{ //using hashtable, avg O(n^2)\\n    \\n    public:\\n    \\n        vector<vector<int> > fourSum(vector<int> &num, int target){\\n            vector<vector<int> > vvi;\\n            int n = num.size();\\n            if(n < 4) return  vvi;\\n            \\n            sort(num.begin(), num.end());        \\n            unordered_map<int, vector<pair<int, int>> > mp;\\n            for(int i = 0; i < n; i++){\\n                for(int j = i + 1; j < n; j++){\\n                    mp[num[i]+num[j]].push_back(make_pair(i,j));\\n                }\\n            }\\n            \\n            for(int i = 0; i < n; i++){\\n                if(i>0 && num[i] == num[i-1]) continue;\\n                for(int j = i + 1; j < n; j++){\\n                    if(j > i + 1 && num[j] == num[j-1]) continue;\\n                    int res = target - num[i] - num[j];\\n                    if(mp.count(res)){\\n                        for(auto it = mp[res].begin(); it != mp[res].end(); it++){\\n                            int k = (*it).first, l = (*it).second;\\n                            if(k > j){ // k>j make sure that the second pair has bigger values than the first pair.\\n                                if(!vvi.empty() && num[i]==vvi.back()[0] && num[j]==vvi.back()[1]\\n                                && num[k]==vvi.back()[2] && num[l] == vvi.back()[3]){\\n                                    continue; //if the obtained 4 elements are the same as previous one continue to next\\n                                }\\n                                vector<int> vi={num[i], num[j], num[k], num[l]};\\n                                vvi.push_back(vi);\\n                            } // if k>j\\n                            \\n                        }//for it\\n                    }//if\\n                }// forj\\n            }//for i\\n            return vvi;\\n        }\\n      };"
		},
		{
			"lc_ans_id":"8653",
			"view":"5234",
			"top":"8",
			"title":"On average O(n^2) and worst case O(n^3) java solution by reducing 4Sum to 2Sum",
			"vote":"27",
			"content":"Basic idea is to reduce the 4Sum problem to 2Sum one. In order to achieve that, we can use an array (size of n^2) to store the pair sums and this array will act as the array in 2Sum case (Here n is the size of the original 1D array and it turned out that we do not even need to explicitly use the n^2 sized array ). We also use a hashmap to mark if a pair sum has been visited or not (the same as in the 2Sum case). The tricky part here is that we may have multiple pairs that result in the same pair sum. So we will use a list to group these pairs together. For every pair with a particular sum, check if the pair sum that is needed to get the target has been visited. If so, further check if there is overlapping between these two pairs. If not, record the result.\\n\\nTime complexity to get all the pairs is O(n^2). For each pair, if the pair sum needed to get the target has been visited, the time complexity will be O(k), where k is the maximum size of the lists holding pairs with visited pair sum. Therefore the total time complexity will be O(k*n^2). Now we need to determine the range of k. Basically the more distinct pair sums we get, the smaller k will be. If all the pair sums are different from each other, k will just be 1. However, if we have many repeated elements in the original 1D array, or in some extreme cases such as the elements form an arithmetic progression, k can be of the order of n (strictly speaking, for the repeated elements case, k can go as high as n^2, but we can get rid of many of them). On average k will be some constant between 1 and n for normal elements distribution in the original 1D array. So on average our algorithm will go in O(n^2) but with worst case of O(n^3).  Here is the complete code in java:\\n\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n        Arrays.sort(num);\\n        \\n        Map<Integer, List<int[]>> twoSumMap = new HashMap<>(); // for holding visited pair sums. All pairs with the same pair sum are grouped together\\n        Set<List<Integer>> res = new HashSet<>();  // for holding the results\\n        \\n        for (int i = 0; i < num.length; i++) {\\n        \\t// get rid of repeated pair sums\\n            if (i > 1 && num[i] == num[i - 2]) continue;\\n        \\t\\n            for (int j = i + 1; j < num.length; j++) {\\n                // get rid of repeated pair sums\\n                if (j > i + 2 && num[j] == num[j - 2]) continue;\\n\\n                // for each pair sum, check if the pair sum that is needed to get the target has been visited.            \\t\\n                if (twoSumMap.containsKey(target - (num[i] + num[j]))) {   \\n                    // if so, get all the pairs that contribute to this visited pair sum.\\n            \\tList<int[]> ls = twoSumMap.get(target - (num[i] + num[j]));\\n            \\t\\t\\n            \\tfor (int[] pair : ls) {\\n            \\t    // we have two pairs: one is indicated as (pair[0], pair[1]), the other is (i, j).\\n            \\t    // we first need to check if they are overlapping with each other.\\n            \\t    int m1 = Math.min(pair[0], i);  // m1 will always be the smallest index\\n                        int m2 = Math.min(pair[1], j);  // m2 will be one of the middle two indices\\n                        int m3 = Math.max(pair[0], i);  // m3 will be one of the middle two indices\\n                        int m4 = Math.max(pair[1], j);  // m4 will always be the largest index\\n                        \\n                        if (m1 == m3 || m1 == m4 || m2 == m3 || m2 == m4) continue;  // two pairs are overlapping, so just ignore this case\\n     \\t\\t    \\n     \\t\\t    res.add(Arrays.asList(num[m1], num[Math.min(m2, m3)], num[Math.max(m2, m3)], num[m4]));  // else record the result\\n            \\t}\\n                }\\n                \\n                // mark that we have visited current pair and add it to the corrsponding pair sum group.\\n                // here we've encoded the pair indices i and j into an integer array of length 2.\\n                twoSumMap.computeIfAbsent(num[i] + num[j], key -> new ArrayList<>()).add(new int[] {i, j});\\n            }\\n        }\\n        \\n        return new ArrayList<List<Integer>>(res);\\n    }"
		},
		{
			"lc_ans_id":"8688",
			"view":"2779",
			"top":"9",
			"title":"*Java* a little bit faster than other common methods (9ms, beats 95%)",
			"vote":"23",
			"content":"To avoid duplicate list items, I skip unnecessary indices at two locations:\\n\\n - one at the end of the outer loop (`i-loop`)\\n - the other at the end of the inner loop (`j-loop`). \\n\\n\\nTo avoid useless computations, the following is kind of critical:\\n\\n - the function `return` immediately when `nums[i]*4 > target`\\n - the inner loop `break` immediately when `nums[j]*4 < target`. \\n\\nThese two lines save quite some time due to the set up of the test cases in OJ.\\n\\n    public class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            List<List<Integer>> list = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n            int second = 0, third = 0, nexti = 0, nextj = 0;\\n            for(int i=0, L=nums.length; i<L-3; i++) {\\n                if(nums[i]<<2 > target) return list; // return immediately\\n                for(int j=L-1; j>i+2; j--) {\\n                    if(nums[j]<<2 < target) break; // break immediately\\n                    int rem = target-nums[i]-nums[j];\\n                    int lo = i+1, hi=j-1;\\n                    while(lo<hi) {\\n                        int sum = nums[lo] + nums[hi];\\n                        if(sum>rem) --hi;\\n                        else if(sum<rem) ++lo;\\n                        else {\\n                            list.add(Arrays.asList(nums[i],nums[lo],nums[hi],nums[j]));\\n                            while(++lo<=hi && nums[lo-1]==nums[lo]) continue; // avoid duplicate results\\n                            while(--hi>=lo && nums[hi]==nums[hi+1]) continue; // avoid duplicate results\\n                        }\\n                    }\\n                    while(j>=1 && nums[j]==nums[j-1]) --j; // skip inner loop\\n                }\\n                while(i<L-1 && nums[i]==nums[i+1]) ++i; // skip outer loop\\n            }\\n            return list;\\n        }\\n    }"
		}
	],
	"id":"18",
	"title":"4Sum",
	"content":"<p>Given an array <i>S</i> of <i>n</i> integers, are there elements <i>a</i>, <i>b</i>, <i>c</i>, and <i>d</i> in <i>S</i> such that <i>a</i> + <i>b</i> + <i>c</i> + <i>d</i> = target? Find all unique quadruplets in the array which gives the sum of target.</p>\r\n\r\n<p><b>Note:</b> The solution set must not contain duplicate quadruplets.\r\n</p>\r\n\r\n<pre>\r\nFor example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\r\n\r\nA solution set is:\r\n[\r\n  [-1,  0, 0, 1],\r\n  [-2, -1, 1, 2],\r\n  [-2,  0, 0, 2]\r\n]\r\n</pre>",
	"frequency":"401",
	"ac_num":"144187"
}