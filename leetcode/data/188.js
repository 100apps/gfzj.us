{
	"difficulty":"3",
	"submit_num":"230487",
	"show_id":"188",
	"leetcode_id":"188",
	"answers":[
		{
			"lc_ans_id":"54113",
			"view":"48514",
			"top":"0",
			"title":"A Concise DP Solution in Java",
			"vote":"198",
			"content":"The general idea is DP, while I had to add a \"quickSolve\" function to tackle some corner cases to avoid TLE.\\n\\nDP: t(i,j) is the max profit for up to i transactions by time j (0<=i<=K, 0<=j<=T).\\n\\n        public int maxProfit(int k, int[] prices) {\\n            int len = prices.length;\\n            if (k >= len / 2) return quickSolve(prices);\\n            \\n            int[][] t = new int[k + 1][len];\\n            for (int i = 1; i <= k; i++) {\\n                int tmpMax =  -prices[0];\\n                for (int j = 1; j < len; j++) {\\n                    t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax);\\n                    tmpMax =  Math.max(tmpMax, t[i - 1][j - 1] - prices[j]);\\n                }\\n            }\\n            return t[k][len - 1];\\n        }\\n        \\n\\n        private int quickSolve(int[] prices) {\\n            int len = prices.length, profit = 0;\\n            for (int i = 1; i < len; i++)\\n                // as long as there is a price gap, we gain a profit.\\n                if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\\n            return profit;\\n        }"
		},
		{
			"lc_ans_id":"54117",
			"view":"20285",
			"top":"1",
			"title":"Clean Java DP solution with comment",
			"vote":"120",
			"content":"    /**\\n\\t * dp[i, j] represents the max profit up until prices[j] using at most i transactions. \\n     * dp[i, j] = max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]) { jj in range of [0, j-1] }\\n     *          = max(dp[i, j-1], prices[j] + max(dp[i-1, jj] - prices[jj]))\\n     * dp[0, j] = 0; 0 transactions makes 0 profit\\n     * dp[i, 0] = 0; if there is only one price data point you can't make any transaction.\\n\\t */\\n\\n    public int maxProfit(int k, int[] prices) {\\n    \\tint n = prices.length;\\n    \\tif (n <= 1)\\n    \\t\\treturn 0;\\n    \\t\\n    \\t//if k >= n/2, then you can make maximum number of transactions.\\n    \\tif (k >=  n/2) {\\n    \\t\\tint maxPro = 0;\\n    \\t\\tfor (int i = 1; i < n; i++) {\\n    \\t\\t\\tif (prices[i] > prices[i-1])\\n    \\t\\t\\t\\tmaxPro += prices[i] - prices[i-1];\\n    \\t\\t}\\n    \\t\\treturn maxPro;\\n    \\t}\\n    \\t\\n        int[][] dp = new int[k+1][n];\\n        for (int i = 1; i <= k; i++) {\\n        \\tint localMax = dp[i-1][0] - prices[0];\\n        \\tfor (int j = 1; j < n; j++) {\\n        \\t\\tdp[i][j] = Math.max(dp[i][j-1],  prices[j] + localMax);\\n        \\t\\tlocalMax = Math.max(localMax, dp[i-1][j] - prices[j]);\\n        \\t}\\n        }\\n        return dp[k][n-1];\\n    }"
		},
		{
			"lc_ans_id":"54118",
			"view":"17227",
			"top":"2",
			"title":"C++ Solution with O(n + klgn) time using Max Heap and Stack",
			"vote":"79",
			"content":"We can find all adjacent valley/peak pairs and calculate the profits easily. Instead of accumulating all these profits like Buy&Sell Stock II, we need the highest k ones.\\n\\nThe key point is when there are two v/p pairs (v1, p1) and (v2, p2), satisfying v1 <= v2 and p1 <= p2, we can either make one transaction at [v1, p2], or make two at both [v1, p1] and [v2, p2]. The trick is to treat [v1, p2] as the first transaction, and [v2, p1] as the second. Then we can guarantee the right max profits in both situations, **p2 - v1** for one transaction and **p1 - v1 + p2 - v2** for two.\\n\\nFinding all v/p pairs and calculating the profits takes O(n) since there are up to n/2 such pairs. And extracting k maximums from the heap consumes another O(klgn).\\n\\n\\n    class Solution {\\n    public:\\n        int maxProfit(int k, vector<int> &prices) {\\n            int n = (int)prices.size(), ret = 0, v, p = 0;\\n            priority_queue<int> profits;\\n            stack<pair<int, int> > vp_pairs;\\n            while (p < n) {\\n                // find next valley/peak pair\\n                for (v = p; v < n - 1 && prices[v] >= prices[v+1]; v++);\\n                for (p = v + 1; p < n && prices[p] >= prices[p-1]; p++);\\n                // save profit of 1 transaction at last v/p pair, if current v is lower than last v\\n                while (!vp_pairs.empty() && prices[v] < prices[vp_pairs.top().first]) {\\n                    profits.push(prices[vp_pairs.top().second-1] - prices[vp_pairs.top().first]);\\n                    vp_pairs.pop();\\n                }\\n                // save profit difference between 1 transaction (last v and current p) and 2 transactions (last v/p + current v/p),\\n                // if current v is higher than last v and current p is higher than last p\\n                while (!vp_pairs.empty() && prices[p-1] >= prices[vp_pairs.top().second-1]) {\\n                    profits.push(prices[vp_pairs.top().second-1] - prices[v]);\\n                    v = vp_pairs.top().first;\\n                    vp_pairs.pop();\\n                }\\n                vp_pairs.push(pair<int, int>(v, p));\\n            }\\n            // save profits of the rest v/p pairs\\n            while (!vp_pairs.empty()) {\\n                profits.push(prices[vp_pairs.top().second-1] - prices[vp_pairs.top().first]);\\n                vp_pairs.pop();\\n            }\\n            // sum up first k highest profits\\n            for (int i = 0; i < k && !profits.empty(); i++) {\\n                ret += profits.top();\\n                profits.pop();\\n            }\\n            return ret;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"54121",
			"view":"12585",
			"top":"3",
			"title":"Share my C++ DP solution with O(kn) time O(k) space, 10ms",
			"vote":"41",
			"content":"This is my DP solution:\\n\\nclass Solution {\\n\\n    public:\\n        int maxProfit(int k, vector<int> &prices) {\\n            int len = prices.size();\\n            if (len<2) return 0;\\n            if (k>len/2){ // simple case\\n                int ans = 0;\\n                for (int i=1; i<len; ++i){\\n                    ans += max(prices[i] - prices[i-1],0);\\n                }\\n                return ans;\\n            }\\n            int hold[k+1];\\n            int rele[k+1];\\n            for (int i=0;i<=k;++i){\\n                hold[i] = INT_MIN;\\n                rele[i] = 0;\\n            }\\n            int cur;\\n            for (int i=0; i<len; ++i){\\n                cur = prices[i];\\n                for(int j=k; j>0; --j){\\n                    rele[j] = max(rele[j],hold[j] + cur);\\n                    hold[j] = max(hold[j],rele[j-1] - cur);\\n                }\\n            }\\n            return rele[k];\\n        }\\n\\n};\\n\\nInspired by weijiac in Best Time to Buy and Sell Stock III\\n\\nhttps://leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1"
		},
		{
			"lc_ans_id":"54114",
			"view":"5593",
			"top":"4",
			"title":"Easy understanding and can be easily modified to different situations Java Solution",
			"vote":"31",
			"content":"The basic idea is to create two tables. hold and unhold. \\n \\nhold[i][j] means the maximum profit with at most j transaction for 0 to i-th day. hold means you have a stock in your hand.\\n\\nunhold[i][j] means the maximum profit with at most j transaction for 0 to i-th day. unhold means you don't have a stock in your hand.\\n\\nThe equation is \\n\\n> **hold[i][j] = Math.max(unhold[i-1][j]-prices[i],hold[i-1][j]);**\\n> \\n> \\n> **unhold[i][j] = Math.max(hold[i-1][j-1]+prices[i],unhold[i-1][j]);**\\n\\nwhen you sell your stock this is a transaction but when you buy a stock, it is not considered as a full transaction. so this is why the two equation look a little different.\\n\\nAnd we have to initiate hold table when **k = 0**.\\n\\nWhen the situation is you can not buy a new stock at the same day when you sell it. For example you can only buy a new stock after one day you sell it. The same idea. Another situation is when you have to pay a transaction fee for each transaction, just make a modification when you sell it, So just change the unhold equation a little. \\n\\n \\n\\n    public class Solution {\\n        //hold[i][k]  ith day k transaction have stock and maximum profit\\n        //unhold[i][k] ith day k transaction do not have stock at hand and maximum profit\\n        public int maxProfit(int k, int[] prices) {\\n            if(k>prices.length/2) return maxP(prices);\\n            int[][] hold = new int[prices.length][k+1];\\n            int[][] unhold = new int[prices.length][k+1];\\n            hold[0][0] = -prices[0];\\n            for(int i=1;i<prices.length;i++) hold[i][0] = Math.max(hold[i-1][0],-prices[i]);\\n            for(int j=1;j<=k;j++) hold[0][j] = -prices[0];\\n            for(int i=1;i<prices.length;i++){\\n                for(int j=1;j<=k;j++){\\n                    hold[i][j] = Math.max(unhold[i-1][j]-prices[i],hold[i-1][j]);\\n                    unhold[i][j] = Math.max(hold[i-1][j-1]+prices[i],unhold[i-1][j]);\\n                }\\n            }\\n            return Math.max(hold[prices.length-1][k],unhold[prices.length-1][k]);\\n        }\\n        public int maxP(int[] prices){\\n            int res =0;\\n            for(int i=0;i<prices.length;i++){\\n                if(i>0 && prices[i] > prices[i-1]){\\n                    res += prices[i]-prices[i-1];\\n                }\\n            }\\n            return res;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"54145",
			"view":"4563",
			"top":"5",
			"title":"O(n)-time 8ms Accepted Solution with Detailed Explanation (C++)",
			"vote":"28",
			"content":"The idea of this thread was originally proposed by **@yishiluo** in\\nhttps://leetcode.com/discuss/26745/c-solution-with-o-n-klgn-time-using-max-heap-and-stack\\n\\n**General idea:**\\n\\nWe use the term \"valley\" to denote a local minimum index of prices, and the term \"peak\" to denote a local maximum index of prices. Let (v1, p1) and (v2, p2) denote two successive valley-peak pairs of the prices, respectively. Consider the two cases:\\n\\n- **Case 1**: prices[v1] <= prices[v2] and prices[p1] <= prices[p2]. In this case, if we can conduct one transaction, we will use (v1, p2). If we can conduct two transactions, we will use (v1, p1) and (v2, p2). Equivalently, we can consider (v1, p2) as one transaction opportunity, and (v2, p1) as another transaction opportunity. The key idea is that these two original valley-peak pairs provide two transaction opportunities: (v1, p2) and (v2, p1).\\n\\n- **Case 2**: prices[v1] >= prices[v2] or prices[p1] >= prices[p2]. In this case, if we can conduct one transaction, we will use either (v1, p1) or (v2, p2). If we can conduct two transactions, we will use both (v1, p1) and (v2, p2). That is, these two valley-peak pairs provides two transaction opportunities: (v1, p1) and (v2, p2).\\n\\n**The algorithm consists of two steps:**\\n\\n- **Step 1**: Find all transaction opportunities and record their profits. We use a stack `vps` to store the valley-peak pairs of the stock prices, wherein the valley value is sorted in ascending order. (The valley value at the top of the stack is the largest.) The profit of all transaction opportunities are recorded in the vector `profits`. The time complexity of this step is O(n).\\n\\n- **Step 2**: Find the k most profitable transaction opportunities. The maximum profit we can get is the summation of the k opportunity. The time complexity of this step is O(n), too.\\n\\n**Overall complexity:**\\n\\n- Time: O(n)\\n\\n- Space: worse-case O(n)\\n\\n---------------------------\\n**C++ code** (Accepted 8ms)\\n\\n    class Solution {\\n    public:\\n        int maxProfit(int k, vector<int>& prices) {\\n\\n            // Step 1: Find out all profit opportunities            \\n            vector<int> profits;\\n            stack<pair<int, int>> vps; // valley-peak pairs\\n            \\n            int v;\\n            int p = -1;\\n            for (;;) {\\n                // find next valley-peak pair\\n                for (v = p+1; (v+1 < prices.size()) && (prices[v] >= prices[v+1]); ++v);\\n                for (p = v  ; (p+1 < prices.size()) && (prices[p] <= prices[p+1]); ++p);\\n                \\n                if (v == p) { // v==p means that both v and p reach the end of the array\\n                    break;\\n                }\\n                \\n                // Consider two transactions (v1, p1) (back of the stack) and (v2, p2) (the new-found).\\n                // If prices[v1] >= prices[v2], \\n                // it is meaningless to combine the two transactions.\\n                // Save of profit of (v1, p1), and pop it out of the record.\\n                while ((!vps.empty()) && (prices[v] <= prices[vps.top().first])) {\\n                    profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n                    vps.pop();\\n                }\\n                \\n                // If prices[v1]<prices[v2] and prices[p1]<prices[p2], \\n                // then it is meaningful to combine the two transactions\\n                // update (v1, p1) to (v1, p2), and save the profit of (v2, p1)\\n                while ((!vps.empty()) && (prices[p] >= prices[vps.top().second])) {\\n                    profits.push_back(prices[vps.top().second] - prices[v]);\\n                    v = vps.top().first;\\n                    vps.pop();\\n                }\\n                \\n                // save the new-found valley-peak pair\\n                vps.emplace(v, p);\\n            }\\n            \\n            // save all remaining profits\\n            while (!vps.empty()) {\\n                profits.push_back(prices[vps.top().second] - prices[vps.top().first]);\\n                vps.pop();\\n            }\\n            \\n            // Step 2: Calculate the k highest profits\\n            int ret;\\n            if (profits.size() <= k) {\\n                ret = accumulate(profits.begin(), profits.end(), 0);\\n            } else {\\n                nth_element(profits.begin(), profits.end() - k, profits.end());\\n                ret = accumulate(profits.end() - k, profits.end(), 0);\\n            }\\n            return ret;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"54198",
			"view":"6207",
			"top":"6",
			"title":"DP, O(KN) Time,O(n) Space, cpp , solution.",
			"vote":"18",
			"content":"if k >= n/2,  we can have transactions any time, it can be solved by O(n).\\n\\nelse, we can do it in DP.\\n\\nuse dp[k][i+1] represents, The max profit of using [0,i] data and k transactions.\\n\\nSo we have:\\n\\ndp[k][i+1] = max(dp[k-1][i+1], dp[k][i], max( dp[k-1][j]  + prices[i] - prices[j] ))\\n\\n= max(dp[k-1][i+1], dp[k][i], prices[i] + max( dp[k-1][j] - prices[j] )) { 0 <= j < i }\\n\\nit can be solved by O(kn).\\n\\n\\nThe Code:\\n\\n\\n    class Solution {\\n    public:\\n        int maxProfit_all(vector<int> &prices) {\\n            int n = prices.size();\\n            int sum = 0;\\n            for(int i = 1;i < n;i++){\\n                if(prices[i] > prices[i-1]){\\n                    sum += prices[i] - prices[i-1];\\n                }\\n            }\\n            return sum;\\n        }\\n        int maxProfit(int k, vector<int> &prices) {\\n            int n = prices.size();\\n            if(k >= n/2){\\n                return maxProfit_all(prices);    \\n            }\\n            int dp[2][n+1];\\n            memset(dp,0,sizeof(dp));\\n            for(int t = 1; t <= k; t++){\\n                int cur_max = 0x80000000;\\n                dp[t%2][0] = 0;\\n                for(int i = 0; i < n; i++){\\n                    dp[t%2][i+1] = max(dp[(t+1)%2][i+1],max(dp[t%2][i],prices[i] + cur_max));\\n                    cur_max = max(cur_max,dp[(t+1)%2][i] - prices[i]);\\n                }\\n            }\\n            return dp[k%2][n];\\n        }\\n    };"
		},
		{
			"lc_ans_id":"54131",
			"view":"3093",
			"top":"7",
			"title":"Well explained Python DP with comments",
			"vote":"17",
			"content":"I think the general idea has been thoroughly explained by other brilliant leetcoders. All of the solutions are beautiful and concise. However, most of the them don't look obvious to me, so I wrote this and hope it looks more straight forward.\\nIt's O(kn),  apparently not optimal. I name the key variables as local profit and global profit to make things much understandable (well, at least , to me). Performance is not too bad though. \\n\\n    def maxProfit4(self, k, prices):\\n        n = len(prices)\\n        if n < 2:\\n            return 0\\n        # k is big enougth to cover all ramps.\\n        if k >= n / 2:\\n            return sum(i - j\\n                       for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\\n        globalMax = [[0] * n for _ in xrange(k + 1)]\\n        for i in xrange(1, k + 1):\\n            # The max profit with i transations and selling stock on day j.\\n            localMax = [0] * n\\n            for j in xrange(1, n):\\n                profit = prices[j] - prices[j - 1]\\n                localMax[j] = max(\\n                    # We have made max profit with (i - 1) transations in\\n                    # (j - 1) days.\\n                    # For the last transation, we buy stock on day (j - 1)\\n                    # and sell it on day j.\\n                    globalMax[i - 1][j - 1] + profit,\\n                    # We have made max profit with (i - 1) transations in\\n                    # (j - 1) days.\\n                    # For the last transation, we buy stock on day j and\\n                    # sell it on the same day, so we have 0 profit, apparently\\n                    # we do not have to add it.\\n                    globalMax[i - 1][j - 1],  # + 0,\\n                    # We have made profit in (j - 1) days.\\n                    # We want to cancel the day (j - 1) sale and sell it on\\n                    # day j.\\n                    localMax[j - 1] + profit)\\n                globalMax[i][j] = max(globalMax[i][j - 1], localMax[j])\\n        return globalMax[k][-1]"
		},
		{
			"lc_ans_id":"54204",
			"view":"2153",
			"top":"8",
			"title":"Clean Java DP O(nk) solution with O(k) space",
			"vote":"15",
			"content":"Extend small_box's idea for \"Best Time to Buy and Sell Stock III\" to general case.\\n[https://leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1][1]\\n\\n    public int maxProfit(int k, int[] prices) {\\n        if(k>=prices.length/2){\\n            int maxProfit = 0;\\n            for(int i=1; i<prices.length; i++){\\n                if(prices[i]>prices[i-1]) maxProfit += prices[i]-prices[i-1];\\n            }\\n            return maxProfit;\\n        }\\n        \\n        int[] maxProfit = new int[k+1];\\n        int[] lowPrice = new int[k+1];\\n        for(int i=0; i<lowPrice.length; i++) lowPrice[i]=Integer.MAX_VALUE;\\n        for(int p : prices){\\n            for(int i=k; i>=1; i--){\\n                maxProfit[i] = Math.max(maxProfit[i],p-lowPrice[i]);\\n                lowPrice[i] = Math.min(lowPrice[i],p-maxProfit[i-1]);\\n            }\\n        }\\n        return maxProfit[k];\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1"
		},
		{
			"lc_ans_id":"54150",
			"view":"1414",
			"top":"9",
			"title":"State machine is the easiest way to understand stock problem, could solve all the stock problem in leetcode",
			"vote":"11",
			"content":"\\n[looking for the state machine picture, please click here][1]\\n\\n[inspired from this link][2]\\n\\n\\n      class Solution {\\n        public:\\n            int maxProfit(int k, vector<int>& prices) {\\n                int m = prices.size();\\n                if(m==0 || m==1 || k == 0) return 0;\\n                if (k>m/2){ // simple case\\n                    int ans = 0;\\n                    for (int i=1; i<m; ++i){\\n                        ans += max(prices[i] - prices[i-1],0);\\n                    }\\n                    return ans;\\n                }\\n                vector<vector<int>> buy(k+1,vector<int>(m+1,0));\\n                vector<vector<int>> sell(k+1,vector<int>(m+1,0));\\n                vector<int> end(m+1,0);\\n                for(int i=1;i<=k;i++)\\n                    buy[i][0] = INT_MIN;\\n                for(int i=1;i<=m;i++){\\n                    for(int j=1;j<=k;j++){\\n                        //for the first buy state, need to compare the current price with the previous price. sell[0][0] are all initialized with 0, then sell[0][0] - prices[i-1] is the price of current first buy state\\n                        buy[j][i] = max(buy[j][i-1], sell[j-1][i-1] - prices[i-1]);\\n                        sell[j][i] = max(buy[j][i-1]+prices[i-1],sell[j][i-1]);\\n                    }\\n                }\\n                return sell[k][m];\\n            }\\n        };\\n\\n\\n  \\n\\n\\n  [1]: http://y74i.imgup.net/IMG_2016069497.jpg\\n  [2]: https://leetcode.com/discuss/72030/share-my-dp-solution-by-state-machine-thinking"
		}
	],
	"id":"188",
	"title":"Best Time to Buy and Sell Stock IV",
	"content":"<p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\r\n\r\n<p>Design an algorithm to find the maximum profit. You may complete at most <b>k</b> transactions.</p>\r\n\r\n<p><b>Note:</b><br />\r\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://oj.leetcode.com/discuss/user/Freezen\">@Freezen</a> for adding this problem and creating all test cases.</p>",
	"frequency":"448",
	"ac_num":"57089"
}