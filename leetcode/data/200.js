{
	"difficulty":"2",
	"submit_num":"421809",
	"show_id":"200",
	"leetcode_id":"200",
	"answers":[
		{
			"lc_ans_id":"56359",
			"view":"58904",
			"top":"0",
			"title":"Very concise Java AC solution",
			"vote":"167",
			"content":"    public class Solution {\\n    \\n    private int n;\\n    private int m;\\n    \\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        n = grid.length;\\n        if (n == 0) return 0;\\n        m = grid[0].length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < m; j++)\\n                if (grid[i][j] == '1') {\\n                    DFSMarking(grid, i, j);\\n                    ++count;\\n                }\\n        }    \\n        return count;\\n    }\\n    \\n    private void DFSMarking(char[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != '1') return;\\n        grid[i][j] = '0';\\n        DFSMarking(grid, i + 1, j);\\n        DFSMarking(grid, i - 1, j);\\n        DFSMarking(grid, i, j + 1);\\n        DFSMarking(grid, i, j - 1);\\n    }\\n}"
		},
		{
			"lc_ans_id":"56349",
			"view":"24143",
			"top":"1",
			"title":"7 lines Python, ~14 lines Java",
			"vote":"88",
			"content":"Sink and count the islands.\\n\\n---\\n\\n**Python Solution**\\n\\n    def numIslands(self, grid):\\n        def sink(i, j):\\n            if 0 <= i < len(grid) and 0 <= j < len(grid[i]) and grid[i][j] == '1':\\n                grid[i][j] = '0'\\n                map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))\\n                return 1\\n            return 0\\n        return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i])))\\n\\n---\\n\\n**Java Solution 1**\\n\\n    public class Solution {\\n        char[][] g;\\n        public int numIslands(char[][] grid) {\\n            int islands = 0;\\n            g = grid;\\n            for (int i=0; i<g.length; i++)\\n                for (int j=0; j<g[i].length; j++)\\n                    islands += sink(i, j);\\n            return islands;\\n        }\\n        int sink(int i, int j) {\\n            if (i < 0 || i == g.length || j < 0 || j == g[i].length || g[i][j] == '0')\\n                return 0;\\n            g[i][j] = '0';\\n            sink(i+1, j); sink(i-1, j); sink(i, j+1); sink(i, j-1);\\n            return 1;\\n        }\\n    }\\n\\n---\\n\\n**Java Solution 2**\\n\\n    public class Solution {\\n        public int numIslands(char[][] grid) {\\n            int islands = 0;\\n            for (int i=0; i<grid.length; i++)\\n                for (int j=0; j<grid[i].length; j++)\\n                    islands += sink(grid, i, j);\\n            return islands;\\n        }\\n        int sink(char[][] grid, int i, int j) {\\n            if (i < 0 || i == grid.length || j < 0 || j == grid[i].length || grid[i][j] == '0')\\n                return 0;\\n            grid[i][j] = '0';\\n            for (int k=0; k<4; k++)\\n                sink(grid, i+d[k], j+d[k+1]);\\n            return 1;\\n        }\\n        int[] d = {0, 1, 0, -1, 0};\\n    }"
		},
		{
			"lc_ans_id":"56347",
			"view":"28752",
			"top":"2",
			"title":"Simple Java Solution",
			"vote":"49",
			"content":"    public class NumberofIslands {\\n    \\tstatic int[] dx = {-1,0,0,1};\\n    \\tstatic int[] dy = {0,1,-1,0};\\n    \\tpublic static int numIslands(char[][] grid) {\\n    \\t\\tif(grid==null || grid.length==0) return 0;\\n    \\t\\tint islands = 0;\\n    \\t\\tfor(int i=0;i<grid.length;i++) {\\n    \\t\\t\\tfor(int j=0;j<grid[i].length;j++) {\\n    \\t\\t\\t\\tif(grid[i][j]=='1') {\\n    \\t\\t\\t\\t\\texplore(grid,i,j);\\n    \\t\\t\\t\\t\\tislands++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn islands;\\n    \\t}\\n    \\tpublic static void explore(char[][] grid, int i, int j) {\\n    \\t\\tgrid[i][j]='x';\\n    \\t\\tfor(int d=0;d<dx.length;d++) {\\n    \\t\\t\\tif(i+dy[d]<grid.length && i+dy[d]>=0 && j+dx[d]<grid[0].length && j+dx[d]>=0 && grid[i+dy[d]][j+dx[d]]=='1') {\\n    \\t\\t\\t\\texplore(grid,i+dy[d],j+dx[d]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n\\nThe algorithm works as follow:\\n\\n 1. Scan each cell in the grid.\\n 2. If the cell value is '1' explore that island.\\n 3. Mark the explored island cells with 'x'.\\n 4. Once finished exploring that island, increment islands counter.\\n\\nThe arrays dx[], dy[] store the possible moves from the current cell. Two land cells ['1'] are considered from the same island if they are horizontally or vertically adjacent (possible moves (-1,0),(0,1),(0,-1),(1,0)). Two '1' diagonally adjacent are not considered from the same island."
		},
		{
			"lc_ans_id":"56364",
			"view":"16815",
			"top":"3",
			"title":"Java Union Find Solution",
			"vote":"47",
			"content":"class UF {\\n\\n    public int count = 0;\\n    public int[] id = null;\\n    \\n    public UF(int m, int n, char[][] grid) {\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == '1') count++;\\n            }\\n        }\\n        id = new int[m * n];\\n        for(int i = 0; i < m * n; i++) {\\n            id[i] = i;\\n        }\\n    }\\n    \\n    public int find(int p) {\\n        while(p != id[p]) {\\n            id[p] = id[id[p]];\\n            p = id[p];\\n        }\\n        return p;\\n    }\\n    \\n    public boolean isConnected(int p, int q) {\\n        int pRoot = find(p);\\n        int qRoot = find(q);\\n        if(pRoot != qRoot) return false;\\n        else return true;\\n    }\\n    \\n    public void union(int p, int q) {\\n        int pRoot = find(p);\\n        int qRoot = find(q);\\n        if(pRoot == qRoot) return;\\n        id[pRoot] = qRoot;\\n        count--;\\n    }\\n}\\n\\n    public int numIslands(char[][] grid) {\\n        if(grid.length == 0 || grid[0].length == 0) return 0;\\n        int m = grid.length, n = grid[0].length;\\n        UF uf = new UF(m , n, grid);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == '0') continue;\\n                int p = i * n + j;\\n                int q;\\n                if(i > 0 && grid[i - 1][j] == '1') {\\n                    q = p - n;\\n                    uf.union(p, q);\\n                }\\n                if(i < m - 1 && grid[i + 1][j] == '1') {\\n                    q = p + n;\\n                    uf.union(p, q);\\n                }\\n                if(j > 0 && grid[i][j - 1] == '1') {\\n                    q = p - 1;\\n                    uf.union(p, q);\\n                }\\n                if(j < n - 1 && grid[i][j + 1] == '1') {\\n                    q = p + 1;\\n                    uf.union(p, q);\\n                }\\n            }\\n        }\\n        return uf.count;\\n    }"
		},
		{
			"lc_ans_id":"56354",
			"view":"5485",
			"top":"4",
			"title":"1D Union Find Java solution, easily generalized to other problems",
			"vote":"43",
			"content":"For any problem I work on, I will try to generalize some reusable template out for future use.  We have limited time during interview and too much to worry about, so having some code template to use is very handy.  For this problem, although it is easier  and probably suggested to use BFS, but Union find also comes handy and can be easily extended to solve Island 2 and Surrounded regions.  \\n\\nI separate all the union find logic in a separate class and use 1d version to make the code clear.  I also use a 2d array for the 4 direction visit.  `int[][] distance = {{1,0},{-1,0},{0,1},{0,-1}};`\\n\\n\\n        int[][] distance = {{1,0},{-1,0},{0,1},{0,-1}};\\n        public int numIslands(char[][] grid) {  \\n            if (grid == null || grid.length == 0 || grid[0].length == 0)  {\\n                return 0;  \\n            }\\n            UnionFind uf = new UnionFind(grid);  \\n            int rows = grid.length;  \\n            int cols = grid[0].length;  \\n            for (int i = 0; i < rows; i++) {  \\n                for (int j = 0; j < cols; j++) {  \\n                    if (grid[i][j] == '1') {  \\n                        for (int[] d : distance) {\\n                            int x = i + d[0];\\n                            int y = j + d[1];\\n                            if (x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] == '1') {  \\n                                int id1 = i*cols+j;\\n                                int id2 = x*cols+y;\\n                                uf.union(id1, id2);  \\n                            }  \\n                        }  \\n                    }  \\n                }  \\n            }  \\n            return uf.count;  \\n        }\\n        \\nUnion Find:\\n\\n        class UnionFind {\\n            int[] father;  \\n            int m, n;\\n            int count = 0;\\n            UnionFind(char[][] grid) {  \\n                m = grid.length;  \\n                n = grid[0].length;  \\n                father = new int[m*n];  \\n                for (int i = 0; i < m; i++) {  \\n                    for (int j = 0; j < n; j++) {  \\n                        if (grid[i][j] == '1') {\\n                            int id = i * n + j;\\n                            father[id] = id;\\n                            count++;\\n                        }\\n                    }  \\n                }  \\n            }\\n            public void union(int node1, int node2) {  \\n                int find1 = find(node1);\\n                int find2 = find(node2);\\n                if(find1 != find2) {\\n                    father[find1] = find2;\\n                    count--;\\n                }\\n            }\\n            public int find (int node) {  \\n                if (father[node] == node) {  \\n                    return node;\\n                }\\n                father[node] = find(father[node]);  \\n                return father[node];\\n            }\\n        }"
		},
		{
			"lc_ans_id":"56460",
			"view":"11983",
			"top":"5",
			"title":"Clear & Easy Java Solution",
			"vote":"39",
			"content":"    public class Solution {\\n        public int numIslands(char[][] grid) {\\n            int count = 0;\\n            \\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[i].length; j++) {\\n                    if (grid[i][j] == '1') {\\n                        count++;\\n                        clearRestOfLand(grid, i, j);\\n                    }\\n                }\\n            }\\n            return count;\\n        }\\n        \\n        private void clearRestOfLand(char[][] grid, int i, int j) {\\n            if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == '0') return;\\n            \\n            grid[i][j] = '0';\\n            clearRestOfLand(grid, i+1, j);\\n            clearRestOfLand(grid, i-1, j);\\n            clearRestOfLand(grid, i, j+1);\\n            clearRestOfLand(grid, i, j-1);\\n            return;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"56356",
			"view":"11778",
			"top":"6",
			"title":"DFS and BFS in C++",
			"vote":"29",
			"content":"When we met a '1', the answer add 1, we also need to search all '1' which connected to it directly or indirectly, and change it to '0'. And we can use DFS or BFS to search.\\n\\n1. DFS\\n======\\n    class Solution\\n    {\\n    public:\\n        int numIslands(vector<vector<char>> &grid)\\n        {\\n            if(grid.size() == 0 || grid[0].size() == 0)\\n                return 0;\\n            \\n            int res = 0;\\n            for(int i = 0; i < grid.size(); ++ i)\\n                for(int j = 0; j < grid[0].size(); ++ j)\\n                    if(grid[i][j] == '1')\\n                    {\\n                        ++ res;\\n                        DFS(grid, i, j);\\n                    }\\n            return res;\\n        }\\n    private:\\n        void DFS(vector<vector<char>> &grid, int x, int y)\\n        {\\n            grid[x][y] = '0';\\n            if(x > 0 && grid[x - 1][y] == '1')\\n                DFS(grid, x - 1, y);\\n            if(x < grid.size() - 1 && grid[x + 1][y] == '1')\\n                DFS(grid, x + 1, y);\\n            if(y > 0 && grid[x][y - 1] == '1')\\n                DFS(grid, x, y - 1);\\n            if(y < grid[0].size() - 1 && grid[x][y + 1] == '1')\\n                DFS(grid, x, y + 1);\\n        }\\n    };\\n\\n2. BFS\\n======\\n\\n    class Solution\\n    {\\n    public:\\n        int numIslands(vector<vector<char>> &grid)\\n        {\\n            if(grid.size() == 0 || grid[0].size() == 0)\\n                return 0;\\n            \\n            int res = 0;\\n            for(int i = 0; i < grid.size(); ++ i)\\n                for(int j = 0; j < grid[0].size(); ++ j)\\n                    if(grid[i][j] == '1')\\n                    {\\n                        ++ res;\\n                        BFS(grid, i, j);\\n                    }\\n            return res;\\n        }\\n    private:\\n        void BFS(vector<vector<char>> &grid, int x, int y)\\n        {\\n            queue<vector<int>> q;\\n            q.push({x, y});\\n            grid[x][y] = '0';\\n            \\n            while(!q.empty())\\n            {\\n                x = q.front()[0], y = q.front()[1];\\n                q.pop();\\n                \\n                if(x > 0 && grid[x - 1][y] == '1')\\n                {\\n                    q.push({x - 1, y});\\n                    grid[x - 1][y] = '0';\\n                }\\n                if(x < grid.size() - 1 && grid[x + 1][y] == '1')\\n                {\\n                    q.push({x + 1, y});\\n                    grid[x + 1][y] = '0';\\n                }\\n                if(y > 0 && grid[x][y - 1] == '1')\\n                {\\n                    q.push({x, y - 1});\\n                    grid[x][y - 1] = '0';\\n                }\\n                if(y < grid[0].size() - 1 && grid[x][y + 1] == '1')\\n                {\\n                    q.push({x, y + 1});\\n                    grid[x][y + 1] = '0';\\n                }\\n            }\\n        }\\n    };"
		},
		{
			"lc_ans_id":"56338",
			"view":"7636",
			"top":"7",
			"title":"Java DFS and BFS solution",
			"vote":"28",
			"content":"Using Flood Fill algorithm:\\n\\nDFS:\\n\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]=='1'){\\n                    dfsFill(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        return count;\\n    }\\n    private void dfsFill(char[][] grid,int i, int j){\\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\\n            grid[i][j]='0';\\n            dfsFill(grid, i + 1, j);\\n            dfsFill(grid, i - 1, j);\\n            dfsFill(grid, i, j + 1);\\n            dfsFill(grid, i, j - 1);\\n        }\\n    }\\n\\nBFS:\\n\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]=='1'){\\n                    bfsFill(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        return count;\\n    }\\n    private void bfsFill(char[][] grid,int x, int y){\\n        grid[x][y]='0';\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        LinkedList<Integer> queue = new LinkedList<Integer>();  \\n        int code = x*m+y;  \\n        queue.offer(code);  \\n        while(!queue.isEmpty())  \\n        {  \\n            code = queue.poll();  \\n            int i = code/m;  \\n            int j = code%m;  \\n            if(i>0 && grid[i-1][j]=='1')    //search upward and mark adjacent '1's as '0'.\\n            {  \\n                queue.offer((i-1)*m+j);  \\n                grid[i-1][j]='0';  \\n            }  \\n            if(i<n-1 && grid[i+1][j]=='1')  //down\\n            {  \\n                queue.offer((i+1)*m+j);  \\n                grid[i+1][j]='0';  \\n            }  \\n            if(j>0 && grid[i][j-1]=='1')  //left\\n            {  \\n                queue.offer(i*m+j-1);  \\n                grid[i][j-1]='0';  \\n            }  \\n            if(j<m-1 && grid[i][j+1]=='1')  //right\\n            {  \\n                queue.offer(i*m+j+1);  \\n                grid[i][j+1]='0';  \\n            }\\n        } \\n    }"
		},
		{
			"lc_ans_id":"56340",
			"view":"3064",
			"top":"8",
			"title":"Python Simple DFS Solution",
			"vote":"27",
			"content":"Iterate through each of the cell and if it is an island, do dfs to mark all adjacent islands, then increase the counter by 1.\\n\\n    def numIslands(self, grid):\\n        if not grid:\\n            return 0\\n            \\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == '1':\\n                    self.dfs(grid, i, j)\\n                    count += 1\\n        return count\\n    \\n    def dfs(self, grid, i, j):\\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':\\n            return\\n        grid[i][j] = '#'\\n        self.dfs(grid, i+1, j)\\n        self.dfs(grid, i-1, j)\\n        self.dfs(grid, i, j+1)\\n        self.dfs(grid, i, j-1)"
		},
		{
			"lc_ans_id":"56383",
			"view":"5523",
			"top":"9",
			"title":"My accepted c++ solution (may be trivial)",
			"vote":"13",
			"content":"    class Solution {\\n    public:\\n        void contaminate(vector<vector<char> > &grid, int i, int j){\\n            if(i>0&&grid[i-1][j]=='1'){\\n                grid[i-1][j]='0';\\n                contaminate(grid, i-1, j);\\n            }\\n            if(j>0&&grid[i][j-1]=='1'){\\n                grid[i][j-1]='0';\\n                contaminate(grid, i, j-1);\\n            }\\n            if(i<grid.size()-1&&grid[i+1][j]=='1'){\\n                grid[i+1][j]='0';\\n                contaminate(grid, i+1, j);\\n            }\\n            if(j<grid[0].size()-1&&grid[i][j+1]=='1'){\\n                grid[i][j+1]='0';\\n                contaminate(grid, i, j+1);\\n            }\\n        }\\n        int numIslands(vector<vector<char>> &grid) {\\n            int n=grid.size();\\n            if(n==0) return 0;\\n            int m=grid[0].size();\\n            \\n            int cnt=0;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(grid[i][j]=='1'){\\n                        cnt++;\\n                        contaminate(grid, i, j);\\n                    }\\n                }\\n            }\\n            return cnt;\\n        }\\n    };"
		}
	],
	"id":"200",
	"title":"Number of Islands",
	"content":"<p>Given a 2d grid map of <code>'1'</code>s (land) and <code>'0'</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\r\n\r\n<p><i><b>Example 1:</b></i></p>\r\n<pre>11110<br>11010<br>11000<br>00000</pre>\r\n<p>Answer: 1</p>\r\n<p><i><b>Example 2:</b></i></p>\r\n<pre>11000<br>11000<br>00100<br>00011</pre>\r\n<p>Answer: 3</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/mithmatt\">@mithmatt</a> for adding this problem and creating all test cases.</p>",
	"frequency":"547",
	"ac_num":"152294"
}