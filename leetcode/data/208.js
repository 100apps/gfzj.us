{
	"difficulty":"2",
	"submit_num":"330979",
	"show_id":"208",
	"leetcode_id":"208",
	"answers":[
		{
			"lc_ans_id":"58842",
			"view":"18177",
			"top":"0",
			"title":"Maybe the code is not too much by using \"next[26]\", C++",
			"vote":"91",
			"content":"    class TrieNode\\n    {\\n    public:\\n        TrieNode *next[26];\\n        bool is_word;\\n        \\n        // Initialize your data structure here.\\n        TrieNode(bool b = false)\\n        {\\n            memset(next, 0, sizeof(next));\\n            is_word = b;\\n        }\\n    };\\n    \\n    class Trie\\n    {\\n        TrieNode *root;\\n    public:\\n        Trie()\\n        {\\n            root = new TrieNode();\\n        }\\n    \\n        // Inserts a word into the trie.\\n        void insert(string s)\\n        {\\n            TrieNode *p = root;\\n            for(int i = 0; i < s.size(); ++ i)\\n            {\\n                if(p -> next[s[i] - 'a'] == NULL)\\n                    p -> next[s[i] - 'a'] = new TrieNode();\\n                p = p -> next[s[i] - 'a'];\\n            }\\n            p -> is_word = true;\\n        }\\n    \\n        // Returns if the word is in the trie.\\n        bool search(string key)\\n        {\\n            TrieNode *p = find(key);\\n            return p != NULL && p -> is_word;\\n        }\\n    \\n        // Returns if there is any word in the trie\\n        // that starts with the given prefix.\\n        bool startsWith(string prefix)\\n        {\\n            return find(prefix) != NULL;\\n        }\\n    \\n    private:\\n        TrieNode* find(string key)\\n        {\\n            TrieNode *p = root;\\n            for(int i = 0; i < key.size() && p != NULL; ++ i)\\n                p = p -> next[key[i] - 'a'];\\n            return p;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"58832",
			"view":"26579",
			"top":"1",
			"title":"AC JAVA solution simple using single array",
			"vote":"87",
			"content":"Detailed explanation after code!\\n\\n    class TrieNode {\\n        public char val;\\n        public boolean isWord; \\n        public TrieNode[] children = new TrieNode[26];\\n        public TrieNode() {}\\n        TrieNode(char c){\\n            TrieNode node = new TrieNode();\\n            node.val = c;\\n        }\\n    }\\n    \\n    public class Trie {\\n        private TrieNode root;\\n        public Trie() {\\n            root = new TrieNode();\\n            root.val = ' ';\\n        }\\n    \\n        public void insert(String word) {\\n            TrieNode ws = root;\\n            for(int i = 0; i < word.length(); i++){\\n                char c = word.charAt(i);\\n                if(ws.children[c - 'a'] == null){\\n                    ws.children[c - 'a'] = new TrieNode(c);\\n                }\\n                ws = ws.children[c - 'a'];\\n            }\\n            ws.isWord = true;\\n        }\\n    \\n        public boolean search(String word) {\\n            TrieNode ws = root; \\n            for(int i = 0; i < word.length(); i++){\\n                char c = word.charAt(i);\\n                if(ws.children[c - 'a'] == null) return false;\\n                ws = ws.children[c - 'a'];\\n            }\\n            return ws.isWord;\\n        }\\n    \\n        public boolean startsWith(String prefix) {\\n            TrieNode ws = root; \\n            for(int i = 0; i < prefix.length(); i++){\\n                char c = prefix.charAt(i);\\n                if(ws.children[c - 'a'] == null) return false;\\n                ws = ws.children[c - 'a'];\\n            }\\n            return true;\\n        }\\n    }\\n\\nWith my  solution I took the simple approach of giving each TrieNode a 26 element array of each possible child node it may have. I only gave 26 children nodes because we are only working with lowercase 'a' - 'z'. If you are uncertain why I made the root of my Trie an empty character this is a standard/typical approach for building out a Trie it is somewhat arbitrary what the root node is. \\n\\nFor insert I used the following algorithm. Loop through each character in the word being inserted check if the character is a child node of the current TrieNode i.e. check if the array has a populated value in the index of this character. If the current character ISN'T a child node of my current node add this character representation to the corresponding index location then set current node equal to the child that was added. However if the current character IS a child of the current node only set current node equal to the child. After evaluating the entire String the Node we left off on is marked as a *word* this allows our Trie to know which words exist in our \"dictionary\"\\n\\nFor search I simply navigate through the Trie if I discover the current character isn't in the Trie I return false.\\nAfter checking each Char in the String I check to see if the Node I left off on was marked as a word returning the result.\\n\\nStarts with is identical to search except it doesn't matter if the Node I left off was marked as a word or not if entire string evaluated i always return true;"
		},
		{
			"lc_ans_id":"58834",
			"view":"6407",
			"top":"2",
			"title":"AC Python Solution",
			"vote":"43",
			"content":"    class TrieNode:\\n    # Initialize your data structure here.\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.is_word = False\\n\\n    class Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        current = self.root\\n        for letter in word:\\n            current = current.children[letter]\\n        current.is_word = True\\n\\n    def search(self, word):\\n        current = self.root\\n        for letter in word:\\n            current = current.children.get(letter)\\n            if current is None:\\n                return False\\n        return current.is_word\\n\\n    def startsWith(self, prefix):\\n        current = self.root\\n        for letter in prefix:\\n            current = current.children.get(letter)\\n            if current is None:\\n                return False\\n        return True"
		},
		{
			"lc_ans_id":"58989",
			"view":"3916",
			"top":"3",
			"title":"My python solution",
			"vote":"28",
			"content":"        \\n    class TrieNode:\\n            # Initialize your data structure here.\\n            def __init__(self):\\n                self.word=False\\n                self.children={}\\n        \\n        class Trie:\\n        \\n            def __init__(self):\\n                self.root = TrieNode()\\n        \\n            # @param {string} word\\n            # @return {void}\\n            # Inserts a word into the trie.\\n            def insert(self, word):\\n                node=self.root\\n                for i in word:\\n                    if i not in node.children:\\n                        node.children[i]=TrieNode()\\n                    node=node.children[i]\\n                node.word=True\\n        \\n            # @param {string} word\\n            # @return {boolean}\\n            # Returns if the word is in the trie.\\n            def search(self, word):\\n                node=self.root\\n                for i in word:\\n                    if i not in node.children:\\n                        return False\\n                    node=node.children[i]\\n                return node.word\\n        \\n            # @param {string} prefix\\n            # @return {boolean}\\n            # Returns if there is any word in the trie\\n            # that starts with the given prefix.\\n            def startsWith(self, prefix):\\n                node=self.root\\n                for i in prefix:\\n                    if i not in node.children:\\n                        return False\\n                    node=node.children[i]\\n                return True\\n                \\n        \\n        # Your Trie object will be instantiated and called as such:\\n        # trie = Trie()\\n        # trie.insert(\"somestring\")\\n        # trie.search(\"key\")"
		},
		{
			"lc_ans_id":"58852",
			"view":"9741",
			"top":"4",
			"title":"C++, My solution,  easy to understand:)",
			"vote":"24",
			"content":"        /**\\n         ** author: cxq\\n         ** weibo: http://weibo.com/chenxq1992\\n         **/ \\n    \\n        class TrieNode {\\n        public:\\n            char content;   // the character included\\n            bool isend;     // if the node is the end of a word\\n            int shared;     // the number of the node shared ,convenient to implement delete(string key), not necessary in this problem\\n            vector<TrieNode*> children; // the children of the node\\n            // Initialize your data structure here.\\n            TrieNode():content(' '), isend(false), shared(0) {}\\n            TrieNode(char ch):content(ch), isend(false), shared(0) {}\\n            TrieNode* subNode(char ch) {\\n                if (!children.empty()) {\\n                    for (auto child : children) {\\n                        if (child->content == ch)\\n                            return child;\\n                    }\\n                }\\n                return nullptr;\\n            }\\n            ~TrieNode() {\\n                for (auto child : children)\\n                    delete child;\\n            }\\n        };\\n        \\n        class Trie {\\n        public:\\n            Trie() {\\n                root = new TrieNode();\\n            }\\n        \\n            // Inserts a word into the trie.\\n            void insert(string s) {\\n                if (search(s)) return;\\n                TrieNode* curr = root;\\n                for (auto ch : s) {\\n                    TrieNode* child = curr->subNode(ch);\\n                    if (child != nullptr) {\\n                        curr = child;\\n                    } else {\\n                        TrieNode *newNode = new TrieNode(ch);\\n                        curr->children.push_back(newNode);\\n                        curr = newNode;\\n                    }\\n                    ++curr->shared;\\n                }\\n                curr->isend = true;\\n            }\\n        \\n            // Returns if the word is in the trie.\\n            bool search(string key) {\\n                TrieNode* curr = root;\\n                for (auto ch : key) {\\n                    curr = curr->subNode(ch);\\n                    if (curr == nullptr)\\n                        return false;\\n                }\\n                return curr->isend == true;\\n            }\\n        \\n            // Returns if there is any word in the trie\\n            // that starts with the given prefix.\\n            bool startsWith(string prefix) {\\n                TrieNode* curr = root;\\n                for (auto ch : prefix) {\\n                    curr = curr->subNode(ch);\\n                    if (curr == nullptr)\\n                        return false;\\n                }\\n                return true;\\n            }\\n            ~Trie() {\\n                delete root;\\n            }\\n        private:\\n            TrieNode* root;\\n        };"
		},
		{
			"lc_ans_id":"58974",
			"view":"454",
			"top":"5",
			"title":"Can we add a Delete Method for this Question?",
			"vote":"21",
			"content":"Admin, it would be really nice to also implement delete method and include delete test cases for this question!"
		},
		{
			"lc_ans_id":"58841",
			"view":"5119",
			"top":"6",
			"title":"AC solution in Java",
			"vote":"19",
			"content":"    class TrieNode {\\n        private final int R = 26;\\n        private final TrieNode[] children;\\n        private String item;\\n        \\n        public TrieNode() {\\n            children = new TrieNode[R];\\n            item = \"\";\\n        }\\n        \\n        public String getItem() {\\n            return item;\\n        }\\n        \\n        public void setItem(String item) {\\n            this.item = item;\\n        }\\n        \\n        public TrieNode[] getChildren() {\\n            return children;\\n        }\\n        \\n        public TrieNode getChild(int i) {\\n            if (i >= 26 || i < 0) throw new IllegalArgumentException();\\n            return children[i];\\n        }\\n        \\n        public void setChild(int i, TrieNode node) {\\n            children[i] = node;\\n        }\\n    }\\n    \\n    public class Trie {\\n        private TrieNode root;\\n    \\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n    \\n        // Inserts a word into the trie.\\n        public void insert(String word) {\\n            TrieNode curr = root;\\n            for (char c : word.toCharArray()) {\\n                if (curr.getChild(c - 'a') == null) curr.setChild(c - 'a', new TrieNode());\\n                curr = curr.getChild(c - 'a');\\n            }\\n            curr.setItem(word);\\n        }\\n    \\n        // Returns if the word is in the trie.\\n        public boolean search(String word) {\\n            TrieNode curr = root;\\n            for (char c : word.toCharArray()) {\\n                if (curr.getChild(c - 'a') == null) return false;\\n                curr = curr.getChild(c - 'a');\\n            }\\n            return curr.getItem().equals(word);\\n        }\\n    \\n        // Returns if there is any word in the trie\\n        // that starts with the given prefix.\\n        public boolean startsWith(String prefix) {\\n            TrieNode curr = root;\\n            for (char c : prefix.toCharArray()) {\\n                if (curr.getChild(c - 'a') == null) return false;\\n                curr = curr.getChild(c - 'a');\\n            }\\n            return true;\\n        }\\n    }\\n    \\n    // Your Trie object will be instantiated and called as such:\\n    // Trie trie = new Trie();\\n    // trie.insert(\"somestring\");\\n    // trie.search(\"key\");\\n\\nThis is standard trie data structure implementation. It is a bit longer since I used getter and setter for TrieNode class."
		},
		{
			"lc_ans_id":"58840",
			"view":"2508",
			"top":"7",
			"title":"AC Java DFS solution (beat 91.31% submissions)",
			"vote":"15",
			"content":"    class TrieNode {\\n        \\n        TrieNode[] children = new TrieNode[26];\\n        boolean isLeaf;\\n        // Constructor\\n        public TrieNode() {\\n        }\\n    }\\n\\n    public class Trie {\\n        \\n        private TrieNode root;\\n    \\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n    \\n        // Inserts a word into the trie.\\n        public void insert(String word) {\\n            insert(word.toCharArray(), 0, root);\\n        }\\n        \\n        public void insert(char[] word, int i, TrieNode node) {\\n            \\n            if (i == word.length) {\\n                node.isLeaf = true;\\n                return;\\n            }\\n            \\n            char c = word[i];\\n            if (node.children[c - 'a'] == null) {\\n                node.children[c - 'a'] = new TrieNode();\\n            }\\n            \\n            insert(word, i + 1, node.children[c - 'a']);\\n        }\\n    \\n        // Returns if the word is in the trie.\\n        public boolean search(String word) {\\n            return search(word.toCharArray(), 0, root);\\n        }\\n        \\n        public boolean search(char[] word, int i, TrieNode node) {\\n            \\n            if (i == word.length) {\\n                return node.isLeaf;\\n            }\\n            \\n            char c = word[i];\\n            \\n            return node.children[c - 'a'] != null && search(word, i + 1, node.children[c - 'a']);\\n        }\\n    \\n        // Returns if there is any word in the trie\\n        // that starts with the given prefix.\\n        public boolean startsWith(String prefix) {\\n            return startsWith(prefix.toCharArray(), 0, root);\\n        }\\n        \\n        public boolean startsWith(char[] word, int i, TrieNode node) {\\n            \\n            if (i == word.length) {\\n                return true;\\n            }\\n            \\n            char c = word[i];\\n            return node.children[c - 'a'] != null && startsWith(word, i + 1, node.children[c - 'a']);\\n        }\\n    }"
		},
		{
			"lc_ans_id":"58927",
			"view":"1104",
			"top":"8",
			"title":"Compact Python solution",
			"vote":"10",
			"content":"    class TrieNode(object):\\n        def __init__(self):\\n            self.is_word = False\\n            self.children = collections.defaultdict(TrieNode)\\n    \\n    class Trie(object):\\n        def __init__(self):\\n            self.root = TrieNode()\\n    \\n        def insert(self, word):\\n            node = self.root\\n            for c in word:\\n                node = node.children[c]\\n            node.is_word = True\\n    \\n        def search(self, word, is_word=True):\\n            node = self.root\\n            for c in word:\\n                if c not in node.children:\\n                    return False\\n                node = node.children[c]\\n            return node.is_word if is_word else True\\n    \\n        def startsWith(self, prefix):\\n            return self.search(prefix, False)"
		},
		{
			"lc_ans_id":"58966",
			"view":"1944",
			"top":"9",
			"title":"*Java* my solution with brief explanations (15ms, beats 95%)",
			"vote":"10",
			"content":"For the `TrieNode`, each node has **two** fields: \\n \\n - a `boolean` `isEnd` that stores whether the current character is the end of a word\\n - a `TrieNode[]` array of size 26 that stores its children\\n\\n`search` and `startsWith` are combined into a helper method `search(String str, int type)` to save coding.\\n\\n\\n    class TrieNode {\\n\\tboolean isEnd;\\n\\tTrieNode[] children;\\n\\t\\n    public TrieNode() {\\n        isEnd = true;\\n        children = new TrieNode[26];\\n    }\\n    }\\n\\n    public class Trie {\\n    private TrieNode root;\\n\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    public void insert(String word) {\\n    \\tTrieNode current = root;\\n    \\tfor(int i=0, L=word.length(); i<L; i++) {\\n        \\tint id = word.charAt(i) - 'a';\\n        \\tif(current.children[id]==null) {\\n        \\t\\tcurrent.children[id] = new TrieNode();\\n        \\t\\tcurrent.children[id].isEnd = false;\\n        \\t}\\n        \\tcurrent = current.children[id];\\n        }\\n        current.isEnd = true;\\n    }\\n    \\n    public boolean search(String word) {\\n        return search(word, 1);\\n    }\\n    public boolean startsWith(String prefix) {\\n        return search(prefix, 2);\\n    }\\n    private boolean search(String str, int type) {\\n        TrieNode current = root;\\n        int i=-1, L=str.length();\\n        while(++i<L) {\\n\\t        int id = str.charAt(i) - 'a';\\n\\t        if((current=current.children[id]) == null) return false;\\n        }\\n        return type==1 ? current.isEnd : true;\\n    }\\n    }"
		}
	],
	"id":"208",
	"title":"Implement Trie (Prefix Tree)",
	"content":"<p>\r\nImplement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b><br>\r\nYou may assume that all inputs are consist of lowercase letters <code>a-z</code>.\r\n</p>",
	"frequency":"395",
	"ac_num":"100006"
}