{
	"difficulty":"2",
	"submit_num":"276712",
	"show_id":"210",
	"leetcode_id":"210",
	"answers":[
		{
			"lc_ans_id":"59317",
			"view":"28488",
			"top":"0",
			"title":"Two AC solution in Java using BFS and DFS with explanation",
			"vote":"109",
			"content":"This question asks for an order in which prerequisite courses must be taken first. This prerequisite relationship reminds one of directed graphs. Then, the problem reduces to find a topological sort order of the courses, which would be a DAG if it has a valid order.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int[] incLinkCounts = new int[numCourses];\\n        List<List<Integer>> adjs = new ArrayList<>(numCourses);\\n        initialiseGraph(incLinkCounts, adjs, prerequisites);\\n        //return solveByBFS(incLinkCounts, adjs);\\n        return solveByDFS(adjs);\\n    }\\n\\nThe first step is to transform it into a directed graph. Since it is likely to be sparse,we use adjacency list graph data structure. 1 -> 2 means 1 must be taken before 2.\\n\\n    private void initialiseGraph(int[] incLinkCounts, List<List<Integer>> adjs, int[][] prerequisites){\\n        int n = incLinkCounts.length;\\n        while (n-- > 0) adjs.add(new ArrayList<>());\\n        for (int[] edge : prerequisites) {\\n            incLinkCounts[edge[0]]++;\\n            adjs.get(edge[1]).add(edge[0]);\\n        }\\n    }\\n\\nHow can we obtain a topological sort order of a DAG?\\n\\nWe observe that if a node has incoming edges, it has prerequisites. Therefore, the first few in the order must be those with no prerequisites, i.e. no incoming edges. Any non-empty DAG must have at least one node without incoming links. You can draw a small graph to convince yourself. If we visit these few and remove all edges attached to them, we are left with a smaller DAG, which is the same problem. This will then give our BFS solution.\\n\\n    private int[] solveByBFS(int[] incLinkCounts, List<List<Integer>> adjs){\\n        int[] order = new int[incLinkCounts.length];\\n        Queue<Integer> toVisit = new ArrayDeque<>();\\n        for (int i = 0; i < incLinkCounts.length; i++) {\\n            if (incLinkCounts[i] == 0) toVisit.offer(i);\\n        }\\n        int visited = 0;\\n        while (!toVisit.isEmpty()) {\\n            int from = toVisit.poll();\\n            order[visited++] = from;\\n            for (int to : adjs.get(from)) {\\n                incLinkCounts[to]--;\\n                if (incLinkCounts[to] == 0) toVisit.offer(to);\\n            }\\n        }\\n        return visited == incLinkCounts.length ? order : new int[0]; \\n    }\\n\\nAnother way to think about it is the last few in the order must be those which are not prerequisites of other courses. Thinking it recursively means if one node has unvisited child node, you should visit them first before you put this node down in the final order array. This sounds like the post-order of a DFS. Since we are putting nodes down in the reverse order, we should reverse it back to correct ordering or use a stack.\\n\\n    private int[] solveByDFS(List<List<Integer>> adjs) {\\n        BitSet hasCycle = new BitSet(1);\\n        BitSet visited = new BitSet(adjs.size());\\n        BitSet onStack = new BitSet(adjs.size());\\n        Deque<Integer> order = new ArrayDeque<>();\\n        for (int i = adjs.size() - 1; i >= 0; i--) {\\n            if (visited.get(i) == false && hasOrder(i, adjs, visited, onStack, order) == false) return new int[0];\\n        }\\n        int[] orderArray = new int[adjs.size()];\\n        for (int i = 0; !order.isEmpty(); i++) orderArray[i] = order.pop();\\n        return orderArray;\\n    }\\n    \\n    private boolean hasOrder(int from, List<List<Integer>> adjs, BitSet visited, BitSet onStack, Deque<Integer> order) {\\n        visited.set(from);\\n        onStack.set(from);\\n        for (int to : adjs.get(from)) {\\n            if (visited.get(to) == false) {\\n                if (hasOrder(to, adjs, visited, onStack, order) == false) return false;\\n            } else if (onStack.get(to) == true) {\\n                return false;\\n            }\\n        }\\n        onStack.clear(from);\\n        order.push(from);\\n        return true;\\n    }"
		},
		{
			"lc_ans_id":"59316",
			"view":"11469",
			"top":"1",
			"title":"20+ lines C++ BFS/DFS Solutions",
			"vote":"42",
			"content":"Well, this problem is spiritually similar to to [Course Schedule][1]. You only need to store the nodes in the order you visit into a vector during BFS or DFS. Well, for DFS, a final reversal is required. \\n\\n----------\\n**BFS**\\n\\n    class Solution {\\n    public:\\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            vector<unordered_set<int>> graph = make_graph(numCourses, prerequisites);\\n            vector<int> degrees = compute_indegree(graph);\\n            queue<int> zeros;\\n            for (int i = 0; i < numCourses; i++)\\n                if (!degrees[i]) zeros.push(i);\\n            vector<int> toposort;\\n            for (int i = 0; i < numCourses; i++) {\\n                if (zeros.empty()) return {};\\n                int zero = zeros.front();\\n                zeros.pop();\\n                toposort.push_back(zero);\\n                for (int neigh : graph[zero]) {\\n                    if (!--degrees[neigh])\\n                        zeros.push(neigh);\\n                }\\n            }\\n            return toposort;\\n        }\\n    private:\\n        vector<unordered_set<int>> make_graph(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            vector<unordered_set<int>> graph(numCourses);\\n            for (auto pre : prerequisites)\\n                graph[pre.second].insert(pre.first);\\n            return graph; \\n        }\\n        vector<int> compute_indegree(vector<unordered_set<int>>& graph) {\\n            vector<int> degrees(graph.size(), 0);\\n            for (auto neighbors : graph)\\n                for (int neigh : neighbors)\\n                    degrees[neigh]++;\\n            return degrees;\\n        }\\n    };\\n\\n----------\\n**DFS**\\n\\n    class Solution {\\n    public:\\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            vector<unordered_set<int>> graph = make_graph(numCourses, prerequisites);\\n            vector<int> toposort;\\n            vector<bool> onpath(numCourses, false), visited(numCourses, false);\\n            for (int i = 0; i < numCourses; i++)\\n                if (!visited[i] && dfs(graph, i, onpath, visited, toposort))\\n                    return {};\\n            reverse(toposort.begin(), toposort.end());\\n            return toposort;\\n        }\\n    private:\\n        vector<unordered_set<int>> make_graph(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            vector<unordered_set<int>> graph(numCourses);\\n            for (auto pre : prerequisites)\\n                graph[pre.second].insert(pre.first);\\n            return graph;\\n        }\\n        bool dfs(vector<unordered_set<int>>& graph, int node, vector<bool>& onpath, vector<bool>& visited, vector<int>& toposort) { \\n            if (visited[node]) return false;\\n            onpath[node] = visited[node] = true; \\n            for (int neigh : graph[node])\\n                if (onpath[neigh] || dfs(graph, neigh, onpath, visited, toposort))\\n                    return true;\\n            toposort.push_back(node);\\n            return onpath[node] = false;\\n        }\\n    };\\n\\n  [1]: https://leetcode.com/problems/course-schedule/ \\n  [2]: https://leetcode.com/discuss/42543/c-bfs-and-dfs-solutions-with-explanations\\n  [3]: https://en.wikipedia.org/wiki/Topological_sorting#Algorithms"
		},
		{
			"lc_ans_id":"59330",
			"view":"3702",
			"top":"2",
			"title":"Concise JAVA solution based on BFS with comments",
			"vote":"31",
			"content":"    public int[] findOrder(int numCourses, int[][] prerequisites) { \\n        if (numCourses == 0) return null;\\n        // Convert graph presentation from edges to indegree of adjacent list.\\n        int indegree[] = new int[numCourses], order[] = new int[numCourses], index = 0;\\n        for (int i = 0; i < prerequisites.length; i++) // Indegree - how many prerequisites are needed.\\n            indegree[prerequisites[i][0]]++;    \\n    \\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        for (int i = 0; i < numCourses; i++) \\n            if (indegree[i] == 0) {\\n                // Add the course to the order because it has no prerequisites.\\n                order[index++] = i;\\n                queue.offer(i);\\n            }\\n    \\n        // How many courses don't need prerequisites. \\n        while (!queue.isEmpty()) {\\n            int prerequisite = queue.poll(); // Already finished this prerequisite course.\\n            for (int i = 0; i < prerequisites.length; i++)  {\\n                if (prerequisites[i][1] == prerequisite) {\\n                    indegree[prerequisites[i][0]]--; \\n                    if (indegree[prerequisites[i][0]] == 0) {\\n                        // If indegree is zero, then add the course to the order.\\n                        order[index++] = prerequisites[i][0];\\n                        queue.offer(prerequisites[i][0]);\\n                    }\\n                } \\n            }\\n        }\\n    \\n        return (index == numCourses) ? order : new int[0];\\n    }"
		},
		{
			"lc_ans_id":"59342",
			"view":"7006",
			"top":"3",
			"title":"Java DFS double cache visiting each vertex once 433ms",
			"vote":"29",
			"content":"    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            List<List<Integer>> adj = new ArrayList<>(numCourses);\\n            for (int i = 0; i < numCourses; i++) adj.add(i, new ArrayList<>());\\n            for (int i = 0; i < prerequisites.length; i++) adj.get(prerequisites[i][1]).add(prerequisites[i][0]);\\n            boolean[] visited = new boolean[numCourses];\\n            Stack<Integer> stack = new Stack<>();\\n            for (int i = 0; i < numCourses; i++) {\\n                if (!topologicalSort(adj, i, stack, visited, new boolean[numCourses])) return new int[0];\\n            }\\n            int i = 0;\\n            int[] result = new int[numCourses];\\n            while (!stack.isEmpty()) {\\n                result[i++] = stack.pop();\\n            }\\n            return result;\\n        }\\n        \\n        private boolean topologicalSort(List<List<Integer>> adj, int v, Stack<Integer> stack, boolean[] visited, boolean[] isLoop) {\\n            if (visited[v]) return true;\\n            if (isLoop[v]) return false;\\n            isLoop[v] = true;\\n            for (Integer u : adj.get(v)) {\\n                if (!topologicalSort(adj, u, stack, visited, isLoop)) return false;\\n            }\\n            visited[v] = true;\\n            stack.push(v);\\n            return true;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"59321",
			"view":"4803",
			"top":"4",
			"title":"Python dfs, bfs solutions with comments.",
			"vote":"26",
			"content":"     \\n    # BFS\\n    def findOrder1(self, numCourses, prerequisites):\\n        dic = {i: set() for i in xrange(numCourses)}\\n        neigh = collections.defaultdict(set)\\n        for i, j in prerequisites:\\n            dic[i].add(j)\\n            neigh[j].add(i)\\n        # queue stores the courses which have no prerequisites\\n        queue = collections.deque([i for i in dic if not dic[i]])\\n        count, res = 0, []\\n        while queue:\\n            node = queue.popleft()\\n            res.append(node)\\n            count += 1\\n            for i in neigh[node]:\\n                dic[i].remove(node)\\n                if not dic[i]:\\n                    queue.append(i)\\n        return res if count == numCourses else []\\n        \\n    # DFS\\n    def findOrder(self, numCourses, prerequisites):\\n        dic = collections.defaultdict(set)\\n        neigh = collections.defaultdict(set)\\n        for i, j in prerequisites:\\n            dic[i].add(j)\\n            neigh[j].add(i)\\n        stack = [i for i in xrange(numCourses) if not dic[i]]\\n        res = []\\n        while stack:\\n            node = stack.pop()\\n            res.append(node)\\n            for i in neigh[node]:\\n                dic[i].remove(node)\\n                if not dic[i]:\\n                    stack.append(i)\\n            dic.pop(node)\\n        return res if not dic else []"
		},
		{
			"lc_ans_id":"59322",
			"view":"1264",
			"top":"5",
			"title":"DFS-based topological sorting (clean Java implementation with detailed comments)",
			"vote":"14",
			"content":"    /*\\n        \\u5f39\\u6808\\u987a\\u5e8f\\u7684\\u9006\\u5e8f\\u5373\\u662f\\u62d3\\u6251\\u5e8f\\u5217, \\u56e0\\u4e3a\\u6808\\u9876\\u7ed3\\u70b9\\u603b\\u662f\\u6700\\u6df1\\u7684\\u7ed3\\u70b9, \\u5373\\u5b83\\u7684prerequisites\\u8def\\u5f84\\u6700\\u957f.\\n        \\u4f8b\\u5982: 4, [[1,0],[2,0],[3,1],[3,2]]\\n        \\n        stack -- topo sequence\\n        0 -- []\\n        0,1 -- []\\n        0,1,3 -- []\\n        0,1 -- [3]\\n        0 -- [3,1]\\n        0,2 -- [3,1]\\n        0 -- [3,1,2]\\n        _ -- [3,1,2,0]\\n        \\n        \\u5219\\u5b83\\u7684\\u62d3\\u6251\\u5e8f\\u5217\\u662f[0,2,1,3].\\n    */\\n    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            List<List<Integer>> adjList = new ArrayList<>();\\n            for (int i = 0; i < numCourses; ++i) { adjList.add(new ArrayList<Integer>()); }\\n            for (int[] edge: prerequisites) { adjList.get(edge[1]).add(edge[0]); }\\n            int[] status = new int[numCourses];  // 0 -- unvisited; 1 -- being visited; 2 -- visited.\\n            LinkedList<Integer> topoSeq = new LinkedList<>();\\n            for (int i = 0; i < numCourses; ++i) {\\n                if (status[i] == 0) {\\n                    if (isCycleExisting(topoSeq, adjList, status, i)) {  // cycle exists\\n                        return new int[0];\\n                    }\\n                }    \\n            }\\n            int[] ans = new int[topoSeq.size()];\\n            for (int i = 0; i < ans.length; ++i) { ans[i] = topoSeq.get(i); }\\n            return ans;\\n        }\\n        \\n        private boolean isCycleExisting(LinkedList<Integer> topoSeq, List<List<Integer>> adjList, int[] status, int cur) {\\n            status[cur] = 1;  // current vertex is being visited, that is, in recursion stack\\n            for (Integer succ: adjList.get(cur)) {\\n                if (status[succ] == 1) { return true; }  // back edge detected, cycle exits\\n                if (status[succ] == 0) {  // visit the unvisited vertices\\n                    if (isCycleExisting(topoSeq, adjList, status, succ)) {  // cycle exists in sub-graph\\n                        return true;\\n                    }\\n                }\\n            }\\n            // cur vertex and its subgraph visited; pop it out of recursion stack; add it to the front of topological sequence\\n            topoSeq.addFirst(cur);\\n            status[cur] = 2;\\n            return false;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"59506",
			"view":"4359",
			"top":"6",
			"title":"Expected: Special judge: No expected output available.",
			"vote":"12",
			"content":"Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
		},
		{
			"lc_ans_id":"59536",
			"view":"1435",
			"top":"7",
			"title":"[C++] Using 3 colored approach",
			"vote":"11",
			"content":"Here, i have used 3 colored approach. Here w -> represent white means vertex yet not visited.\\ng -> gray , it means it is under DFS recursion and we again found the same node. This means cycle exists and return false.\\nb -> black node when DFS is done visiting the node. \\nThis method checks cycle as well as keeps storing answer in stack in case cycle doesn't exists.\\n\\n    \\n\\n    class Graph {\\n        public:\\n        int v;\\n        list <int> *adj;\\n        Graph(int v)\\n        {\\n            this->v=v;\\n            adj = new list<int> [v];\\n        }\\n        void addedges(int src , int dest)\\n           {\\n    \\t     adj[dest].push_back(src);\\n           }\\t\\n    };\\n    class Solution {\\n    public:\\n        stack <int> st;\\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            Graph g(numCourses);\\n            for (int i=0 ; i < prerequisites.size() ; i++)\\n                    g.addedges(prerequisites[i].first , prerequisites[i].second);        \\n            vector <int> ans;\\n            if(!courseScheduleCheck(g))\\n                    return ans;              \\n            while(!st.empty())\\n                {\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }\\n            return ans;       \\n        }\\n       bool courseScheduleCheck(Graph g)\\n        {\\n            int v = g.v;    \\n            vector <char> visit(v,'w');\\n            for(int i=0 ; i<v;i++)\\n            {        \\n               if(visit[i]== 'w')\\n                    if(iscycle(g,i,visit))\\n                        return false;\\n            }\\n            return true;\\n        }  \\n        bool iscycle(Graph g , int i, vector <char> & visit)\\n        {\\n            list <int> ::iterator it;\\n            for(it = g.adj[i].begin() ; it!=g.adj[i].end() ; it++)\\n            {\\n                if(visit[*it]== 'g')\\n                    return true;\\n                else\\n                {\\n                    if(visit[*it] != 'b')\\n                     {\\n                         visit[*it] = 'g';\\n                         if(iscycle(g,*it,visit))\\n                            return true;\\n                     }        \\n                }     \\n            }\\n             visit[i]='b';\\n             st.push(i);           \\n            return false;\\n        }            \\n    };"
		},
		{
			"lc_ans_id":"59390",
			"view":"1680",
			"top":"8",
			"title":"Java 6ms topological sort solution with explanation",
			"vote":"9",
			"content":"This problem is a classic graph topological sort problem. Each prerequisite has edges to the courses that require it.\\n\\nWe define **in degree** as the number of edges into a node in the graph. What we do is we remove the nodes that has in degree equals to 0, decrease the in degree of the nodes that require the current node, and repeat, until we've removed all the nodes (the successful case), or there's no node with in degree equals to 0 (the failed case).\\n\\nSo, we can do this using a priority queue, and make the in degree as the priority. Every time we poll a node from the queue, and decrease the priorities of the children of the node. If the polled node has in degree larger than 1, it means we failed. But since Java's priority queue doesn't support convenient decrease key operation, we have to remove one node and add it back, which causes bad performance.\\n\\n**Or we can use two pointers. We put the removed node in an array, and use a left pointer to iterate through the array and decrease the in degrees of the nodes than require the current node. And use a right pointer to add those nodes which have 0 in degree after the decreasing operation. Repeat this until all nodes are added.**\\n\\n    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            \\n            int[] inDeg = new int[numCourses];\\n            List<Integer>[] chl = new ArrayList[numCourses];\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                chl[i] = new ArrayList<Integer>();\\n            }\\n            \\n            int pre;\\n            int cour;\\n            \\n            for (int[] pair : prerequisites) {\\n                pre = pair[1];\\n                cour = pair[0];\\n                \\n                chl[pre].add(cour);\\n                inDeg[cour]++;\\n            }\\n            \\n            int[] res = new int[numCourses];\\n            int k = 0;\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                if (inDeg[i] == 0) {\\n                    res[k++] = i;\\n                }\\n            }\\n            \\n            if (k == 0) {\\n                return new int[0];\\n            }\\n            \\n            int j = 0;\\n            List<Integer> tmp;\\n            \\n            while (k < numCourses) {\\n                tmp = chl[res[j++]];\\n                \\n                for (int id : tmp) {\\n                    if (--inDeg[id] == 0) {\\n                        res[k++] = id;\\n                    }\\n                }\\n                \\n                if (j == k) {\\n                    return new int[0];\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"59455",
			"view":"1283",
			"top":"9",
			"title":"Fast python DFS solution with inline explanation",
			"vote":"9",
			"content":"Runs takes 80ms\\n\\n    class Solution:\\n        # @param {integer} numCourses\\n        # @param {integer[][]} prerequisites\\n        # @return {integer[]}\\n        def findOrder(self, numCourses, prerequisites):\\n            # use DFS to parse the course structure\\n            self.graph = collections.defaultdict(list) # a graph for all courses\\n            self.res = [] # start from empty\\n            for pair in prerequisites:\\n                self.graph[pair[0]].append(pair[1]) \\n            self.visited = [0 for x in xrange(numCourses)] # DAG detection \\n            for x in xrange(numCourses):\\n                if not self.DFS(x):\\n                    return []\\n                 # continue to search the whole graph\\n            return self.res\\n        \\n        def DFS(self, node):\\n            if self.visited[node] == -1: # cycle detected\\n                return False\\n            if self.visited[node] == 1:\\n                return True # has been finished, and been added to self.res\\n            self.visited[node] = -1 # mark as visited\\n            for x in self.graph[node]:\\n                if not self.DFS(x):\\n                    return False\\n            self.visited[node] = 1 # mark as finished\\n            self.res.append(node) # add to solution as the course depenedent on previous ones\\n            return True"
		}
	],
	"id":"210",
	"title":"Course Schedule II",
	"content":"<p>\r\nThere are a total of <i>n</i> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p>\r\n\r\n<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>\r\n\r\n<p>\r\nGiven the total number of courses and a list of prerequisite <b>pairs</b>, return the ordering of courses you should take to finish all courses.</p>\r\n\r\n<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\r\n</p>\r\n\r\n<p>For example:</p>\r\n<pre>2, [[1,0]]</pre>\r\n<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is <code>[0,1]</code></p>\r\n\r\n<pre>4, [[1,0],[2,0],[3,1],[3,2]]</pre>\r\n<p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is <code>[0,1,2,3]</code>. Another correct ordering is<code>[0,2,1,3]</code>.</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The input prerequisites is a graph represented by <b>a list of edges</b>, not adjacency matrices. Read more about <a href=\"https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs\" target=\"_blank\">how a graph is represented</a>.</li>\r\n<li>You may assume that there are no duplicate edges in the input prerequisites.</li>\r\n</ol>\r\n</p>\r\n\r\n<p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show more hints.</a></p>\r\n\r\n<div class=\"spoilers\"><b>Hints:</b>\r\n<ol>\r\n<li>This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.</li>\r\n<li><a href=\"https://class.coursera.org/algo-003/lecture/52\" target=\"_blank\">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.</li>\r\n<li>Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>.</li>\r\n</ol>\r\n</div>",
	"frequency":"202",
	"ac_num":"82300"
}