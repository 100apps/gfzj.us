{
	"difficulty":"3",
	"submit_num":"241471",
	"show_id":"212",
	"leetcode_id":"212",
	"answers":[
		{
			"lc_ans_id":"59780",
			"view":"40804",
			"top":"0",
			"title":"Java 15ms Easiest Solution (100.00%)",
			"vote":"374",
			"content":"<h2>Backtracking + Trie</h2>\\n<hr>\\n\\nIntuitively, start from every cell and try to build a word in the dictionary. `Backtracking (dfs)` is the powerful way to exhaust every possible ways. Apparently, we need to do `pruning` when current character is not in any word. \\n\\n1. How do we instantly know the current character is invalid? `HashMap`? \\n2. How do we instantly know what's the next valid character? `LinkedList`?\\n3. But the next character can be chosen from a list of characters. `\"Mutil-LinkedList\"`?\\n\\nCombing them, `Trie` is the natural choice. Notice that:\\n\\n1. `TrieNode` is all we need. `search` and `startsWith` are useless.\\n2. No need to store character at TrieNode. `c.next[i] != null` is enough.\\n3. Never use `c1 + c2 + c3`. Use `StringBuilder`.\\n4. No need to use `O(n^2)` extra space `visited[m][n].` \\n5. No need to use `StringBuilder`. Storing `word` itself at leaf node is enough.\\n6. No need to use `HashSet` to de-duplicate. Use \"one time search\" trie.\\n\\nFor more explanations, check out [dietpepsi's blog][1].\\n\\n<hr>\\n<h2>Code Optimization</h2>\\n<hr>\\n\\nUPDATE: Thanks to @dietpepsi we further improved from `17ms` to `15ms`.\\n\\n1. `59ms`: Use `search` and `startsWith` in Trie class like [this popular solution.][2]\\n2. `33ms`: Remove Trie class which unnecessarily starts from `root` in every `dfs` call. \\n3. `30ms`: Use `w.toCharArray()` instead of `w.charAt(i)`.\\n4. `22ms`: Use `StringBuilder` instead of `c1 + c2 + c3`.\\n5. `20ms`: Remove `StringBuilder` completely by storing `word` instead of `boolean` in TrieNode.\\n6. `20ms`: Remove `visited[m][n]` completely by modifying `board[i][j] = '#'` directly.\\n7. `18ms`: check validity, e.g., `if(i > 0) dfs(...)`, before going to the next `dfs`.\\n8. `17ms`: De-duplicate `c - a` with one variable `i`.\\n9. `15ms`: Remove `HashSet` completely. dietpepsi's idea is awesome. \\n\\nThe final run time is `15ms`. Hope it helps!\\n\\n<hr>\\n\\n    public List<String> findWords(char[][] board, String[] words) {\\n        List<String> res = new ArrayList<>();\\n        TrieNode root = buildTrie(words);\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                dfs (board, i, j, root, res);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\\n        char c = board[i][j];\\n        if (c == '#' || p.next[c - 'a'] == null) return;\\n        p = p.next[c - 'a'];\\n        if (p.word != null) {   // found one\\n            res.add(p.word);\\n            p.word = null;     // de-duplicate\\n        }\\n\\n        board[i][j] = '#';\\n        if (i > 0) dfs(board, i - 1, j ,p, res); \\n        if (j > 0) dfs(board, i, j - 1, p, res);\\n        if (i < board.length - 1) dfs(board, i + 1, j, p, res); \\n        if (j < board[0].length - 1) dfs(board, i, j + 1, p, res); \\n        board[i][j] = c;\\n    }\\n    \\n    public TrieNode buildTrie(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String w : words) {\\n            TrieNode p = root;\\n            for (char c : w.toCharArray()) {\\n                int i = c - 'a';\\n                if (p.next[i] == null) p.next[i] = new TrieNode();\\n                p = p.next[i];\\n           }\\n           p.word = w;\\n        }\\n        return root;\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] next = new TrieNode[26];\\n        String word;\\n    }\\n\\n\\n  [1]: http://algobox.org/word-search-ii/\\n  [2]: https://leetcode.com/discuss/36337/my-simple-and-clean-java-code-using-dfs-and-trie"
		},
		{
			"lc_ans_id":"59784",
			"view":"20727",
			"top":"1",
			"title":"My simple and clean Java code using DFS and Trie",
			"vote":"85",
			"content":"Compared with [Word Search][1], I make my DFS with a tire but a word. The Trie is formed by all the words in given *words*. Then during the DFS, for each current formed word, I check if it is in the Trie.\\n\\n    public class Solution {\\n        Set<String> res = new HashSet<String>();\\n        \\n        public List<String> findWords(char[][] board, String[] words) {\\n            Trie trie = new Trie();\\n            for (String word : words) {\\n                trie.insert(word);\\n            }\\n            \\n            int m = board.length;\\n            int n = board[0].length;\\n            boolean[][] visited = new boolean[m][n];\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dfs(board, visited, \"\", i, j, trie);\\n                }\\n            }\\n            \\n            return new ArrayList<String>(res);\\n        }\\n        \\n        public void dfs(char[][] board, boolean[][] visited, String str, int x, int y, Trie trie) {\\n            if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return;\\n            if (visited[x][y]) return;\\n            \\n            str += board[x][y];\\n            if (!trie.startsWith(str)) return;\\n            \\n            if (trie.search(str)) {\\n                res.add(str);\\n            }\\n            \\n            visited[x][y] = true;\\n            dfs(board, visited, str, x - 1, y, trie);\\n            dfs(board, visited, str, x + 1, y, trie);\\n            dfs(board, visited, str, x, y - 1, trie);\\n            dfs(board, visited, str, x, y + 1, trie);\\n            visited[x][y] = false;\\n        }\\n    }\\n \\n\\n  [1]: https://leetcode.com/problems/word-search/"
		},
		{
			"lc_ans_id":"59836",
			"view":"10308",
			"top":"2",
			"title":"My C++ Trie + Backtrace based solution (48 ms)",
			"vote":"25",
			"content":"The idea is to use a Trie to build a prefix tree for words to simplify the search and do DFS to search all the possible strings. \\nFor Trie, 26 pointers to point the sub-strings and a bool leaf to indicate whether the current node is a leaf (i.e. a string in words) and also idx is used to save the index of words for the current node.\\nFor DFS, just check if the current position is visited before (board[i][j]=='X'), if so, return, check if there is a string with such prefix (nullptr == root->children[words[idx][pos]-'a']), if not, return; otherwise, check if the current searched string is a leaf of the trie (a string in words), if so, save it to res and set leaf of the trie node to false to indicate such string is already found. At last, move to its neighbors to continue the search. Remember to recover the char [i][j] at the end.    \\n\\n        class Solution {\\n            class Trie{\\n            public:\\n                Trie *children[26]; // pointers to its substrings starting with 'a' to 'z'\\n                bool leaf; // if the node is a leaf, or if there is a word stopping at here\\n                int idx; // if it is a leaf, the string index of the array words\\n                Trie()\\n                {\\n                    this->leaf = false;\\n                    this->idx = 0;\\n                    fill_n(this->children, 26, nullptr);            \\n                }\\n            };\\n            \\n        public:\\n            void insertWords(Trie *root, vector<string>& words, int idx)\\n            {\\n                int pos = 0, len = words[idx].size();\\n                while(pos<len)\\n                {\\n                    if(nullptr == root->children[words[idx][pos]-'a']) root->children[words[idx][pos]-'a'] = new Trie();\\n                    root = root->children[words[idx][pos++]-'a'];\\n                }\\n                root->leaf = true;\\n                root->idx = idx;\\n            }\\n            \\n            Trie *buildTrie(vector<string>& words)\\n            {\\n                Trie *root = new Trie(); \\n                int i;\\n                for(i=0; i<words.size();i++) insertWords(root, words, i);\\n                return root;\\n            }\\n            \\n            void checkWords(vector<vector<char>>& board, int i, int j, int row, int col, Trie *root, vector<string> &res, vector<string>& words)\\n            {\\n                char temp;\\n                if(board[i][j]=='X') return; // visited before;\\n                if(nullptr == root->children[board[i][j]-'a']) return ; // no string with such prefix\\n                else\\n                {\\n                    temp = board[i][j];\\n                    if(root->children[temp-'a']->leaf)  // if it is a leaf\\n                    {\\n                        res.push_back(words[root->children[temp-'a']->idx]);\\n                        root->children[temp-'a']->leaf = false; // set to false to indicate that we found it already\\n                    }\\n                    board[i][j]='X'; //mark the current position as visited\\n    // check all the possible neighbors\\n                    if(i>0) checkWords(board, i-1, j, row, col, root->children[temp-'a'], res, words);\\n                    if((i+1)<row) checkWords(board, i+1, j, row, col,  root->children[temp-'a'], res, words);\\n                    if(j>0) checkWords(board, i, j-1,  row, col, root->children[temp-'a'], res, words);\\n                    if((j+1)<col)  checkWords(board, i, j+1,  row, col, root->children[temp-'a'], res, words);\\n                    board[i][j] = temp; // recover the current position\\n                }\\n            }\\n        \\n            vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n               vector<string> res;\\n               int row = board.size();\\n               if(0==row) return res;\\n               int col = board[0].size();\\n               if(0==col) return res;\\n               int wordCount = words.size();\\n               if(0==wordCount) return res;\\n               \\n               Trie *root = buildTrie(words);\\n               \\n               int i,j;\\n               for(i =0 ; i<row; i++)\\n               {\\n                   for(j=0; j<col && wordCount > res.size(); j++)\\n                   {\\n                       checkWords(board, i, j, row, col, root, res, words);\\n                   }\\n               }\\n               return res;\\n            }\\n     };\\n\\nBased on the comments received. I created another version with Trie node counter (thanks,   zhiqing_xiao and gxyeecspku). However, for the current test set, it doesn't help too much. Anyway, my version with Trie node counter.\\n\\n    class Solution {\\n    private:\\n    class Trie\\n    {\\n    public:    \\n        Trie * children[26];\\n        bool isLeaf;\\n        int  wordIdx;\\n        int prefixCount;\\n        \\n        Trie()\\n        {\\n            isLeaf = false;\\n            wordIdx = 0;\\n            prefixCount = 0;\\n            fill_n(children, 26, nullptr);\\n        }\\n        \\n        ~Trie()\\n        {\\n            for(auto i=0; i<26; ++i) delete children[i];\\n        }\\n    };\\n        void insertWord(Trie *root,  const vector<string>& words, int idx)\\n        {\\n            int i, childID, len = words[idx].size();\\n            for(i=0, root->prefixCount++ ; i<len; ++i)\\n            {\\n                childID = words[idx][i]-'a';\\n                if(!root->children[childID]) root->children[childID] = new Trie();\\n                root = root->children[childID];\\n                ++root->prefixCount;\\n            }\\n            root->isLeaf = true; \\n            root->wordIdx = idx;\\n        }\\n        \\n        Trie *buildTrie(const vector<string> &words)\\n        {\\n            Trie *root = new Trie();\\n            for(int i=0; i < words.size(); ++i) insertWord(root, words, i);\\n            return root;\\n        }\\n        \\n        int dfs_Trie(vector<string> &res, Trie *root, vector<vector<char>>& board, vector<string>& words, int row, int col)\\n        {\\n            int detected = 0;\\n    \\n            if(root->isLeaf)\\n            {\\n                ++detected;\\n                root->isLeaf = false;\\n                res.push_back(words[root->wordIdx]);\\n            }\\n            \\n            if( row<0 || row>=board.size() || col<0 || col>=board[0].size() || board[row][col]=='*' || !root->children[ board[row][col]-'a'] || root->children[ board[row][col]-'a']->prefixCount <= 0 ) return detected;\\n            int curC = board[row][col] - 'a';\\n            board[row][col] = '*';\\n            detected += dfs_Trie(res, root->children[curC], board, words, row-1, col) + \\n                   dfs_Trie(res, root->children[curC], board, words, row+1, col) +    \\n                   dfs_Trie(res, root->children[curC], board, words, row, col - 1) +    \\n                   dfs_Trie(res, root->children[curC], board, words, row, col + 1) ;\\n            root->prefixCount -=detected;\\n            board[row][col] = curC+'a';\\n            return detected;\\n        }\\n        \\n    public:\\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            int M, N, wordNum = words.size();\\n            vector<string> res;\\n            if( !(M = board.size()) || !(N = board[0].size()) || !wordNum) return res;\\n            Trie *root = buildTrie(words);\\n            for(auto i=0; i<M && root->prefixCount; ++i)\\n                for(auto j=0; j<N; ++j)\\n                    dfs_Trie(res, root, board, words, i, j);\\n            delete root;\\n            return res;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"59864",
			"view":"3834",
			"top":"3",
			"title":"Python code use trie and dfs 380ms",
			"vote":"23",
			"content":"    class Solution:\\n        # @param {character[][]} board\\n        # @param {string[]} words\\n        # @return {string[]}\\n        def findWords(self, board, words):\\n        #make trie\\n            trie={}\\n            for w in words:\\n                t=trie\\n                for c in w:\\n                    if c not in t:\\n                        t[c]={}\\n                    t=t[c]\\n                t['#']='#'\\n            self.res=set()\\n            self.used=[[False]*len(board[0]) for _ in range(len(board))]\\n            for i in range(len(board)):\\n                for j in range(len(board[0])):\\n                    self.find(board,i,j,trie,'')\\n            return list(self.res)\\n        \\n        def find(self,board,i,j,trie,pre):\\n            if '#' in trie:\\n                self.res.add(pre)\\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]):\\n                return\\n            if not self.used[i][j] and board[i][j] in trie:\\n                self.used[i][j]=True\\n                self.find(board,i+1,j,trie[board[i][j]],pre+board[i][j])\\n                self.find(board,i,j+1,trie[board[i][j]],pre+board[i][j])\\n                self.find(board,i-1,j,trie[board[i][j]],pre+board[i][j])\\n                self.find(board,i,j-1,trie[board[i][j]],pre+board[i][j])\\n                self.used[i][j]=False"
		},
		{
			"lc_ans_id":"59841",
			"view":"4740",
			"top":"4",
			"title":"My AC very clean C++ code",
			"vote":"22",
			"content":"The idea is start from every position of the board, and then see if we can find a word starting from this position with checking if is_end is true in TrieNode structure\\n\\n    class TrieNode{\\n    public:\\n        bool is_end;\\n        vector<TrieNode*> children;\\n        TrieNode(){\\n            is_end=false;\\n            children=vector<TrieNode*>(26, NULL);\\n        }   \\n    };\\n    \\n    class Trie{\\n    public:\\n        TrieNode* getRoot(){return root;}\\n        Trie(vector<string>& words){\\n            root=new TrieNode();\\n            for(int i=0; i<words.size(); ++i)\\n                addWord(words[i]);\\n        }\\n        void addWord(const string& word){\\n            TrieNode* cur=root;\\n            for(int i=0; i<word.size(); ++i){\\n                int index=word[i]-'a';\\n                if(cur->children[index]==NULL)   \\n                   cur->children[index]=new TrieNode();\\n                cur=cur->children[index];    \\n            }\\n            cur->is_end=true;\\n        }\\n    private:\\n        TrieNode* root;\\n    };\\n    \\n    class Solution {\\n    public:\\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            Trie* trie = new Trie(words);\\n            TrieNode* root=trie->getRoot();\\n            set<string> result_set;\\n            for(int x=0; x<board.size(); ++x)\\n                for(int y=0; y<board[0].size(); ++y)\\n                    findWords(board, x, y, root, \"\", result_set);\\n            \\n            vector<string> result;\\n            for(auto it:result_set)    result.push_back(it);\\n            return result;        \\n        }\\n    private:\\n        void findWords(vector<vector<char>>& board, int x, int y, TrieNode* root, string word, set<string>& result){\\n            if(x<0||x>=board.size()||y<0||y>=board[0].size() || board[x][y]==' ') return;\\n            \\n            if(root->children[board[x][y]-'a'] != NULL){\\n                word=word+board[x][y];\\n                root=root->children[board[x][y]-'a']; \\n                if(root->is_end) result.insert(word);\\n                char c=board[x][y];\\n                board[x][y]=' ';\\n                findWords(board, x+1, y, root, word, result);\\n                findWords(board, x-1, y, root, word, result);\\n                findWords(board, x, y+1, root, word, result);\\n                findWords(board, x, y-1, root, word, result);\\n                board[x][y]=c;        \\n            }\\n        }\\n    };"
		},
		{
			"lc_ans_id":"59804",
			"view":"2998",
			"top":"5",
			"title":"27 lines, uses complex numbers",
			"vote":"19",
			"content":"I first build the tree of words with root `root` and also represent the board a different way, namely as one-dimensional dictionary where the keys are complex numbers representing the row/column indexes. That makes further work with it easier. Looping over all board positions is just `for z in board`, the four neighbors of a board position z are just `z + 1j**k` (for k in 0 to 3), and I don't need to check borders because `board.get` just returns \"None\" if I request an invalid position.\\n\\nAfter this preparation, I just take the tree and recursively dive with it into each board position. Similar to how you'd search a single word, but with the tree instead.\\n\\n    class Solution:\\n        def findWords(self, board, words):\\n    \\n            root = {}\\n            for word in words:\\n                node = root\\n                for c in word:\\n                    node = node.setdefault(c, {})\\n                node[None] = True\\n            board = {i + 1j*j: c\\n                     for i, row in enumerate(board)\\n                     for j, c in enumerate(row)}\\n    \\n            found = []\\n            def search(node, z, word):\\n                if node.pop(None, None):\\n                    found.append(word)\\n                c = board.get(z)\\n                if c in node:\\n                    board[z] = None\\n                    for k in range(4):\\n                        search(node[c], z + 1j**k, word + c)\\n                    board[z] = c\\n            for z in board:\\n                search(root, z, '')\\n    \\n            return found"
		},
		{
			"lc_ans_id":"59881",
			"view":"2995",
			"top":"6",
			"title":"My Java solution using Trie",
			"vote":"18",
			"content":"    public class Solution {\\n        public class TrieNode{\\n            public boolean isWord = false;\\n            public TrieNode[] child = new TrieNode[26];\\n            public TrieNode(){\\n                \\n            }\\n        }\\n        \\n        TrieNode root = new TrieNode();\\n        boolean[][] flag;\\n        public List<String> findWords(char[][] board, String[] words) {\\n            Set<String> result = new HashSet<>();\\n            flag = new boolean[board.length][board[0].length];\\n            \\n            addToTrie(words);\\n            \\n            for(int i = 0; i < board.length; i++){\\n                for(int j = 0; j < board[0].length; j++){\\n                    if(root.child[board[i][j] - 'a'] != null){\\n                        search(board, i, j, root, \"\", result);\\n                    }\\n                }\\n            }\\n            \\n            return new LinkedList<>(result);\\n        }\\n        \\n        private void addToTrie(String[] words){\\n            for(String word: words){\\n                TrieNode node = root;\\n                for(int i = 0; i < word.length(); i++){\\n                    char ch = word.charAt(i);\\n                    if(node.child[ch - 'a'] == null){\\n                        node.child[ch - 'a'] = new TrieNode();\\n                    }\\n                    node = node.child[ch - 'a'];\\n                }\\n                node.isWord = true;\\n            }\\n        }\\n        \\n        private void search(char[][] board, int i, int j, TrieNode node, String word, Set<String> result){\\n            if(i >= board.length || i < 0 || j >= board[i].length || j < 0 || flag[i][j]){\\n                return;\\n            }\\n            \\n            if(node.child[board[i][j] - 'a'] == null){\\n                return;\\n            }\\n            \\n            flag[i][j] = true;\\n            node = node.child[board[i][j] - 'a'];\\n            if(node.isWord){\\n                result.add(word + board[i][j]);\\n            }\\n            \\n            search(board, i-1, j, node, word + board[i][j], result);\\n            search(board, i+1, j, node, word + board[i][j], result);\\n            search(board, i, j-1, node, word + board[i][j], result);\\n            search(board, i, j+1, node, word + board[i][j], result);\\n            \\n            flag[i][j] = false;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"59790",
			"view":"1781",
			"top":"7",
			"title":"Python dfs solution (directly use Trie implemented).",
			"vote":"15",
			"content":"Here is an implementation based on  [Implement Trie][1] in LeetCode. TrieNode, Trie, Solution are treated as seperated classes. \\n\\n    class TrieNode():\\n        def __init__(self):\\n            self.children = collections.defaultdict(TrieNode)\\n            self.isWord = False\\n        \\n    class Trie():\\n        def __init__(self):\\n            self.root = TrieNode()\\n        \\n        def insert(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children[w]\\n            node.isWord = True\\n        \\n        def search(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children.get(w)\\n                if not node:\\n                    return False\\n            return node.isWord\\n        \\n    class Solution(object):\\n        def findWords(self, board, words):\\n            res = []\\n            trie = Trie()\\n            node = trie.root\\n            for w in words:\\n                trie.insert(w)\\n            for i in xrange(len(board)):\\n                for j in xrange(len(board[0])):\\n                    self.dfs(board, node, i, j, \"\", res)\\n            return res\\n        \\n        def dfs(self, board, node, i, j, path, res):\\n            if node.isWord:\\n                res.append(path)\\n                node.isWord = False\\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\\n                return \\n            tmp = board[i][j]\\n            node = node.children.get(tmp)\\n            if not node:\\n                return \\n            board[i][j] = \"#\"\\n            self.dfs(board, node, i+1, j, path+tmp, res)\\n            self.dfs(board, node, i-1, j, path+tmp, res)\\n            self.dfs(board, node, i, j-1, path+tmp, res)\\n            self.dfs(board, node, i, j+1, path+tmp, res)\\n            board[i][j] = tmp\\n\\n\\n  [1]: https://leetcode.com/problems/implement-trie-prefix-tree/"
		},
		{
			"lc_ans_id":"59851",
			"view":"532",
			"top":"8",
			"title":"Test Case [a], [a, a] doesn't make sense?",
			"vote":"12",
			"content":"Why is my output [\"a\", \"a\"] not correct, the description doesn't ask the output array to contain unique strings, right?\\n\\nInput: [\"a\"], [\"a\",\"a\"]\\n\\nOutput: [\"a\",\"a\"]\\n\\nExpected: [\"a\"]"
		},
		{
			"lc_ans_id":"59868",
			"view":"903",
			"top":"9",
			"title":"C++ 48ms - 56ms simple Trie structure 68lines",
			"vote":"8",
			"content":"    class Trie {\\n        public:\\n        Trie *next[26];\\n        bool exist;\\n        \\n        Trie() {\\n            fill_n(next, 26, nullptr);\\n            exist = false;\\n        }\\n        \\n        ~Trie() {\\n            for (int i = 0; i < 26; ++i)\\n                delete next[i];\\n        }\\n        \\n        void insert(const string &t) {\\n            Trie *iter = this;\\n            for (int i = 0; i < t.size(); ++i) {\\n                if (iter->next[t[i] - 'a'] == nullptr)\\n                    iter->next[t[i] - 'a'] = new Trie();\\n                iter = iter->next[t[i] - 'a'];\\n            }\\n            iter->exist = true;\\n        }\\n    };\\n\\n    class Solution {\\n        public:\\n        int m, n;\\n        \\n        vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\\n            Trie *trie = new Trie();\\n            for (auto &s : words)\\n                trie->insert(s);\\n            m = board.size();\\n            n = board[0].size();\\n            \\n            vector<string> ret;\\n            string sofar;\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    bc(board, ret, sofar, trie, i, j);\\n                }\\n            }\\n            return ret;\\n        }\\n        \\n        void bc(vector<vector<char>> &board, vector<string> &ret, string &sofar, Trie *root, int x, int y) {\\n            if (x < 0 || y < 0 || x >= m || y >= n || board[x][y] == '\\\\0' || root == nullptr)\\n                return ;\\n            if (root->next[board[x][y] - 'a'] == nullptr)\\n                return ;\\n            root = root->next[board[x][y] - 'a'];\\n            char t = '\\\\0';\\n            swap(t, board[x][y]);\\n            sofar.push_back(t);\\n            if (root->exist) {\\n                root->exist = false;\\n                ret.push_back(sofar);\\n            }\\n            bc(board, ret, sofar, root, x, y + 1);\\n            bc(board, ret, sofar, root, x + 1, y);\\n            bc(board, ret, sofar, root, x - 1, y);\\n            bc(board, ret, sofar, root, x, y - 1);\\n            swap(t, board[x][y]);\\n            sofar.pop_back();\\n        }\\n    };"
		}
	],
	"id":"212",
	"title":"Word Search II",
	"content":"<p>\r\nGiven a 2D board and a list of words from the dictionary, find all words in the board.\r\n</p>\r\n<p>\r\nEach word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\r\n</p>\r\n\r\n<p>\r\nFor example,<br />\r\nGiven <b>words</b> = <code>[\"oath\",\"pea\",\"eat\",\"rain\"]</code> and <b>board</b> = \r\n<pre>\r\n[\r\n  ['<span style=\"color:#d70\">o</span>','<span style=\"color:#d70\">a</span>','a','n'],\r\n  ['e','<span style=\"color:#d30\">t</span>','<span style=\"color:#d00\">a</span>','<span style=\"color:#d00\">e</span>'],\r\n  ['i','<span style=\"color:#d70\">h</span>','k','r'],\r\n  ['i','f','l','v']\r\n]\r\n</pre>\r\n\r\nReturn <code>[\"eat\",\"oath\"]</code>.\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b><br>\r\nYou may assume that all inputs are consist of lowercase letters <code>a-z</code>.\r\n</p>\r\n\r\n<p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show hint.</a></p>\r\n\r\n<div class=\"spoilers\"><p>You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?</p>\r\n\r\n<p>If the current candidate does not exist in all words' prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\">Implement Trie (Prefix Tree)</a> first.</p>\r\n</div>",
	"frequency":"319",
	"ac_num":"58903"
}