{
	"difficulty":"2",
	"submit_num":"457504",
	"show_id":"215",
	"leetcode_id":"215",
	"answers":[
		{
			"lc_ans_id":"60294",
			"view":"80761",
			"top":"0",
			"title":"Solution explained",
			"vote":"326",
			"content":"This problem is well known and quite often can be found in various text books.\\n\\nYou can take a couple of approaches to actually solve it:\\n\\n- O(N lg N) running time + O(1) memory\\n\\nThe simplest approach is to sort the entire input array and then access the element by it's index (which is O(1)) operation:\\n\\n----------\\n\\n    public int findKthLargest(int[] nums, int k) {\\n            final int N = nums.length;\\n            Arrays.sort(nums);\\n            return nums[N - k];\\n    }\\n\\n----------\\n\\n- O(N lg K) running time + O(K) memory\\n\\nOther possibility is to use a min oriented priority queue that will store the K-th largest values. The algorithm iterates over the whole input and maintains the size of priority queue.\\n\\n----------\\n\\n    public int findKthLargest(int[] nums, int k) {\\n\\n        final PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int val : nums) {\\n            pq.offer(val);\\n\\n            if(pq.size() > k) {\\n                pq.poll();\\n            }\\n        }\\n        return pq.peek();\\n    }\\n\\n----------\\n\\n- O(N) best case / O(N^2) worst case running time + O(1) memory\\n\\nThe smart approach for this problem is to use the selection algorithm (based on the partion method - the same one as used in quicksort).\\n\\n\\n----------\\n\\n    public int findKthLargest(int[] nums, int k) {\\n    \\n            k = nums.length - k;\\n            int lo = 0;\\n            int hi = nums.length - 1;\\n            while (lo < hi) {\\n                final int j = partition(nums, lo, hi);\\n                if(j < k) {\\n                    lo = j + 1;\\n                } else if (j > k) {\\n                    hi = j - 1;\\n                } else {\\n                    break;\\n                }\\n            }\\n            return nums[k];\\n        }\\n    \\n        private int partition(int[] a, int lo, int hi) {\\n    \\n            int i = lo;\\n            int j = hi + 1;\\n            while(true) {\\n                while(i < hi && less(a[++i], a[lo]));\\n                while(j > lo && less(a[lo], a[--j]));\\n                if(i >= j) {\\n                    break;\\n                }\\n                exch(a, i, j);\\n            }\\n            exch(a, lo, j);\\n            return j;\\n        }\\n    \\n        private void exch(int[] a, int i, int j) {\\n            final int tmp = a[i];\\n            a[i] = a[j];\\n            a[j] = tmp;\\n        }\\n    \\n        private boolean less(int v, int w) {\\n            return v < w;\\n        }\\n\\n----------\\n\\nO(N) guaranteed running time + O(1) space\\n\\nSo how can we improve the above solution and make it O(N) guaranteed? The answer is quite simple, we can randomize the input, so that even when the worst case input would be provided the algorithm wouldn't be affected. So all what it is needed to be done is to shuffle the input.\\n\\n----------\\n\\n    public int findKthLargest(int[] nums, int k) {\\n    \\n            shuffle(nums);\\n            k = nums.length - k;\\n            int lo = 0;\\n            int hi = nums.length - 1;\\n            while (lo < hi) {\\n                final int j = partition(nums, lo, hi);\\n                if(j < k) {\\n                    lo = j + 1;\\n                } else if (j > k) {\\n                    hi = j - 1;\\n                } else {\\n                    break;\\n                }\\n            }\\n            return nums[k];\\n        }\\n    \\n    private void shuffle(int a[]) {\\n    \\n            final Random random = new Random();\\n            for(int ind = 1; ind < a.length; ind++) {\\n                final int r = random.nextInt(ind + 1);\\n                exch(a, ind, r);\\n            }\\n        }\\n\\n----------\\n\\nThere is also worth mentioning the Blum-Floyd-Pratt-Rivest-Tarjan algorithm that has a guaranteed O(N) running time."
		},
		{
			"lc_ans_id":"60309",
			"view":"36457",
			"top":"1",
			"title":"4 C++ Solutions using Partition, Max-Heap, priority_queue and multiset respectively",
			"vote":"239",
			"content":"Well, this problem has a naive solution, which is to sort the array in descending order and return the `k-1`-th element. \\n\\n    class Solution {\\n    public:\\n        int findKthLargest(vector<int>& nums, int k) {\\n            sort(nums.begin(), nums.end());\\n            return nums[k - 1];\\n        }\\n    }; \\n\\nHowever, sorting algorithm gives `O(nlogn)` complexity. Suppose `n = 10000` and `k = 2`, then we are doing a lot of unnecessary operations. In fact, this problem has at least two simple and faster solutions.\\n\\nWell, the faster solution has no mystery. It is also closely related to sorting. I will give two algorithms for this problem below, one using quicksort(specifically, the partition subroutine) and the other using heapsort.\\n\\n----------\\n**Quicksort**\\n\\nIn quicksort, in each iteration, we need to select a pivot and then partition the array into three parts:\\n\\n 1. Elements smaller than the pivot;\\n 2. Elements equal to the pivot;\\n 3. Elements larger than the pivot.\\n\\nNow, let's do an example with the array `[3, 2, 1, 5, 4, 6]` in the problem statement. Let's assume in each time we select the leftmost element to be the pivot, in this case, `3`. We then use it to partition the array into the above 3 parts, which results in `[1, 2, 3, 5, 4, 6]`. Now `3` is in the third position and we know that it is the third smallest element. Now, do you recognize that this subroutine can be used to solve this problem? \\n\\nIn fact, the above partition puts elements smaller than the pivot  before the pivot and thus the pivot will then be the `k`-th smallest element if it is at the `k-1`-th position. Since the problem requires us to find the `k`-th largest element, we can simply modify the partition to put elements larger than the pivot before the pivot. That is, after partition, the array becomes `[5, 6, 4, 3, 1, 2]`. Now we know that `3` is the `4`-th largest element. If we are asked to find the `2`-th largest element, then we know it is left to `3`. If we are asked to find the `5`-th largest element, then we know it is right to `3`. So, in the **average** sense, the problem is reduced to approximately half of its original size, giving the recursion `T(n) = T(n/2) + O(n)` in which `O(n)` is the time for partition. This recursion, once solved, gives `T(n) = O(n)` and thus we have a linear time solution. Note that since we only need to consider one half of the array, the time complexity is `O(n)`. If we need to consider both the two halves of the array, like quicksort, then the recursion will be `T(n) = 2T(n/2) + O(n)` and the complexity will be `O(nlogn)`. \\n\\nOf course, `O(n)` is the average time complexity. In the worst case, the recursion may become `T(n) = T(n - 1) + O(n)` and the complexity will be `O(n^2)`. \\n\\nNow let's briefly write down the algorithm before writing our codes.\\n\\n 1. Initialize `left` to be 0 and `right` to be `nums.size() - 1`;\\n 2. Partition the array, if the pivot is at the `k-1`-th position, return it (we are done);\\n 3. If the pivot is right to the `k-1`-th position, update `right` to be the left neighbor of the pivot;\\n 4. Else update `left` to be the right neighbor of the pivot.\\n 5. Repeat 2.\\n\\nNow let's turn it into code.\\n\\n    class Solution { \\n    public:\\n        int partition(vector<int>& nums, int left, int right) {\\n            int pivot = nums[left];\\n            int l = left + 1, r = right;\\n            while (l <= r) {\\n                if (nums[l] < pivot && nums[r] > pivot)\\n                    swap(nums[l++], nums[r--]);\\n                if (nums[l] >= pivot) l++; \\n                if (nums[r] <= pivot) r--;\\n            }\\n            swap(nums[left], nums[r]);\\n            return r;\\n        }\\n        \\n        int findKthLargest(vector<int>& nums, int k) {\\n            int left = 0, right = nums.size() - 1;\\n            while (true) {\\n                int pos = partition(nums, left, right);\\n                if (pos == k - 1) return nums[pos];\\n                if (pos > k - 1) right = pos - 1;\\n                else left = pos + 1;\\n            }\\n        }\\n    };\\n\\n----------\\n**Heapsort**\\n\\nWell, this problem still has a tag \"heap\". If you are familiar with heapsort, you can solve this problem using the following idea:\\n\\n 1. Build a max-heap for `nums`, set `heap_size` to be `nums.size()`;\\n 2. Swap `nums[0]` (after buding the max-heap, it will be the largest element) with `nums[heap_size - 1]` (currently the last element). Then decrease `heap_size` by 1 and max-heapify `nums` (recovering its max-heap property) at index `0`;\\n 3. Repeat 2 for `k` times and the `k`-th largest element will be stored finally at `nums[heap_size]`.\\n\\nNow I paste my code below. If you find it tricky, I suggest you to read the Heapsort chapter of Introduction to Algorithms, which has a nice explanation of the algorithm. My code simply translates the pseudo code in that book :-) \\n    \\n    class Solution {\\n    public:   \\n        inline int left(int idx) {\\n            return (idx << 1) + 1;\\n        }\\n        inline int right(int idx) {\\n            return (idx << 1) + 2;\\n        }\\n        void max_heapify(vector<int>& nums, int idx) {\\n            int largest = idx;\\n            int l = left(idx), r = right(idx);\\n            if (l < heap_size && nums[l] > nums[largest]) largest = l;\\n            if (r < heap_size && nums[r] > nums[largest]) largest = r;\\n            if (largest != idx) {\\n                swap(nums[idx], nums[largest]);\\n                max_heapify(nums, largest);\\n            }\\n        }\\n        void build_max_heap(vector<int>& nums) {\\n            heap_size = nums.size();\\n            for (int i = (heap_size >> 1) - 1; i >= 0; i--)\\n                max_heapify(nums, i);\\n        }\\n        int findKthLargest(vector<int>& nums, int k) {\\n            build_max_heap(nums);\\n            for (int i = 0; i < k; i++) {\\n                swap(nums[0], nums[heap_size - 1]);\\n                heap_size--;\\n                max_heapify(nums, 0);\\n            }\\n            return nums[heap_size];\\n        }\\n    private:\\n        int heap_size;\\n    }\\n\\nIf we are allowed to use the built-in `priority_queue`, the code will be much more shorter :-)\\n\\n    class Solution {\\n    public:\\n        int findKthLargest(vector<int>& nums, int k) {\\n            priority_queue<int> pq(nums.begin(), nums.end());\\n            for (int i = 0; i < k - 1; i++)\\n                pq.pop(); \\n            return pq.top();\\n        }\\n    }; \\n\\nWell, the `priority_queue` can also be replaced by `multiset` :-)\\n\\n    class Solution {\\n    public:\\n        int findKthLargest(vector<int>& nums, int k) {\\n            multiset<int> mset;\\n            int n = nums.size();\\n            for (int i = 0; i < n; i++) { \\n                mset.insert(nums[i]);\\n                if (mset.size() > k)\\n                    mset.erase(mset.begin());\\n            }\\n            return *mset.begin();\\n        }\\n    };"
		},
		{
			"lc_ans_id":"60312",
			"view":"31381",
			"top":"2",
			"title":"AC Clean QuickSelect Java solution avg. O(n) time",
			"vote":"92",
			"content":"https://en.wikipedia.org/wiki/Quickselect\\n\\n    public class Solution {\\n      \\n      public int findKthLargest(int[] a, int k) {\\n        int n = a.length;\\n        int p = quickSelect(a, 0, n - 1, n - k + 1);\\n        return a[p];\\n      }\\n      \\n      // return the index of the kth smallest number\\n      int quickSelect(int[] a, int lo, int hi, int k) {\\n        // use quick sort's idea\\n        // put nums that are <= pivot to the left\\n        // put nums that are  > pivot to the right\\n        int i = lo, j = hi, pivot = a[hi];\\n        while (i < j) {\\n          if (a[i++] > pivot) swap(a, --i, --j);\\n        }\\n        swap(a, i, hi);\\n        \\n        // count the nums that are <= pivot from lo\\n        int m = i - lo + 1;\\n        \\n        // pivot is the one!\\n        if (m == k)     return i;\\n        // pivot is too big, so it must be on the left\\n        else if (m > k) return quickSelect(a, lo, i - 1, k);\\n        // pivot is too small, so it must be on the right\\n        else            return quickSelect(a, i + 1, hi, k - m);\\n      }\\n      \\n      void swap(int[] a, int i, int j) {\\n        int tmp = a[i];\\n        a[i] = a[j];\\n        a[j] = tmp;\\n      }\\n    \\n    }"
		},
		{
			"lc_ans_id":"60306",
			"view":"10009",
			"top":"3",
			"title":"Python different solutions with comments (bubble sort, selection sort, heap sort and quick sort).",
			"vote":"45",
			"content":"        \\n    # O(nlgn) time\\n    def findKthLargest1(self, nums, k):\\n        return sorted(nums, reverse=True)[k-1]\\n        \\n    # O(nk) time, bubble sort idea, TLE\\n    def findKthLargest2(self, nums, k):\\n        for i in xrange(k):\\n            for j in xrange(len(nums)-i-1):\\n                if nums[j] > nums[j+1]:\\n                    # exchange elements, time consuming\\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\\n        return nums[len(nums)-k]\\n        \\n    # O(nk) time, selection sort idea\\n    def findKthLargest3(self, nums, k):\\n        for i in xrange(len(nums), len(nums)-k, -1):\\n            tmp = 0\\n            for j in xrange(i):\\n                if nums[j] > nums[tmp]:\\n                    tmp = j\\n            nums[tmp], nums[i-1] = nums[i-1], nums[tmp]\\n        return nums[len(nums)-k]\\n        \\n    # O(k+(n-k)lgk) time, min-heap\\n    def findKthLargest4(self, nums, k):\\n        heap = []\\n        for num in nums:\\n            heapq.heappush(heap, num)\\n        for _ in xrange(len(nums)-k):\\n            heapq.heappop(heap)\\n        return heapq.heappop(heap)\\n    \\n    # O(k+(n-k)lgk) time, min-heap        \\n    def findKthLargest5(self, nums, k):\\n        return heapq.nlargest(k, nums)[k-1]\\n        \\n    # O(n) time, quick selection\\n    def findKthLargest(self, nums, k):\\n        # convert the kth largest to smallest\\n        return self.findKthSmallest(nums, len(nums)+1-k)\\n        \\n    def findKthSmallest(self, nums, k):\\n        if nums:\\n            pos = self.partition(nums, 0, len(nums)-1)\\n            if k > pos+1:\\n                return self.findKthSmallest(nums[pos+1:], k-pos-1)\\n            elif k < pos+1:\\n                return self.findKthSmallest(nums[:pos], k)\\n            else:\\n                return nums[pos]\\n     \\n    # choose the right-most element as pivot   \\n    def partition(self, nums, l, r):\\n        low = l\\n        while l < r:\\n            if nums[l] < nums[r]:\\n                nums[l], nums[low] = nums[low], nums[l]\\n                low += 1\\n            l += 1\\n        nums[low], nums[r] = nums[r], nums[low]\\n        return low"
		},
		{
			"lc_ans_id":"60333",
			"view":"18091",
			"top":"4",
			"title":"Concise JAVA solution based on Quick Select",
			"vote":"44",
			"content":"The basic idea is to use Quick Select algorithm to  partition the array with pivot: \\n\\n    Put numbers < pivot to pivot's left\\n    Put numbers > pivot to pivot's right\\nThen \\n\\n    if indexOfPivot == k, return A[k]\\n    else if indexOfPivot < k, keep checking left part to pivot\\n    else if indexOfPivot > k, keep checking right part to pivot\\n\\n**Time complexity = O(n)**\\n\\nDiscard half each time: n+(n/2)+(n/4)..1 = n + (n-1) = O(2n-1) = O(n), because n/2+n/4+n/8+..1=n-1.\\n\\n**Quick Select Solution Code:** \\n\\n    public int findKthLargest(int[] nums, int k) {\\n    \\tif (nums == null || nums.length == 0) return Integer.MAX_VALUE;\\n        return findKthLargest(nums, 0, nums.length - 1, nums.length - k);\\n    }    \\n    \\n    public int findKthLargest(int[] nums, int start, int end, int k) {// quick select: kth smallest\\n    \\tif (start > end) return Integer.MAX_VALUE;\\n    \\t\\n    \\tint pivot = nums[end];// Take A[end] as the pivot, \\n    \\tint left = start;\\n    \\tfor (int i = start; i < end; i++) {\\n    \\t\\tif (nums[i] <= pivot) // Put numbers < pivot to pivot's left\\n    \\t\\t\\tswap(nums, left++, i);\\t\\t\\t\\n    \\t}\\n    \\tswap(nums, left, end);// Finally, swap A[end] with A[left]\\n    \\t\\n    \\tif (left == k)// Found kth smallest number\\n    \\t\\treturn nums[left];\\n    \\telse if (left < k)// Check right part\\n    \\t\\treturn findKthLargest(nums, left + 1, end, k);\\n    \\telse // Check left part\\n    \\t\\treturn findKthLargest(nums, start, left - 1, k);\\n    } \\n    \\n    void swap(int[] A, int i, int j) {\\n    \\tint tmp = A[i];\\n    \\tA[i] = A[j];\\n    \\tA[j] = tmp;\\t\\t\\t\\t\\n    }"
		},
		{
			"lc_ans_id":"60300",
			"view":"12022",
			"top":"5",
			"title":"Java Quick Select",
			"vote":"25",
			"content":"Personally, the most straightforward way is to use quick select. There is a simple conversion: Find kith largest element is equivalent to find (n - k)th smallest element in array. It is worth mentioning that (n - k) is the real index (start from 0) of an element. \\n\\n    public class Solution {\\n        public int findKthLargest(int[] nums, int k) {\\n            int start = 0, end = nums.length - 1, index = nums.length - k;\\n            while (start < end) {\\n                int pivot = partion(nums, start, end);\\n                if (pivot < index) start = pivot + 1; \\n                else if (pivot > index) end = pivot - 1;\\n                else return nums[pivot];\\n            }\\n            return nums[start];\\n        }\\n        \\n        private int partion(int[] nums, int start, int end) {\\n            int pivot = start, temp;\\n            while (start <= end) {\\n                while (start <= end && nums[start] <= nums[pivot]) start++;\\n                while (start <= end && nums[end] > nums[pivot]) end--;\\n                if (start > end) break;\\n                temp = nums[start];\\n                nums[start] = nums[end];\\n                nums[end] = temp;\\n            }\\n            temp = nums[end];\\n            nums[end] = nums[pivot];\\n            nums[pivot] = temp;\\n            return end;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"60580",
			"view":"3270",
			"top":"6",
			"title":"Java PriorityQueue O(n * log k)",
			"vote":"19",
			"content":"    public class Solution {\\n                public int findKthLargest(int[] nums, int k) {\\n                    PriorityQueue<Integer> largeK = new PriorityQueue<Integer>(k + 1);\\n        \\n                    for(int el : nums) {\\n                        largeK.add(el);\\n                        if (largeK.size() > k) {\\n                            largeK.poll();\\n                        }\\n                    }\\n    \\n                    return largeK.poll();\\n                }\\n    }"
		},
		{
			"lc_ans_id":"60520",
			"view":"2812",
			"top":"7",
			"title":"4ms c++ solution. straightforward to find largest k. kind like a partition version.",
			"vote":"17",
			"content":"    class Solution {\\n    public:\\n        int findKthLargest(vector<int>& nums, int k) {\\n            int cur=nums[k-1];\\n            vector<int> bigger;\\n            vector<int> smaller;\\n            for(size_t i=0; i<nums.size(); ++i){\\n                if(i==k-1) continue;\\n                if(nums[i]>=cur) bigger.push_back(nums[i]);\\n                else smaller.push_back(nums[i]);\\n            }\\n            if(bigger.size()==k-1) return cur;\\n            if(bigger.size()>k-1) return findKthLargest(bigger,k);\\n            if(bigger.size()<k-1) return findKthLargest(smaller,k-bigger.size()-1);\\n        }\\n    };"
		},
		{
			"lc_ans_id":"60293",
			"view":"2738",
			"top":"8",
			"title":"Share my Python solution with QuickSelect idea",
			"vote":"15",
			"content":"    class Solution:\\n    # @param {integer[]} nums\\n    # @param {integer} k\\n    # @return {integer}\\n    def findKthLargest(self, nums, k):\\n        # QuickSelect idea: AC in 52 ms\\n        # ---------------------------\\n        #\\n        pivot = nums[0]\\n        left  = [l for l in nums if l < pivot]\\n        equal = [e for e in nums if e == pivot]\\n        right = [r for r in nums if r > pivot]\\n\\n        if k <= len(right):\\n            return self.findKthLargest(right, k)\\n        elif (k - len(right)) <= len(equal):\\n            return equal[0]\\n        else:\\n            return self.findKthLargest(left, k - len(right) - len(equal))"
		},
		{
			"lc_ans_id":"60510",
			"view":"2105",
			"top":"9",
			"title":"97% 2ms Java quick select solution",
			"vote":"10",
			"content":"    public class Solution {\\n        \\n        public int findKthLargest(int[] nums, int k) {\\n    \\n            return select(nums, k-1);\\n        }\\n        \\n        // Quick select\\n        private int select(int[] nums, int k) {\\n            int left = 0, right = nums.length-1;\\n            while(true) {\\n                if(left == right)\\n                    return nums[left];\\n                int pivotIndex = medianOf3(nums, left, right);\\n                pivotIndex = partition(nums, left, right, pivotIndex);\\n                if(pivotIndex == k)\\n                    return nums[k];\\n                else if(pivotIndex > k)\\n                    right = pivotIndex-1;\\n                else\\n                    left = pivotIndex+1;\\n            }\\n        }\\n        \\n        //Use median-of-three strategy to choose pivot\\n        private int medianOf3(int[] nums, int left, int right) {\\n            int mid = left + (right - left) / 2;\\n            if(nums[right] > nums[left])\\n                swap(nums, left, right);\\n            if(nums[right] > nums[mid])\\n                swap(nums, right, mid);\\n            if(nums[mid] > nums[left])\\n                swap(nums,left, mid);\\n            return mid;\\n        }\\n        \\n        private int partition(int[] nums, int left, int right, int pivotIndex) {\\n            int pivotValue = nums[pivotIndex];\\n            swap(nums, pivotIndex, right);\\n            int index = left;\\n            for(int i = left; i < right; ++i) {\\n                if(nums[i] > pivotValue) {\\n                    swap(nums, index, i);\\n                    ++index;\\n                }\\n            }\\n            swap(nums, right, index);\\n            return index;\\n        }\\n        \\n        private void swap(int[] nums, int a, int b) {\\n            int temp = nums[a];\\n            nums[a] = nums[b];\\n            nums[b] = temp;\\n        }\\n    \\n    }"
		}
	],
	"id":"215",
	"title":"Kth Largest Element in an Array",
	"content":"Find the <b>k</b>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\r\n\r\n<p>For example,<br>\r\nGiven <code>[3,2,1,5,6,4]</code> and k = 2, return 5.\r\n</p>\r\n\r\n<p><b>Note: </b><br>\r\nYou may assume k is always valid, 1 &le; k &le; array's length.</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/mithmatt\">@mithmatt</a> for adding this problem and creating all test cases.</p>",
	"frequency":"420",
	"ac_num":"184237"
}