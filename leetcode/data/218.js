{
	"difficulty":"3",
	"submit_num":"194603",
	"show_id":"218",
	"leetcode_id":"218",
	"answers":[
		{
			"lc_ans_id":"61197",
			"view":"41829",
			"top":"0",
			"title":"(Guaranteed) Really Detailed and Good (Perfect) Explanation of The Skyline Problem",
			"vote":"468",
			"content":"Please, do not ever say detailed explanation if you are not explaining you thoughts very clear!\\nJust posting code with some comments is not explanation at all, OK? \\n \\nAll the posts I have seen with explanations is just different style of obscure.\\n\\nCheck the following link, that is authentic detailed explanation! your understanding is almost GUARANTEED!\\n\\n[https://briangordon.github.io/2014/08/the-skyline-problem.html][1]\\n \\n\\n\\n  [1]: https://briangordon.github.io/2014/08/the-skyline-problem.html"
		},
		{
			"lc_ans_id":"61193",
			"view":"39663",
			"top":"1",
			"title":"Short Java solution",
			"vote":"186",
			"content":"    \\tpublic List<int[]> getSkyline(int[][] buildings) {\\n\\t    List<int[]> result = new ArrayList<>();\\n\\t    List<int[]> height = new ArrayList<>();\\n\\t    for(int[] b:buildings) {\\n\\t        height.add(new int[]{b[0], -b[2]});\\n\\t        height.add(new int[]{b[1], b[2]});\\n\\t    }\\n\\t    Collections.sort(height, (a, b) -> {\\n\\t            if(a[0] != b[0]) \\n\\t                return a[0] - b[0];\\n\\t            return a[1] - b[1];\\n\\t    });\\n\\t    Queue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n\\t    pq.offer(0);\\n\\t    int prev = 0;\\n\\t    for(int[] h:height) {\\n\\t        if(h[1] < 0) {\\n\\t            pq.offer(-h[1]);\\n\\t        } else {\\n\\t            pq.remove(h[1]);\\n\\t        }\\n\\t        int cur = pq.peek();\\n\\t        if(prev != cur) {\\n\\t            result.add(new int[]{h[0], cur});\\n\\t            prev = cur;\\n\\t        }\\n\\t    }\\n\\t    return result;\\n\\t}"
		},
		{
			"lc_ans_id":"61279",
			"view":"18171",
			"top":"2",
			"title":"My C++ code using one priority queue (812 ms)",
			"vote":"81",
			"content":"The idea is to  do line sweep and just process the buildings only at the start and end points. The key is to use a priority queue to save all the buildings that are still \"alive\". The queue is sorted by its height and end time (the larger height first and if equal height, the one with a bigger end time first). For each iteration, we  first find the current process time, which is either the next new building start time or the end time of the top entry of the live queue. If the new building start time is larger than the top one end time, then process  the one in the queue first (pop them until it is empty or find the first one that ends after the new building); otherswise, if the new building starts before the top one ends, then process the new building (just put them in the queue). After processing, output it to the resulting vector if the height changes. Complexity is the worst case O(NlogN)\\n\\nNot sure why my algorithm is so slow considering others' Python solution can achieve 160ms, any commments?\\n\\n    class Solution {\\n    public:\\n        vector<pair<int, int>> getSkyline(vector<vector<int>>& buildings) {\\n            vector<pair<int, int>> res;\\n            int cur=0, cur_X, cur_H =-1,  len = buildings.size();\\n            priority_queue< pair<int, int>> liveBlg; // first: height, second, end time\\n            while(cur<len || !liveBlg.empty())\\n            { // if either some new building is not processed or live building queue is not empty\\n                cur_X = liveBlg.empty()? buildings[cur][0]:liveBlg.top().second; // next timing point to process\\n    \\n                if(cur>=len || buildings[cur][0] > cur_X)\\n                { //first check if the current tallest building will end before the next timing point\\n                      // pop up the processed buildings, i.e. those  have height no larger than cur_H and end before the top one\\n                    while(!liveBlg.empty() && ( liveBlg.top().second <= cur_X) ) liveBlg.pop();\\n                }\\n                else\\n                { // if the next new building starts before the top one ends, process the new building in the vector\\n                    cur_X = buildings[cur][0];\\n                    while(cur<len && buildings[cur][0]== cur_X)  // go through all the new buildings that starts at the same point\\n                    {  // just push them in the queue\\n                        liveBlg.push(make_pair(buildings[cur][2], buildings[cur][1]));\\n                        cur++;\\n                    }\\n                }\\n                cur_H = liveBlg.empty()?0:liveBlg.top().first; // outut the top one\\n                if(res.empty() || (res.back().second != cur_H) ) res.push_back(make_pair(cur_X, cur_H));\\n            }\\n            return res;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"61192",
			"view":"14302",
			"top":"3",
			"title":"Once for all, explanation with clean Java code(O(n^2)time, O(n) space)",
			"vote":"80",
			"content":"Though I came up with  a solution using PriorityQueue and BST, this problems still confuses me. To make it more clear, I went through it several times and investigated several good solutions on this forum.\\n\\nHere is my explanation which tries to make understanding this easier and may help you write a bug-free solution quickly.\\n\\nWhen visiting all start points and end points in order:\\n\\nObservations:\\n\\n1. If a position is shadowed by other buildings\\n\\n        1. height of that building is larger than the building to which current\\n            position belong;\\n        2. the start point of that building must be smaller(or equal to) than this\\n            position;\\n        3. the end point of that building must be larger(or equal to) than this\\n            position;\\n\\nTus we have:\\n\\n    1. when you reach a start point, the height of current building immediately\\n        takes effect which means it could possibly affect the contour or shadow\\n        others when mixed with other following buildings;\\n    2. when you reach a end point, the height of current building will stop its\\n        influences;\\n    3. our target exists at the position where height change happens and there\\n        is nothing above it shadowing it;\\n\\nObviously, to implement the idea that 'current height takes effect' and 'find out whether current height is shadowed by other buildings',  we need a mechanism to store current taking effect heights, meanwhile, figure out which one is the maximum, delete it if needed efficiently, which hints us to use a priority queue or BST.\\n\\nThus, our algorithm could be summarised in following pseudo code:\\n\\n    for position in sorted(all start points and all end points)\\n           if this position is a start point\\n                  add its height\\n           else if this position is a end point\\n                  delete its height\\n           compare current max height with previous max height, if different, add\\n           current position together with this new max height to our result, at the\\n           same time, update previous max height to current max height;\\n\\nTo implement this algorithm, here are some concrete examples:\\n\\n1. In my implementation, I use a PriorityQueue to store end point values when visiting a start point, and store the [height, end point value] into a TreeMap. Thus:\\n      1. when moving to next start point value, I can compare the next start point value with elements in PriorityQueue, thus achieving visiting all start points and end points in order(exploits the fact that start points are already sorted);\\n      2. Meantime, I can get current max height from TreeMap in O(logn);\\n      3. However, to delete a height when visiting a end point, I have to use 'map.values.remove()' which is a method defined in Collection interface and tends to be slower(O(n) is this case, plz correct me if I'm wrong);\\n\\nMy code can be found at https://leetcode.com/discuss/62617/short-and-clean-java-solution-heap-and-treemap\\n\\n2. Following is wujin's implementation(plz refer to https://leetcode.com/discuss/54201/short-java-solution). This one is quite straightforward, clean and clever.\\n\\nFirstly, please notice what we need to achieve:\\n\\n      1. visit all start points and all end points in order;\\n      2. when visiting a point, we need to know whether it is a start point or a\\n          end point, based on which we can add a height or delete a height from\\n          our data structure;\\n\\nTo achieve this, his implementation:\\n\\n      1. use a int[][] to collect all [start point, - height] and [end point, height]\\n          for every building;\\n      2. sort it, firstly based on the first value, then use the second to break\\n          ties;\\n\\nThus,\\n\\n      1. we can visit all points in order;\\n      2. when points have the same value, higher height will shadow the lower one;\\n      3. we know whether current point is a start point or a end point based on the\\n          sign of its height;\\n\\nHis code is as follows(clear and concise) as reference with my comment(again, https://leetcode.com/discuss/54201/short-java-solution):\\n\\n    public List<int[]> getSkyline(int[][] buildings) {\\n        List<int[]> result = new ArrayList<>();\\n        List<int[]> height = new ArrayList<>();\\n        for(int[] b:buildings) {\\n            // start point has negative height value\\n            height.add(new int[]{b[0], -b[2]});\\n            // end point has normal height value\\n            height.add(new int[]{b[1], b[2]}); \\n        }\\n\\n        // sort $height, based on the first value, if necessary, use the second to\\n        // break ties\\n        Collections.sort(height, (a, b) -> {\\n                if(a[0] != b[0]) \\n                    return a[0] - b[0];\\n                return a[1] - b[1];\\n        });\\n\\n        // Use a maxHeap to store possible heights\\n        Queue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n\\n        // Provide a initial value to make it more consistent\\n        pq.offer(0);\\n\\n        // Before starting, the previous max height is 0;\\n        int prev = 0;\\n\\n        // visit all points in order\\n        for(int[] h:height) {\\n            if(h[1] < 0) { // a start point, add height\\n                pq.offer(-h[1]);\\n            } else {  // a end point, remove height\\n                pq.remove(h[1]);\\n            }\\n            int cur = pq.peek(); // current max height;\\n      \\n            // compare current max height with previous max height, update result and \\n            // previous max height if necessary\\n            if(prev != cur) {\\n                result.add(new int[]{h[0], cur});\\n                prev = cur;\\n            }\\n        }\\n        return result;\\n    }\\n\\nHopefully now, you can write a good solution in a blink with good understanding..."
		},
		{
			"lc_ans_id":"61246",
			"view":"10528",
			"top":"4",
			"title":"Share my divide and conquer java solution, 464 ms",
			"vote":"68",
			"content":"Detailed explanation: http://www.geeksforgeeks.org/divide-and-conquer-set-7-the-skyline-problem/\\n\\n    public class Solution {\\n    \\tpublic List<int[]> getSkyline(int[][] buildings) {\\n    \\t\\tif (buildings.length == 0)\\n    \\t\\t\\treturn new LinkedList<int[]>();\\n    \\t\\treturn recurSkyline(buildings, 0, buildings.length - 1);\\n    \\t}\\n    \\n    \\tprivate LinkedList<int[]> recurSkyline(int[][] buildings, int p, int q) {\\n    \\t\\tif (p < q) {\\n    \\t\\t\\tint mid = p + (q - p) / 2;\\n    \\t\\t\\treturn merge(recurSkyline(buildings, p, mid),\\n    \\t\\t\\t\\t\\trecurSkyline(buildings, mid + 1, q));\\n    \\t\\t} else {\\n    \\t\\t\\tLinkedList<int[]> rs = new LinkedList<int[]>();\\n    \\t\\t\\trs.add(new int[] { buildings[p][0], buildings[p][2] });\\n    \\t\\t\\trs.add(new int[] { buildings[p][1], 0 });\\n    \\t\\t\\treturn rs;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\tprivate LinkedList<int[]> merge(LinkedList<int[]> l1, LinkedList<int[]> l2) {\\n    \\t\\tLinkedList<int[]> rs = new LinkedList<int[]>();\\n    \\t\\tint h1 = 0, h2 = 0;\\n    \\t\\twhile (l1.size() > 0 && l2.size() > 0) {\\n    \\t\\t\\tint x = 0, h = 0;\\n    \\t\\t\\tif (l1.getFirst()[0] < l2.getFirst()[0]) {\\n    \\t\\t\\t\\tx = l1.getFirst()[0];\\n    \\t\\t\\t\\th1 = l1.getFirst()[1];\\n    \\t\\t\\t\\th = Math.max(h1, h2);\\n    \\t\\t\\t\\tl1.removeFirst();\\n    \\t\\t\\t} else if (l1.getFirst()[0] > l2.getFirst()[0]) {\\n    \\t\\t\\t\\tx = l2.getFirst()[0];\\n    \\t\\t\\t\\th2 = l2.getFirst()[1];\\n    \\t\\t\\t\\th = Math.max(h1, h2);\\n    \\t\\t\\t\\tl2.removeFirst();\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tx = l1.getFirst()[0];\\n    \\t\\t\\t\\th1 = l1.getFirst()[1];\\n    \\t\\t\\t\\th2 = l2.getFirst()[1];\\n    \\t\\t\\t\\th = Math.max(h1, h2);\\n    \\t\\t\\t\\tl1.removeFirst();\\n    \\t\\t\\t\\tl2.removeFirst();\\n    \\t\\t\\t}\\n    \\t\\t\\tif (rs.size() == 0 || h != rs.getLast()[1]) {\\n    \\t\\t\\t\\trs.add(new int[] { x, h });\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\trs.addAll(l1);\\n    \\t\\trs.addAll(l2);\\n    \\t\\treturn rs;\\n    \\t}\\n    }"
		},
		{
			"lc_ans_id":"61222",
			"view":"6848",
			"top":"5",
			"title":"17-Line O(n log n)-time O(n)-space C++ Accepted Easy Solution w/ Explanations",
			"vote":"47",
			"content":"General idea:\\n\\n- Step 1:\\n\\n   Use a multimap to sort all boundary points. For a start point of an interval, let the height be positive; otherwise, let the height be negative. Time complexity: *O*(n log n)\\n\\n- Step 2:\\n\\n   Use a multiset (rather than a heap/priority_queue) to maintain the current set of heights to be considered. If a new start point is met, insert the height into the set, otherwise, delete the height. The current max height is the back() element of the multiset. For each point, the time complexity is O(log n). The overall time complexity is *O*(n log n).\\n\\n- Step 3:\\n\\n   Delete the points with equal heights. Time: *O*(n)\\n\\n----------\\n\\nTime Complexity: *O*(n log n)\\n\\nSpace Complexity: *O*(n)\\n\\n----------\\n\\n\\n**C++**\\n\\n    class Solution {\\n    public:\\n    \\tvector<pair<int, int>> getSkyline(vector<vector<int>>& buildings) {\\n\\n            // Step 1:\\n    \\t\\tmultimap<int, int> coords;\\n    \\t\\tfor (const vector<int> & building : buildings) {\\n    \\t\\t\\tcoords.emplace(building[0], building[2]);\\n    \\t\\t\\tcoords.emplace(building[1], -building[2]);\\n    \\t\\t}\\n    \\n            // Step 2:\\n    \\t\\tmultiset<int> heights = { 0 };\\n    \\t\\tmap<int, int> corners;\\n    \\t\\tfor (const pair<int, int> & p : coords) {\\n    \\t\\t\\tif (p.second > 0) {\\n    \\t\\t\\t\\theights.insert(p.second);\\n    \\t\\t\\t}\\n    \\t\\t\\telse {\\n    \\t\\t\\t\\theights.erase(heights.find(-p.second));\\n    \\t\\t\\t}\\n    \\t\\t\\tint cur_y = *heights.rbegin();\\n    \\t\\t\\tcorners[p.first] = cur_y;\\n    \\t\\t}\\n    \\n            // Step 3:\\n    \\t\\tfunction<bool(pair<int, int> l, pair<int, int> r)> eq2nd = [](pair<int, int> l, pair<int, int> r){ return l.second == r.second;  };\\n    \\t\\tvector<pair<int, int>> results;\\n    \\t\\tunique_copy(corners.begin(), corners.end(), back_insert_iterator<vector<pair<int, int>>>(results), eq2nd);\\n    \\t\\treturn results;\\n    \\t}\\n    };\\n\\n\\n----------\\n\\n\\nIn fact, the last two steps can be merged together:\\n\\n**Yet another solution (C++):**\\n\\n\\n    class Solution {\\n    public:\\n    \\tvector<pair<int, int>> getSkyline(vector<vector<int>>& buildings) {\\n    \\t\\tmultimap<int, int> coords;\\n    \\t\\tfor (const vector<int> & building : buildings) {\\n    \\t\\t\\tcoords.emplace(building[0], building[2]);\\n    \\t\\t\\tcoords.emplace(building[1], -building[2]);\\n    \\t\\t}\\n    \\n    \\t\\tmultiset<int> heights = { 0 };\\n    \\t\\tvector<pair<int, int>> corners;\\n    \\t\\tint x = -1;\\n    \\t\\tint y = 0;\\n    \\t\\tfor (const pair<int, int> & p : coords) {\\n    \\t\\t\\tif ((x >= 0) && (p.first != x) && (corners.empty() || (corners.rbegin()->second != y))) {\\n    \\t\\t\\t\\tcorners.emplace_back(x, y);\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\tif (p.second >= 0) {\\n    \\t\\t\\t\\theights.insert(p.second);\\n    \\t\\t\\t}\\n    \\t\\t\\telse {\\n    \\t\\t\\t\\theights.erase(heights.find(-p.second));\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\tx = p.first;\\n    \\t\\t\\ty = *heights.rbegin();\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif (!corners.empty()) {\\n    \\t\\t\\tcorners.emplace_back(x, 0);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn corners;\\n    \\t}\\n    };"
		},
		{
			"lc_ans_id":"61194",
			"view":"13428",
			"top":"6",
			"title":"108 ms, 17 lines body, explained",
			"vote":"45",
			"content":"This is a Python version of [my modification](https://leetcode.com/discuss/37630/my-c-code-using-one-priority-queue-812-ms?show=37735#c37735) of [dong.wang.1694's brilliant C++ solution](https://leetcode.com/discuss/37630/my-c-code-using-one-priority-queue-812-ms). It sweeps from left to right. But it doesn't only keep *heights* of \"alive buildings\" in the priority queue and it doesn't remove them as soon as their building is left behind. Instead, (height, right) *pairs* are kept in the priority queue and they stay in there as long as there's a larger height in there, not just until their building is left behind.\\n\\nIn each loop, we first check what has the smaller x-coordinate: adding the next building from the input, or removing the next building from the queue. In case of a tie, adding buildings wins, as that guarantees correctness (think about it :-). We then either add all input buildings starting at that x-coordinate or we remove all queued buildings ending at that x-coordinate *or earlier* (remember we keep buildings in the queue as long as they're \"under the roof\" of a larger actually alive building). And then, if the current maximum height in the queue differs from the last in the skyline, we add it to the skyline.\\n\\n    from heapq import *\\n\\n    class Solution:\\n        def getSkyline(self, LRH):\\n            skyline = []\\n            i, n = 0, len(LRH)\\n            liveHR = []\\n            while i < n or liveHR:\\n                if not liveHR or i < n and LRH[i][0] <= -liveHR[0][1]:\\n                    x = LRH[i][0]\\n                    while i < n and LRH[i][0] == x:\\n                        heappush(liveHR, (-LRH[i][2], -LRH[i][1]))\\n                        i += 1\\n                else:\\n                    x = -liveHR[0][1]\\n                    while liveHR and -liveHR[0][1] <= x:\\n                        heappop(liveHR)\\n                height = len(liveHR) and -liveHR[0][0]\\n                if not skyline or height != skyline[-1][1]:\\n                    skyline += [x, height],\\n            return skyline"
		},
		{
			"lc_ans_id":"61281",
			"view":"1682",
			"top":"7",
			"title":"Java divide and conquer solution beats 96%",
			"vote":"30",
			"content":"The basic idea is divide the buildings into two subarrays, calculate their skylines respectively, then merge two skylines together.\\n\\n```\\npublic class Solution {\\n    public List<int[]> getSkyline(int[][] buildings) {\\n        return merge(buildings, 0, buildings.length-1);\\n    }\\n    \\n    private LinkedList<int[]> merge(int[][] buildings, int lo, int hi) {\\n        LinkedList<int[]> res = new LinkedList<>();\\n        if(lo > hi) {\\n            return res;\\n        } else if(lo == hi) {\\n            res.add(new int[]{buildings[lo][0], buildings[lo][2]});\\n            res.add(new int[]{buildings[lo][1], 0});\\n            return res;\\n        } \\n        int mid = lo+(hi-lo)/2;\\n        LinkedList<int[]> left = merge(buildings, lo, mid);\\n        LinkedList<int[]> right = merge(buildings, mid+1, hi);\\n        int leftH = 0, rightH = 0;\\n        while(!left.isEmpty() || !right.isEmpty()) {\\n            long x1 = left.isEmpty()? Long.MAX_VALUE: left.peekFirst()[0];\\n            long x2 = right.isEmpty()? Long.MAX_VALUE: right.peekFirst()[0];\\n            int x = 0;\\n            if(x1 < x2) {\\n                int[] temp = left.pollFirst();\\n                x = temp[0];\\n                leftH = temp[1];\\n            } else if(x1 > x2) {\\n                int[] temp = right.pollFirst();\\n                x = temp[0];\\n                rightH = temp[1];\\n            } else {\\n                x = left.peekFirst()[0];\\n                leftH = left.pollFirst()[1];\\n                rightH = right.pollFirst()[1];\\n            }\\n            int h = Math.max(leftH, rightH);\\n            if(res.isEmpty() || h != res.peekLast()[1]) {\\n                res.add(new int[]{x, h});\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"61261",
			"view":"2542",
			"top":"8",
			"title":"10-line Python solution, 104 ms",
			"vote":"27",
			"content":"Use an infinite vertical line `x` to scan from left to right. If max height changes, record [x, height] in `res`. Online judge is using Python 2.7.9 and there's no max heap's push and pop method, so we can use a min heap `hp` storing `-H` as \"max heap\". Thanks to [this discussion][1], set comprehension is faster and shorter than `list(set((R, 0, None) for L, R, H in buildings))`.\\n\\n    def getSkyline(self, buildings):\\n        events = sorted([(L, -H, R) for L, R, H in buildings] + list({(R, 0, None) for _, R, _ in buildings}))\\n        res, hp = [[0, 0]], [(0, float(\"inf\"))]\\n        for x, negH, R in events:\\n            while x >= hp[0][1]: \\n                heapq.heappop(hp)\\n            if negH: \\n                heapq.heappush(hp, (negH, R))\\n            if res[-1][1] + hp[0][0]: \\n                res += [x, -hp[0][0]],\\n        return res[1:]\\n\\n\\n  [1]: https://leetcode.com/discuss/37736/108-ms-17-lines-body-explained"
		},
		{
			"lc_ans_id":"61304",
			"view":"2960",
			"top":"9",
			"title":"Java solution using priority queue and sweepline",
			"vote":"24",
			"content":"Sweepline is used in solving the problem.  `List<int[]> height` is used to save each of the line segments including both start and end point.  The trick here is to set the start segment as negative height.  This has a few good uses:  \\n\\nfirst, make sure the start segment comes before the end one after sorting.\\n\\nsecond, when pushing into the queue, it is very each to distinguish either to add or remove a segment.\\n\\nlastly, when the two adjacent building share same start and end x value, the next start segment always come before due to the negative height, this makes sure that when we peek the queue, we always get the value we are supposed to get.  When the first building is lower, when we peek the queue, we get the height of the second building, and the first building will be removed in the next round of iteration.  When the second building is lower, the first peek returns the first building and since it equals to `prev`, the height will not be added."
		}
	],
	"id":"218",
	"title":"The Skyline Problem",
	"content":"<p>A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are <b>given the locations and height of all the buildings</b> as shown on a cityscape photo (Figure A), write a program to <b>output the skyline</b> formed by these buildings collectively (Figure B).</p>\r\n\r\n<!-- Cityscape -->\r\n<a href=\"/static/images/problemset/skyline1.jpg\" target=\"_blank\">\r\n    <img style=\" max-width: 45%;\" src=\"/static/images/problemset/skyline1.jpg\" border=\"0\" alt=\"Buildings\">\r\n</a>\r\n\r\n<!-- Use this image for the 'turning point' description of skyline -->\r\n<a href=\"/static/images/problemset/skyline2.jpg\" target=\"_blank\">\r\n    <img style=\"max-width: 45%;\" src=\"/static/images/problemset/skyline2.jpg\" border=\"0\" alt=\"Skyline Contour\">\r\n</a>\r\n\r\n<!-- Use the following image if we'd like to define the output as 'horizontal lines' rather than 'turning points'-->\r\n<!--\r\n<a href=\"http://tinypic.com?ref=mij3wi\" target=\"_blank\">\r\n<img style=\"max-width: 45%;\" src=\"http://i59.tinypic.com/mij3wi.jpg\" border=\"0\" alt=\"Skyline Contour\">\r\n</a>\r\n-->\r\n\r\n<p>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and <code>Hi</code> is its height. It is guaranteed that <code>0 &le; Li, Ri &le; INT_MAX</code>, <code>0 < Hi &le; INT_MAX</code>, and <code>Ri - Li > 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>\r\n\r\n<p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] </code>.</p>\r\n\r\n<p>The output is a list of \"<b>key points</b>\" (red dots in Figure B) in the format of <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> that uniquely defines a skyline. <b>A key point is the left endpoint of a horizontal line segment</b>. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.\r\n\r\n<p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p>\r\n\r\n<p><b>Notes:</b>\r\n<ul>\r\n<li> The number of buildings in any input list is guaranteed to be in the range <code>[0, 10000]</code>.</li>\r\n<li> The input list is already sorted in ascending order by the left x position <code>Li</code>. </li>\r\n<li> The output list must be sorted by the x position. </li>\r\n<li> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...[2 3], [4 5], [12 7], ...]</code></li>\r\n</ul>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://oj.leetcode.com/discuss/user/stellari\">@stellari</a> for adding this problem, creating these two awesome images and all test cases.</p>",
	"frequency":"461",
	"ac_num":"55739"
}