{
	"difficulty":"2",
	"submit_num":"266874",
	"show_id":"221",
	"leetcode_id":"221",
	"answers":[
		{
			"lc_ans_id":"61803",
			"view":"30919",
			"top":"0",
			"title":"Easy DP solution in C++ with detailed explanations (8ms, O(n^2) time and O(n) space)",
			"vote":"354",
			"content":"Well, this problem desires for the use of dynamic programming. They key to any DP problem is to come up with the state equation. In this problem, we define the state to be **the maximal size of the square that can be achieved at point `(i, j)`**, denoted as `P[i][j]`. Remember that we use **size** instead of square as the state (`square = size^2`).\\n\\nNow let's try to come up with the formula for `P[i][j]`.\\n\\nFirst, it is obvious that for the topmost row (`i = 0`) and the leftmost column (`j = 0`), `P[i][j] = matrix[i][j]`. This is easily understood. Let's suppose that the topmost row of `matrix` is like `[1, 0, 0, 1]`. Then we can immediately know that the first and last point can be a square of size `1` while the two middle points cannot make any square, giving a size of `0`. Thus, `P = [1, 0, 0, 1]`, which is the same as `matrix`. The case is similar for the leftmost column. Till now, the boundary conditions of this DP problem are solved.\\n\\nLet's move to the more general case for `P[i][j]` in which `i > 0` and `j > 0`. First of all, let's see another simple case in which `matrix[i][j] = 0`. It is obvious that `P[i][j] = 0` too. Why? Well, since `matrix[i][j] = 0`, no square will contain `matrix[i][j]`. According to our definition of `P[i][j]`, `P[i][j]` is also `0`.\\n\\nNow we are almost done. The only unsolved case is `matrix[i][j] = 1`. Let's see an example.\\n\\nSuppose `matrix = [[0, 1], [1, 1]]`, it is obvious that `P[0][0] = 0, P[0][1] = P[1][0] = 1`, what about `P[1][1]`? Well, to give a square of size larger than `1` in `P[1][1]`, all of its three neighbors (left, up, left-up) should be non-zero, right? In this case, the left-up neighbor `P[0][0] = 0`, so `P[1][1]` can only be 1, which means that it contains the square of itself.\\n\\nNow you are near the solution. In fact, `P[i][j] = min(P[i - 1][j], P[i][j - 1], P[i - 1][j - 1]) + 1` in this case.\\n\\nTaking all these together, we have the following state equations.\\n\\n 1. `P[0][j] = matrix[0][j]` (topmost row);\\n 2. `P[i][0] = matrix[i][0]` (leftmost column);\\n 3. For `i > 0` and `j > 0`: if `matrix[i][j] = 0`, `P[i][j] = 0`; if `matrix[i][j] = 1`, `P[i][j] = min(P[i - 1][j], P[i][j - 1], P[i - 1][j - 1]) + 1`.\\n\\nPutting them into codes, and maintain a variable `maxsize` to record the maximum size of the square we have seen, we have the following (unoptimized) solution.\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m = matrix.size();\\n        if (!m) return 0;\\n        int n = matrix[0].size();\\n        vector<vector<int> > size(m, vector<int>(n, 0));\\n        int maxsize = 0;\\n        for (int j = 0; j < n; j++) {\\n            size[0][j] = matrix[0][j] - '0';\\n            maxsize = max(maxsize, size[0][j]);\\n        }\\n        for (int i = 1; i < m; i++) {\\n            size[i][0] = matrix[i][0] - '0';\\n            maxsize = max(maxsize, size[i][0]);\\n        }\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (matrix[i][j] == '1') {\\n                    size[i][j] = min(size[i - 1][j - 1], min(size[i - 1][j], size[i][j - 1])) + 1;\\n                    maxsize = max(maxsize, size[i][j]);\\n                }\\n            }\\n        }\\n        return maxsize * maxsize;\\n    }\\n\\nNow let's try to optimize the above solution. As can be seen, each time when we update `size[i][j]`, we only need `size[i][j - 1], size[i - 1][j - 1]` (at the previous left column) and `size[i - 1][j]` (at the current column). So we do not need to maintain the full `m*n` matrix. In fact, keeping two columns is enough. Now we have the following optimized solution.\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n    \\tint m = matrix.size();\\n    \\tif (!m) return 0;\\n    \\tint n = matrix[0].size();\\n    \\tvector<int> pre(m, 0);\\n    \\tvector<int> cur(m, 0);\\n    \\tint maxsize = 0;\\n    \\tfor (int i = 0; i < m; i++) {\\n    \\t\\tpre[i] = matrix[i][0] - '0';\\n    \\t\\tmaxsize = max(maxsize, pre[i]);\\n    \\t}\\n    \\tfor (int j = 1; j < n; j++) {\\n    \\t\\tcur[0] = matrix[0][j] - '0';\\n    \\t\\tmaxsize = max(maxsize, cur[0]);\\n    \\t\\tfor (int i = 1; i < m; i++) {\\n    \\t\\t\\tif (matrix[i][j] == '1') {\\n    \\t\\t\\t\\tcur[i] = min(cur[i - 1], min(pre[i - 1], pre[i])) + 1;\\n    \\t\\t\\t\\tmaxsize = max(maxsize, cur[i]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tswap(pre, cur);\\n    \\t\\tfill(cur.begin(), cur.end(), 0);\\n    \\t}\\n    \\treturn maxsize * maxsize;\\n    }\\n\\nNow you see the solution is finished? In fact, it can still be optimized! In fact, we need not maintain two vectors and one is enough. If you want to explore this idea, please refer to the answers provided by @stellari below. Moreover, in the code above, we distinguish between the `0`-th row and other rows since the `0`-th row has no row above it. In fact, we can make all the `m` rows the same by padding a `0` row on the top (in the following code, we pad a `0` on top of `dp`). Finally, we will have the following short code :) If you find it hard to understand, try to run it using your pen and paper and notice how it realizes what the two-vector solution does using only one vector.\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) return 0;\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> dp(m + 1, 0);\\n        int maxsize = 0, pre = 0;\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 1; i <= m; i++) {\\n                int temp = dp[i];\\n                if (matrix[i - 1][j] == '1') {\\n                    dp[i] = min(dp[i], min(dp[i - 1], pre)) + 1;\\n                    maxsize = max(maxsize, dp[i]);\\n                }\\n                else dp[i] = 0; \\n                pre = temp;\\n            }\\n        }\\n        return maxsize * maxsize;\\n    }\\n\\n\\n----------\\nThis solution, since posted, has been suggested various improvements by kind people. For a more comprehensive collection of the solutions, please visit [my technical blog][1].\\n\\n\\n  [1]: http://www.cnblogs.com/jcliBlogger/p/4548751.html"
		},
		{
			"lc_ans_id":"61802",
			"view":"22437",
			"top":"1",
			"title":"Extremely Simple Java Solution :)",
			"vote":"256",
			"content":"    public int maximalSquare(char[][] a) {\\n        if(a.length == 0) return 0;\\n        int m = a.length, n = a[0].length, result = 0;\\n        int[][] b = new int[m+1][n+1];\\n        for (int i = 1 ; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if(a[i-1][j-1] == '1') {\\n                    b[i][j] = Math.min(Math.min(b[i][j-1] , b[i-1][j-1]), b[i-1][j]) + 1;\\n                    result = Math.max(b[i][j], result); // update result\\n                }\\n            }\\n        }\\n        return result*result;\\n    }"
		},
		{
			"lc_ans_id":"61876",
			"view":"10096",
			"top":"2",
			"title":"Accepted clean Java DP solution",
			"vote":"72",
			"content":"    public int maximalSquare(char[][] a) {\\n      if (a == null || a.length == 0 || a[0].length == 0)\\n        return 0;\\n          \\n      int max = 0, n = a.length, m = a[0].length;\\n      \\n      // dp(i, j) represents the length of the square \\n      // whose lower-right corner is located at (i, j)\\n      // dp(i, j) = min{ dp(i-1, j-1), dp(i-1, j), dp(i, j-1) }\\n      int[][] dp = new int[n + 1][m + 1];\\n      \\n      for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= m; j++) {\\n          if (a[i - 1][j - 1] == '1') {\\n            dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;\\n            max = Math.max(max, dp[i][j]);\\n          }\\n        }\\n      }\\n      \\n      // return the area\\n      return max * max;\\n    }"
		},
		{
			"lc_ans_id":"61811",
			"view":"3965",
			"top":"3",
			"title":"Clear C++ solution, no extra space, 12 ms.",
			"vote":"22",
			"content":"A square with '1' means any '0' will interrupt counting of it's right/down/right-down, and '1' will 'inherit' the existing counting result. \\n\\nSine the target is a square, we shall take the smallest counting result from up/left/up-left.\\n\\nSo for each element '0', it doesn't inherit previous accumulated counting;<br>\\nAnd for each element '1', it takes the smallest number from left/up/left-up and add 1 to it \\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int rst = 0;\\n        for(int ii=0; ii<matrix.size(); ++ii)\\n        {\\n            for(int jj=0; jj<matrix[0].size(); ++jj)\\n            {\\n                int a = (ii&&jj) ? matrix[ii-1][jj-1] : 0;\\n                int b = (ii) ? matrix[ii-1][jj] : 0;\\n                int c = (jj) ? matrix[ii][jj-1] : 0;\\n\\n                matrix[ii][jj] = (matrix[ii][jj]>'0') ? (min(a, min(b, c))+1) : 0;\\n                \\n                rst = max(rst, matrix[ii][jj]*matrix[ii][jj]);\\n            }\\n        }\\n        return rst;\\n    }"
		},
		{
			"lc_ans_id":"61935",
			"view":"2117",
			"top":"4",
			"title":"6 lines, Visual Explanation, O(mn)",
			"vote":"20",
			"content":"**Explanation**\\n\\nWhat's the largest (full-of-ones-)square ending at (i,j), meaning lower right corner in row i, column j? Imagine there are 4x4 squares above, above-left and left of it:\\n\\n    above  above-left  left\\n    \\n     1111     1111\\n     1111     1111     1111\\n     1111     1111     1111\\n     1111     1111     1111\\n        *         *    1111*\\n\\nClearly, if cell (i,j) itself is 1 as well, then there's a 5x5 square ending at (i,j). And if there were 5x5 squares above, above-left and left of it, then we'd have a 6x6. So to find the largest square ending at (i,j), we just take the minimum size of squares ending at (i-1,j), (i-1,j-1) and (i,j-1), and add 1.\\n\\n---\\n\\n**Implementation** - 164 ms\\n\\nI write the maximum sizes directly into the input matrix `A`. Cell `A[i][j]` will tell the side length of the largest square ending at (i,j). I go top to bottom and left to right, so (i-1,j), (i-1,j-1) and (i,j-1) have all been handled already. First thing I do for each cell is turn it into an integer, and then if it's 1 and it's not on the top or left border of the matrix, I determine its largest-square size as explained above. In the end, I return 0 for the empty matrix and otherwise the area of the largest square ending anywhere.\\n\\n    class Solution:\\n        def maximalSquare(self, A):\\n            for i in range(len(A)):\\n                for j in range(len(A[i])):\\n                    A[i][j] = int(A[i][j])\\n                    if A[i][j] and i and j:\\n                        A[i][j] = min(A[i-1][j], A[i-1][j-1], A[i][j-1]) + 1\\n            return len(A) and max(map(max, A)) ** 2\\n\\n---\\n\\n**Smaller Version** - 132 ms\\n\\nThis version is a bit smaller and faster due to using more of Python and some \"tricks\":\\n\\n    class Solution:\\n        def maximalSquare(self, A):\\n            for i, r in enumerate(A):\\n                r = A[i] = map(int, r)\\n                for j, c in enumerate(r):\\n                    if i * j * c:\\n                        r[j] = min(A[i-1][j], r[j-1], A[i-1][j-1]) + 1\\n            return max(map(max, A + [[0]])) ** 2\\n\\n---\\n\\n**O(n) Extra Space** - 128 ms\\n\\nHere's a version that doesn't overwrite the input matrix but uses two integer lists: `s` tells the sizes of the squares ending it the current row and `p` does the same for the previous row.\\n\\n    class Solution:\\n        def maximalSquare(self, A):\\n            area = 0\\n            if A:\\n                p = [0] * len(A[0])\\n                for row in A:\\n                    s = map(int, row)\\n                    for j, c in enumerate(s[1:], 1):\\n                        s[j] *= min(p[j-1], p[j], s[j-1]) + 1\\n                    area = max(area, max(s) ** 2)\\n                    p = s\\n            return area\\n\\nNote that in Python with its integer and string objects, I'm not sure this actually saves space. But in other languages, overwriting the input array might not even be possible, and if it's possible, it might take more space than a \"O(n) Extra Space\" variant."
		},
		{
			"lc_ans_id":"61894",
			"view":"1591",
			"top":"5",
			"title":"20 lines C++ solution using dynamic programming",
			"vote":"18",
			"content":"class Solution {\\n\\npublic:\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if(matrix.size()==0) return 0;\\n        int maxSq=0;\\n        int nRow=matrix.size();\\n        int nCol=matrix[0].size();\\n        vector<vector<int>> dp(nRow+1,vector<int>(nCol+1,0));\\n        //dp[i][j] represents max square ending at position (i-1, j-1)\\n        for(int i=1;i<=nRow;++i){\\n            for(int j=1;j<=nCol;++j){\\n                if(matrix[i-1][j-1]=='1'){\\n                    dp[i][j]=min(min(dp[i-1][j-1],dp[i-1][j]),dp[i][j-1])+1;\\n                    maxSq=max(maxSq,dp[i][j]);\\n                }\\n            }\\n        }\\n        return maxSq*maxSq;\\n    }\\n};"
		},
		{
			"lc_ans_id":"61828",
			"view":"3361",
			"top":"6",
			"title":"My Java DP AC solution simple and easy to understand with explanation",
			"vote":"18",
			"content":"It's actually to keep recording the max n*n window at each cell of the matrix. \\nAt each cell, we define that the dynamic programming status at that cell is - if I am the most right-bottom guy of a square, how big the square I can build.  With this definition, this status will be transferrable to the guys, right, below, and right below me. \\n       \\n     public class Solution {\\n            public int maximalSquare(char[][] matrix) {\\n                \\n                //illegal check - no square can be formed\\n                if(matrix == null || matrix.length == 0) return 0;\\n                \\n                int result = 0;\\n                int[][] count = new int[matrix.length][matrix[0].length];\\n                \\n                //initialize first row and first column\\n                for(int i = 0; i < matrix.length; i ++) {\\n                    count[i][0] = matrix[i][0] == '0' ? 0 : 1;\\n                    result = Math.max(result, count[i][0]);\\n                }\\n                \\n                for(int i = 0; i < matrix[0].length; i ++) {\\n                    count[0][i] = matrix[0][i] == '0' ? 0 : 1;\\n                    result = Math.max(result, count[0][i]);\\n                }\\n                \\n                //start to transfer status to iterate each cell from (1, 1) to (m, n)\\n                //if i am a 0, the square stops, reset\\n                for(int i = 1; i < matrix.length; i++) {\\n                    for(int j = 1; j < matrix[0].length; j++) {\\n                        \\n                        //I break the square reset myself to zero\\n                        if(matrix[i][j] == '0') {\\n                            count[i][j] = 0;\\n                            continue;\\n                        }\\n                        \\n                        //if I am 1, it depends if I can grow the size of the square, if I have a 0 guy around me, \\n                        //I can only be a top left guy\\n                        if(count[i - 1][j - 1] == 0 || count[i - 1][j] == 0 || count[i][j - 1] == 0) {\\n                            count[i][j] = 1;\\n                        }\\n                        //if guys around are the same size, I can be the right-bottom guy of a bigger square\\n                        else if(count[i - 1][j - 1] == count[i - 1][j] && count[i - 1][j] == count[i][j - 1]) {\\n                            count[i][j] = count[i - 1][j - 1] + 1;\\n                        }\\n                        //guys around me not the same, I can only be the right-bottom guy of a least square\\n                        else {\\n                            count[i][j] = Math.min(Math.min(count[i - 1][j - 1], count[i - 1][j]), \\n                                                                                  count[i][j - 1]) + 1;\\n                        }\\n                        result = Math.max(result, count[i][j]);\\n                    }\\n                }\\n                return result * result;\\n            }\\n        }\\n\\nOf course, the last three if-else condition can be entirely removed by this line of code:\\nMath.min(Math.min(count[i - 1][j - 1], count[i - 1][j]), count[i][j - 1])  + 1, because it covers all situations we can think of. \\n\\n    public class Solution {\\n        public int maximalSquare(char[][] matrix) {\\n            \\n            if(matrix == null || matrix.length == 0) return 0;\\n            \\n            int result = 0;\\n            int[][] count = new int[matrix.length][matrix[0].length];\\n            \\n            for(int i = 0; i < matrix.length; i ++) {\\n                count[i][0] = matrix[i][0] == '0' ? 0 : 1;\\n                result = Math.max(result, count[i][0]);\\n            }\\n            \\n            for(int i = 0; i < matrix[0].length; i ++) {\\n                count[0][i] = matrix[0][i] == '0' ? 0 : 1;\\n                result = Math.max(result, count[0][i]);\\n            }\\n            \\n            \\n            for(int i = 1; i < matrix.length; i++) {\\n                for(int j = 1; j < matrix[0].length; j++) {\\n                    \\n                    if(matrix[i][j] == '0') {\\n                        count[i][j] = 0;\\n                        continue;\\n                    }\\n                    \\n                    count[i][j] = Math.min(Math.min(count[i - 1][j - 1], count[i - 1][j]), \\n                                                                          count[i][j - 1]) + 1;\\n                    result = Math.max(result, count[i][j]);\\n                }\\n            }\\n            return result * result;\\n        }\\n    }\\n\\nBut by breaking into the situation into sub pieces will help my think cautiously. \\n\\nIn addition, the space O(n^2) can be possibly downgraded to O(n)  or even O(1) with 3 pointers to the current value of guys to my left, left-above, and above, if needed."
		},
		{
			"lc_ans_id":"61912",
			"view":"1379",
			"top":"7",
			"title":"My C++ code, 8ms (DP, O(n^2)time, O(n) space)",
			"vote":"11",
			"content":"The basic idea is to do DP: scan the matrix row by row (top down) and colume by colume (left to right) and for the position [i][j], the maximum square with the bottom-right corner sitting at [i][j] will have the edge length of \\n\\n    area[i][j]  = 0 if matrix[i][j] = '0'\\n                   = min(area[i-1][j-1], area[i][j-1], area[i-1][j]) + 1 if matrix[i][j] = '1'\\n\\nFor the case that  matrix[i][j] = '1', the algorithm tries to grow the  square sitting at [i-1][j-1], area[i-1][j-1] by 1. However, it is also limitted by the bottom edge at row i and right edge at col j, which was represented by area[i][j-1] and area[i-1][j] repectively. We have to choose the min of those three values.\\n\\nThe DP table works on a ping-pong mode to save memory since the area recursive equation only relys on i and i-1 rows.\\n\\n    class Solution {\\n    public:\\n        int maximalSquare(vector<vector<char>>& matrix) {\\n            int maxA = 0;\\n            const int m = matrix.size();\\n            if(!m) return maxA;\\n            const int n = matrix[0].size();\\n            if(!n) return maxA;\\n            int area[2][n]; // DP table to save the maximum square (with bottom-right corner at [i][j]) edge length \\n            int cur = 0, next =1; // ping-pog switch index\\n            fill_n(area[0],n,0);\\n    \\n            int i, j;\\n            \\n            for(i=0;i<m;i++)\\n            {\\n                area[next][0] = matrix[i][0] == '1'; // the first colume\\n                for(j=1; j<n; j++)\\n                    area[next][j] = matrix[i][j]=='1'? (min(area[cur][j-1],min(area[next][j-1],area[cur][j])) + 1):0; //DP update\\n                for(j=0; j<n && maxA<=i; j++) if(maxA<area[next][j]) maxA = area[next][j]; // find the maximum square for the current row\\n                cur = next;\\n                next = 1-cur;\\n            }\\n            return maxA * maxA;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"61925",
			"view":"1360",
			"top":"8",
			"title":"Share my concise python solution",
			"vote":"10",
			"content":"    class Solution:\\n    # @param {character[][]} matrix\\n    # @return {integer}\\n    def maximalSquare(self, matrix):\\n        if not matrix: return 0\\n        m , n = len(matrix),len(matrix[0])\\n        dp = [[0 if matrix[i][j]=='0' else 1for j in xrange(n)]for i in xrange(m)]\\n        \\n        for i in xrange(1,m):\\n            for j in xrange(1,n):\\n                if matrix[i][j] =='1': dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1\\n                else: dp[i][j] = 0\\n        \\n        ans = max([max(i) for i in dp])\\n        return ans ** 2"
		},
		{
			"lc_ans_id":"61805",
			"view":"469",
			"top":"9",
			"title":"Evolve from brute force to dp",
			"vote":"6",
			"content":"If we are not comfortable to start with dp, we may start from brute force. Identifying and fixing the problems in the naive approach can guide us to the optimal solution.\\n1. Brute force O(n^5), check all sizes starting at all points\\n```\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r=matrix.size();\\n        if(!r) return 0;\\n        int c=matrix[0].size(), n=min(r,c);\\n        for(int s=n;s>0;s--)  //all sizes\\n            for(int i=0;i<=r-s;i++)  //each starting point\\n                for(int j=0;j<=c-s;j++) {\\n                    bool has0=false;\\n                    for(int p=i;p<i+s;p++) {\\n                        for(int q=j;q<j+s;q++)\\n                            if(matrix[p][q]=='0') {\\n                                has0=true;\\n                                break;\\n                            }\\n                        if(has0) break;\\n                    }\\n                    if (!has0) return s*s;\\n                }\\n        return 0;\\n    }\\n```\\n2. O(n^3), check if a square contains all 1s can be improved to constant by preprocessing\\n```\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r=matrix.size();\\n        if(!r) return 0;\\n        int c=matrix[0].size(), n=min(r,c);\\n        vector<vector<int>> ones(r+1,vector<int>(c+1));\\n        for(int i=1;i<=r;i++) \\n            for(int j=1;j<=c;j++) ones[i][j] = matrix[i-1][j-1]-'0' + ones[i-1][j]+ones[i][j-1]-ones[i-1][j-1];\\n        for(int s=n;s>0;s--)\\n            for(int i=0;i<=r-s;i++)\\n                for(int j=0;j<=c-s;j++) if(ones[i+s][j+s]-ones[i+s][j]-ones[i][j+s]+ones[i][j] == s*s) return s*s;\\n        return 0;\\n    }\\n```\\n3. O(n^2). There is still redundant computation in #2. For each start/end point, we don't have to check all sizes. The maximal square at a point can be derived from adjacent points in constant time. The idea is similar to the preprocessing step in #2.\\n```\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if(!r) return 0;\\n        int c = matrix[0].size(), s = 0;\\n        vector<vector<int>> dp(r+1, vector<int>(c+1));\\n        for(int i=1;i<=r;i++) \\n            for(int j=1;j<=c;j++) {\\n                if(matrix[i-1][j-1]=='0') continue;\\n                s = max(s, dp[i][j] = 1 + min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))); \\n\\t    }\\n        return s*s;\\n     }     \\n```\\n4. O(n^2). Same as #3 but optimize extra space to O(n).\\n```\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if(!r) return 0;\\n        int c = matrix[0].size(), s = 0;\\n        vector<int> dp(c+1);\\n        for(int i=0;i<r;i++) {\\n            int temp = 0;\\n            for(int j=1;j<=c;j++) {\\n                int pre = dp[j];\\n                if(matrix[i][j-1]=='1') s = max(s, dp[j] = 1 + min(dp[j],min(temp,dp[j-1])));\\n                else dp[j] = 0;\\n                temp = pre;\\n            }\\n        }\\n        return s*s;\\n    }\\n```"
		}
	],
	"id":"221",
	"title":"Maximal Square",
	"content":"<p>\r\nGiven a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\r\n</p>\r\n\r\n<p>For example, given the following matrix:\r\n<pre>\r\n1 0 1 0 0\r\n1 0 <font color=\"red\">1</font> <font color=\"red\">1</font> 1\r\n1 1 <font color=\"red\">1</font> <font color=\"red\">1</font> 1\r\n1 0 0 1 0\r\n</pre>\r\nReturn 4.\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://oj.leetcode.com/discuss/user/Freezen\">@Freezen</a> for adding this problem and creating all test cases.</p>",
	"frequency":"331",
	"ac_num":"80101"
}