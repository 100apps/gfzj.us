{
	"difficulty":"3",
	"submit_num":"215032",
	"show_id":"224",
	"leetcode_id":"224",
	"answers":[
		{
			"lc_ans_id":"62361",
			"view":"25380",
			"top":"0",
			"title":"Iterative Java solution with stack",
			"vote":"211",
			"content":"Simple iterative solution by identifying characters one by one. One important thing is that the input is valid, which means the parentheses are always paired and in order.\\nOnly 5 possible input we need to pay attention:\\n\\n 1. digit: it should be one digit from the current number\\n 2. '+': number is over, we can add the previous number and start a new number\\n 3. '-': same as above\\n 4. '(': push the previous result and the sign into the stack, set result to 0, just calculate the new result within the parenthesis.\\n 5. ')': pop out the top two numbers from stack, first one is the sign before this pair of parenthesis, second is the temporary result before this pair of parenthesis. We add them together.\\n \\n \\nFinally if there is only one number, from the above solution, we haven't add the number to the result, so we do a check see if the number is zero.\\n\\n----------\\n\\n\\n    public int calculate(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int result = 0;\\n        int number = 0;\\n        int sign = 1;\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(Character.isDigit(c)){\\n                number = 10 * number + (int)(c - '0');\\n            }else if(c == '+'){\\n                result += sign * number;\\n                number = 0;\\n                sign = 1;\\n            }else if(c == '-'){\\n                result += sign * number;\\n                number = 0;\\n                sign = -1;\\n            }else if(c == '('){\\n                //we push the result first, then sign;\\n                stack.push(result);\\n                stack.push(sign);\\n                //reset the sign and result for the value in the parenthesis\\n                sign = 1;   \\n                result = 0;\\n            }else if(c == ')'){\\n                result += sign * number;  \\n                number = 0;\\n                result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n                result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n                \\n            }\\n        }\\n        if(number != 0) result += sign * number;\\n        return result;\\n    }"
		},
		{
			"lc_ans_id":"62362",
			"view":"13345",
			"top":"1",
			"title":"JAVA-----------Easy Version To Understand!!!!!",
			"vote":"178",
			"content":"    public static int calculate(String s) {\\n\\t\\tint len = s.length(), sign = 1, result = 0;\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (Character.isDigit(s.charAt(i))) {\\n\\t\\t\\t\\tint sum = s.charAt(i) - '0';\\n\\t\\t\\t\\twhile (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n\\t\\t\\t\\t\\tsum = sum * 10 + s.charAt(i + 1) - '0';\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult += sum * sign;\\n\\t\\t\\t} else if (s.charAt(i) == '+')\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\telse if (s.charAt(i) == '-')\\n\\t\\t\\t\\tsign = -1;\\n\\t\\t\\telse if (s.charAt(i) == '(') {\\n\\t\\t\\t\\tstack.push(result);\\n\\t\\t\\t\\tstack.push(sign);\\n\\t\\t\\t\\tresult = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t} else if (s.charAt(i) == ')') {\\n\\t\\t\\t\\tresult = result * stack.pop() + stack.pop();\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}"
		},
		{
			"lc_ans_id":"62377",
			"view":"7918",
			"top":"2",
			"title":"16 ms solution in C++ with stacks",
			"vote":"68",
			"content":"    class Solution {\\n    public:\\n        int calculate(string s) {\\n            stack <int> nums, ops;\\n            int num = 0;\\n            int rst = 0;\\n            int sign = 1;\\n            for (char c : s) { \\n                if (isdigit(c)) {\\n                    num = num * 10 + c - '0';\\n                }\\n                else {\\n                    rst += sign * num;\\n                    num = 0;\\n                    if (c == '+') sign = 1;\\n                    if (c == '-') sign = -1;\\n                    if (c == '(') {\\n                        nums.push(rst);\\n                        ops.push(sign);\\n                        rst = 0;\\n                        sign = 1;\\n                    }\\n                    if (c == ')' && ops.size()) {\\n                        rst = ops.top() * rst + nums.top();\\n                        ops.pop(); nums.pop();\\n                    }\\n                }\\n            }\\n            rst += sign * num;\\n            return rst;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"62344",
			"view":"9030",
			"top":"3",
			"title":"Easy 18 lines C++, 16 lines Python",
			"vote":"55",
			"content":"Keep a global running total and a stack of signs (+1 or -1), one for each open scope. The \"global\" outermost sign is +1.\\n\\n- Each number consumes a sign.\\n- Each `+` and `-` causes a new sign.\\n- Each `(` duplicates the current sign so it can be used for the first term inside the new scope. That's also why I start with `[1, 1]` - the global sign 1 and a duplicate to be used for the first term, since expressions start like `3...` or `(...`, not like `+3...` or `+(...`.\\n- Each `)` closes the current scope and thus drops the current sign.\\n\\nAlso see the example trace below my programs.\\n\\n**C++:**\\n\\n    int calculate(string s) {\\n        int total = 0;\\n        vector<int> signs(2, 1);\\n        for (int i=0; i<s.size(); i++) {\\n            char c = s[i];\\n            if (c >= '0') {\\n                int number = 0;\\n                while (i < s.size()  &&  s[i] >= '0')\\n                    number = 10 * number + s[i++] - '0';\\n                total += signs.back() * number;\\n                signs.pop_back();\\n                i--;\\n            }\\n            else if (c == ')')\\n                signs.pop_back();\\n            else if (c != ' ')\\n                signs.push_back(signs.back() * (c == '-' ? -1 : 1));\\n        }\\n        return total;\\n    }\\n\\n**Python:**\\n\\n    def calculate(self, s):\\n        total = 0\\n        i, signs = 0, [1, 1]\\n        while i < len(s):\\n            c = s[i]\\n            if c.isdigit():\\n                start = i\\n                while i < len(s) and s[i].isdigit():\\n                    i += 1\\n                total += signs.pop() * int(s[start:i])\\n                continue\\n            if c in '+-(':\\n                signs += signs[-1] * (1, -1)[c == '-'],\\n            elif c == ')':\\n                signs.pop()\\n            i += 1\\n        return total\\n\\n**Example trace:**\\n\\nHere's an example trace for input `3-(2+(9-4))`.\\n\\n      remaining   sign stack      total\\n    3-(2+(9-4))   [1, 1]            0\\n     -(2+(9-4))   [1]               3\\n      (2+(9-4))   [1, -1]           3\\n       2+(9-4))   [1, -1, -1]       3\\n        +(9-4))   [1, -1]           1\\n         (9-4))   [1, -1, -1]       1\\n          9-4))   [1, -1, -1, -1]   1\\n           -4))   [1, -1, -1]      -8\\n            4))   [1, -1, -1, 1]   -8\\n             ))   [1, -1, -1]      -4\\n              )   [1, -1]          -4\\n                  [1]              -4\\n\\nIf you want to see traces for other examples, you can add this at the start inside the loop and after the loop (that's for the Python solution, where it's all easier):\\n\\n    print '%11s   %-16s %2d' % (s[i:], signs, total)"
		},
		{
			"lc_ans_id":"62430",
			"view":"5282",
			"top":"4",
			"title":"Java solution/Stack",
			"vote":"41",
			"content":"My approach is based on the fact that the final arithmetic operation on each number is not only depend on the sign directly operating on it, but all signs associated with each unmatched '(' before that number.\\n\\ne.g.\\n5 - ( 6 + ( 4 - 7 ) ), if we remove all parentheses, the expression becomes 5 - 6 - 4 + 7.\\n\\nsign:\\n\\n6: (-1)(1) = -1\\n\\n4: (-1)(1)(1) = -1\\n\\n7: (-1)(1)(-1) = 1\\n\\nThe effect of associated signs are cumulative, stack is builded based on this. Any improvement is welcome.\\n\\n    public int calculate(String s) {\\n        Deque<Integer> stack = new LinkedList<>();\\n        int rs = 0;\\n        int sign = 1;\\n        stack.push(1);\\n        for (int i = 0; i < s.length(); i++){\\n            if (s.charAt(i) == ' ') continue;\\n            else if (s.charAt(i) == '('){\\n                stack.push(stack.peekFirst() * sign);\\n                sign = 1;\\n            }\\n            else if (s.charAt(i) == ')') stack.pop();\\n            else if (s.charAt(i) == '+') sign = 1;\\n            else if (s.charAt(i) == '-') sign = -1;\\n            else{\\n                int temp = s.charAt(i) - '0';\\n                while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1)))\\n                    temp = temp * 10 + s.charAt(++i) - '0';\\n                rs += sign * stack.peekFirst() * temp;\\n            }\\n        }\\n        return rs;\\n    }"
		},
		{
			"lc_ans_id":"62449",
			"view":"5283",
			"top":"5",
			"title":"Simple c++ in 24 ms",
			"vote":"39",
			"content":"    class Solution {\\n    public:\\n        int calculate(string s) {\\n            // the given expression is always valid!!!\\n            // only + and - !!!\\n            // every + and - can be flipped base on it's depth in ().\\n            stack<int> signs;\\n            int sign = 1;\\n            int num = 0;\\n            int ans = 0;\\n            \\n            // always transform s into ( s )\\n            signs.push(1);\\n            \\n            for (auto c : s) {\\n                if (c >= '0' && c <= '9') {\\n                    num = 10 * num + c - '0';\\n                } else if (c == '+' || c == '-') {\\n                    ans = ans + signs.top() * sign * num;\\n                    num = 0;\\n                    sign = (c == '+' ? 1 : -1);\\n                } else if (c == '(') {\\n                    signs.push(sign * signs.top());\\n                    sign = 1;\\n                } else if (c == ')') {\\n                    ans = ans + signs.top() * sign * num;\\n                    num = 0;\\n                    signs.pop();\\n                    sign = 1;\\n                }\\n            }\\n            \\n            if (num) {\\n                ans = ans + signs.top() * sign * num;\\n            }\\n            \\n            return ans;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"62372",
			"view":"6549",
			"top":"6",
			"title":"Accepted Java Infix to Postfix based solution with explaination [600ms]",
			"vote":"27",
			"content":"The solution has 2 steps:\\n\\n  1. parse the input string and convert it to postfix notation.\\n  2. evaluate the postfix string from step 1.\\n\\n**Infix to postfix conversion** \\n\\nconverting a simple expression string that doesn't contain brackets to postfix is explained [here][1]. You can imagine the expression between brackets as a new simple expression (which we know how to convert to postfix). So when we encounter opening bracket \"(\" push it to the top stack. When we encounter a closing bracket \")\" keep popping from stack until we find the matching \"(\", here we are removing all operators that belong to the expression between brackets. Then pop the \"(\" from the stack.\\n\\nOne more thing to take into consideration, we don't want any operator to pop the \"(\" from the stack except the \")\". We can handle this be assigning the \"(\" the lowest rank such that no operator can pop it.\\n\\n\\n**Evaluate postfix expression**\\n\\npostfix evaluation is explained [here][2]\\n\\nIf you have any ideas how to cut down the run time, please share your ideas :D.\\n\\nDisclaimer: I didn't write the included links, however I find them simple and neat.\\n\\n\\n    public class Solution {\\n    \\tint rank(char op){\\n    \\t    // the bigger the number, the higher the rank\\n    \\t    switch(op){\\n    \\t        case '+':return 1;\\n    \\t        case '-':return 1;\\n    \\t        case '*':return 2;\\n    \\t        case '/':return 2;\\n    \\t        default :return 0; // '(' \\n    \\t    }\\n    \\t}\\n    \\tList<Object> infixToPostfix(String s) {\\n    \\t\\tStack<Character> operators = new Stack<Character>();\\n    \\t\\tList<Object> postfix = new LinkedList<Object>();\\n    \\n    \\t\\tint numberBuffer = 0;\\n    \\t\\tboolean bufferingOperand = false;\\n    \\t\\tfor (char c : s.toCharArray()) {\\n    \\t\\t\\tif (c >= '0' && c <= '9') {\\n    \\t\\t\\t\\tnumberBuffer = numberBuffer * 10 + c - '0';\\n    \\t\\t\\t\\tbufferingOperand = true;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tif(bufferingOperand)\\n    \\t\\t\\t\\t\\tpostfix.add(numberBuffer);\\n    \\t\\t\\t\\tnumberBuffer = 0;\\n    \\t\\t\\t\\tbufferingOperand = false;\\n    \\t\\t\\t\\t\\n    \\t\\t\\t\\tif (c == ' '|| c == '\\\\t')\\n    \\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t\\n    \\t\\t\\t\\tif (c == '(') {\\n    \\t\\t\\t\\t\\toperators.push('(');\\n    \\t\\t\\t\\t} else if (c == ')') {\\n    \\t\\t\\t\\t\\twhile (operators.peek() != '(')\\n    \\t\\t\\t\\t\\t\\tpostfix.add(operators.pop());\\n    \\t\\t\\t\\t\\toperators.pop(); // popping \"(\"\\n    \\t\\t\\t\\t} else { // operator\\n    \\t\\t\\t\\t\\twhile (!operators.isEmpty() && rank(c) <= rank(operators.peek()))\\n    \\t\\t\\t\\t\\t\\tpostfix.add(operators.pop());\\n    \\t\\t\\t\\t\\toperators.push(c);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\n    \\t\\t}\\n    \\t\\tif (bufferingOperand)\\n    \\t\\t\\tpostfix.add(numberBuffer);\\n    \\n    \\t\\twhile (!operators.isEmpty())\\n    \\t\\t\\tpostfix.add(operators.pop());\\n    \\n    \\t\\treturn postfix;\\n    \\t}\\n    \\n    \\tint evaluatePostfix(List<Object> postfix) {\\n    \\t\\tStack<Integer> operands = new Stack<Integer>();\\n    \\t\\tint a = 0, b = 0;\\n    \\t\\tfor (Object s : postfix) {\\n    \\t\\t\\tif(s instanceof Character){\\n    \\t\\t\\t\\tchar c = (Character) s;\\n    \\t\\t\\t\\tb = operands.pop();\\n    \\t\\t\\t\\ta = operands.pop();\\n    \\t\\t\\t\\tswitch (c) {\\n    \\t\\t\\t\\t\\tcase '+': operands.push(a + b); break;\\n    \\t\\t\\t\\t\\tcase '-': operands.push(a - b); break;\\n    \\t\\t\\t\\t\\tcase '*': operands.push(a * b); break;\\n    \\t\\t\\t\\t\\tdefault : operands.push(a / b); \\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else { // instanceof Integer\\n    \\t\\t\\t\\toperands.push((Integer)s);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn operands.pop();\\n    \\t}\\n    \\n    \\tpublic int calculate(String s) {\\n    \\t\\treturn evaluatePostfix(infixToPostfix(s));\\n    \\t}\\n    \\n    }\\n\\n\\n  [1]: http://scriptasylum.com/tutorials/infix_postfix/algorithms/infix-postfix/\\n  [2]: http://scriptasylum.com/tutorials/infix_postfix/algorithms/postfix-evaluation/"
		},
		{
			"lc_ans_id":"62464",
			"view":"2465",
			"top":"7",
			"title":"64 ms c++ easy solution",
			"vote":"21",
			"content":"    class Solution {\\n    public:\\n        int calculate(string s) {\\n            int n = s.size();\\n            stack<int> s1;\\n            stack<char> s2;\\n            string v;\\n            for(int i = n - 1; i >= 0; i--){\\n                if(s[i] == ')' || s[i] == '+' || s[i] == '-') s2.push(s[i]);\\n                else if(s[i] >= '0' && s[i] <= '9'){\\n                    v = s[i] + v;\\n                    if(i == 0 || s[i - 1] < '0' || s[i - 1] > '9'){\\n                        s1.push(stoi(v)); \\n                        v = \"\";\\n                    }\\n                } else if(s[i] == '('){\\n                    while(s2.top() != ')') cal(s1, s2);\\n                    s2.pop();\\n                }\\n            }\\n            while(!s2.empty()) cal(s1, s2);\\n            return s1.top();\\n        }\\n    \\n        void cal(stack<int> &s1, stack<char> &s2){\\n            int v1 = s1.top(); s1.pop();\\n            int v2 = s1.top(); s1.pop();\\n            char c = s2.top(); s2.pop();\\n            if(c == '+') s1.push(v1 + v2);\\n            if(c == '-') s1.push(v1 - v2);\\n        }\\n    };"
		},
		{
			"lc_ans_id":"62345",
			"view":"1697",
			"top":"8",
			"title":"24-line C++ O(n) Recursive Solution, 20ms and Intuitive",
			"vote":"20",
			"content":"Each invocation of evaluate() evaluates whatever inside a pair of parenthese. Nested parenthese will be handled by recursive calls.\\n\\nSo \"(1+(4+5+2)-3)+(6+8)\"\\n\\n->\\n\\n(1+(9+2)-3)+(6+8)\\n\\n->\\n\\n(1+11-3)+(6+8)\\n\\n->\\n\\n(12-3)+(6+8)\\n\\n->\\n\\n9+(6+8)\\n\\n->\\n\\n9+14\\n\\n->\\n\\n23\\n\\n\\n    class Solution {\\n    public:\\n        int calculate(string s) {\\n            int pos=0;\\n            return evaluate(s,pos);\\n        }\\n        \\n        int evaluate(string& s, int& i) {\\n            int res = 0;\\n            bool negFlag=false;\\n            while(i<s.size()&&s[i]!=')') {\\n                if(s[i]=='+'||s[i]==' ') \\n                    i++;\\n                else if(s[i]=='-') {\\n                    i++;\\n                    negFlag=true;\\n                }\\n                else if(s[i]=='(') {\\n                    i++;\\n                    res+=negFlag?-evaluate(s,i):evaluate(s,i);\\n                    negFlag=false;\\n                }\\n                else {// numeric chars\\n                    int num=0;\\n                    while(i<s.size()&&isdigit(s[i]))\\n                        num = num*10 + s[i++]-'0';\\n                    res+=negFlag?-num:num;\\n                    negFlag=false;\\n                }\\n            }\\n            i++; // skip the current ')'\\n            return res;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"62421",
			"view":"2128",
			"top":"9",
			"title":"3ms java concise and fast recursive solution with comments(beats 99.61%)",
			"vote":"17",
			"content":"    public int calculate(String s) {\\n        if (s.length() == 0) return 0;\\n        s = \"(\" + s + \")\";\\n        int[] p = {0};\\n        return eval(s, p);\\n    }\\n    // calculate value between parentheses\\n    private int eval(String s, int[] p){\\n        int val = 0;\\n        int i = p[0]; \\n        int oper = 1; //1:+ -1:-\\n        int num = 0;\\n        while(i < s.length()){\\n            char c = s.charAt(i);\\n            switch(c){\\n                case '+': val = val + oper * num; num = 0; oper = 1; i++; break;// end of number and set operator\\n                case '-': val = val + oper * num; num = 0; oper = -1; i++; break;// end of number and set operator\\n                case '(': p[0] = i + 1; val = val + oper * eval(s, p); i = p[0]; break; // start a new eval\\n                case ')': p[0] = i + 1; return val + oper * num; // end current eval and return. Note that we need to deal with the last num\\n                case ' ': i++; continue;\\n                default : num = num * 10 + c - '0'; i++;\\n            }\\n        }\\n        return val;\\n    }"
		}
	],
	"id":"224",
	"title":"Basic Calculator",
	"content":"<p>Implement a basic calculator to evaluate a simple expression string.</p>\r\n\r\n<p>The expression string may contain open <code>(</code> and closing parentheses <code>)</code>, the plus <code>+</code> or minus sign <code>-</code>, <b>non-negative</b> integers and empty spaces <code> </code>.</p>\r\n\r\n<p>You may assume that the given expression is always valid.</p>\r\n\r\n<p>Some examples:<br>\r\n<pre>\r\n\"1 + 1\" = 2\r\n\" 2-1 + 2 \" = 3\r\n\"(1+(4+5+2)-3)+(6+8)\" = 23\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b> <b>Do not</b> use the <code>eval</code> built-in library function.\r\n</p>",
	"frequency":"434",
	"ac_num":"60687"
}