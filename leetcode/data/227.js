{
	"difficulty":"2",
	"submit_num":"200644",
	"show_id":"227",
	"leetcode_id":"227",
	"answers":[
		{
			"lc_ans_id":"63003",
			"view":"29837",
			"top":"0",
			"title":"Share my  java solution",
			"vote":"283",
			"content":"    public class Solution {\\n    public int calculate(String s) {\\n        int len;\\n        if(s==null || (len = s.length())==0) return 0;\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int num = 0;\\n        char sign = '+';\\n        for(int i=0;i<len;i++){\\n            if(Character.isDigit(s.charAt(i))){\\n                num = num*10+s.charAt(i)-'0';\\n            }\\n            if((!Character.isDigit(s.charAt(i)) &&' '!=s.charAt(i)) || i==len-1){\\n                if(sign=='-'){\\n                    stack.push(-num);\\n                }\\n                if(sign=='+'){\\n                    stack.push(num);\\n                }\\n                if(sign=='*'){\\n                    stack.push(stack.pop()*num);\\n                }\\n                if(sign=='/'){\\n                    stack.push(stack.pop()/num);\\n                }\\n                sign = s.charAt(i);\\n                num = 0;\\n            }\\n        }\\n\\n        int re = 0;\\n        for(int i:stack){\\n            re += i;\\n        }\\n        return re;\\n    }\\n}"
		},
		{
			"lc_ans_id":"63004",
			"view":"13269",
			"top":"1",
			"title":"17 lines C++, easy, 20 ms",
			"vote":"106",
			"content":"If you don't like the `44 - op` ASCII trick, you can use `op == '+' ? 1 : -1` instead. And wow, I didn't know C++ has `or`. I'm a Python guy and wrote that out of habit and only realized it after getting this accepted :-)\\n\\n    int calculate(string s) {\\n        istringstream in('+' + s + '+');\\n        long long total = 0, term = 0, n;\\n        char op;\\n        while (in >> op) {\\n            if (op == '+' or op == '-') {\\n                total += term;\\n                in >> term;\\n                term *= 44 - op;\\n            } else {\\n                in >> n;\\n                if (op == '*')\\n                    term *= n;\\n                else\\n                    term /= n;\\n            }\\n        }\\n        return total;\\n    }"
		},
		{
			"lc_ans_id":"62996",
			"view":"12099",
			"top":"2",
			"title":"Java straight forward iteration Solution with comments, No Stack, O(N) & O(1)",
			"vote":"54",
			"content":"    public int calculate(String s) {\\n        if (s == null) return 0;\\n        s = s.trim().replaceAll(\" +\", \"\");\\n        int length = s.length();\\n        \\n        int res = 0;\\n        long preVal = 0; // initial preVal is 0\\n        char sign = '+'; // initial sign is +\\n        int i = 0;\\n        while (i < length) {\\n            long curVal = 0;\\n            while (i < length && (int)s.charAt(i) <= 57 && (int)s.charAt(i) >= 48) { // int\\n                curVal = curVal*10 + (s.charAt(i) - '0');\\n                i++;\\n            }\\n            if (sign == '+') {\\n                res += preVal;  // update res\\n                preVal = curVal;\\n            } else if (sign == '-') {\\n                res += preVal;  // update res\\n                preVal = -curVal;\\n            } else if (sign == '*') {\\n                preVal = preVal * curVal; // not update res, combine preVal & curVal and keep loop\\n            } else if (sign == '/') {\\n                preVal = preVal / curVal; // not update res, combine preVal & curVal and keep loop\\n            }\\n            if (i < length) { // getting new sign\\n                sign = s.charAt(i);\\n                i++;\\n            }\\n        }\\n        res += preVal;\\n        return res;\\n    }"
		},
		{
			"lc_ans_id":"63014",
			"view":"6133",
			"top":"3",
			"title":"My 16 ms No stack One pass short C++ solution",
			"vote":"37",
			"content":"\\n\\n    class Solution {\\n    public:\\n        int calculate(string s) {\\n            int result = 0, cur_res = 0;\\n            char op = '+';\\n            for(int pos = s.find_first_not_of(' '); pos < s.size(); pos = s.find_first_not_of(' ', pos)) {\\n                if(isdigit(s[pos])) {\\n                    int tmp = s[pos] - '0';\\n                    while(++pos < s.size() && isdigit(s[pos]))\\n                        tmp = tmp*10 + (s[pos] - '0');\\n                    switch(op) {\\n                        case '+' : cur_res += tmp; break;\\n                        case '-' : cur_res -= tmp; break;\\n                        case '*' : cur_res *= tmp; break;\\n                        case '/' : cur_res /= tmp; break;\\n                    }\\n                }\\n                else {\\n                    if(s[pos] == '+' || s[pos] == '-') {\\n                        result += cur_res;\\n                        cur_res = 0;\\n                    }\\n                    op = s[pos++];\\n                }\\n            }\\n            return result + cur_res;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"63006",
			"view":"4829",
			"top":"4",
			"title":"C++ stack solution.",
			"vote":"20",
			"content":"        \\n    int calculate(string s) {\\n        stack<int> myStack;\\n        char sign = '+';\\n        int res = 0, tmp = 0;\\n        for (unsigned int i = 0; i < s.size(); i++) {\\n            if (isdigit(s[i]))\\n                tmp = 10*tmp + s[i]-'0';\\n            if (!isdigit(s[i]) && !isspace(s[i]) || i == s.size()-1) {\\n                if (sign == '-')\\n                    myStack.push(-tmp);\\n                else if (sign == '+')\\n                    myStack.push(tmp);\\n                else {\\n                    int num;\\n                    if (sign == '*' )\\n                        num = myStack.top()*tmp;\\n                    else\\n                        num = myStack.top()/tmp;\\n                    myStack.pop();\\n                    myStack.push(num);\\n                } \\n                sign = s[i];\\n                tmp = 0;\\n            }\\n        }\\n        while (!myStack.empty()) {\\n            res += myStack.top();\\n            myStack.pop();\\n        }\\n        return res;\\n    }"
		},
		{
			"lc_ans_id":"63000",
			"view":"2089",
			"top":"5",
			"title":"My 28ms C++ code with two stacks (one for op, one for oprand), extension to cover '(' & ')' also given",
			"vote":"20",
			"content":"Use two stacks : one to save operators, one to save oprands. Every time, if we get a digit, then update curNum, if we get an operator, then it means we get a complete oprand, which is saved in curNum; if the last operator is * or /, then calculate it, otherwise, just save curNum and s[i] (new operator) in the stacks. At last, the opS stack has only \"+\" & \"-\", which are the sign of the corresponding operands saved in numS. Then we do sum to get the result.\\n\\n    class Solution {\\n    public:\\n        int calculate(string s) {\\n           stack<char> opS;\\n           stack<int>  numS;\\n           s.push_back(')'); // to make sure the last operand will be saved in the stack e.g. 1+2*3), 2*3 will be calculated and push in the stack\\n           opS.push('+'); // sign for the first operand\\n           \\n           int i, curNum, len = s.size(), res =0;\\n           for(i=0,curNum=0; i<len; ++i)\\n           {\\n               if(isdigit(s[i])) curNum = curNum*10 + s[i] -'0'; // digit, recover the oprand\\n               else if(isspace(s[i])) continue; // skip the space\\n               else\\n               {\\n                   switch(opS.top())\\n                   { \\n                       case '*': // if the last operator is * / , do calculation\\n                       case '/':\\n                            curNum = opS.top()=='/'?numS.top()/curNum : numS.top()*curNum;\\n                            opS.pop();\\n                            numS.pop();\\n                   }\\n                    numS.push(curNum); /\\n                    curNum = 0;\\n                    opS.push(s[i]);\\n               }\\n           }\\n           opS.pop(); // skip the \")\"\\n           while(!opS.empty()) {res += (opS.top()=='-')? -numS.top(): numS.top(); opS.pop(); numS.pop();}\\n           return res;\\n        }\\n    };\\n\\nThe below version covers both +-*/ and ()\\n\\n    class Solution {\\n    public:\\n        int calculate(string s) {\\n           stack<char> opS;\\n           stack<int>  numS;\\n           s = '(' + s + ')';\\n    \\n           int i, curNum = 0, len = s.size();\\n           for(i=0; i<len; ++i)\\n           {\\n               if(isdigit(s[i])) curNum = curNum*10 + s[i] -'0';\\n               else if(isspace(s[i])) continue;\\n               else if(s[i] == '(')\\n               {\\n                    opS.push('(');\\n                    opS.push('+');\\n               }\\n               else\\n               {\\n                    switch(opS.top())\\n                    {\\n                        case '*':\\n                        case '/':\\n                            curNum = opS.top()=='/'?numS.top()/curNum : numS.top()*curNum;\\n                            opS.pop();\\n                            numS.pop();\\n                    }\\n                    switch(s[i])\\n                    {\\n                        case ')':\\n                            if('-'== opS.top()) curNum = -curNum;\\n                           opS.pop();\\n    \\n                           while(opS.top()!='(') \\n                           {\\n                               curNum += (opS.top()=='-')? -numS.top(): numS.top(); \\n                               opS.pop(); \\n                               numS.pop();\\n                           }\\n                           opS.pop(); // skip '('\\n                           break;\\n                        default: //+,-,*,/\\n                            opS.push(s[i]);\\n                            numS.push(curNum);\\n                            curNum = 0;\\n                    }\\n               }\\n           }\\n           return curNum;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"63076",
			"view":"2884",
			"top":"6",
			"title":"Python short solution with stack.",
			"vote":"17",
			"content":"        \\n    def calculate(self, s):\\n        if not s:\\n            return \"0\"\\n        stack, num, sign = [], 0, \"+\"\\n        for i in xrange(len(s)):\\n            if s[i].isdigit():\\n                num = num*10+ord(s[i])-ord(\"0\")\\n            if (not s[i].isdigit() and not s[i].isspace()) or i == len(s)-1:\\n                if sign == \"-\":\\n                    stack.append(-num)\\n                elif sign == \"+\":\\n                    stack.append(num)\\n                elif sign == \"*\":\\n                    stack.append(stack.pop()*num)\\n                else:\\n                    tmp = stack.pop()\\n                    if tmp//num < 0 and tmp%num != 0:\\n                        stack.append(tmp//num+1)\\n                    else:\\n                        stack.append(tmp//num)\\n                sign = s[i]\\n                num = 0\\n        return sum(stack)"
		},
		{
			"lc_ans_id":"63114",
			"view":"2886",
			"top":"7",
			"title":"20ms, O(n) time, O(1) space, one scan C++ solution",
			"vote":"17",
			"content":"O(n) time, O(1) space, one scan C++ solution, code maybe optimized though. Every time I got a number, I will aggregate it into the temp result. when I met '+' or '-\", temp result will be aggregated into the final result sum. \\n\\n     int calculate(string s) {\\n        int sum = 0; \\n        if(s.size() < 1) return sum; \\n        int i = 0; \\n        int last = 0, last_result = 1;  \\n        char last_operator = '+'; //remember the last operator\\n        int sign = 1; \\n        while(i < s.size()){\\n            if(s[i] == ' '){++i; continue;}\\n            if(s[i] == '+' || s[i] == '-'){\\n                sum += last_result * sign;\\n                sign = s[i++] == '+' ? 1 : -1; \\n                last_result = 1;\\n                last_operator = '+'; \\n            }\\n            else if(s[i] == '/' || s[i] == '*'){\\n                last_operator = s[i];\\n                ++i; \\n            }\\n            if(isdigit(s[i])){\\n                last = 0; \\n                while(i < s.size() && isdigit(s[i])){\\n                    last =  last * 10 + s[i++] - '0'; \\n                }\\n                \\n                if(last_operator == '*') last_result *= last;\\n                else if(last_operator == '/') last_result /= last;\\n                else  last_result = last; \\n            }\\n        }\\n        sum += last_result * sign;\\n        return sum; \\n    }"
		},
		{
			"lc_ans_id":"63031",
			"view":"1101",
			"top":"8",
			"title":"Simple C++ solution beats 85% submissions with detailed explanations",
			"vote":"13",
			"content":"**THOUGHT** \\n\\nI used a variable 'interim' to calculate interim result. interim result are separated by either '-' or '+'. For example, \"1 +2 * 4-5/3\", there will be three interims: (+)1, (+)2 * 4, (-)5/3. \\n\\nHere is the process, each time, we read a character:\\n\\n1) If it's a digit, we continue reading until a non-digit appears, we record the number as \"num\". Then we check the operator before this num as to update the current interim result. Note that, there is no operator before the first number in expressions, so op is initialized to be '+'. Also note that, when a '+' or '-' appears, it means the end of current interim calculation, which should be added to the final answer, and then we reset interim for the next 'interim calculation'.\\n\\n2) If it's ' ', we skip; \\n\\n\\n**PROCESS** \\n\\nTo walk you though using an example, in \"1 + 2*4 - 5/3\":\\n\\nBEG\\n\\n* op is set to be '+'\\n* when we read '1', we check the operator before 1, it's '+', so first interim is 1, and \"ans = 1\";  \\n* when we read '+', op is set to be '+'\\n* when we read 2, because the operator before 2 is '+', so 2 is the beginning number of the new interim, so we set interim = (+) 2;\\n* when we read *, op is set to be *\\n* when we read 4, interim = (+) 2*4\\n* when we read '-', op is set to be '-'\\n* when we read 5, we check the operator before 5 is '-' which indicates the end of current interim, so we update final answer, ans = 1 + 2*4, and interim is reset to be (-) 5;\\n* when we read '/', op is set to be '/'\\n* when we read '3', because the operator before 3 is '/', update interim = (-5) / 3.\\n* When we finished reading everything, add the last interim to final answer: ans = 1 + 2*4 + (-5)/3\\n\\nEND\\n\\n\\n    class Solution {\\n    public:\\n        int calculate(string s) {\\n            int i = 0, ans = 0, num = 0;\\n            int interim = 0;\\n            char op = '+';\\n            while(i < s.size()){\\n                if(isdigit(s[i])){\\n                    num = 0;\\n                    while(i < s.size() && isdigit(s[i])){\\n                        num = num * 10 + s[i] - '0';\\n                        i++;\\n                    }\\n                    if(op == '+' || op == '-'){\\n                        ans += interim;\\n                        interim = num * (op == '-' ? -1 : 1);\\n                    }else if(op == '*'){\\n                        interim *= num;\\n                    }else if(op == '/'){\\n                        interim /= num;\\n                    }\\n                    continue;\\n                }\\n                else if(s[i] != ' ') op = s[i];\\n               \\n                i++;\\n            }    \\n    \\n            ans += interim;            \\n            return ans;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"63088",
			"view":"1322",
			"top":"9",
			"title":"Explanation for Java O(n) time & O(1) space solution",
			"vote":"9",
			"content":"To have O(1) space solution, we have to drop the stack. To see why we can drop it, we need to reexamine the main purpose of the stack: it is used to hold temporary results for partial expressions with lower precedence levels.\\n\\nFor problem [224. Basic Calculator][1], the depth of precedence levels is unknown, since we can have arbitrary levels of parentheses in the expression. Therefore we do need the stack in the solution.\\n\\nHowever for the current problem, we only have two precedence levels, lower level with '+' & '-' operations and higher level with '\\\\*' & '/' operations. So the stack can be replaced by two variables, one for the lower level and the other for the higher level. Note that when we are done with a partial expression involving '/' & '*' operations only, the result will fall back to the lower level.\\n\\nNow let's look at each level separately.\\n\\nFirst of course we will have a variable \"num\" to represent the current number involved in the operations.\\n\\nFor the lower level, we use a variable \"pre\" to denote the partial result. And as usual we will have a variable \"sign\" to indicate the sign of the incoming result.\\n\\nFor the higher level, we use a variable \"curr\" to represent the partial result, and another variable \"op\" to indicate what operation should be performed:\\n\\n 1. If op = 0, no '*' or '/' operation is needed and we simply assign num to curr; \\n 2. if op = 1, we perform multiplication:  curr = curr * num;\\n 3. if op = -1, we perform division: curr = curr / num.\\n\\nThe key now is to figure out what to do depending on the scanned character from string s. There are three cases:\\n\\n 1. **A digit is hit**: As usual we will update the variable \"num\". One more step here is that we need to determine if this is the last digit of the current number. If so, we need to perform the corresponding operation depending on the value of \"op\" and update the value of \"curr\" (It is assumed that we are at the higher precedence level by default);\\n 2. **A ' * ' or '/' is hit**: We need to update the value of \"op\" and reset \"num\" to 0;\\n 3. **A '+' or '-' is hit**: Current higher precedence level is over, so the partial result (which is denoted by \"curr\") will fall back to the lower level and can be incorporated into the lower level partial result \"pre\". And of course we need to update the \"sign\" as well as reset \"op\" and \"num\" to 0. \\n\\nOne last point is that the string will end with digit or space, so we need to add the result for the last partial higher level expression to \"pre\". Here is the Java program.\\n\\n    public int calculate(String s) {\\n        int pre = 0, curr = 0, sign = 1, op = 0, num = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (Character.isDigit(s.charAt(i))) {\\n                num = num * 10 + (s.charAt(i) - '0');\\n                if (i == s.length() - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                \\tcurr = (op == 0 ? num : (op == 1 ? curr * num : curr / num));\\n                }\\n                \\n            } else if (s.charAt(i) == '*' || s.charAt(i) == '/') {\\n                op = (s.charAt(i) == '*' ? 1 : -1);\\n                num = 0;\\n                \\n            } else if (s.charAt(i) == '+' || s.charAt(i) == '-') {\\n                pre += sign * curr;\\n                sign = (s.charAt(i) == '+' ? 1 : -1);\\n                op = 0;\\n                num = 0;\\n            }\\n        }\\n        \\n        return pre + sign * curr;\\n    }\\n\\n  [1]: https://leetcode.com/problems/basic-calculator/"
		}
	],
	"id":"227",
	"title":"Basic Calculator II",
	"content":"<p>Implement a basic calculator to evaluate a simple expression string.</p>\r\n\r\n<p>The expression string contains only <b>non-negative</b> integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operators and empty spaces <code> </code>. The integer division should truncate toward zero.</p>\r\n\r\n<p>You may assume that the given expression is always valid.</p>\r\n\r\n<p>Some examples:<br>\r\n<pre>\r\n\"3+2*2\" = 7\r\n\" 3/2 \" = 1\r\n\" 3+5 / 2 \" = 5\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b> <b>Do not</b> use the <code>eval</code> built-in library function.\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/ts\">@ts</a> for adding this problem and creating all test cases.</p>",
	"frequency":"350",
	"ac_num":"59739"
}