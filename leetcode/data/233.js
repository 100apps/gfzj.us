{
	"difficulty":"3",
	"submit_num":"113961",
	"show_id":"233",
	"leetcode_id":"233",
	"answers":[
		{
			"lc_ans_id":"64381",
			"view":"34879",
			"top":"0",
			"title":"4+ lines, O(log n), C++/Java/Python",
			"vote":"290",
			"content":"Go through the digit positions one at a time, find out how often a \"1\" appears at each position, and sum those up.\\n\\n**C++ solution**\\n\\n    int countDigitOne(int n) {\\n        int ones = 0;\\n        for (long long m = 1; m <= n; m *= 10)\\n            ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1);\\n        return ones;\\n    }\\n\\n**Explanation**\\n\\nLet me use variables `a` and `b` to make the explanation a bit nicer.\\n\\n    int countDigitOne(int n) {\\n        int ones = 0;\\n        for (long long m = 1; m <= n; m *= 10) {\\n            int a = n/m, b = n%m;\\n            ones += (a + 8) / 10 * m + (a % 10 == 1) * (b + 1);\\n        }\\n        return ones;\\n    }\\n\\nGo through the digit positions by using position multiplier `m` with values 1, 10, 100, 1000, etc.\\n\\nFor each position, split the decimal representation into two parts, for example split n=3141592 into a=31415 and b=92 when we're at m=100 for analyzing the hundreds-digit. And then we know that the hundreds-digit of n is 1 for prefixes \"\" to \"3141\", i.e., 3142 times. Each of those times is a streak, though. Because it's the hundreds-digit, each streak is 100 long. So `(a / 10 + 1) * 100` times, the hundreds-digit is 1. \\n\\nConsider the thousands-digit, i.e., when m=1000. Then a=3141 and b=592. The thousands-digit is 1 for prefixes \"\" to \"314\", so 315 times. And each time is a streak of 1000 numbers. However, since the thousands-digit is a 1, the very last streak isn't 1000 numbers but only 593 numbers, for the suffixes \"000\" to \"592\". So `(a / 10 * 1000) + (b + 1)` times, the thousands-digit is 1.\\n\\nThe case distincton between the current digit/position being 0, 1 and >=2 can easily be done in one expression. With `(a + 8) / 10` you get the number of full streaks, and `a % 10 == 1` tells you whether to add a partial streak.\\n\\n**Java version**\\n\\n    public int countDigitOne(int n) {\\n        int ones = 0;\\n        for (long m = 1; m <= n; m *= 10)\\n            ones += (n/m + 8) / 10 * m + (n/m % 10 == 1 ? n%m + 1 : 0);\\n        return ones;\\n    }\\n\\n**Python version**\\n\\n    def countDigitOne(self, n):\\n        ones, m = 0, 1\\n        while m <= n:\\n            ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1)\\n            m *= 10\\n        return ones\\n\\nUsing `sum` or recursion it can also be a [one-liner](https://leetcode.com/discuss/44302/1-liners-in-python).\\n\\n---\\n\\nOld solution\\n---\\n\\nGo through the digit positions from back to front. I found it ugly to explain, so I made up that above new solution instead. The `n` here is the new solution's `a`, and the `r` here is the new solution's `b+1`.\\n\\n**Python**\\n\\n    def countDigitOne(self, n):\\n        ones = 0\\n        m = r = 1\\n        while n > 0:\\n            ones += (n + 8) / 10 * m + (n % 10 == 1) * r\\n            r += n % 10 * m\\n            m *= 10\\n            n /= 10\\n        return ones\\n\\n**Java**\\n\\n    public int countDigitOne(int n) {\\n        int ones = 0, m = 1, r = 1;\\n        while (n > 0) {\\n            ones += (n + 8) / 10 * m + (n % 10 == 1 ? r : 0);\\n            r += n % 10 * m;\\n            m *= 10;\\n            n /= 10;\\n        }\\n        return ones;\\n    }\\n\\n**C++**\\n\\n    int countDigitOne(int n) {\\n        int ones = 0, m = 1, r = 1;\\n        while (n > 0) {\\n            ones += (n + 8) / 10 * m + (n % 10 == 1) * r;\\n            r += n % 10 * m;\\n            m *= 10;\\n            n /= 10;\\n        }\\n        return ones;\\n    }"
		},
		{
			"lc_ans_id":"64390",
			"view":"10892",
			"top":"1",
			"title":"AC short Java solution",
			"vote":"133",
			"content":"    public int countDigitOne(int n) {\\n      int count = 0;\\n        \\n      for (long k = 1; k <= n; k *= 10) {\\n        long r = n / k, m = n % k;\\n        // sum up the count of ones on every place k\\n        count += (r + 8) / 10 * k + (r % 10 == 1 ? m + 1 : 0);\\n      }\\n        \\n      return count;\\n    }\\n\\nSolution explanation:\\n\\nLet's start by counting the ones for every 10 numbers...\\n\\n0,  1,  2,  3  ... 9  (1)\\n\\n**10, 11, 12, 13 ... 19** (1) + **10**\\n\\n20, 21, 22, 23 ... 29 (1)\\n\\n...\\n\\n90, 91, 92, 93 ... 99 (1)\\n\\n-\\n\\n100, 101, 102, 103 ... 109 (10 + 1)\\n\\n**110, 111, 112, 113 ... 119** (10 + 1) + **10**\\n\\n120, 121, 122, 123 ... 129 (10 + 1)\\n\\n...\\n\\n190, 191, 192, 193 ... 199 (10 + 1)\\n\\n-\\n\\n\\n**1).** If we don't look at those special rows (start with 10, 110 etc), we know that there's a one at ones' place in every 10 numbers, there are 10 ones at tens' place in every 100 numbers, and 100 ones at hundreds' place in every 1000 numbers, so on and so forth.\\n\\nOk, let's start with ones' place and count how many ones at this place, set k = 1, as mentioned above, there's a one at ones' place in every 10 numbers, so how many 10 numbers do we have? \\n\\nThe answer is (n / k) / 10.\\n\\nNow let's count the ones in tens' place, set k = 10, as mentioned above, there are 10 ones at tens' place in every 100 numbers, so how many 100 numbers do we have? \\n\\nThe answer is (n / k) / 10, and the number of ones at ten's place is (n / k) / 10 * k.\\n\\nLet r = n / k, now we have a formula to count the ones at k's place: **r / 10 * k**\\n\\n-\\n\\n**2).** So far, everything looks good, but we need to fix those special rows, how? \\n\\nWe can use the mod. Take 10, 11, and 12 for example, if n is 10, we get (n / 1) / 10 * 1 = 1 ones at ones's place, perfect, but for tens' place, we get (n / 10) / 10 * 10 = 0, that's not right, there should be a one at tens' place! Calm down, from 10 to 19, we always have a one at tens's place, let m = n % k, the number of ones at this special place is m + 1, so let's fix the formula to be:\\n\\n\\n**r / 10 * k + (r % 10 == 1 ? m + 1 : 0)**\\n\\n-\\n\\n\\n**3).** Wait, how about 20, 21 and 22? \\n\\nLet's say 20, use the above formula we get 0 ones at tens' place, but it should be 10! How to fix it? We know that once the digit is larger than 2, we should add 10 more ones to the tens' place, a clever way to fix is to add 8 to r, so our final formula is:\\n\\n**(r + 8) / 10 * k + (r % 10 == 1 ? m + 1 : 0)**\\n\\nAs you can see, it's all about how we fix the formula. Really hope that makes sense to you."
		},
		{
			"lc_ans_id":"64382",
			"view":"7096",
			"top":"2",
			"title":"Java/Python one pass solution easy to understand",
			"vote":"103",
			"content":"The idea is to calculate occurrence of 1 on every digit. There are 3 scenarios, for example \\n\\n    if n = xyzdabc\\n\\nand we are considering the occurrence of one on thousand, it should be:\\n\\n    (1) xyz * 1000                     if d == 0\\n    (2) xyz * 1000 + abc + 1           if d == 1\\n    (3) xyz * 1000 + 1000              if d > 1\\n\\niterate through all digits and sum them all will give the final answer\\n\\n\\n**Java**\\n\\n    public int countDigitOne(int n) {\\n\\n        if (n <= 0) return 0;\\n        int q = n, x = 1, ans = 0;\\n        do {\\n            int digit = q % 10;\\n            q /= 10;\\n            ans += q * x;\\n            if (digit == 1) ans += n % x + 1;\\n            if (digit >  1) ans += x;\\n            x *= 10;\\n        } while (q > 0);\\n        return ans;\\n\\n    }\\n\\n    // 40 / 40 test cases passed.\\n    // Status: Accepted\\n    // Runtime: 0 ms\\n\\n**Python**\\n\\n    def countDigitOne(self, n):\\n        if n <= 0:\\n            return 0\\n        q, x, ans = n, 1, 0\\n        while q > 0:\\n            digit = q % 10\\n            q /= 10\\n            ans += q * x\\n            if digit == 1:\\n                ans += n % x + 1\\n            elif digit > 1:\\n                ans += x\\n            x *= 10\\n        return ans\\n\\n    # 40 / 40 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 32 ms\\n    # 97.59%"
		},
		{
			"lc_ans_id":"64476",
			"view":"5916",
			"top":"3",
			"title":"0ms o(lgn) accepted c++ solution using counting principle with explanation",
			"vote":"29",
			"content":"For every digit in n (Suppose n = 240315, the digits are 2, 4, 0, 3, 1, 5)\\uff0cI respectively count the number of digit 1 assuming the position of current digit is 1 and other digits of n is arbitrary.\\n\\nFor example, I select 3 in n as the current digit, and I suppose the position of 3 is 1.\\n\\nThe highn is the number composed with the digits before the current digit. In the example, highn = 240;\\n\\nThe lown is the number composed with the digits after the current digit. In the example, lown = 15.\\n\\nThe lowc = 10 ^ (the number of lower digits). In the example, lowc = 100;\\n\\nAs curn = 3 and curn > 1,  (highn * 10 + 1) must be less than  (highn * 10 + curn). Then the higher part can be 0 ~ highn, the lower part can be 0 ~ (lowc-1), and the current result = (highn + 1)  *  lowc.\\n\\n    int countDigitOne(int n) {\\n            long long int res(0);\\n            int highn(n), lowc(1), lown(0);\\n            while(highn > 0){\\n                int curn = highn % 10;\\n                highn = highn / 10;\\n                if(1 == curn){\\n                    //higher: 0~(highn-1);  lower:  0 ~ (lowc-1)\\n                    res += highn * lowc;\\n                    //higher: highn ~ highn;     lower:0~lown\\n                    res += lown + 1;\\n                }else if(0 == curn){  \\n                    //curn < 1\\n                   //higher: 0~(highn-1);  lower:  0 ~ (lowc-1)\\n                    res += highn * lowc;\\n                }else{              \\n                    //curn > 1\\n                    res += (highn + 1) * lowc;\\n                }\\n                //update lown and lowc\\n                lown = curn * lowc + lown;\\n                lowc = lowc * 10;\\n            }\\n            return res;\\n        }"
		},
		{
			"lc_ans_id":"64397",
			"view":"3665",
			"top":"4",
			"title":"0 ms recursive solution",
			"vote":"23",
			"content":"    int countDigitOne(int n) {\\n        if(n<1) return 0;\\n        if(n>=1 && n<10) return 1;\\n        // x: first digit\\n        int y=1, x=n;\\n        while(!(x<10)){\\n            x/=10;\\n            y*=10;\\n        }\\n        if(x==1)\\n            return n-y+1+countDigitOne(y-1)+countDigitOne(n%y);\\n        else\\n            return y+x*countDigitOne(y-1)+countDigitOne(n%y);\\n    }"
		},
		{
			"lc_ans_id":"64451",
			"view":"2876",
			"top":"5",
			"title":"Easy Understand Java Solution with Detailed Explaination",
			"vote":"22",
			"content":"The basic idea is to find the relationship between the increse of number of digit 1 and each digit. For example, let (edcba) be a number, I want to find a  relationship that represents how number of digit 1 incresed with the current digit, like f(e) = countDigitOne(edcba)-countDigitOne(dcba). Once such function is identified, the total number of digit 1 can be iteratively calculated.\\n\\nThe following is the process to identify the relationship(function f()):\\nThe function (f(e)) is defined as the number of digit 1 increased because of digit e. (i.e. compared to there was no digit e, just (dcba), for example).\\n\\nWe take (edcba) as a number like 12345 (e =1, d=2,c=3,b=4 and a =5) here.\\n\\nStart from f(a), it's obvious that **if a=0, f(a) = 0, if a >0, f(a)=1.**\\n\\nThen f(b). If b =1,since countDigitOne(11) = 4 while countDigitOne(01) =1 ,and countDigitOne(19) = 12 while countDigitOne(09) = 1, it shows that **f(b) = 1 + a +1.**\\n\\nIf b>1, since countDigitOne(21) = 13 while countDigitOne(01) = 1 and countDigitOne(99) = 20 while countDigitOne(09) = 1, **f(b) = b + 10;**\\n\\nSimilarly, \\n\\n**if c=1, f(c) = 20 + 10b+a+1; if c>1, f(c) = 20c+100;**\\n\\n**if d = 1, f(d) = 300+100c+10b+a+1; if d>1, f(d) = 300d+1000;**\\n\\n\\nThe relationships between the parameters are easy to find out. Take f(d) as an example, **300 = f(a)+f(b)+f(c) when (a = b = c = 9 ),** that is 1+19+280 = 300, which essentialy is the countDigitOne(999). 1000 = 10*10*10, and 100*c+10*b+a is the value of number (cba). \\n\\nWith these relationships, a scan and accumulate from lowest digit can lead to the answer.\\n\\n    public int countDigitOne(int n) {\\n\\t\\tint remain;\\n\\t\\tint acc = 0;\\n\\t\\tint numIndex = 0;\\n\\t\\tint factor = 1;\\n\\t\\tint count = 0;\\n\\t\\twhile (n > 0) {\\n\\t\\t\\tremain = n % 10;\\n\\t\\t\\tn /= 10;\\n\\t\\t\\tif (remain == 1)\\n\\t\\t\\t\\tcount += numIndex + acc + 1;\\n\\t\\t\\telse if (remain > 1)\\n\\t\\t\\t\\tcount += remain * numIndex + factor;\\n\\t\\t\\tacc += remain * factor;\\n\\t\\t\\tnumIndex += 9 * numIndex + factor;\\n\\t\\t\\tfactor *= 10;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}"
		},
		{
			"lc_ans_id":"64426",
			"view":"1180",
			"top":"6",
			"title":"Easy to understand C++ 0ms solution with detailed explanation",
			"vote":"19",
			"content":"We start from basics:\\n\\n    f(9) = 1;\\n    f(99) = f(9) * 10 + 10(contributed by the most significant digit in range [10, 19]) = 20  \\n    f(999) = f(99) * 10 + 100(contributed by the most significant digit in range [100, 199]) = 300\\n    f(9999) = f(999) * 10 + 1000(contributed by the most significant digit in range [1000, 1999]) = 10 * 300 + 1000 = 4000\\n    ... ...\\n\\nHow about 23?\\n\\n    23 = [0, 9] + [10, 19] + [20, 23]\\n\\n[10, 19] can be reduced to solve f(9) + 10, because its most significant digit is 1. And [20, 23] can be reduced to solve f(3) + 0, because the most significant digit is 2, so this digit doesn't contribute to final result.\\nSo now we know\\n\\n    f(23) = f(9) * 2 + 10 + f(3)\\n\\nSo now when we look at a number n (e.g. 2356), we look at the most significant digit(2), its divisor with highest 10's power (1000), and its remainder (356), try to reduce to a smaller number iteratively.\\n\\n(1) Since most significant digit is 2, so we know range [0, 999], [1000, 1999] are included, so we add 2 * f(999). \\n\\n(2) Also, since we have [1000, 1999] covered, we should add extra 1000. \\n\\n(3) Then we look at range [2000, 2356], try to reduce it to [0, 356] by dropping most significant digit 2, it doesn't impact the final result since most significant digit is 2 not 1. \\n\\n(4) Finally, we add f(356)\\n\\nSo eventually, we have\\n\\n    f(2356) += (2356 / 1000) * f(1000 - 1) = 2 * f(999);\\n    f(2356) += (2356 / 1000 > 1 ? 1000 : 0); \\n    f(2356) += (2356 / 1000 == 1 ? 356 + 1 : 0);\\n    f(2356) += f(356);\\n\\nBelow is the code:\\n\\n    class Solution {\\n    public:\\n        int countDigitOne(int n) {\\n            int ans = 0;\\n            if(n <= 0) return 0;\\n            if(n <= 9) return 1;\\n            \\n            unordered_map<int, int> mp;\\n            mp[9] = 1;\\n            for(int i = 9; i <= (INT_MAX - 9) / 10; i = i * 10 + 9){\\n                mp[i*10 + 9] = mp[i] * 10 + (i + 1); // mp[99], mp[999], mp[9999], ... ...\\n            }\\n            \\n            int nn = n, divisor = 1;\\n            while(nn / 10){\\n                nn /= 10;\\n                divisor *= 10;\\n            }\\n            ans += (n / divisor) *  mp[divisor - 1]; \\n            ans += (n / divisor > 1) ? divisor : 0; \\n            ans += (n / divisor == 1) ? n % divisor + 1 : 0;\\n            ans += countDigitOne(n % divisor);\\n\\n            return  ans;  \\n        }\\n    };"
		},
		{
			"lc_ans_id":"64383",
			"view":"2183",
			"top":"7",
			"title":"My simple and understandable Java solution",
			"vote":"17",
			"content":"\\n     /**\\n\\t * Calculate occurance on every digit, from\\n\\t * least important digit to most important digit\\n\\t * number = 1432\\n\\t * One's digit: n/10=143 143*1+1\\n\\t * Ten's digit: n/100=14 14*10+10\\n\\t * Hun's digit: n/1000=1 1*100+100\\n\\t * Tho's digit: 1432%1000+1=433\\n\\t * Sum all occurance on digits together\\n\\t */\\n\\tpublic static int countDigitOne(int k) {\\n        int count = 0, factor = 1, n = k;\\n        while(n>0){\\n        \\tint m = n/10, r = n%10, amount;\\n        \\t\\n        \\tif(r == 0) amount = 0;\\n        \\telse if(r > 1) amount = factor;\\n        \\telse amount = k%factor+1;\\n     \\n        \\tcount += m*factor + amount;\\n        \\tfactor *= 10;\\n        \\tn = n/10;\\n        }\\n        return count;\\n\\t}"
		},
		{
			"lc_ans_id":"64440",
			"view":"2981",
			"top":"8",
			"title":"Share my O(lgn) C++ solution to Number of Digit One",
			"vote":"10",
			"content":"\\nshare my O(lgn) solution : \\n    \\n\\n    class Solution {\\n    public:\\n    int countDigitOne(int n) {\\n     \\tlong long base = 1, res = 0, last = 0;\\n\\t\\twhile(n >= base){\\n\\t\\t\\tint index = (n / base) % 10;\\n\\t\\t\\tlong long remain = n - (n / base) * base;\\n\\t\\t\\tif(index > 1){\\n\\t\\t\\t\\tres = res + index * last + base;\\n\\t\\t\\t}else if(index == 1){\\n\\t\\t\\t\\tres = res + index * last + remain + 1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tres = res + index * last;\\n\\t\\t\\t}\\n\\t\\t\\tlast = last * 10 + base;\\n\\t\\t\\tbase = base * 10;\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n    };\\n\\n\\nFollow Up:    you can change the code to meet the new problem `Number of Digit K`, such as `Number of Digit 3`\\n\\n    class Solution {\\n    public:\\n    int countDigitK(int n, int k) {\\n     \\tlong long base = 1, res = 0, last = 0;\\n\\t\\twhile(n >= base){\\n\\t\\t\\tint index = (n / base) % 10;\\n\\t\\t\\tlong long remain = n - (n / base) * base;\\n\\t\\t\\tif(index > k){\\n\\t\\t\\t\\tres = res + index * last + base;\\n\\t\\t\\t}else if(index == k){\\n\\t\\t\\t\\tres = res + index * last + remain + 1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tres = res + index * last;\\n\\t\\t\\t}\\n\\t\\t\\tlast = last * 10 + base;\\n\\t\\t\\tbase = base * 10;\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n    };"
		},
		{
			"lc_ans_id":"64418",
			"view":"3112",
			"top":"9",
			"title":"5 lines solution using recursion with explanation",
			"vote":"10",
			"content":"The concept is count 1s in current level, recursively do it until the number is smaller than 10.\\n\\n**Javascript Solution**\\n\\n    var countDigitOne = function(n) {\\n        if(n <= 0) return 0;\\n        if(n < 10) return 1;\\n        var base = Math.pow(10, n.toString().length - 1);\\n        var answer = parseInt(n / base);\\n        return countDigitOne(base - 1) * answer + (answer === 1 ? (n - base + 1) : base) + countDigitOne(n % base);\\n    };\\n\\nFor example '8192':\\n\\n1-999 -> countDigitOne(999)\\n\\n1000-1999 -> 1000 of 1s + countDigitOne(999)\\n\\n2000-2999 -> countDigitOne(999)\\n\\n.\\n\\n.\\n\\n7000-7999 -> countDigitOne(999)\\n\\n8000-8192 -> countDigitOne(192)\\n\\nCount of 1s : **countDigitOne(999)*8 + 1000 + countDigitOne(192)**\\n\\n**Noticed that**, if the target is '1192':\\n\\nCount of 1s : **countDigitOne(999)*1 + (1192 - 1000  + 1) + countDigitOne(192)**\\n\\n (1192 - 1000  + 1) is the 1s in thousands from 1000 to 1192.\\n\\n\\n\\n**Same codes as above, maybe much easier to understand.**\\n\\n    var countDigitOne = function(n) {\\n        if(n <= 0){\\n            return 0;\\n        }else if(n < 10){\\n            return 1;\\n        }\\n        var len = n.toString().length;\\n        var base = Math.pow(10, len - 1);\\n        var answer = parseInt(n / base);\\n        var remainder = n % base;\\n        var oneInBase = 0;\\n        if(answer === 1){\\n            oneInBase = n - base + 1;\\n        }else{\\n            oneInBase = base;\\n        }\\n        return countDigitOne(base - 1) * answer + oneInBase + countDigitOne(remainder);\\n    };"
		}
	],
	"id":"233",
	"title":"Number of Digit One",
	"content":"<p>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.</p>\r\n\r\n<p>\r\nFor example:<br> \r\nGiven n = 13,<br>\r\nReturn 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.\r\n</p>",
	"frequency":"518",
	"ac_num":"32879"
}