{
	"difficulty":"2",
	"submit_num":"114612",
	"show_id":"241",
	"leetcode_id":"241",
	"answers":[
		{
			"lc_ans_id":"66328",
			"view":"27319",
			"top":"0",
			"title":"A recursive Java solution (284 ms)",
			"vote":"183",
			"content":"    public class Solution {\\n        public List<Integer> diffWaysToCompute(String input) {\\n            List<Integer> ret = new LinkedList<Integer>();\\n            for (int i=0; i<input.length(); i++) {\\n                if (input.charAt(i) == '-' ||\\n                    input.charAt(i) == '*' ||\\n                    input.charAt(i) == '+' ) {\\n                    String part1 = input.substring(0, i);\\n                    String part2 = input.substring(i+1);\\n                    List<Integer> part1Ret = diffWaysToCompute(part1);\\n                    List<Integer> part2Ret = diffWaysToCompute(part2);\\n                    for (Integer p1 :   part1Ret) {\\n                        for (Integer p2 :   part2Ret) {\\n                            int c = 0;\\n                            switch (input.charAt(i)) {\\n                                case '+': c = p1+p2;\\n                                    break;\\n                                case '-': c = p1-p2;\\n                                    break;\\n                                case '*': c = p1*p2;\\n                                    break;\\n                            }\\n                            ret.add(c);\\n                        }\\n                    }\\n                }\\n            }\\n            if (ret.size() == 0) {\\n                ret.add(Integer.valueOf(input));\\n            }\\n            return ret;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"66331",
			"view":"16014",
			"top":"1",
			"title":"C++ 4ms Recursive & DP solution with brief explanation",
			"vote":"116",
			"content":"Here is the basic recursive solution\\n\\n    class Solution {\\n    public:\\n        vector<int> diffWaysToCompute(string input) {\\n            vector<int> result;\\n            int size = input.size();\\n            for (int i = 0; i < size; i++) {\\n                char cur = input[i];\\n                if (cur == '+' || cur == '-' || cur == '*') {\\n                    // Split input string into two parts and solve them recursively\\n                    vector<int> result1 = diffWaysToCompute(input.substr(0, i));\\n                    vector<int> result2 = diffWaysToCompute(input.substr(i+1));\\n                    for (auto n1 : result1) {\\n                        for (auto n2 : result2) {\\n                            if (cur == '+')\\n                                result.push_back(n1 + n2);\\n                            else if (cur == '-')\\n                                result.push_back(n1 - n2);\\n                            else\\n                                result.push_back(n1 * n2);    \\n                        }\\n                    }\\n                }\\n            }\\n            // if the input string contains only number\\n            if (result.empty())\\n                result.push_back(atoi(input.c_str()));\\n            return result;\\n        }\\n    };\\n\\nThere are many repeating subquestions in this recursive method, therefore, we could use dynamic programming to avoid this situation by saving the results for subquestions. Here is the DP solution.\\n\\n    class Solution {\\n    public:\\n    \\tvector<int> diffWaysToCompute(string input) {\\n    \\t\\tunordered_map<string, vector<int>> dpMap;\\n    \\t\\treturn computeWithDP(input, dpMap);\\n    \\t}\\n    \\n    \\tvector<int> computeWithDP(string input, unordered_map<string, vector<int>> &dpMap) {\\n    \\t\\tvector<int> result;\\n    \\t\\tint size = input.size();\\n    \\t\\tfor (int i = 0; i < size; i++) {\\n    \\t\\t\\tchar cur = input[i];\\n    \\t\\t\\tif (cur == '+' || cur == '-' || cur == '*') {\\n    \\t\\t\\t\\t// Split input string into two parts and solve them recursively\\n    \\t\\t\\t\\tvector<int> result1, result2;\\n    \\t\\t\\t\\tstring substr = input.substr(0, i);\\n    \\t\\t\\t\\t// check if dpMap has the result for substr\\n    \\t\\t\\t\\tif (dpMap.find(substr) != dpMap.end())\\n    \\t\\t\\t\\t\\tresult1 = dpMap[substr];\\n    \\t\\t\\t\\telse\\n    \\t\\t\\t\\t\\tresult1 = computeWithDP(substr, dpMap);\\n    \\n    \\t\\t\\t\\tsubstr = input.substr(i + 1);\\n    \\t\\t\\t\\tif (dpMap.find(substr) != dpMap.end())\\n    \\t\\t\\t\\t\\tresult2 = dpMap[substr];\\n    \\t\\t\\t\\telse\\n    \\t\\t\\t\\t\\tresult2 = computeWithDP(substr, dpMap);\\n    \\t\\t\\t\\t\\n    \\t\\t\\t\\tfor (auto n1 : result1) {\\n    \\t\\t\\t\\t\\tfor (auto n2 : result2) {\\n    \\t\\t\\t\\t\\t\\tif (cur == '+')\\n    \\t\\t\\t\\t\\t\\t\\tresult.push_back(n1 + n2);\\n    \\t\\t\\t\\t\\t\\telse if (cur == '-')\\n    \\t\\t\\t\\t\\t\\t\\tresult.push_back(n1 - n2);\\n    \\t\\t\\t\\t\\t\\telse\\n    \\t\\t\\t\\t\\t\\t\\tresult.push_back(n1 * n2);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// if the input string contains only number\\n    \\t\\tif (result.empty())\\n    \\t\\t\\tresult.push_back(atoi(input.c_str()));\\n    \\t\\t// save to dpMap\\n    \\t\\tdpMap[input] = result;\\n    \\t\\treturn result;\\n    \\t}\\n    };"
		},
		{
			"lc_ans_id":"66350",
			"view":"12846",
			"top":"2",
			"title":"1-11 lines Python, 9 lines C++",
			"vote":"78",
			"content":"Just doing it...\\n\\n---\\n\\n**Solution 1** ... 48 ms\\n\\n    def diffWaysToCompute(self, input):\\n       tokens = re.split('(\\\\D)', input)\\n       nums = map(int, tokens[::2])\\n       ops = map({'+': operator.add, '-': operator.sub, '*': operator.mul}.get, tokens[1::2])\\n       def build(lo, hi):\\n           if lo == hi:\\n               return [nums[lo]]\\n           return [ops[i](a, b)\\n                   for i in xrange(lo, hi)\\n                   for a in build(lo, i)\\n                   for b in build(i + 1, hi)]\\n       return build(0, len(nums) - 1)\\n\\n---\\n\\n**Solution 2** ... 168 ms\\n\\nOne-liner inspired by [Soba](https://leetcode.com/discuss/48410/python-solution-52ms-with-simple-interpretation?show=48432#a48432).\\n\\n    def diffWaysToCompute(self, input):\\n        return [eval(`a`+c+`b`)\\n                for i, c in enumerate(input) if c in '+-*'\\n                for a in self.diffWaysToCompute(input[:i])\\n                for b in self.diffWaysToCompute(input[i+1:])] or [int(input)]\\n\\n---\\n\\n**Solution 3** ... 64 ms\\n\\nFaster version of solution 2.\\n\\n    def diffWaysToCompute(self, input):\\n        return [a+b if c == '+' else a-b if c == '-' else a*b\\n                for i, c in enumerate(input) if c in '+-*'\\n                for a in self.diffWaysToCompute(input[:i])\\n                for b in self.diffWaysToCompute(input[i+1:])] or [int(input)]\\n\\n---\\n\\n**Solution 4** ... 188 ms\\n\\nA code golf version of solution 2.\\n\\n    diffWaysToCompute=d=lambda s,t:[eval(`a`+c+`b`)for i,c in enumerate(t)if\\n    c<'0'for a in s.d(t[:i])for b in s.d(t[i+1:])]or[int(t)]\\n\\n---\\n\\n**C++** ... 8 ms\\n\\nC++ version of solution 3.\\n\\n    vector<int> diffWaysToCompute(string input) {\\n        vector<int> output;\\n        for (int i=0; i<input.size(); i++) {\\n            char c = input[i];\\n            if (ispunct(c))\\n                for (int a : diffWaysToCompute(input.substr(0, i)))\\n                    for (int b : diffWaysToCompute(input.substr(i+1)))\\n                        output.push_back(c=='+' ? a+b : c=='-' ? a-b : a*b);\\n        }\\n        return output.size() ? output : vector<int>{stoi(input)};\\n    }"
		},
		{
			"lc_ans_id":"66342",
			"view":"6925",
			"top":"3",
			"title":"Share a clean and short JAVA solution",
			"vote":"53",
			"content":"    public class Solution {\\n        public List<Integer> diffWaysToCompute(String input) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            for (int i = 0; i < input.length(); i++) {\\n                char c = input.charAt(i);\\n                if (c == '-' || c == '+' || c == '*') {\\n                    String a = input.substring(0, i);\\n                    String b = input.substring(i + 1);\\n                    List<Integer> al = diffWaysToCompute(a);\\n                    List<Integer> bl = diffWaysToCompute(b);\\n                    for (int x : al) {\\n                        for (int y : bl) {\\n                            if (c == '-') {\\n                                res.add(x - y);\\n                            } else if (c == '+') {\\n                                res.add(x + y);\\n                            } else if (c == '*') {\\n                                res.add(x * y);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            if (res.size() == 0) res.add(Integer.valueOf(input));\\n            return res;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"66419",
			"view":"4290",
			"top":"4",
			"title":"Python easy to understand solution (divide and conquer).",
			"vote":"41",
			"content":"        \\n   \\n    def diffWaysToCompute(self, input):\\n        if input.isdigit():\\n            return [int(input)]\\n        res = []\\n        for i in xrange(len(input)):\\n            if input[i] in \"-+*\":\\n                res1 = self.diffWaysToCompute(input[:i])\\n                res2 = self.diffWaysToCompute(input[i+1:])\\n                for j in res1:\\n                    for k in res2:\\n                        res.append(self.helper(j, k, input[i]))\\n        return res\\n        \\n    def helper(self, m, n, op):\\n        if op == \"+\":\\n            return m+n\\n        elif op == \"-\":\\n            return m-n\\n        else:\\n            return m*n"
		},
		{
			"lc_ans_id":"66333",
			"view":"3505",
			"top":"5",
			"title":"Java recursive (9ms) and dp (4ms) solution",
			"vote":"34",
			"content":"I think it's more efficient to pre-parse the string because String.substring() is costly. I store the parsed string in a list, for example, if the string is 1+2+3+4, then the list will contain:\\n\\n    \"1\", \"+\", \"2\", \"+\", \"3\", \"+\", \"4\"\\n\\nPersonally I feel this is also more convenient because all integers occurs at even indices (0, 2, 4, 6) and all operators are at odd indices (1, 3, 5).\\n\\nThen the problem is very similar to \"Unique Binary Search Trees II\". For each operator in the list, we compute all possible results for entries to the left of that operator, which is `List<Integer> left`, and also all possible results for entries to the right of that operator, namely `List<Integer> right`, and combine the results. It can be achieved by recursion or more efficiently by dp.\\n\\nRecursion:\\n\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> result=new ArrayList<>();\\n        if(input==null||input.length()==0)  return result;\\n        List<String> ops=new ArrayList<>();\\n        for(int i=0; i<input.length(); i++){\\n            int j=i;\\n            while(j<input.length()&&Character.isDigit(input.charAt(j)))\\n                j++;\\n            String num=input.substring(i, j);\\n            ops.add(num);\\n            if(j!=input.length())   ops.add(input.substring(j, j+1));\\n            i=j;\\n        }\\n        result=compute(ops, 0, ops.size()-1);\\n        return result;\\n    }\\n    private List<Integer> compute(List<String> ops, int lo, int hi){\\n        List<Integer> result=new ArrayList<>();\\n        if(lo==hi){\\n            Integer num=Integer.valueOf(ops.get(lo));\\n            result.add(num);\\n            return result;\\n        }\\n        for(int i=lo+1; i<=hi-1; i=i+2){\\n            String operator=ops.get(i);\\n            List<Integer> left=compute(ops,lo, i-1), right=compute(ops, i+1, hi);\\n            for(int leftNum:left)\\n                for(int rightNum: right){\\n                    if(operator.equals(\"+\"))\\n                        result.add(leftNum+rightNum);\\n                    else if(operator.equals(\"-\"))\\n                        result.add(leftNum-rightNum);\\n                    else\\n                        result.add(leftNum*rightNum);\\n                }\\n        }\\n        return result;\\n    }\\n\\n\\nAnd DP, where dp[i][j] stores all possible results from the i-th integer to the j-th integer (inclusive) in the list.\\n\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> result=new ArrayList<>();\\n        if(input==null||input.length()==0)  return result;\\n        List<String> ops=new ArrayList<>();\\n        for(int i=0; i<input.length(); i++){\\n            int j=i;\\n            while(j<input.length()&&Character.isDigit(input.charAt(j)))\\n                j++;\\n            ops.add(input.substring(i, j));\\n            if(j!=input.length())   ops.add(input.substring(j, j+1));\\n            i=j;\\n        }\\n        int N=(ops.size()+1)/2; //num of integers\\n        ArrayList<Integer>[][] dp=(ArrayList<Integer>[][]) new ArrayList[N][N];\\n        for(int d=0; d<N; d++){\\n            if(d==0){\\n                for(int i=0; i<N; i++){\\n                    dp[i][i]=new ArrayList<>();\\n                    dp[i][i].add(Integer.valueOf(ops.get(i*2)));\\n                }\\n                continue;\\n            }\\n            for(int i=0; i<N-d; i++){\\n                dp[i][i+d]=new ArrayList<>();\\n                for(int j=i; j<i+d; j++){\\n                    ArrayList<Integer> left=dp[i][j], right=dp[j+1][i+d];\\n                    String operator=ops.get(j*2+1);\\n                    for(int leftNum:left)\\n                        for(int rightNum:right){\\n                            if(operator.equals(\"+\"))\\n                                dp[i][i+d].add(leftNum+rightNum);\\n                            else if(operator.equals(\"-\"))\\n                                dp[i][i+d].add(leftNum-rightNum);\\n                            else\\n                                dp[i][i+d].add(leftNum*rightNum);\\n                        }\\n                }\\n            }\\n        }\\n        return dp[0][N-1];\\n    }"
		},
		{
			"lc_ans_id":"66395",
			"view":"3306",
			"top":"6",
			"title":"Java recursive solution with memorization",
			"vote":"22",
			"content":"    public class Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        //cache for memorization\\n        HashMap<String,List<Integer>> cache = new HashMap<String,List<Integer>>();\\n        return this.helper(input,cache);\\n    }\\n    \\n    List<Integer>helper(String s, HashMap<String,List<Integer>> cache) {\\n        if (cache.get(s)!=null) {\\n            return cache.get(s);\\n        }\\n        boolean expression = false;\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n        for(int i=0; i<s.length(); i++) {\\n            if(\"+-*\".indexOf(s.charAt(i))!=-1) {\\n                List<Integer> left = helper(s.substring(0,i),cache);\\n                List<Integer> right = helper(s.substring(i+1),cache);\\n                for(Integer l: left) {\\n                    for(Integer r: right) {\\n                        result.add(cal(l,r,s.charAt(i)));\\n                    }\\n                }\\n                expression = true;\\n            }\\n        }\\n        if (!expression) {\\n            result.add(Integer.parseInt(s));\\n        }\\n        cache.put(s, result);\\n        return result;\\n    }\\n    int cal(int l, int r, char op) {\\n        int result = 0;\\n        switch (op) {\\n            case '+': result= l+r; break;\\n            case '-': result = l-r; break;\\n            case '*': result= l*r; break;\\n            default: break;\\n        }\\n        return result;\\n    }\\n    }\\n\\nWe first split the string by operators and recursively calculate left and right side, then combine the result. The only improvement is to use memorization to cache previously calculated expressions."
		},
		{
			"lc_ans_id":"66329",
			"view":"1465",
			"top":"7",
			"title":"Java Simple Solution beats 95%",
			"vote":"19",
			"content":"    public class Solution {\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        public List<Integer> diffWaysToCompute(String input) {\\n            if(map.containsKey(input))\\n                return map.get(input);\\n            List<Integer> res = new ArrayList<>();\\n            for(int i=0;i<input.length();++i){\\n                char c=input.charAt(i);\\n                if(c=='+'|| c=='-' || c=='*'){\\n                    List<Integer> list1 = diffWaysToCompute(input.substring(0,i));\\n                    List<Integer> list2 = diffWaysToCompute(input.substring(i+1));\\n                    for(int v1:list1){\\n                        for(int v2: list2){\\n                            if(c=='+')\\n                                res.add(v1+v2);\\n                            if(c=='-')\\n                                res.add(v1-v2);\\n                            if(c=='*')\\n                                res.add(v1*v2);\\n                        }\\n                    }\\n                }\\n            }\\n            if(res.isEmpty())\\n                res.add(Integer.parseInt(input));\\n            map.put(input, res);\\n            return res;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"66415",
			"view":"1657",
			"top":"8",
			"title":"14-line c++ solution",
			"vote":"14",
			"content":"    class Solution {\\n    public:\\n        \\n        vector<int> diffWaysToCompute(string input) {\\n            vector<int> ans;\\n            bool pureNum=true;\\n            for (int i=0; i<input.length(); i++) \\n                if (input[i]<'0' || input[i]>'9') {\\n                    pureNum=false;\\n                    vector<int> L=diffWaysToCompute(input.substr(0, i)), R=diffWaysToCompute(input.substr(i+1, input.length()-i-1));\\n                    for (auto l : L)\\n                        for (auto r : R)\\n                            if (input[i]=='+') ans.push_back(l+r);\\n                            else if (input[i]=='-') ans.push_back(l-r);\\n                            else if (input[i]=='*') ans.push_back(l*r);\\n                }\\n            \\n            if (pureNum)\\n                ans.push_back(atoi(input.c_str()));\\n            return ans;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"66372",
			"view":"1806",
			"top":"9",
			"title":"My recursive java solution",
			"vote":"12",
			"content":"    public class Solution {\\n    public List<Integer> diffWaysToCompute(String input) {\\n        List<Integer> list=new ArrayList();\\n        if(input==null||input.length()==0) return list;\\n        if(!input.contains(\"+\")&&!input.contains(\"-\")&&!input.contains(\"*\")) {\\n            list.add(Integer.valueOf(input));\\n            return list;\\n        }\\n        for(int i=0;i<input.length();i++){\\n             char ops=input.charAt(i);\\n             if(ops=='+'||ops=='-'||ops=='*'){\\n                List<Integer> leftList=diffWaysToCompute(input.substring(0,i));\\n                List<Integer> rightList=diffWaysToCompute(input.substring(i+1,input.length()));\\n                for(int leftValue:leftList){\\n                    for(int rightValue:rightList){\\n                        switch(ops){\\n                            case '+': list.add(leftValue+rightValue); break;\\n                            case '-': list.add(leftValue-rightValue); break;\\n                            case '*': list.add(leftValue*rightValue); break;\\n                        }\\n                    }\\n                }\\n             }\\n          }\\n        return list;\\n    }\\n}"
		}
	],
	"id":"241",
	"title":"Different Ways to Add Parentheses",
	"content":"<p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are <code>+</code>, <code>-</code> and <code>*</code>.</p>\r\n<br>\r\n<b>Example 1</b>\r\n<p>Input: <code>\"2-1-1\"</code>.</p> \r\n<pre>((2-1)-1) = 0\r\n(2-(1-1)) = 2</pre>\r\n<p>Output: <code>[0, 2]</code></p>\r\n<br>\r\n<b>Example 2</b>\r\n<p>Input: <code>\"2*3-4*5\"</code></p> \r\n<pre>(2*(3-(4*5))) = -34\r\n((2*3)-(4*5)) = -14\r\n((2*(3-4))*5) = -10\r\n(2*((3-4)*5)) = -10\r\n(((2*3)-4)*5) = 10</pre>\r\n<p>Output: <code>[-34, -14, -10, -10, 10]</code></p> \r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/mithmatt\">@mithmatt</a> for adding this problem and creating all test cases.</p>",
	"frequency":"455",
	"ac_num":"52213"
}