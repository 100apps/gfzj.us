{
	"difficulty":"3",
	"submit_num":"33805",
	"show_id":"248",
	"leetcode_id":"248",
	"answers":[
		{
			"lc_ans_id":"67378",
			"view":"8828",
			"top":"0",
			"title":"Concise Java Solution",
			"vote":"64",
			"content":"* Construct char arrays from `low.length()` to `high.length()` \\n* Add stro pairs from outside\\n* When `left` > `right`, add eligible `count`\\n\\n\\n    private static final char[][] pairs = {{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\\n    \\n    public int strobogrammaticInRange(String low, String high) {\\n        int[] count = {0};\\n        for (int len = low.length(); len <= high.length(); len++) {\\n            char[] c = new char[len];\\n            dfs(low, high, c, 0, len - 1, count);\\n        }\\n        return count[0];\\n    }\\n    \\n    public void dfs(String low, String high , char[] c, int left, int right, int[] count) {\\n        if (left > right) {\\n            String s = new String(c);\\n            if ((s.length() == low.length() && s.compareTo(low) < 0) || \\n                (s.length() == high.length() && s.compareTo(high) > 0)) {\\n                return;\\n            }\\n            count[0]++;\\n            return;\\n        }\\n        for (char[] p : pairs) {\\n            c[left] = p[0];\\n            c[right] = p[1];\\n            if (c.length != 1 && c[0] == '0') {\\n                continue;\\n            }\\n            if (left == right && p[0] != p[1]) {\\n                continue;\\n            }\\n            dfs(low, high, c, left + 1, right - 1, count);\\n        }\\n    }"
		},
		{
			"lc_ans_id":"67406",
			"view":"5724",
			"top":"1",
			"title":"Clear Java AC solution using Strobogrammatic Number II method",
			"vote":"29",
			"content":"The basic idea is to find generate a list of strobogrammatic number with the length between the length of lower bound and the length of upper bound. Then we pass the list and ignore the numbers with the same length of lower bound or upper bound but not in the range.\\n\\nI think it is not a a very optimized method and can any one provide a better one?\\n\\n\\n\\n    public class Solution{\\n    \\n    \\n    \\tpublic int strobogrammaticInRange(String low, String high){\\n    \\t\\tint count = 0;\\n    \\t\\tList<String> rst = new ArrayList<String>();\\n    \\t\\tfor(int n = low.length(); n <= high.length(); n++){\\n    \\t\\t\\trst.addAll(helper(n, n));\\n    \\t\\t}\\n    \\t\\tfor(String num : rst){\\n    \\t\\t    \\n    \\t\\t\\tif((num.length() == low.length()&&num.compareTo(low) < 0 ) ||(num.length() == high.length() && num.compareTo(high) > 0)) continue;\\n    \\t\\t\\t\\tcount++;\\n    \\t\\t}\\n    \\t\\treturn count;\\n    \\t}\\n    \\n    \\tprivate List<String> helper(int cur, int max){\\n    \\t\\tif(cur == 0) return new ArrayList<String>(Arrays.asList(\"\"));\\n    \\t\\tif(cur == 1) return new ArrayList<String>(Arrays.asList(\"1\", \"8\", \"0\"));\\n    \\n    \\t\\tList<String> rst = new ArrayList<String>();\\n    \\t\\tList<String> center = helper(cur - 2, max);\\n    \\n    \\t\\tfor(int i = 0; i < center.size(); i++){\\n    \\t\\t\\tString tmp = center.get(i);\\n    \\t\\t\\tif(cur != max) rst.add(\"0\" + tmp + \"0\");\\n    \\t\\t\\trst.add(\"1\" + tmp + \"1\");\\n    \\t\\t\\trst.add(\"6\" + tmp + \"9\");\\n    \\t\\t\\trst.add(\"8\" + tmp + \"8\");\\n    \\t\\t\\trst.add(\"9\" + tmp + \"6\");\\n    \\t\\t}\\n    \\t\\treturn rst;\\n    \\t}\\n    }"
		},
		{
			"lc_ans_id":"67393",
			"view":"2540",
			"top":"2",
			"title":"JAVA 0ms solution (99.5%)",
			"vote":"13",
			"content":"Basic Idea:\\n\\nreturn all valid nums under upper (inclusive) - all valid nums under low (exclusive).\\n\\nSuppose upper has length len. The numbers of valid nums of len_i's < len, can be very efficiently computed using recursion or Math.pow();. \\n\\n\\nFor valid nums with len, construct them all and aggressively discard them if they are higher than upper (pruning). After all, char array comparison is cheap :   if(compareCharArray(chs, upper, i) > 0)     break;\\n\\n    public class Solution {\\n        private static char[][] pairs = new char[][]{{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\\n        public int strobogrammaticInRange(String low, String high) {\\n            if(low.length()>high.length() || low.length()==high.length() && high.compareTo(low)<0) return 0;\\n            return strobogrammaticInRangeFrom0(high, true) - strobogrammaticInRangeFrom0(low, false);\\n        }\\n        private int strobogrammaticInRangeFrom0(String num, boolean inclusive){\\n            int len = num.length();\\n            if(len == 1){\\n                if(num.charAt(0) == '0')        return inclusive ? 1 : 0;       // 0?\\n                else if(num.charAt(0) == '1')   return inclusive ? 2 : 1;       // 0,1?\\n                else if(num.charAt(0) < '8')    return 2;                       // 0,1\\n                else if(num.charAt(0) == '8')   return inclusive ? 3 : 2;       // 0,1,8?\\n                else                            return 3;                       // 0,1,8\\n            }\\n            int sum = 0;\\n            for(int i = 1; i < len; i++)\\n                sum += strobogrammaticDigit(i, true);\\n            sum += strobogrammaticInRangeSameDigits(new char[len], 0, len - 1, num.toCharArray(),inclusive);\\n            return sum;\\n        }\\n        private int strobogrammaticInRangeSameDigits(char[] chs, int i, int j, char[] upper, boolean inclusive){\\n            int sum = 0;\\n            if(i > j){\\n                if( inclusive && compareCharArray(upper, chs, chs.length-1 ) >= 0 || !inclusive && compareCharArray(upper, chs, chs.length-1) > 0 )    return 1;\\n                else    return 0;\\n            }\\n            for(char[] pair: pairs){\\n                if(i == 0 && pair[0] == '0' || i==j && (pair[0] == '6' || pair[0] == '9') )     continue;\\n                chs[i] = pair[0];\\n                chs[j] = pair[1];\\n                if(compareCharArray(chs, upper, i) > 0)     break;\\n                sum += strobogrammaticInRangeSameDigits(chs, i+1, j-1, upper, inclusive);\\n            }\\n            return sum;\\n        }\\n        private int strobogrammaticDigit(int digit, boolean outside){\\n            if(digit == 0)      return 1;\\n            if(digit == 1)      return 3;\\n            return outside? strobogrammaticDigit(digit-2, false)*4: strobogrammaticDigit(digit-2, false)*5;\\n        }\\n        private int compareCharArray(char[] arr1, char[] arr2, int idx){\\n            for(int i = 0; i <= idx; i++)\\n                if(arr1[i] == arr2[i])          continue;\\n                else if(arr1[i] > arr2[i])      return 1;\\n                else                            return -1;\\n            return 0;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"67380",
			"view":"1883",
			"top":"3",
			"title":"Python solution 180ms",
			"vote":"9",
			"content":"The solution is also base on strobogrammatic number II, but with a little optimization.\\n\\n    class Solution:\\n    # @param {string} low\\n    # @param {string} high\\n    # @return {integer}\\n    def strobogrammaticInRange(self, low, high):\\n        a=self.below(high)\\n        b=self.below(low,include=False)\\n        return a-b if a>b else 0\\n    \\n    '''\\n    get how many strobogrammatic numbers less than n\\n    '''\\n    def below(self,n,include=True):\\n        res=0\\n        for i in range(1,len(n)):\\n            res+=self.number(i)\\n        l=self.strobogrammatic(len(n))\\n        '''\\n        filter num larger than n and start with 0\\n        '''\\n        if include:\\n            l=[num for num in l if (len(num)==1 or num[0]!='0') and num<=n]\\n        else:\\n            l=[num for num in l if (len(num)==1 or num[0]!='0') and num<n]\\n        return res+len(l)\\n    \\n    '''\\n    get strobogrammatic numbers with length l\\n    number start with 0 would be included\\n    '''\\n    def strobogrammatic(self,l):\\n        res=[]\\n        if l==1:\\n            return ['0','1','8']\\n        if l==2:\\n            return ['00','11','69','96','88']\\n        for s in self.strobogrammatic(l-2):\\n            res.append('0'+s+'0')\\n            res.append('1'+s+'1')\\n            res.append('6'+s+'9')\\n            res.append('8'+s+'8')\\n            res.append('9'+s+'6')\\n        return res\\n\\n    '''\\n    get number of strobogrammatic numbers of length l\\n    '''\\n    def number(self,l):\\n        if l==0:\\n            return 0\\n        '''\\n        If l is an even number, the first digit has four choices (1,6,8,9). digits \\n        at other position have five choices(0,1,6,8,9)\\n        '''\\n        if l%2==0:\\n            return 4*(5**(l/2-1))\\n        '''\\n        If l is an odd number, the first digit has four choices (1,6,8,9) and digit \\n        at the middle has 3 choices (0,1,8),other digits have 5 choices.\\n        digit at other position could be 0,1,6,8,9\\n        '''\\n        elif l==1:\\n            return 3\\n        else:\\n            return 3*(5**(l/2-1))*4"
		},
		{
			"lc_ans_id":"67432",
			"view":"1498",
			"top":"4",
			"title":"C++ accepted solution",
			"vote":"6",
			"content":"    bool compare(string s1, string s2) {\\n\\t\\tif (s1.length() != s2.length())\\n\\t\\t\\treturn s1.length() <= s2.length();\\n\\n\\t\\tfor (int i = 0; i < s1.length(); i++) {\\n\\t\\t\\tif (s1[i] < s2[i]) return true;\\n\\t\\t\\telse if (s1[i] > s2[i]) return false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tint strobogrammaticInRange(const vector<pair<char, char>>& nums, const string& low, const string& high, string t, int cnt) {\\n\\t\\tif (high.length() < t.length())\\n\\t\\t\\treturn cnt;\\n\\t\\tif (compare(low, t) && compare(t, high)) \\n\\t\\t\\tif (t.length() == 1 || t.length() > 1 && t.front() != '0')\\n\\t\\t\\t\\tcnt++;\\n\\n\\t\\tfor (auto iter = nums.begin(); iter != nums.end(); ++iter) \\n\\t\\t\\tcnt = strobogrammaticInRange(nums, low, high, string(1, iter->first) + t + string(1, iter->second), cnt);\\n\\n\\t\\treturn cnt;\\n\\t}\\n\\n\\tint strobogrammaticInRange(string low, string high) {\\n\\t\\tif (!compare(low, high)) return 0;\\n\\n\\t\\tvector<pair<char, char>> nums = { { '0', '0' }, { '1', '1' }, { '6', '9' }, { '8', '8' }, { '9', '6' } };\\n\\t\\t\\n\\t\\tint cnt = strobogrammaticInRange(nums, low, high, \"\", 0);\\n\\t\\tcnt = strobogrammaticInRange(nums, low, high, \"0\", cnt);\\n\\t\\tcnt = strobogrammaticInRange(nums, low, high, \"1\", cnt);\\n\\t\\tcnt = strobogrammaticInRange(nums, low, high, \"8\", cnt);\\n\\t\\t\\n\\t\\treturn cnt;\\n\\t}"
		},
		{
			"lc_ans_id":"67433",
			"view":"3011",
			"top":"5",
			"title":"Clean and Easy Understanding Java Solution",
			"vote":"6",
			"content":"My clear Java solution. All comments are welcome.\\n\\n        public class Solution {\\n    Map<Character, Character> map = new HashMap<>();\\n    {\\n        map.put('1', '1');\\n        map.put('8', '8');\\n        map.put('6', '9');\\n        map.put('9', '6');\\n        map.put('0', '0');\\n    }\\n    String low = \"\", high = \"\";\\n    public int strobogrammaticInRange(String low, String high) {\\n        this.low = low;\\n        this.high = high;\\n        int result = 0;\\n        for(int n = low.length(); n <= high.length(); n++){\\n            int[] count = new int[1];\\n            strobogrammaticInRange(new char[n], count, 0, n-1);\\n            result += count[0];\\n        }\\n        return result;\\n    }\\n    private void strobogrammaticInRange(char[] arr, int[] count, int lo, int hi){\\n        if(lo > hi){\\n            String s = new String(arr);\\n            if((arr[0] != '0' || arr.length == 1) && compare(low, s) && compare(s, high)){\\n                count[0]++;\\n            }\\n            return;\\n        }\\n        for(Character c: map.keySet()){\\n            arr[lo] = c;\\n            arr[hi] = map.get(c);\\n            if((lo == hi && c == map.get(c)) || lo < hi)\\n                strobogrammaticInRange(arr, count, lo+1, hi-1);\\n        }\\n    }\\n    private boolean compare(String a, String b){\\n        if(a.length() != b.length())\\n            return a.length() < b.length();\\n        int i = 0;\\n        while(i < a.length() &&a.charAt(i) == b.charAt(i))\\n            i++;\\n        return i == a.length() ? true: a.charAt(i) <= b.charAt(i);\\n    }\\n}"
		},
		{
			"lc_ans_id":"67414",
			"view":"513",
			"top":"6",
			"title":"Java 1ms solution with comments in the code",
			"vote":"4",
			"content":"Key points:\\n\\n1. Generating the numbers in ascending order so it can be teminated when the number is greater than high.\\n2. Only need to actually generate the numbers having the same length of low and high for range checking. The total nubmers of other lengths can be counted with a dp function.\\n3. Using char arrays and placing char on both ends is faster than using adding String operation. In addtion, comparing char arrays directly should be faster than calling String.compareTo() function. \\n\\n        public class Solution {\\n        char[] singles = new char[]{'0','1','8'};\\n        // Sorted by the first char in ascending order\\n        char[][] pairs = new char[][]{ {'0','0'},{'1','1'},{'6','9'},{'8','8'},{'9','6'} };\\n        char[] ans; // buffer of storing the number\\n        int count = 0; // total count\\n        char[] l; // char array of low\\n        char[] h; // char array of high\\n        \\n        // Compare two numbers' char array. Longer one is the larger one.\\n        // If have same length then compare each char from left to right\\n        // return positive when s2 > s1, 0 when s2==s1, nagetive when s2 < s1\\n        int comp(char[] s1, char[] s2) {\\n            int len1 = s1.length;\\n            int len2 = s2.length;\\n            if (len1 != len2) return len2-len1;\\n            else {\\n                for (int i=0; i < len1; i++) {\\n                    if (s1[i] != s2[i]) return s2[i]-s1[i];\\n                }\\n                return 0;\\n            }\\n        }\\n        // Recursion for generating Strobogrammatic numbers of length n \\n        // starting from both ends. As a result, the numbers are \\n        // generate in ascending order.\\n        // Therefore, when when a number is greater than high it returns false \\n        // and then terminate the loop. \\n        boolean helper(int n, int s, int e, int len) {\\n            if (n==0) return false;\\n            if (len==n) { // a resulting number \\n                // checking the range\\n                if ( comp(l, ans) >=0  && comp(ans, h) >=0 ) count++;\\n                if ( comp(ans, h) < 0) return false; // the nubmer is greater than high\\n                return true;\\n            } else if (s==e) { // odd length at the middle position, apply single digit\\n                for (int i =0 ; i< singles.length; i++) {\\n                    if ( ! ( s == 0 && i == 0 && n > 1)  ) { // first digit can't be 0\\n                        ans[s] = singles[i];\\n                        if ( ! helper( n, s+1, e-1, len+1) ) return false;\\n                    }\\n                }\\n            } else { // placing two digits at both ends\\n                for (int i =0 ; i< pairs.length; i++) {\\n                    char[] pair = pairs[i];\\n                    if ( ! ( s == 0 && i == 0)  ) { // first digit can't be 0\\n                        ans[s] = pair[0];\\n                        ans[e] = pair[1];\\n                        if ( ! helper( n, s+1, e-1, len+2 ) ) return false;\\n                    }\\n                }\\n            }\\n            return true;\\n        }\\n        // counting the total Strobogrammatic numbers of lengh n \\n        // without considering the range\\n        int counts(int n, int next) {\\n            if (next<=0) return 0;\\n            if (next==1) return 3;\\n            if (next==2) return n==next? 4 :5; // first digit can't be 0\\n            return n==next? 4 * counts(n, next-2) : 5 * counts(n, next-2);\\n        }\\n        \\n        public int strobogrammaticInRange(String low, String high) {\\n            int low_len = low.length();\\n            int high_len = high.length();\\n            l = low.toCharArray();\\n            h = high.toCharArray();\\n            for (int i=low_len; i <= high_len; i++) {\\n                // generating the numbers only when the length is equal to low or high\\n                if (i== low_len || i== high_len) {\\n                    ans = new char[i];\\n                    helper(i, 0, i-1, 0);\\n                } else { \\n                    // counting the total numbers without acctualy generating them\\n                    count+=counts(i,i);\\n                }\\n            }\\n            return count;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"67422",
			"view":"459",
			"top":"7",
			"title":"Python iterative solution, like level order traversal",
			"vote":"4",
			"content":"    class Solution(object):\\n        def strobogrammaticInRange(self, low, high):\\n            \"\"\"\\n            :type low: str\\n            :type high: str\\n            :rtype: int\\n            \"\"\"\\n            maps={\"0\":\"0\",\"1\":\"1\",\"6\":\"9\",\"8\":\"8\",\"9\":\"6\"}\\n            cl,ch=len(low), len(high)\\n            if cl>ch or (cl==ch and low>high): return 0\\n            \\n            ans=[\"\",\"0\",\"1\",\"8\"]\\n            count=0\\n            while ans:\\n                tmp=[]\\n                for w in ans:\\n                    if len(w)<ch or (len(w)==ch and w<=high):\\n                        if len(w)>cl or (len(w)==cl and w>=low):  \\n                            if len(w)>1 and w[0]==\"0\":##leading zeros\\n                                pass\\n                            else:\\n                                count+=1\\n                        \\n                        if ch-len(w)>=2:                \\n                            for key in maps:\\n                                res=key+w+maps[key]\\n                                tmp.append(res)\\n                ans=tmp\\n            return count"
		},
		{
			"lc_ans_id":"67437",
			"view":"1184",
			"top":"8",
			"title":"AC Java solution with explanation",
			"vote":"4",
			"content":"    public class Solution {\\n      \\n      int count = 0;\\n      String[][] pairs = {{\"0\", \"0\"}, {\"1\", \"1\"}, {\"6\", \"9\"}, {\"8\", \"8\"}, {\"9\", \"6\"}};\\n      \\n      public int strobogrammaticInRange(String low, String high) {\\n        // use a look-up table to return the strobogrammatic list of length n\\n        Map<Integer, List<String>> map = new HashMap<Integer, List<String>>();\\n        map.put(0, new ArrayList<String>(Arrays.asList(\"\")));\\n        map.put(1, new ArrayList<String>(Arrays.asList(\"0\", \"1\", \"8\")));\\n        \\n        // loop through all possible lengths\\n        for (int len = low.length(); len <= high.length(); len++)\\n          helper(len, map, low, high);\\n        \\n        return count;\\n      }\\n      \\n      // return the strobogrammatic list of length n \\n      List<String> helper(int n, Map<Integer, List<String>> map, String low, String high) {\\n        List<String> res = new ArrayList<String>();\\n        \\n        if (map.containsKey(n)) {\\n          res = map.get(n);\\n        } else {\\n          // found in look-up table? return it, otherwise do the recursion by n - 2\\n          List<String> list = map.containsKey(n - 2) ? map.get(n - 2) : helper(n - 2, map, low, high);\\n          \\n          for (int i = 0; i < list.size(); i++) {\\n            String s = list.get(i);\\n            \\n            for (int j = 0; j < pairs.length; j++) {\\n              // form the new strobogrammatic number\\n              String v = pairs[j][0] + s + pairs[j][1];\\n              \\n              // if it's larger than high already, no need to proceed\\n              if (v.length() == high.length() && v.compareTo(high) > 0)\\n                break;\\n              \\n              res.add(v);\\n            }\\n          }\\n          \\n          // put the new list to look-up table\\n          map.put(n, res);\\n        }\\n        \\n        // if current length is longer than low\\n        // we start to count\\n        if (n >= low.length()) {\\n          count += res.size();\\n          \\n          for (String s : res) {\\n            // eliminate the number that is outside [low, high] range\\n            if ((s.length() > 1 && s.charAt(0) == '0') || \\n                (s.length() == low.length() && s.compareTo(low) < 0) || \\n                (s.length() == high.length() && s.compareTo(high) > 0))\\n              count--;\\n          }\\n        }\\n        \\n        return res;\\n      }\\n      \\n    }"
		},
		{
			"lc_ans_id":"67404",
			"view":"212",
			"top":"9",
			"title":"Fast general solution with detailed solution without generating numbers",
			"vote":"2",
			"content":"### 1. Introduction\\nThe idea based on this [post](https://discuss.leetcode.com/topic/50073/python-46ms-96-77-without-generating-all-the-numbers). I rewrote some part of the codes and made it more general  and understandable to all the language coding member. The main idea is as follow:\\n1) count the number less than high.\\n2) count the number less than low-1.\\n3)  minus the two result getting the final answer.\\n\\n### 2. Count the strobogrammatic number less than a number\\nWe can divide the problem into two mini issues.\\n1) Count the number with the less length than the target string number.\\n2) Count the number with the same length of the target string number.\\n\\n#### 2.1 With less length\\nTo solve this problem,  we can use dynamic programming. We know the following transfer equation:\\n`dp[0]=1 dp[1]=3,dp[2]=5 dp[i]=dp[i-2]*5`\\nIt's simple to get the results. However, the results contain the first digital with `0`. To get rid of these invalid results, we only need times`4/5` since the are `5` in `dp[2]`.\\n\\n\\n#### 2.2 With the same length\\nIt's the core and hard part of this problem. We need to take consideration of the total length and the situation equal to the target number.\\nUsing one pointer `spos` to locate the candidate numbers and another length iteration pointer `pstr`. Every iteration the total length minus `2` since we get rid of the fist and last characters. For the candidates, there are three situations:\\n* Only one digital, it's `(0,1,8)`\\n* The first layer means the first pair, it's could be `(1,6,8,9)`\\n* The others could be `(0, 1, 6, 8, 9)`\\n\\nFor all the numbers in candidates, \\n1) if the number less than the target position number, we can directly add the `dp[pstr-2]`. \\n2) If it equals, we need to do more work. Checking the mapping position number is less than or equal to the target, record the count of this situations. If only reaches the half length of the numbers, it could be the right candidates. For example:  the target number is `8 9 7 8 9`, the fist candidate  number is `8` and the second is `9`, since the `8<9` and '6<8' , we reaches the most inner layer of the number, so `8 9 * 6 8` is the candidates (* means less than 7).    \\n\\nThe coding could be like this:\\n```python\\nclass Solution(object):\\n    def __init__(self):\\n        # 1-{0,1,8} 2-{00,11,69,88,96}\\n        self.cntmemo = {-1: 1, 0: 1, 1: 3, 2: 5}\\n        # mapping the corresponding number\\n        self.mapping = {0: 0, 1: 1, 6: 9, 8: 8, 9: 6}\\n\\n    def count_same_len(self, str_num):\\n        slen = len(str_num)\\n        spos, pstr = 0, slen\\n        rescnt = 0\\n        # record equal cnt when compare with the target\\n        lesscnt = 0\\n        while pstr > 0:\\n            if slen == 1 or pstr == 1:\\n                candidates = (0, 1, 8)\\n            # first digital get rid of 0\\n            elif pstr == slen:\\n                candidates = (1, 6, 8, 9)\\n            else:\\n                candidates = (0, 1, 6, 8, 9)\\n            for num in candidates:\\n                # if the number less than the target,add all the possible in strlen-2\\n                if num < int(str_num[spos]):\\n                    rescnt += self.cntmemo[pstr - 2]\\n                # if equal we need to record, util to the middle compare\\n                elif num == int(str_num[spos]):\\n                    # if the mapping pos num less or equal to the target, it's possible\\n                    if self.mapping[num] <= int(str_num[slen-1-spos]):\\n                        # record the less cnt\\n                        lesscnt += 1\\n                        if pstr < 3 and lesscnt == (slen + 1) / 2:\\n                            rescnt += 1\\n                    break\\n                else:\\n                    return rescnt\\n            pstr -= 2\\n            spos += 1\\n        return rescnt\\n    \\n    def count_less_than(self, str_num):\\n        rescnt, slen = 0, len(str_num)\\n        # count the number less than str_num with length less than str len\\n        if int(str_num) < 0: return 0\\n        if slen > 1:\\n            # len==1\\n            rescnt = 3\\n            # len>2\\n            for i in xrange(2, slen):\\n                rescnt += self.cntmemo[i] * 4 / 5\\n        # plus the number with the same length\\n        return rescnt+self.count_same_len(str_num)\\n\\n    def strobogrammaticInRange(self, low, high):\\n        if int(low) > int(high):\\n            return 0\\n        # count all larger than 2\\n        for i in xrange(3, len(high)):\\n            self.cntmemo[i] = self.cntmemo[i - 2] * 5\\n        return self.count_less_than(high) - self.count_less_than(str(int(low)-1))\\n```"
		}
	],
	"id":"248",
	"title":"Strobogrammatic Number III",
	"content":"<p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>\r\n<p>Write a function to count the total strobogrammatic numbers that exist in the range of low <= num <= high.</p>\r\n<p>For example,<br>\r\nGiven low = \"50\", high = \"100\", return 3. Because 69, 88, and 96 are three strobogrammatic numbers.\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\nBecause the range might be a large number, the <i>low</i> and <i>high</i> numbers are represented as string.\r\n</p>",
	"frequency":"158",
	"ac_num":"10974"
}