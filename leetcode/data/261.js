{
	"difficulty":"2",
	"submit_num":"129291",
	"show_id":"261",
	"leetcode_id":"261",
	"answers":[
		{
			"lc_ans_id":"69018",
			"view":"26375",
			"top":"0",
			"title":"AC Java Union-Find solution",
			"vote":"162",
			"content":"    public class Solution {\\n        public boolean validTree(int n, int[][] edges) {\\n            // initialize n isolated islands\\n            int[] nums = new int[n];\\n            Arrays.fill(nums, -1);\\n            \\n            // perform union find\\n            for (int i = 0; i < edges.length; i++) {\\n                int x = find(nums, edges[i][0]);\\n                int y = find(nums, edges[i][1]);\\n                \\n                // if two vertices happen to be in the same set\\n                // then there's a cycle\\n                if (x == y) return false;\\n                \\n                // union\\n                nums[x] = y;\\n            }\\n            \\n            return edges.length == n - 1;\\n        }\\n        \\n        int find(int nums[], int i) {\\n            if (nums[i] == -1) return i;\\n            return find(nums, nums[i]);\\n        }\\n    }"
		},
		{
			"lc_ans_id":"69019",
			"view":"7693",
			"top":"1",
			"title":"Simple and clean c++ solution, with detailed explanation.",
			"vote":"95",
			"content":"\\n    class Solution {\\n    public:\\n        bool validTree(int n, vector<pair<int, int>>& edges) {\\n            vector<int> nodes(n,0);\\n            for(int i=0; i<n; i++) nodes[i] = i;\\n            for(int i=0; i<edges.size(); i++){\\n                int f = edges[i].first;\\n                int s = edges[i].second;\\n                while(nodes[f]!=f) f = nodes[f];\\n                while(nodes[s]!=s) s = nodes[s];\\n                if(nodes[f] == nodes[s]) return false;\\n                nodes[s] = f;\\n            }\\n            return edges.size() == n-1;\\n        }\\n    };\\n\\n\\n\\nTo tell whether a graph is a valid tree, we have to:\\n\\n1. Make sure there is no cycle in the graph - this has to be a none-cyclic graph;\\n2. Make sure every node is reached - this has to be a connected graph;\\n\\nReference: https://en.wikipedia.org/wiki/Tree_(graph_theory)\\n\\nSolution: \\n\\n1. To test cyclic, we can make an array for each node (as array index), and the array will store the parent of the node (as array index). Every time we fetch a new pair of nodes, we trace the root node (the deepest parent node) of these two nodes, if it has the same root, then is will be a cycle; otherwise, we set the parent of second node to be the first node;\\n2. After we make sure there is node cycle in the graph, we simple test if there is enough edges to make this graph connected."
		},
		{
			"lc_ans_id":"69020",
			"view":"12778",
			"top":"2",
			"title":"8-10 lines, Union-Find, DFS and BFS",
			"vote":"48",
			"content":"There are so many different approaches and so many different ways to implement each. I find it hard to decide, so here are several :-)\\n\\nIn all of them, I check one of these tree characterizations:\\n\\n- Has n-1 edges and is acyclic.\\n- Has n-1 edges and is connected.\\n\\n---\\n\\n**Solution 1** ... **Union-Find**\\n\\nThe test cases are small and harmless, [simple union-find](https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Disjoint-set_forests) suffices (runs in about 50~60 ms).\\n\\n    def validTree(self, n, edges):\\n        parent = range(n)\\n        def find(x):\\n            return x if parent[x] == x else find(parent[x])\\n        def union(xy):\\n            x, y = map(find, xy)\\n            parent[x] = y\\n            return x != y\\n        return len(edges) == n-1 and all(map(union, edges))\\n\\nA version without using `all(...)`, to be closer to other programming languages:\\n\\n    def validTree(self, n, edges):\\n        parent = range(n)\\n        def find(x):\\n            return x if parent[x] == x else find(parent[x])\\n        for e in edges:\\n            x, y = map(find, e)\\n            if x == y:\\n                return False\\n            parent[x] = y\\n        return len(edges) == n - 1\\n\\nA version checking `len(edges) != n - 1` first, as `parent = range(n)` could fail for huge `n`:\\n\\n    def validTree(self, n, edges):\\n        if len(edges) != n - 1:\\n            return False\\n        parent = range(n)\\n        def find(x):\\n            return x if parent[x] == x else find(parent[x])\\n        def union(xy):\\n            x, y = map(find, xy)\\n            parent[x] = y\\n            return x != y\\n        return all(map(union, edges))\\n\\n---\\n\\n**Solution 2** ... **DFS**\\n\\n    def validTree(self, n, edges):\\n        neighbors = {i: [] for i in range(n)}\\n        for v, w in edges:\\n            neighbors[v] += w,\\n            neighbors[w] += v,\\n        def visit(v):\\n            map(visit, neighbors.pop(v, []))\\n        visit(0)\\n        return len(edges) == n-1 and not neighbors\\n\\nOr check the number of edges first, to be faster and to survive unreasonably huge `n`:\\n\\n    def validTree(self, n, edges):\\n        if len(edges) != n - 1:\\n            return False\\n        neighbors = {i: [] for i in range(n)}\\n        for v, w in edges:\\n            neighbors[v] += w,\\n            neighbors[w] += v,\\n        def visit(v):\\n            map(visit, neighbors.pop(v, []))\\n        visit(0)\\n        return not neighbors\\n\\nFor an iterative version, just replace the three \"visit\" lines with\\n\\n        stack = [0]\\n        while stack:\\n            stack += neighbors.pop(stack.pop(), [])\\n\\n---\\n\\n**Solution 3** ... **BFS**\\n\\nJust like DFS above, but replace the three \"visit\" lines with\\n\\n        queue = [0]\\n        for v in queue:\\n            queue += neighbors.pop(v, [])\\n\\nor, since that is not guaranteed to work, the safer\\n\\n        queue = collections.deque([0])\\n        while queue:\\n            queue.extend(neighbors.pop(queue.popleft(), []))"
		},
		{
			"lc_ans_id":"69042",
			"view":"12898",
			"top":"3",
			"title":"AC Java Graph DFS solution with adjacency list",
			"vote":"48",
			"content":"    public class Solution {\\n        public boolean validTree(int n, int[][] edges) {\\n            // initialize adjacency list\\n            List<List<Integer>> adjList = new ArrayList<List<Integer>>(n);\\n            \\n            // initialize vertices\\n            for (int i = 0; i < n; i++)\\n                adjList.add(i, new ArrayList<Integer>());\\n            \\n            // add edges    \\n            for (int i = 0; i < edges.length; i++) {\\n                int u = edges[i][0], v = edges[i][1];\\n                adjList.get(u).add(v);\\n                adjList.get(v).add(u);\\n            }\\n            \\n            boolean[] visited = new boolean[n];\\n            \\n            // make sure there's no cycle\\n            if (hasCycle(adjList, 0, visited, -1))\\n                return false;\\n            \\n            // make sure all vertices are connected\\n            for (int i = 0; i < n; i++) {\\n                if (!visited[i]) \\n                    return false;\\n            }\\n            \\n            return true;\\n        }\\n        \\n        // check if an undirected graph has cycle started from vertex u\\n        boolean hasCycle(List<List<Integer>> adjList, int u, boolean[] visited, int parent) {\\n            visited[u] = true;\\n            \\n            for (int i = 0; i < adjList.get(u).size(); i++) {\\n                int v = adjList.get(u).get(i);\\n                \\n                if ((visited[v] && parent != v) || (!visited[v] && hasCycle(adjList, v, visited, u)))\\n                    return true;\\n            }\\n            \\n            return false;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"69038",
			"view":"6287",
			"top":"4",
			"title":"Share my [25-line DFS], [20-line BFS] and [clean Union-Find] Java solutions",
			"vote":"32",
			"content":"> Check 2 things: 1. whether there is loop 2. whether the number of connected components is 1\\n\\n\\n----------\\n\\n\\n> DFS\\n\\n    public class Solution {\\n        public boolean validTree(int n, int[][] edges) {\\n            int[] visited = new int[n];\\n            List<List<Integer>> adjList = new ArrayList<>();\\n            for (int i=0; i<n; ++i) { adjList.add(new ArrayList<Integer>()); }\\n            for (int[] edge: edges) {\\n                adjList.get(edge[0]).add(edge[1]);\\n                adjList.get(edge[1]).add(edge[0]);\\n            }\\n            if (hasCycle(-1, 0, visited, adjList)) { return false; }  // has cycle\\n            for (int v: visited) { if (v == 0) { return false; } }  // not 1 single connected component\\n            return true;\\n        }\\n        \\n        private boolean hasCycle(int pred, int vertex, int[] visited, List<List<Integer>> adjList) {\\n            visited[vertex] = 1;  // current vertex is being visited\\n            for (Integer succ: adjList.get(vertex)) {  // successors of current vertex\\n                if (succ != pred) {  // exclude current vertex's predecessor\\n                    if (visited[succ] == 1) { return true; }  // back edge/loop detected!\\n                    else if (visited[succ] == 0) {\\n                        if (hasCycle(vertex, succ, visited, adjList)) { return true; }\\n                    }\\n                }\\n            }\\n            visited[vertex] = 2;\\n            return false;\\n        }\\n    }\\n\\n> BFS\\n\\n    public class Solution {\\n        public boolean validTree(int n, int[][] edges) {\\n            int[] visited = new int[n];\\n            List<List<Integer>> adjList = new ArrayList<>();\\n            for (int i=0; i<n; ++i) { adjList.add(new ArrayList<Integer>()); }\\n            for (int[] edge: edges) {\\n                adjList.get(edge[0]).add(edge[1]);\\n                adjList.get(edge[1]).add(edge[0]);\\n            }\\n            Deque<Integer> q = new ArrayDeque<>();\\n            q.addLast(0); visited[0] = 1;  // vertex 0 is in the queue, being visited\\n            while (!q.isEmpty()) {\\n                Integer cur = q.removeFirst();\\n                for (Integer succ: adjList.get(cur)) {\\n                    if (visited[succ] == 1) { return false; }  // loop detected\\n                    if (visited[succ] == 0) { q.addLast(succ); visited[succ] = 1; }\\n                }\\n                visited[cur] = 2;  // visit completed\\n            }\\n            for (int v: visited) { if (v == 0) { return false; } }  // # of connected components is not 1\\n            return true;\\n        }\\n    }\\n\\n> Union-Find with path compression and merge by rank\\n\\n    public class Solution {\\n        \\n        class UnionFind {\\n            \\n            int[] parent;\\n            int[] rank;\\n            int count;\\n            \\n            UnionFind(int n) {\\n                parent = new int[n];\\n                rank = new int[n];\\n                count = n;  // number of components\\n                for (int i=0; i<n; ++i) { parent[i] = i; }  // initially, each node's parent is itself.\\n            }\\n            \\n            int find(int x) {\\n                if (x != parent[x]) {\\n                    parent[x] = find(parent[x]);  // find root with path compression\\n                }\\n                return parent[x];\\n            }\\n            \\n            boolean union(int x, int y) {\\n                int X = find(x), Y = find(y);\\n                if (X == Y) { return false; }\\n                if (rank[X] > rank[Y]) { parent[Y] = X; }  // tree Y is lower\\n                else if (rank[X] < rank[Y]) { parent[X] = Y; }  // tree X is lower\\n                else {  // same height\\n                    parent[Y] = X;\\n                    ++rank[X];\\n                }\\n                --count;\\n                return true;\\n            }\\n        }\\n        \\n        public boolean validTree(int n, int[][] edges) {\\n            UnionFind uf = new UnionFind(n);\\n            for (int[] edge: edges) {\\n                int x = edge[0], y = edge[1];\\n                if (!uf.union(x, y)) { return false; }  // loop detected\\n            }\\n            return uf.count == 1;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"69078",
			"view":"4749",
			"top":"5",
			"title":"AC Java solutions: Union-Find, BFS, DFS",
			"vote":"19",
			"content":"    class Node{\\n        int val;\\n        Node parent;\\n        public Node(int val)\\n        {\\n            this.val = val;\\n        }\\n    }\\n    \\n    public class Solution {\\n        Map<Integer, Node> forest;\\n        \\n        public boolean validTree(int n, int[][] edges) {\\n            return unionFind(n, edges);\\n        }\\n        \\n        private boolean unionFind(int n, int[][] edges)\\n        {\\n            // make set for each node\\n            forest = new HashMap<Integer, Node>();\\n            for(int i = 0; i < n; i++)\\n                forest.put(i, makeSet(i));\\n            \\n            // for the two vertice of each edge, find if they are in the same set,\\n            // If so, there is a cycle, return false.\\n            for(int[] edge : edges)\\n            {\\n                if(find(edge[0]) == find(edge[1]))\\n                    return false;\\n                \\n                union(edge[0], edge[1]);\\n            }\\n            \\n            return edges.length == n - 1;\\n        }\\n        \\n        private Node makeSet(int val)\\n        {\\n            Node node = new Node(val);\\n            node.parent = node;\\n            return node;\\n        }\\n        \\n        private Node find(int node)\\n        {\\n            if(forest.get(node).parent.val == node)\\n                return forest.get(node);\\n            \\n            return find(forest.get(node).parent.val);\\n        }\\n        \\n        private void union(int node1, int node2)\\n        {\\n            Node set1 = find(node1);\\n            Node set2 = find(node2);\\n            set1.parent = set2;\\n        }\\n        \\n        // DFS, using stack\\n        private boolean validDFS(int n, int[][] edges)\\n        {\\n            // build the graph using adjacent list\\n            List<Set<Integer>> graph = new ArrayList<Set<Integer>>();\\n            for(int i = 0; i < n; i++)\\n                graph.add(new HashSet<Integer>());\\n            for(int[] edge : edges)\\n            {\\n                graph.get(edge[0]).add(edge[1]);\\n                graph.get(edge[1]).add(edge[0]);\\n            }\\n            \\n            // no cycle\\n            boolean[] visited = new boolean[n];\\n            Deque<Integer> stack = new ArrayDeque<Integer>();\\n            stack.push(0);\\n            while(!stack.isEmpty())\\n            {\\n                int node = stack.pop();\\n                if(visited[node])\\n                    return false;\\n                visited[node] = true;\\n                for(int neighbor : graph.get(node))\\n                {\\n                    stack.push(neighbor);\\n                    graph.get(neighbor).remove(node);\\n                }\\n            }\\n            \\n            // fully connected\\n            for(boolean result : visited)\\n            {\\n                if(!result)\\n                    return false;\\n            }\\n            \\n            return true;\\n        }\\n        \\n        // BFS, using queue\\n        private boolean valid(int n, int[][] edges)\\n        {\\n            // build the graph using adjacent list\\n            List<Set<Integer>> graph = new ArrayList<Set<Integer>>();\\n            for(int i = 0; i < n; i++)\\n                graph.add(new HashSet<Integer>());\\n            for(int[] edge : edges)\\n            {\\n                graph.get(edge[0]).add(edge[1]);\\n                graph.get(edge[1]).add(edge[0]);\\n            }\\n            \\n            // no cycle\\n            boolean[] visited = new boolean[n];\\n            Queue<Integer> queue = new ArrayDeque<Integer>();\\n            queue.add(0);\\n            while(!queue.isEmpty())\\n            {\\n                int node = queue.poll();\\n                if(visited[node])\\n                    return false;\\n                visited[node] = true;\\n                for(int neighbor : graph.get(node))\\n                {\\n                    queue.offer(neighbor);\\n                    graph.get(neighbor).remove((Integer)node);\\n                }\\n            }\\n            \\n            // fully connected\\n            for(boolean result : visited)\\n            {\\n                if(!result)\\n                    return false;\\n            }\\n            \\n            return true;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"69110",
			"view":"2450",
			"top":"6",
			"title":"Java BFS Solution",
			"vote":"11",
			"content":"    public class Solution {\\n        public boolean validTree(int n, int[][] edges) {\\n            // n must be at least 1\\n            if (n < 1) return false;\\n\\n            // create hashmap to store info of edges\\n            Map<Integer, Set<Integer>> map = new HashMap<>();\\n            for (int i = 0; i < n; i++) map.put(i, new HashSet<>());\\n            for (int[] edge : edges) {\\n                map.get(edge[0]).add(edge[1]);\\n                map.get(edge[1]).add(edge[0]);\\n            }\\n\\n            // bfs starts with node in label \"0\"\\n            Set<Integer> set = new HashSet<>();\\n            Queue<Integer> queue = new LinkedList<>();\\n            queue.add(0);\\n            while (!queue.isEmpty()) {\\n                int top = queue.remove();\\n                // if set already contains top, then the graph has cycle\\n                // hence return false\\n                if (set.contains(top)) return false;\\n\\n                for (int node : map.get(top)) {\\n                    queue.add(node);\\n                    // we should remove the edge: node -> top\\n                    // after adding a node into set to avoid duplicate\\n                    // since we already consider top -> node\\n                    map.get(node).remove(top);\\n                }\\n                set.add(top);\\n            }\\n            return set.size() == n;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"69036",
			"view":"3045",
			"top":"7",
			"title":"16-lines C++ DFS",
			"vote":"11",
			"content":"As suggested by the hint, just check for cycle and connectedness in the graph. Both of these can be done via DFS.\\n\\nThe code is as follows.\\n\\n    class Solution {\\n    public:\\n        bool validTree(int n, vector<pair<int, int>>& edges) {\\n            vector<vector<int>> neighbors(n);\\n            for (auto e : edges) {\\n                neighbors[e.first].push_back(e.second);\\n                neighbors[e.second].push_back(e.first);\\n            }\\n            vector<bool> visited(n, false);\\n            if (hasCycle(neighbors, 0, -1, visited))\\n                return false;\\n            for (bool v : visited)\\n                if (!v) return false; \\n            return true;\\n        } \\n    private:\\n        bool hasCycle(vector<vector<int>>& neighbors, int kid, int parent, vector<bool>& visited) {\\n            if (visited[kid]) return true;\\n            visited[kid] = true;\\n            for (auto neigh : neighbors[kid])\\n                if (neigh != parent && hasCycle(neighbors, neigh, kid, visited))\\n                    return true;\\n            return false;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"69118",
			"view":"891",
			"top":"8",
			"title":"Java, simple DFS solution",
			"vote":"9",
			"content":"    public boolean validTree(int n, int[][] edges) {\\n        boolean[] visited = new boolean[n];\\n        List<Integer>[] adj = new ArrayList[n];\\n        for (int i = 0; i < adj.length; i++) \\n            adj[i] = new ArrayList<Integer>();\\n        for (int[] edge : edges) {\\n            adj[edge[0]].add(edge[1]);\\n            adj[edge[1]].add(edge[0]);\\n        }\\n        if (!dfs(0, -1, visited, adj)) return false;\\n        for (boolean b : visited)\\n            if (!b) return false;\\n        return true;\\n    }\\n    \\n    // p is the pointer to 'parent' node, we ignore it to avoid infinite loop\\n    private boolean dfs(int v, int p, boolean[] visited, List<Integer>[] adj) {\\n        visited[v] = true;\\n        for (int i : adj[v]) {\\n            if (i == p) continue;\\n            if (visited[i] || !dfs(i, v, visited, adj)) return false;\\n        }\\n        return true;\\n    }"
		},
		{
			"lc_ans_id":"69080",
			"view":"1161",
			"top":"9",
			"title":"Simple 1ms Java Union-Find Solution",
			"vote":"8",
			"content":"    public class Solution {\\n        public boolean validTree(int n, int[][] edges) {\\n            if (n <= 1) return true;\\n            int[] parent = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n            for (int[] edge : edges) {\\n                int x = find(parent, edge[0]);\\n                int y = find(parent, edge[1]);\\n                if (x == y) return false;\\n                parent[y] = x;\\n            }\\n            \\n            return edges.length == n - 1;\\n        }\\n        \\n        public int find(int[] parent, int i) {\\n            if (parent[i] != i) {\\n                parent[i] = find(parent, parent[i]);\\n            }\\n            return parent[i];\\n        }\\n    }"
		}
	],
	"id":"261",
	"title":"Graph Valid Tree",
	"content":"<p>\r\nGiven <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\r\n</p>\r\n\r\n<p>\r\nFor example:\r\n</p>\r\n<p>\r\nGiven <code>n = 5</code> and <code>edges = [[0, 1], [0, 2], [0, 3], [1, 4]]</code>, return <code>true</code>.\r\n</p>\r\n<p>\r\nGiven <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]</code>, return <code>false</code>.\r\n</p>\r\n\r\n<p>\r\n<b>Note</b>: you can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.\r\n</p>",
	"frequency":"118",
	"ac_num":"49592"
}