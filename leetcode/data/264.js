{
	"difficulty":"2",
	"submit_num":"210495",
	"show_id":"264",
	"leetcode_id":"264",
	"answers":[
		{
			"lc_ans_id":"69364",
			"view":"24677",
			"top":"0",
			"title":"My 16ms C++ DP solution with short explanation",
			"vote":"234",
			"content":"We have an array *k* of first n ugly number. We only know, at the beginning, the first one, which is 1. Then\\n\\nk[1] = min( k[0]x2, k[0]x3, k[0]x5). The answer is k[0]x2. So we move 2's pointer to 1. Then we test:\\n\\nk[2] = min( k[1]x2, k[0]x3, k[0]x5). And so on. Be careful about the cases such as 6, in which we need to forward both pointers of 2 and 3. \\n\\nx here is multiplication.\\n\\n    class Solution {\\n    public:\\n        int nthUglyNumber(int n) {\\n            if(n <= 0) return false; // get rid of corner cases \\n            if(n == 1) return true; // base case\\n            int t2 = 0, t3 = 0, t5 = 0; //pointers for 2, 3, 5\\n            vector<int> k(n);\\n            k[0] = 1;\\n            for(int i  = 1; i < n ; i ++)\\n            {\\n                k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5));\\n                if(k[i] == k[t2]*2) t2++; \\n                if(k[i] == k[t3]*3) t3++;\\n                if(k[i] == k[t5]*5) t5++;\\n            }\\n            return k[n-1];\\n        }\\n    };"
		},
		{
			"lc_ans_id":"69362",
			"view":"21795",
			"top":"1",
			"title":"O(n) Java solution",
			"vote":"172",
			"content":"The idea of this solution is from this page:http://www.geeksforgeeks.org/ugly-numbers/\\n   \\nThe ugly-number sequence is 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, \\u2026\\nbecause every number can only be divided by 2, 3, 5, one way to look at the sequence is to split the sequence to three groups as below:\\n\\n    (1) 1\\xd72, 2\\xd72, 3\\xd72, 4\\xd72, 5\\xd72, \\u2026\\n    (2) 1\\xd73, 2\\xd73, 3\\xd73, 4\\xd73, 5\\xd73, \\u2026\\n    (3) 1\\xd75, 2\\xd75, 3\\xd75, 4\\xd75, 5\\xd75, \\u2026\\n   \\nWe can find that every subsequence is the ugly-sequence itself (1, 2, 3, 4, 5, \\u2026) multiply 2, 3, 5. \\n\\nThen we use similar merge method as merge sort, to get every ugly number from the three subsequence.    \\n\\nEvery step we choose the smallest one, and move one step after,including nums with same value.\\n\\nThanks for this author about this brilliant idea. Here is my java solution\\n\\n    public class Solution {\\n        public int nthUglyNumber(int n) {\\n            int[] ugly = new int[n];\\n            ugly[0] = 1;\\n            int index2 = 0, index3 = 0, index5 = 0;\\n            int factor2 = 2, factor3 = 3, factor5 = 5;\\n            for(int i=1;i<n;i++){\\n                int min = Math.min(Math.min(factor2,factor3),factor5);\\n                ugly[i] = min;\\n                if(factor2 == min)\\n                    factor2 = 2*ugly[++index2];\\n                if(factor3 == min)\\n                    factor3 = 3*ugly[++index3];\\n                if(factor5 == min)\\n                    factor5 = 5*ugly[++index5];\\n            }\\n            return ugly[n-1];\\n        }\\n    }"
		},
		{
			"lc_ans_id":"69368",
			"view":"9321",
			"top":"2",
			"title":"Elegant C++ Solution O(N) space time with detailed explanation.",
			"vote":"133",
			"content":"    struct Solution {\\n        int nthUglyNumber(int n) {\\n            vector <int> results (1,1);\\n            int i = 0, j = 0, k = 0;\\n            while (results.size() < n)\\n            {\\n                results.push_back(min(results[i] * 2, min(results[j] * 3, results[k] * 5)));\\n                if (results.back() == results[i] * 2) ++i;\\n                if (results.back() == results[j] * 3) ++j;\\n                if (results.back() == results[k] * 5) ++k;\\n            }\\n            return results.back();\\n        }\\n    };\\n\\n**Explanation:**\\n\\nThe key is to realize each number can be and have to be generated by a former number multiplied by 2, 3 or 5\\ne.g. \\n1 2 3 4 5 6 8 9 10 12 15..\\nwhat is next?\\nit must be x * 2 or y * 3 or z * 5, where x, y, z is an existing number.\\n\\nHow do we determine x, y, z then?\\napparently, you can just *traverse the sequence generated by far* from 1 ... 15, until you find such x, y, z that x * 2, y * 3, z * 5 is just bigger than 15. In this case x=8, y=6, z=4. Then you compare x * 2, y * 3, z * 5 so you know next number will be x * 2 = 8 * 2 = 16.\\nk, now you have 1,2,3,4,....,15, 16,\\n\\nThen what is next?\\nYou wanna do the same process again to find the new x, y, z, but you realize, wait, do I have to \\n*traverse the sequence generated by far* again? \\n\\nNO! since you know last time, x=8, y=6, z=4 and x=8 was used to generate 16, so this time, you can immediately know the new_x = 9 (the next number after 8 is 9 in the generated sequence), y=6, z=4.\\nThen you need to compare new_x * 2, y * 3, z * 5. You know next number is 9 * 2 = 18;\\n\\nAnd you also know, the next x will be 10 since new_x = 9 was used this time.\\nBut what is next y? apparently, if y=6, 6*3 = 18, which is already generated in this round. So you also need to update next y from 6 to 8.\\n\\nBased on the idea above, you can actually generated x,y,z from very beginning, and update x, y, z accordingly. It ends up with a O(n) solution."
		},
		{
			"lc_ans_id":"69384",
			"view":"4631",
			"top":"3",
			"title":"My expressive Python solution",
			"vote":"43",
			"content":"\\n    def nthUglyNumber(self, n):\\n        ugly = [1]\\n        i2, i3, i5 = 0, 0, 0\\n        while n > 1:\\n            u2, u3, u5 = 2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5]\\n            umin = min((u2, u3, u5))\\n            if umin == u2:\\n                i2 += 1\\n            if umin == u3:\\n                i3 += 1\\n            if umin == u5:\\n                i5 += 1\\n            ugly.append(umin)\\n            n -= 1\\n        return ugly[-1]"
		},
		{
			"lc_ans_id":"69385",
			"view":"7076",
			"top":"4",
			"title":"Java Easy Understand O(n) Solution",
			"vote":"31",
			"content":"The basic idea of this problem is to compute all the ugly numbers in sequence and count to the given number of k ugly numbers. The way I approached this problem is first I have a arraylist to store the ugly numbers in sequence. Then I declared three counter variables: a,b,and c which represent the corresponding index in the arraylist for the multiplier of 2,3,and 5. Since each previous ugly number times one of the multiplier will produce a new ugly number, I start from the starting index 0 and multiply the ugly number at that index with each multiplier and get the smallest product which is the next ugly number from the three. The corresponding multipliers' index will be incremented by one and we do this recursively until we have K ugly numbers. Here is the code implementation in Java:\\n\\n    public class Solution {\\n    \\tpublic int nthUglyNumber(int n) {\\n    \\t\\tif(n<=0) return 0;\\n    \\t\\tint a=0,b=0,c=0;\\n    \\t\\tList<Integer> table = new ArrayList<Integer>();\\n    \\t\\ttable.add(1);\\n    \\t\\twhile(table.size()<n)\\n    \\t\\t{\\n    \\t\\t\\tint next_val = Math.min(table.get(a)*2,Math.min(table.get(b)*3,table.get(c)*5));\\n    \\t\\t\\ttable.add(next_val);\\n    \\t\\t\\tif(table.get(a)*2==next_val) a++;\\n    \\t\\t\\tif(table.get(b)*3==next_val) b++;\\n    \\t\\t\\tif(table.get(c)*5==next_val) c++;\\n    \\t\\t}\\n    \\t\\treturn table.get(table.size()-1);\\n    \\t}\\n    }"
		},
		{
			"lc_ans_id":"69427",
			"view":"2959",
			"top":"5",
			"title":"C++, one pass, simple solution.",
			"vote":"28",
			"content":"Use three index for 2, 3, 5 in to trace the last generated numbers based on 2, 3, 5 and generate next number based on the last generated numbers.\\n\\n    class Solution {\\n    public:\\n        int nthUglyNumber(int n) {\\n            if(n<1)\\n                return 0;\\n    \\n            int id2=0, id3=0, id5=0, rst=1;\\n            vector<int> buf;\\n    \\n            while(--n)\\n            {\\n                buf.push_back(rst);\\n    \\n                int v2 = 2*(buf[id2]), v3 = 3*(buf[id3]), v5 = 5*(buf[id5]);\\n                rst = min(v2, min(v3, v5));\\n                \\n                id2 += (rst == v2), id3 += (rst == v3), id5 += (rst == v5);\\n            }\\n            return rst;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"69439",
			"view":"2311",
			"top":"6",
			"title":"Shortest O(n) Java DP solution",
			"vote":"27",
			"content":"    public int nthUglyNumber(int n) {\\n            if(n==1) return 1;\\n            int[] dp = new int[n+1]; // dp[i] holds the ith's ugly number\\n            dp[1] = 1;\\n            int p2=1, p3=1, p5=1;\\n            for(int i=2; i<=n; i++){ // loop invariant:dp[i] holds the smallest ith uglynumber\\n                dp[i] = Math.min(2*dp[p2], Math.min(3*dp[p3],5*dp[p5])); // the next ugly number must be built from a smaller ugly number\\n                if(dp[i]==2*dp[p2])p2++; \\n                if(dp[i]==3*dp[p3])p3++;\\n                if(dp[i]==5*dp[p5])p5++;\\n            }\\n            return dp[n];\\n        }"
		},
		{
			"lc_ans_id":"69372",
			"view":"5156",
			"top":"7",
			"title":"Java solution -- using PriorityQueue",
			"vote":"26",
			"content":"    public int nthUglyNumber(int n) {\\n        if(n==1) return 1;\\n        PriorityQueue<Long> q = new PriorityQueue();\\n        q.add(1l);\\n        \\n        for(long i=1; i<n; i++) {\\n            long tmp = q.poll();\\n            while(!q.isEmpty() && q.peek()==tmp) tmp = q.poll();\\n            \\n            q.add(tmp*2);\\n            q.add(tmp*3);\\n            q.add(tmp*5);\\n        }\\n        return q.poll().intValue();\\n    }"
		},
		{
			"lc_ans_id":"69373",
			"view":"2966",
			"top":"8",
			"title":"Short and O(n), Python and C++",
			"vote":"22",
			"content":"I love this problem. Came up with a linear time solution almost 13 years ago and now I still correctly remembered that it was problem 136 at the now defunct acm.uva.es :-)\\n\\n---\\n\\n**Python** ... **Simple Precompute** ... 64 ms\\n\\nIt's fastest to precompute and store all possibilities for lookup, and it's simplest to just generate them out of order and then sort them.\\n\\n    class Solution:\\n        ugly = sorted(2**a * 3**b * 5**c\\n                      for a in range(32) for b in range(20) for c in range(14))\\n        def nthUglyNumber(self, n):\\n            return self.ugly[n-1]\\n\\n---\\n\\n**Python** ... **O(n), generate first n in order** ... 308 ms\\n\\nMy version of [epsilon0's solution](https://uva.onlinejudge.org/board/viewtopic.php?p=6441#p6441). It's nicer than my own old one.\\n\\nThis generates the first n ugly numbers, in order from smallest to largest, in O(n) time. For each prime 2, 3 and 5, have an index to the next number that can be multiplied with the prime to produce a new ugly number. Update the three indexes and then add the smallest of the three candidate ugly numbers.\\n\\n    def nthUglyNumber(self, n):\\n        ugly = [1]\\n        i2 = i3 = i5 = 0\\n        while len(ugly) < n:\\n            while ugly[i2] * 2 <= ugly[-1]: i2 += 1\\n            while ugly[i3] * 3 <= ugly[-1]: i3 += 1\\n            while ugly[i5] * 5 <= ugly[-1]: i5 += 1\\n            ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))\\n        return ugly[-1]\\n\\n---\\n\\n**Python** ... **O(n), generate first n in order with heapq.merge** ... 416 ms\\n\\nI like using heapq.merge.\\n\\n    def nthUglyNumber(self, n):\\n        q2, q3, q5 = [2], [3], [5]\\n        ugly = 1\\n        for u in heapq.merge(q2, q3, q5):\\n            if n == 1:\\n                return ugly\\n            if u > ugly:\\n                ugly = u\\n                n -= 1\\n                q2 += 2 * u,\\n                q3 += 3 * u,\\n                q5 += 5 * u,\\n\\nWorks, but might not be totally safe, both because I extend lists while iterating over them and because at the start, q2 becomes empty for a moment, which I think allows heapq.merge to drop it (at least in CPython it just doesn't, as it first yields the value before trying to get the next one from that list, and when it continues, the list isn't empty anymore).\\n\\n---\\n\\n**C++** ... **O(n), generate first n in order** ... 12 ms\\n\\nC++ version of the second Python solution, though adding extra variables for the three candidates to prevent re-multiplication.\\n\\n    int nthUglyNumber(int n) {\\n        vector<int> ugly(n, 1);\\n        int c2 = 2, c3 = 3, c5 = 5;\\n        int i2 = 0, i3 = 0, i5 = 0;\\n        for (int i=1; i<n; ++i) {\\n            int last = ugly[i] = min(c2, min(c3, c5));\\n            while (c2 <= last) c2 = 2 * ugly[++i2];\\n            while (c3 <= last) c3 = 3 * ugly[++i3];\\n            while (c5 <= last) c5 = 5 * ugly[++i5];\\n        }\\n        return ugly[n-1];\\n    }\\n\\n---\\n\\n**C++** ... **O(n), generate on demand and remember** ... 4 ms\\n\\nSame as the previous, but I keep everything in static variables and only compute more when needed. It's faster, and I think pretty neat.\\n\\n    int nthUglyNumber(int n) {\\n        static vector<int> ugly {1};\\n        static int last(1);\\n        static int c2(2), c3(3), c5(5);\\n        static int i2(0), i3(0), i5(0);\\n        while (ugly.size() < n) {\\n            while (c2 <= last) c2 = 2 * ugly[++i2];\\n            while (c3 <= last) c3 = 3 * ugly[++i3];\\n            while (c5 <= last) c5 = 5 * ugly[++i5];\\n            ugly.push_back(last = min(c2, min(c3, c5)));\\n        }\\n        return ugly[n-1];\\n    }\\n\\n---\\n\\n**C++** ... **Simple Precompute** ... 4 ms\\n\\nPrecompute all possibilities in easy order and sort them.\\n\\n    int nthUglyNumber(int n) {\\n        static vector<int> ugly;\\n        long long a, b, c, m = INT_MAX;\\n        if (ugly.empty()) {\\n            for (a=1; a<=m; a*=2)\\n                for (b=a; b<=m; b*=3)\\n                    for (c=b; c<=m; c*=5)\\n                        ugly.push_back(c);\\n            sort(begin(ugly), end(ugly));\\n        }\\n        return ugly[n-1];\\n    }\\n\\n---\\n\\n**My own old one**\\n\\nPython version of my own O(n) C++ solution from almost [13 years ago](https://uva.onlinejudge.org/board/viewtopic.php?p=6444#p6444). Good old times...\\nMaybe I'll try to improve it, but mainly I wanted to see how a pretty much direct translation would look.\\n\\n    def nthUglyNumber(self, n):\\n        factor = 2, 3, 5\\n        lists = [collections.deque([1]) for _ in range(3)]\\n        for _ in range(n - 1):\\n            next = [lists[i][0] * factor[i] for i in range(3)]\\n            winner = min(range(3), key=lambda j: next[j])\\n            for i in range(winner, 3):\\n                lists[i] += next[winner],\\n            lists[winner].popleft()\\n        return lists[2][-1]"
		},
		{
			"lc_ans_id":"69449",
			"view":"1746",
			"top":"9",
			"title":"\\x08two standard dp solutions",
			"vote":"17",
			"content":"    // three lists:\\n    // (1) 1\\xd72, 2\\xd72, 3\\xd72, 4\\xd72, 5\\xd72, \\u2026\\n    // (2) 1\\xd73, 2\\xd73, 3\\xd73, 4\\xd73, 5\\xd73, \\u2026\\n    // (3) 1\\xd75, 2\\xd75, 3\\xd75, 4\\xd75, 5\\xd75, \\u2026\\n    \\n    // O(n) time, O(n) space \\n    int nthUglyNumber(int n) {\\n        vector<int> d(n, 0);\\n        d[0] = 1;\\n        \\n        int f2 = 2, f3 = 3, f5 = 5;     // min values for multipy factor 2, 3, 5\\n        int ix2 = 0, ix3 = 0, ix5 = 0;  // indexs for min values of f2, f3, f5 \\n        \\n        for (int i = 1; i < n; ++i) {\\n            int minV = min(min(f2, f3), f5);\\n            d[i] = minV;\\n            \\n            if (minV == f2) f2 = 2 * d[++ix2];\\n            if (minV == f3) f3 = 3 * d[++ix3];\\n            if (minV == f5) f5 = 5 * d[++ix5];\\n        }\\n        \\n        return d[n-1];\\n    }\\n    \\n    // O(n) (might be more) time, O(3n) space\\n    int nthUglyNumber1(int n) {\\n        queue<int> q1, q2, q3;\\n        q1.push(1), q2.push(1), q3.push(1);\\n        \\n        int m = 0;\\n        for (int i = 0; i < n; ++i) {\\n            m = min(min(q1.front(), q2.front()), q3.front());\\n            if (m == q1.front()) q1.pop();\\n            if (m == q2.front()) q2.pop();\\n            if (m == q3.front()) q3.pop();\\n            q1.push(2*m);\\n            q2.push(3*m);\\n            q3.push(5*m);\\n        }\\n        \\n        return m;\\n    }"
		}
	],
	"id":"264",
	"title":"Ugly Number II",
	"content":"<p>\r\nWrite a program to find the <code>n</code>-th ugly number.\r\n</p>\r\n\r\n<p>\r\nUgly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.\r\n</p>\r\n\r\n<p>\r\nNote that <code>1</code> is typically treated as an ugly number, and <i>n</i> <b>does not exceed 1690</b>.\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/jianchao.li.fighter\">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>",
	"frequency":"361",
	"ac_num":"69922"
}