{
	"difficulty":"2",
	"submit_num":"52130",
	"show_id":"267",
	"leetcode_id":"267",
	"answers":[
		{
			"lc_ans_id":"69696",
			"view":"12269",
			"top":"0",
			"title":"AC Java solution with explanation",
			"vote":"57",
			"content":"Basically, the idea is to perform permutation on half of the palindromic string and then form the full palindromic result.\\n\\n    public List<String> generatePalindromes(String s) {\\n        int odd = 0;\\n        String mid = \"\";\\n        List<String> res = new ArrayList<>();\\n        List<Character> list = new ArrayList<>();\\n        Map<Character, Integer> map = new HashMap<>();\\n    \\n        // step 1. build character count map and count odds\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            map.put(c, map.containsKey(c) ? map.get(c) + 1 : 1);\\n            odd += map.get(c) % 2 != 0 ? 1 : -1;\\n        }\\n    \\n        // cannot form any palindromic string\\n        if (odd > 1) return res;\\n    \\n        // step 2. add half count of each character to list\\n        for (Map.Entry<Character, Integer> entry : map.entrySet()) {\\n            char key = entry.getKey();\\n            int val = entry.getValue();\\n    \\n            if (val % 2 != 0) mid += key;\\n    \\n            for (int i = 0; i < val / 2; i++) list.add(key);\\n        }\\n    \\n        // step 3. generate all the permutations\\n        getPerm(list, mid, new boolean[list.size()], new StringBuilder(), res);\\n    \\n        return res;\\n    }\\n    \\n    // generate all unique permutation from list\\n    void getPerm(List<Character> list, String mid, boolean[] used, StringBuilder sb, List<String> res) {\\n        if (sb.length() == list.size()) {\\n            // form the palindromic string\\n            res.add(sb.toString() + mid + sb.reverse().toString());\\n            sb.reverse();\\n            return;\\n        }\\n    \\n        for (int i = 0; i < list.size(); i++) {\\n            // avoid duplication\\n            if (i > 0 && list.get(i) == list.get(i - 1) && !used[i - 1]) continue;\\n    \\n            if (!used[i]) {\\n                used[i] = true; sb.append(list.get(i));\\n                // recursion\\n                getPerm(list, mid, used, sb, res);\\n                // backtracking\\n                used[i] = false; sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"69698",
			"view":"4419",
			"top":"1",
			"title":"Short backtracking solution in Java (3 ms)",
			"vote":"27",
			"content":"We only need to generate the first part of palindrome string, and the remaining part will be a middle character with the reverse of first part.\\n\\n\\n\\n    private List<String> list = new ArrayList<>();\\n\\n    public List<String> generatePalindromes(String s) {\\n        int numOdds = 0; // How many characters that have odd number of count\\n        int[] map = new int[256]; // Map from character to its frequency\\n        for (char c: s.toCharArray()) {\\n            map[c]++;\\n            numOdds = (map[c] & 1) == 1 ? numOdds+1 : numOdds-1;\\n        }\\n        if (numOdds > 1)   return list;\\n        \\n        String mid = \"\";\\n        int length = 0;\\n        for (int i = 0; i < 256; i++) {\\n            if (map[i] > 0) {\\n                if ((map[i] & 1) == 1) { // Char with odd count will be in the middle\\n                    mid = \"\" + (char)i;\\n                    map[i]--;\\n                }\\n                map[i] /= 2; // Cut in half since we only generate half string\\n                length += map[i]; // The length of half string\\n            }\\n        }\\n        generatePalindromesHelper(map, length, \"\", mid);\\n        return list;\\n    }\\n    private void generatePalindromesHelper(int[] map, int length, String s, String mid) {\\n        if (s.length() == length) {\\n            StringBuilder reverse = new StringBuilder(s).reverse(); // Second half\\n            list.add(s + mid + reverse);\\n            return;\\n        }\\n        for (int i = 0; i < 256; i++) { // backtracking just like permutation\\n            if (map[i] > 0) {\\n                map[i]--;\\n                generatePalindromesHelper(map, length, s + (char)i, mid);\\n                map[i]++;\\n            } \\n        }\\n    }"
		},
		{
			"lc_ans_id":"69751",
			"view":"3650",
			"top":"2",
			"title":"My accepted Java Solution",
			"vote":"14",
			"content":"    public List<String> generatePalindromes(String s) {\\n        int[] map = new int[256];\\n        for(int i=0;i<s.length();i++){\\n            map[s.charAt(i)]++;\\n        }\\n        int j=0,count=0;\\n        for(int i=0;i<256;i++){\\n            if(count== 0 && map[i] %2 == 1){\\n                j= i;\\n                count++;\\n            }else if(map[i] % 2==1){\\n                return new ArrayList<String>();\\n            }\\n        }\\n        String cur = \"\";\\n        if(j != 0){\\n            cur = \"\"+ (char)j;\\n            map[j]--;\\n        }\\n        List<String> res = new ArrayList<String>();\\n        DFS(res,cur,map,s.length());\\n        return res;\\n    }\\n    public void DFS(List<String> res,String cur,int[] map,int len){\\n        if(cur.length()== len){\\n            res.add(new String(cur));\\n        }else {\\n            for(int i=0;i<map.length;i++){\\n                if(map[i] <= 0) continue;\\n                map[i] = map[i] - 2;\\n                cur = (char)i + cur + (char)i;\\n                DFS(res,cur,map,len);\\n                cur = cur.substring(1,cur.length()-1);\\n                map[i] = map[i]+2;\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"69769",
			"view":"2545",
			"top":"3",
			"title":"0ms Easy C++ Solution",
			"vote":"9",
			"content":"As suggested by the first hint, we just need to get one half of the string (each character appears half the times in `s`), then generate all its unique permutations and concatenate them with the reversed half (possibly the single middle character if the length of the string `s` is odd).\\n\\nAll the above work will only be done if an palindrome permutation exists. To tell whether a palindrome permutation exists, [Palindrome Permutation][1] has paved the way for us. To generate all the unique permutations, you may as well refer to [Permutations II][2] or [Next Permutation][3] as suggested by the second hint. But I guess this part is not the main point of this problem, so I directly use the `next_permutation` of C++.  Well, I am not quite whether this is the right way, but this gives shorter codes. Moreover, the tag of this problem is backtracking, which I guess only needs to be used in generating the permutations. After this is done, we can simply concatenate to make the palindromes. \\n\\nThe code is as follows. \\n\\n    class Solution {\\n    public:\\n        vector<string> generatePalindromes(string s) {\\n    \\t\\tvector<string> palindromes;\\n            unordered_map<char, int> counts;\\n            for (char c : s) counts[c]++;\\n            int odd = 0; char mid; string half;\\n            for (auto p : counts) {\\n                if (p.second & 1) {\\n                    odd++, mid = p.first;\\n    \\t\\t\\t\\tif (odd > 1) return palindromes;\\n                }\\n                half += string(p.second / 2, p.first);\\n            }\\n            palindromes = permutations(half);\\n            for (string& p : palindromes) {\\n                string t(p);\\n                reverse(t.begin(), t.end());\\n    \\t\\t\\tif (odd) t = mid + t;\\n                p += t;\\n            }\\n            return palindromes;\\n        }\\n    private: \\n        vector<string> permutations(string& s) {\\n            vector<string> perms;\\n            string t(s);\\n            do {\\n                perms.push_back(s);\\n                next_permutation(s.begin(), s.end()); \\n            } while (s != t);\\n            return perms; \\n        }\\n    };\\n\\n[1]: https://leetcode.com/problems/palindrome-permutation/\\n[2]: https://leetcode.com/problems/permutations-ii/\\n[3]: https://leetcode.com/problems/next-permutation/"
		},
		{
			"lc_ans_id":"69691",
			"view":"1875",
			"top":"4",
			"title":"4 lines Python solution",
			"vote":"6",
			"content":"Use `collections.Counter` and `itertools.permutations`\\n\\n    class Solution(object):\\n        def generatePalindromes(self, s):\\n            d = collections.Counter(s)\\n            m = tuple(k for k, v in d.iteritems() if v % 2)\\n            p = ''.join(k*(v/2) for k, v in d.iteritems())\\n            return [''.join(i + m + i[::-1]) for i in set(itertools.permutations(p))] if len(m) < 2 else []"
		},
		{
			"lc_ans_id":"69704",
			"view":"1758",
			"top":"5",
			"title":"Java 1ms beats 99.67%",
			"vote":"5",
			"content":"I'm generating permutations on the left side of the string, then constantly copying characters to the right side to maintain the palindrome.\\n\\nThere are lots of comments in the code, but please ask if there is anything that is unclear.\\n\\n    public class Solution {\\n        \\n        List<String> results;\\n        \\n        char[] chars;\\n        \\n        int lengthMinusOne, halfLength;\\n        \\n        public List<String> generatePalindromes(String s) {\\n            \\n            results = new ArrayList<String>();\\n            \\n            // We will be generating permutations in place.\\n            chars = s.toCharArray();\\n            int length = chars.length;\\n            \\n            // Return no result for empty string.\\n            if(length == 0) return results;\\n            \\n            // Sort the array to bring duplicates together.\\n            Arrays.sort(chars);\\n            // The array now looks like aabbcdd\\n            \\n            // Precompute a few values for performance. \\n            lengthMinusOne = length - 1;\\n            halfLength = length / 2; \\n            \\n            // Prepare the first half of the string. It will contain\\n            // a single character from each pair. The middle character\\n            // is placed in the middle.\\n            // When done, the array will look like abdc***\\n            boolean foundMiddle = false;\\n            \\n            for(int readCursor = 0, writeCursor = 0; readCursor < length; readCursor++){\\n                char c = chars[readCursor];\\n                \\n                // Check for pair of characters.\\n                if(readCursor < lengthMinusOne && c == chars[readCursor+1]){\\n                    \\n                    // Found pair. Write one of them to the left of the string.\\n                    chars[writeCursor++] = c;\\n                    readCursor++;\\n                \\n                }else{\\n                    \\n                    // Found isolated character. Make sure this is the only one\\n                    // so far, and check that the string length is odd.\\n                    if(!foundMiddle && (chars.length & 1) == 1){\\n                        \\n                        // Place the middle character.\\n                        foundMiddle = true;\\n                        chars[chars.length / 2] = c;\\n                        \\n                    }else{\\n    \\n                        // Can't make palindromes from this string.\\n                        return results;\\n                    }\\n                }\\n            }\\n            \\n            // Generate permutations for all characters.\\n            generate(0);\\n            \\n            return results;\\n        }\\n\\n        // Generates permutations by swapping characters.\\n        void generate(int start){\\n            \\n            // When we run out of characters, add the result to the list.\\n            if(start == halfLength){\\n                results.add(new String(chars));\\n                return;\\n            }\\n\\n            // Swap each character into place.\\n            char prev = 0;\\n            for(int i=start; i<halfLength; i++){\\n                \\n                // Check for duplicates.\\n                if(prev == chars[i]) continue;\\n                prev = chars[i];\\n                \\n                // Place one character.\\n                swap(start,i);\\n                \\n                // Generate permutations for remaining characters.\\n                generate(start+1);\\n                \\n                // Return the character to it's position.\\n                swap(start,i);\\n            }\\n        }\\n\\n        // Swap maintains the palindrome by mirroring chars on the right side.\\n        void swap(int a, int b){\\n            char temp = chars[a];\\n            \\n            // Place at a on left side of palindrome.\\n            chars[a] = chars[b];\\n            \\n            // Place matching char on right side.\\n            chars[lengthMinusOne - a] = chars[b];\\n            \\n            // Place left.\\n            chars[b] = temp;\\n            \\n            // Place right.\\n            chars[lengthMinusOne - b] = temp;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"69753",
			"view":"665",
			"top":"6",
			"title":"Java 6ms solution, no reversal or concat",
			"vote":"4",
			"content":"The idea is to start recursion from the mid position, and copy char to left and right in the char array in-place until we reach the left and right ends.\\n\\nRunning time is 6ms, better than 11ms which comes from my other implementation using reversal and string concatenation.\\n\\n\\n    // 6ms, beating 64%\\n    // the idea is to build a count map for the chars in s\\n    // and terminate if s cannot form a palindrome \\n    // then do DFS from the center until reaching the left/right end\\n    // complexity: time O(n!), space O(n)\\n    public List<String> generatePalindromes(String s) {\\n    \\tList<String> result = new LinkedList<String>();\\n    \\tif (s == null)\\n    \\t\\treturn result;\\n    \\tchar[] array = s.toCharArray();\\n    \\tMap<Character, Integer> map = new HashMap<Character, Integer>();\\n    \\tfor (int i = 0; i < array.length; i++) {\\n    \\t\\tchar c = array[i];\\n    \\t\\tmap.put(c, map.getOrDefault(c, 0) + 1);\\n    \\t}\\n    \\tCharacter odd = null;\\n    \\tfor (Map.Entry<Character, Integer> e : map.entrySet()) {\\n    \\t\\tif (e.getValue() % 2 == 1) { // odd\\n    \\t\\t\\tif (odd != null) {\\n    \\t\\t\\t\\treturn result;\\n    \\t\\t\\t}\\n    \\t\\t\\tif (array.length % 2 == 0) {\\n    \\t\\t\\t\\treturn result;\\n    \\t\\t\\t}\\n    \\t\\t\\todd = e.getKey();\\n    \\t\\t}\\n    \\t}\\n    \\tif (odd == null) { // s is of even length\\n    \\t\\thelper(array, result, map, array.length / 2 - 1, array.length / 2);\\n    \\t} else { // odd length\\n    \\t\\tarray[array.length / 2] = odd;\\n    \\t\\tmap.put(odd, map.get(odd) - 1);\\n    \\t\\thelper(array, result, map, array.length / 2 - 1,\\n    \\t\\t\\t\\tarray.length / 2 + 1);\\n    \\t}\\n    \\treturn result;\\n    }\\n    \\n    private void helper(char[] array, List<String> result,\\n    \\t\\tMap<Character, Integer> map, int left, int right) {\\n    \\tif (left == -1) {\\n    \\t\\tresult.add(new String(array));\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor (Map.Entry<Character, Integer> e : map.entrySet()) {\\n    \\t\\tif (e.getValue() >= 2) {\\n    \\t\\t\\te.setValue(e.getValue() - 2);\\n    \\t\\t\\tarray[left] = e.getKey();\\n    \\t\\t\\tarray[right] = e.getKey();\\n    \\t\\t\\thelper(array, result, map, left - 1, right + 1);\\n    \\t\\t\\te.setValue(e.getValue() + 2);\\n    \\t\\t}\\n    \\t}\\n    }"
		},
		{
			"lc_ans_id":"69700",
			"view":"946",
			"top":"7",
			"title":"Python solution sharing: Preprocess, then it would be like ordinary backtracking permutation!",
			"vote":"3",
			"content":"Take `aabbbcc` as an example\\n\\n`counter` would be {\"a\":2, \"b\":3, \"c\":2}\\n\\nAfter preprocess: `baseStr` = \"abc\", `mid` = \"b\" (if there is no char happens odd times, mid = \"\")\\n\\nThen use backtracking to find all the permutation of `baseStr`, \\n\\nthe valid palindrome would be \"permuStr + mid + reverseOfPermuStr\"\\n\\n\\n    \\n\\n    def generatePalindromes(self, s):\\n        counter = collections.Counter(s)\\n        odds = filter(lambda x: x % 2, counter.values())\\n        if len(odds) > 1:\\n            return []\\n        baseStr, mid = self.preProcess(counter)\\n        return self.backTracking(baseStr, 0, mid, [baseStr + mid + baseStr[::-1]])\\n        \\n    def preProcess(self, counter):\\n        baseStr = mid = \"\"\\n        for char in counter:    \\n            if counter[char] % 2:\\n                mid = char\\n            baseStr += char*(counter[char]/2)\\n        return baseStr, mid\\n        \\n    def backTracking(self, s, idx, mid, ans):\\n        if idx == len(s) - 1:\\n            return ans\\n        for i in range(idx, len(s)):\\n            if i >= 1 and s[i] == s[i-1] == s[idx]:\\n                continue #no need to go deeper if swap would be the same\\n            #Swap s[idx] with s[i]\\n            if i != idx:\\n                permu = s[:idx] + s[i] + s[idx+1:i] + s[idx] + s[i+1:] \\n                ans.append(permu + mid + permu[::-1])\\n            else:\\n                permu = s\\n            self.backTracking(permu, idx+1, mid, ans)\\n        return ans"
		},
		{
			"lc_ans_id":"69764",
			"view":"935",
			"top":"8",
			"title":"C++ Solution - Permutation II with Hashmap",
			"vote":"2",
			"content":"    class Solution {\\n    public:\\n        vector<string> generatePalindromes(string s) {\\n            vector<string> result;\\n            unordered_map<char, int> charCount;\\n            int oddCnt=0, N=0;\\n            string mid;\\n            for (int i=0; i<s.size(); i++)\\n                charCount[s[i]] ++;\\n            for (auto &c : charCount) {\\n                if (c.second & 1) {\\n                    mid = c.first;\\n                    oddCnt++;\\n                }\\n                c.second /= 2;\\n                N += c.second;\\n            }\\n            if (oddCnt > 1)\\n                return result;\\n            helper(charCount, \"\", mid, N, result);\\n            return result;\\n        }\\n    private:\\n        void helper(unordered_map<char, int> &charCount, string s, string &mid, int &N, vector<string> &r) {\\n            if (s.size() == N) {\\n                string rev = s;\\n                reverse(rev.begin(), rev.end());\\n                r.push_back(s + mid + rev);\\n                return;\\n            }\\n            for (auto &c : charCount) {\\n                if (c.second > 0) {\\n                    c.second--;\\n                    helper(charCount, s+c.first, mid, N, r);\\n                    c.second++;\\n                }\\n            }\\n        }\\n    };"
		},
		{
			"lc_ans_id":"69767",
			"view":"756",
			"top":"9",
			"title":"22 lines 0ms C++ easy to understand",
			"vote":"2",
			"content":"  \\n\\n    class Solution {\\n        public:\\n            vector<string> generatePalindromes(string s) {\\n                vector<string> output;\\n                unordered_map<char,int> ht;\\n                for(auto &c : s)\\n                    ht[c]++;\\n                char oddChar;\\n                int count = 0;\\n                string str = \"\";\\n                for(auto &pair : ht){\\n                    str += string(pair.second/2, pair.first);\\n                    if(pair.second&1){\\n                        count++;\\n                        oddChar = pair.first;\\n                        if(count==2)  return output;\\n                    }\\n                }\\n                sort(str.begin(), str.end());\\n                do{\\n                    output.push_back(str+(count==0?\"\":string(1,oddChar))+string(str.rbegin(),str.rend()));\\n                }while(std::next_permutation(str.begin(), str.end()));\\n                \\n                return output;\\n            }\\n        };"
		}
	],
	"id":"267",
	"title":"Palindrome Permutation II",
	"content":"<p>\r\nGiven a string <code>s</code>, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.\r\n</p>\r\n<p>\r\nFor example:\r\n</p>\r\n<p>\r\nGiven <code>s = \"aabb\"</code>, return <code>[\"abba\", \"baab\"]</code>.\r\n</p>\r\n<p>\r\nGiven <code>s = \"abc\"</code>, return <code>[]</code>.\r\n</p>",
	"frequency":"136",
	"ac_num":"16791"
}