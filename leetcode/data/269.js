{
	"difficulty":"3",
	"submit_num":"140163",
	"show_id":"269",
	"leetcode_id":"269",
	"answers":[
		{
			"lc_ans_id":"70119",
			"view":"38502",
			"top":"0",
			"title":"Java AC solution using BFS",
			"vote":"132",
			"content":"    public String alienOrder(String[] words) {\\n        Map<Character, Set<Character>> map=new HashMap<Character, Set<Character>>();\\n        Map<Character, Integer> degree=new HashMap<Character, Integer>();\\n        String result=\"\";\\n        if(words==null || words.length==0) return result;\\n        for(String s: words){\\n            for(char c: s.toCharArray()){\\n                degree.put(c,0);\\n            }\\n        }\\n        for(int i=0; i<words.length-1; i++){\\n            String cur=words[i];\\n            String next=words[i+1];\\n            int length=Math.min(cur.length(), next.length());\\n            for(int j=0; j<length; j++){\\n                char c1=cur.charAt(j);\\n                char c2=next.charAt(j);\\n                if(c1!=c2){\\n                    Set<Character> set=new HashSet<Character>();\\n                    if(map.containsKey(c1)) set=map.get(c1);\\n                    if(!set.contains(c2)){\\n                        set.add(c2);\\n                        map.put(c1, set);\\n                        degree.put(c2, degree.get(c2)+1);\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        Queue<Character> q=new LinkedList<Character>();\\n        for(char c: degree.keySet()){\\n            if(degree.get(c)==0) q.add(c);\\n        }\\n        while(!q.isEmpty()){\\n            char c=q.remove();\\n            result+=c;\\n            if(map.containsKey(c)){\\n                for(char c2: map.get(c)){\\n                    degree.put(c2,degree.get(c2)-1);\\n                    if(degree.get(c2)==0) q.add(c2);\\n                }\\n            }\\n        }\\n        if(result.length()!=degree.size()) return \"\";\\n        return result;\\n    }"
		},
		{
			"lc_ans_id":"70137",
			"view":"20915",
			"top":"1",
			"title":"16/18 lines Python, 30 lines C++",
			"vote":"53",
			"content":"Two similar solutions. Both first go through the word list to find letter pairs `(a, b)` where `a` must come before `b` in the alien alphabet. The first solution just works with these pairs, the second is a bit smarter and uses successor/predecessor sets. Doesn't make a big difference here, though, I got both accepted in 48 ms.\\n\\n**Solution 1**\\n\\n    def alienOrder(self, words):\\n        less = []\\n        for pair in zip(words, words[1:]):\\n            for a, b in zip(*pair):\\n                if a != b:\\n                    less += a + b,\\n                    break\\n        chars = set(''.join(words))\\n        order = []\\n        while less:\\n            free = chars - set(zip(*less)[1])\\n            if not free:\\n                return ''\\n            order += free\\n            less = filter(free.isdisjoint, less)\\n            chars -= free\\n        return ''.join(order + list(chars))\\n\\n**Solution 2**\\n\\n    def alienOrder(self, words):\\n        pre, suc = collections.defaultdict(set), collections.defaultdict(set)\\n        for pair in zip(words, words[1:]):\\n            for a, b in zip(*pair):\\n                if a != b:\\n                    suc[a].add(b)\\n                    pre[b].add(a)\\n                    break\\n        chars = set(''.join(words))\\n        free = chars - set(pre)\\n        order = ''\\n        while free:\\n            a = free.pop()\\n            order += a\\n            for b in suc[a]:\\n                pre[b].discard(a)\\n                if not pre[b]:\\n                    free.add(b)\\n        return order * (set(order) == chars)\\n\\n**C++ version of solution 2**\\n\\n    string alienOrder(vector<string>& words) {\\n        map<char, set<char>> suc, pre;\\n        set<char> chars;\\n        string s;\\n        for (string t : words) {\\n            chars.insert(t.begin(), t.end());\\n            for (int i=0; i<min(s.size(), t.size()); ++i) {\\n                char a = s[i], b = t[i];\\n                if (a != b) {\\n                    suc[a].insert(b);\\n                    pre[b].insert(a);\\n                    break;\\n                }\\n            }\\n            s = t;\\n        }\\n        set<char> free = chars;\\n        for (auto p : pre)\\n            free.erase(p.first);\\n        string order;\\n        while (free.size()) {\\n            char a = *begin(free);\\n            free.erase(a);\\n            order += a;\\n            for (char b : suc[a]) {\\n                pre[b].erase(a);\\n                if (pre[b].empty())\\n                    free.insert(b);\\n            }\\n        }\\n        return order.size() == chars.size() ? order : \"\";\\n    }"
		},
		{
			"lc_ans_id":"70111",
			"view":"11151",
			"top":"2",
			"title":"The description is wrong?",
			"vote":"52",
			"content":"The question says:\\nif the input is `[\\n  \"wrt\",\\n  \"wrf\",\\n  \"er\",\\n  \"ett\",\\n  \"rftt\"\\n]`\\nThe correct order is: `\"wertf\"`.\\nbut from `\"rftt\"`, f should be lexicographically smaller than t? How can the result be \"wertf\"? Correct me if I am wrong."
		},
		{
			"lc_ans_id":"70115",
			"view":"11840",
			"top":"3",
			"title":"3ms Clean Java Solution (DFS)",
			"vote":"27",
			"content":"The key to this problem is: \\n\\n> A topological ordering is possible if and only if the graph has no directed cycles\\n\\nLet's build a graph and perform a DFS. The following states made things easier.\\n\\n 1.  `visited[i] = -1`. Not even exist.\\n 2.  `visited[i] = 0`. Exist. Non-visited.\\n 3.  `visited[i] = 1`. Visiting.\\n 4. `visited[i] = 2`. Visited.\\n\\nSimilarly, there is another [simple BFS version.][1] \\n\\n    private final int N = 26;\\n    public String alienOrder(String[] words) {\\n        boolean[][] adj = new boolean[N][N];\\n        int[] visited = new int[N];\\n        buildGraph(words, adj, visited);\\n\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < N; i++) {\\n            if(visited[i] == 0) {                 // unvisited\\n                if(!dfs(adj, visited, sb, i)) return \"\";\\n            }\\n        }\\n        return sb.reverse().toString();\\n    }\\n    \\n    public boolean dfs(boolean[][] adj, int[] visited, StringBuilder sb, int i) {\\n        visited[i] = 1;                            // 1 = visiting\\n        for(int j = 0; j < N; j++) {\\n            if(adj[i][j]) {                        // connected\\n                if(visited[j] == 1) return false;  // 1 => 1, cycle   \\n                if(visited[j] == 0) {              // 0 = unvisited\\n                    if(!dfs(adj, visited, sb, j)) return false;\\n                }\\n            }\\n        }\\n        visited[i] = 2;                           // 2 = visited\\n        sb.append((char) (i + 'a'));\\n        return true;\\n    }\\n    \\n    public void buildGraph(String[] words, boolean[][] adj, int[] visited) {\\n        Arrays.fill(visited, -1);                 // -1 = not even existed\\n        for(int i = 0; i < words.length; i++) {\\n            for(char c : words[i].toCharArray()) visited[c - 'a'] = 0;\\n            if(i > 0) {\\n                String w1 = words[i - 1], w2 = words[i];\\n                int len = Math.min(w1.length(), w2.length());\\n                for(int j = 0; j < len; j++) {\\n                    char c1 = w1.charAt(j), c2 = w2.charAt(j);\\n                    if(c1 != c2) {\\n                        adj[c1 - 'a'][c2 - 'a'] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/77078/easiest-java-bfs-solution"
		},
		{
			"lc_ans_id":"70113",
			"view":"5402",
			"top":"4",
			"title":"Java BFS Solution",
			"vote":"26",
			"content":"    public String alienOrder(String[] words) {\\n        List<Set<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            adj.add(new HashSet<Integer>());\\n        }\\n        int[] degree = new int[26];\\n        Arrays.fill(degree, -1);\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            for (char c : words[i].toCharArray()) {\\n                if (degree[c - 'a'] < 0) {\\n                    degree[c - 'a'] = 0;\\n                }\\n            }\\n            if (i > 0) {\\n                String w1 = words[i - 1], w2 = words[i];\\n                int len = Math.min(w1.length(), w2.length());\\n                for (int j = 0; j < len; j++) {\\n                    int c1 = w1.charAt(j) - 'a', c2 = w2.charAt(j) - 'a';\\n                    if (c1 != c2) {\\n                        if (!adj.get(c1).contains(c2)) {\\n                            adj.get(c1).add(c2);\\n                            degree[c2]++;\\n                        }\\n                        break;\\n                    }\\n                    if (j == w2.length() - 1 && w1.length() > w2.length()) { // \"abcd\" -> \"ab\"\\n                        return \"\";\\n                    }\\n                }\\n            }\\n        }\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < degree.length; i++) {\\n            if (degree[i] == 0) {\\n                q.add(i);       \\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (!q.isEmpty()) {\\n            int i = q.poll();\\n            sb.append((char) ('a'  + i));\\n            for (int j : adj.get(i)) {\\n                degree[j]--;\\n                if (degree[j] == 0) {\\n                    q.add(j);        \\n                }\\n            }\\n        }\\n        \\n        for (int d : degree) {\\n            if (d > 0) {\\n                return \"\";\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }"
		},
		{
			"lc_ans_id":"70121",
			"view":"4758",
			"top":"5",
			"title":"Wrong test case: for test case [\"wrtkj\",\"wrt\"], we are doing this based on \"Alien\" dictionary.",
			"vote":"25",
			"content":"Let's see these two test cases:\\n\\nfor test case [\"xz\",\"xy\"], the expected answer is xzy. It means that we don't need to care about the position of the letters without dependency, like x. The answer can be like xzy, zyx, zxy. As long as z is in front of y.\\n\\nBut for test case [\"wrtkj\",\"wrt\"], the expected answer is \"\". Interesting..\\naccording to test case [\"xz\",\"xy\"], the result of [\"wrtkj\",\"wrt\"] can be any order Coz there is no dependency of the letters.\\n\\nSome people says that because \"wrt\" is the prefix of \"wrtkj\", it should appear first. \\n\\nBut I think this question is called \"Alien Dictionary\" and there are no specific rules for the situation like \"wrtkj\", \"wrt\".\\nI may say that according to this \"Alien\" lexicography, \"a\" should appear after \"ab\", and \"ab\" should appear after \"aba\", that's totally possible, Coz it's allowed \"Alien\" lexicographically.\\n\\nI think if they want us to solve the problem based on the rule you mentioned, they should make it clear.\\n\\nIf I am wrong about this, please do let me know, thanks guys."
		},
		{
			"lc_ans_id":"70157",
			"view":"6919",
			"top":"6",
			"title":"Straightforward C++ solution",
			"vote":"23",
			"content":"The code is lengthy, but the idea is straightforward. \\n\\n1.convert words vector into a graph.\\n\\n2.simply get the result by topological sort. \\n\\n\\n\\n\\n    bool dfs(unordered_map<char, unordered_set<char>>& g, unordered_set<char>& visited, unordered_set<char>& rec, string& order, char n) {\\n\\t\\tif (rec.count(n)) return false;\\n\\t\\tif (visited.count(n)) return true;\\n\\n\\t\\tvisited.insert(n);\\n\\t\\trec.insert(n);\\n\\n\\t\\tfor (auto iter = g[n].begin(); iter != g[n].end(); ++iter)\\n\\t\\t\\tif (dfs(g, visited, rec, order, *iter) == false)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\trec.erase(rec.find(n));\\n\\t\\torder += string(1, n);\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tstring topsort(unordered_map<char, unordered_set<char>>& g) {\\n\\t\\tunordered_set<char> visited;\\n\\t\\tunordered_set<char> rec;\\n\\t\\tstring order;\\n\\n\\t\\tfor (auto iter = g.begin(); iter != g.end(); ++iter) {\\n\\t\\t\\tif (dfs(g, visited, rec, order, iter->first) == false)\\n\\t\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\n\\t\\treverse(order.begin(), order.end());\\n\\t\\treturn order;\\n\\t}\\n\\t\\n\\tstring alienOrder(vector<string>& words) {\\n\\t\\tif (words.size() == 1) return words.front();\\n\\n\\t\\tunordered_map<char, unordered_set<char>> g;\\n\\t\\tfor (int i = 1; i < words.size(); i++) {\\n\\t\\t\\tstring t1 = words[i - 1];\\n\\t\\t\\tstring t2 = words[i];\\t\\t\\t\\n\\t\\t\\tbool found = false;\\n\\t\\t\\tfor (int j = 0; j < max(t1.length(), t2.length()); j++) {\\n\\t\\t\\t\\tif (j < t1.length() && g.count(t1[j]) == 0)\\n\\t\\t\\t\\t\\tg.insert(make_pair(t1[j], unordered_set<char>()));\\n\\t\\t\\t\\tif (j < t2.length() && g.count(t2[j]) == 0)\\n\\t\\t\\t\\t\\tg.insert(make_pair(t2[j], unordered_set<char>()));\\n\\t\\t\\t\\tif (j < t1.length() && j < t2.length() && t1[j] != t2[j] && !found) {\\n\\t\\t\\t\\t\\tg[t1[j]].insert(t2[j]);\\n\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n    \\treturn topsort(g);\\n\\t}"
		},
		{
			"lc_ans_id":"70284",
			"view":"2931",
			"top":"7",
			"title":"Alien Dictionary: Special judge: No expected output available.",
			"vote":"15",
			"content":"Why do I see this error?\\n\\nInput:\\n[\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]\\nOutput:\\n\"werft\"\\nExpected:\\nSpecial judge: No expected output available."
		},
		{
			"lc_ans_id":"70286",
			"view":"4928",
			"top":"8",
			"title":"Java - toposort solution, clean",
			"vote":"14",
			"content":"    public String alienOrder(String[] words) {\\n\\t\\tMap<Character, List<Character>> graph = new HashMap<>();\\n\\t\\tString ans = null;\\n\\t\\tSet<Character> charSet = new HashSet<>(); //Maintain a set of chars that are not in the graph.\\n\\t\\tbuildGraph(words, graph, charSet);\\n\\t\\tans = toposortDFS(graph, charSet);\\n\\t\\treturn ans;\\n\\t}\\n\\t\\n\\tprivate Set<Character> getCharSet(String[] words, Set<Character> charSet) {\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\t\\tcharSet.add(c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn charSet;\\n\\t}\\n\\n\\tprivate String toposortDFS(Map<Character, List<Character>> graph, Set<Character> charSet) {\\n\\t\\tStringBuffer ans = new StringBuffer();\\n\\t\\tboolean[] visited = new boolean[26]; //permanent marker.\\n\\t\\tboolean[] tempMark = new boolean[26]; //temporary marker\\n\\t\\t\\n\\t\\tfor (Character v : graph.keySet()) {\\n\\t\\t\\tif (!visited[v - 'a']) {\\n\\t\\t\\t\\tif (!visitDFS(ans, graph, visited, v, tempMark)) {\\n\\t\\t\\t\\t\\treturn \"\";\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (Character c : charSet) { //insert orphan chars.\\n\\t\\t\\tans.insert(0, c);\\n\\t\\t}\\n\\t\\treturn ans.reverse().toString();\\n\\t}\\n\\n\\tprivate boolean visitDFS(StringBuffer ans, Map<Character, List<Character>> graph, boolean[] visited,\\n\\t\\t\\tCharacter node, boolean[] marked) {\\n\\t\\tif (marked[node - 'a']) {  //if temporally marked already, it is not DAG. return failure(false);\\n\\t\\t\\treturn false;\\n\\t\\t} \\n\\t\\tif (!visited[node - 'a']) {\\n\\t\\t\\tmarked[node - 'a'] = true; //mark the current node temporally.\\n\\t\\t\\tList<Character> adjList = graph.get(node);\\n\\t\\t\\tif (adjList != null) {\\n\\t\\t\\t\\tfor (Character m : graph.get(node)) {\\n\\t\\t\\t\\t\\tif (!visitDFS(ans, graph, visited, m, marked))\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//there is no adjacent node, it is a leaf, output the node(char).\\n\\t\\t\\tvisited[node - 'a'] = true; //mark the node permanently.\\n\\t\\t\\tmarked[node - 'a'] = false; //remove the temp mark.\\n\\t\\t\\tans.append(node);\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tprivate void buildGraph(String[] words, Map<Character, List<Character>> graph, Set<Character> charSet) {\\n\\t\\t\\n\\t\\tgetCharSet(words, charSet); //Find all chars in the words.\\n\\t\\t\\n\\t\\tfor (int i = 0; i < words.length - 1; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < words.length; j++) {\\n\\t\\t\\t\\tfor (int k = 0; k < Math.min(words[i].length(), words[j].length()); k++) {\\n\\t\\t\\t\\t\\tif (words[i].charAt(k) != words[j].charAt(k)) {\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tcharSet.remove(words[i].charAt(k)); //Remove the chars that are in the graph from charSet.\\n\\t\\t\\t\\t\\t\\tcharSet.remove(words[j].charAt(k));\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tif (graph.containsKey(words[i].charAt(k))) {\\n\\t\\t\\t\\t\\t\\t\\tList<Character> adjList = graph.get(words[i].charAt(k));\\n\\t\\t\\t\\t\\t\\t\\tif (!adjList.contains(words[j].charAt(k)))\\n\\t\\t\\t\\t\\t\\t\\t\\tgraph.get(words[i].charAt(k)).add(words[j].charAt(k));\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tList<Character> adjList = new ArrayList<Character>();\\n\\t\\t\\t\\t\\t\\t\\tadjList.add(words[j].charAt(k));\\n\\t\\t\\t\\t\\t\\t\\tgraph.put(words[i].charAt(k), adjList);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}"
		},
		{
			"lc_ans_id":"70169",
			"view":"2701",
			"top":"9",
			"title":"My Concise JAVA solution based on Topological Sorting",
			"vote":"12",
			"content":"This problem is actually similar as [Course Schedule II][1]. The basic idea to solve this problem:\\n\\n    1. Convert characters to a graph: Adjacency lists\\n    2. Topological sorting: keep adding elements whose in-degree is 0\\n\\nWhile figuring out the solution, it helped me to understand topological sorting entirely.\\n\\n**[Topological sorting:][2]** The classic linear algorithm to solve dependency problems, e.g. course schedule. \\n\\n**In-degree:** The amount of dependencies of the element E, which means the amount of E's  predecessors. We have to fulfill E's predecessors before executing E, when E's in-degree = 0.\\n\\n**Time complexity = O(n + m) - n represents all vertices, m represents all edges** \\n\\n\\n**JAVA Code:**\\n \\n\\n    public String alienOrder(String[] words) {\\n        List<Point> pairs = new LinkedList<Point>(); // Adjacency list: pair = (node, node's predecessor)\\n        Set<Character>chs = new HashSet<Character>();// All distinct characters\\n    \\n        // 1. Convert characters to a graph: Adjacency lists \\n        for (int i = 0; i < words.length; i++) {            \\n            String word = words[i];     \\n            boolean alreadySet = false;// Only set one pair where the characters at the same position differs in two neighbor rows. e.g. \"wrtk\" < \"wrfp\"=> 't' < 'f'\\n            for (int j = 0; j < words[i].length(); j++) {                \\n                if (!alreadySet && i > 0 && j < words[i-1].length() && words[i].charAt(j) != words[i-1].charAt(j)) {// Set dependency of two characters by comparing two neighbor rows. \\n                    pairs.add(new Point(words[i].charAt(j), words[i-1].charAt(j)));\\n                    alreadySet = true;\\n                }               \\n                chs.add(word.charAt(j));// Add distinct character to chs set\\n            }\\n        }       \\n    \\n        // 2. Topological sorting: keep adding elements whose in-degree is 0\\n        String res = \"\";\\n        int indegree[] = new int[256];\\n        Arrays.fill(indegree, Integer.MIN_VALUE);\\n    \\n        for (Character ch : chs) indegree[ch] = 0;// Initialize in-degree of the distinct characters in the words list\\n        for (int i = 0; i < pairs.size(); i++)// Increase in-degree according to the dependency of pairs list\\n            indegree[pairs.get(i).x]++;\\n    \\n        Queue<Character> queue = new LinkedList<Character>();\\n        for (int i = 0; i < 256; i++) {\\n            if (indegree[i] == 0) {// Add the character whose in-degree = 0, which means it doesn't have any predecessor \\n                res += (char) i;\\n                queue.offer((char) i);\\n            }\\n        }\\n    \\n        while (!queue.isEmpty()) {\\n            Character predecessor = queue.poll(); // Dequeue the character whose in-degree = 0 from queue\\n    \\n            for (int i = 0; i < pairs.size(); i++) {\\n                if (pairs.get(i).y == predecessor) {// Update in-degree: decrease 1 to the successors of the character whose in-degree = 0\\n                    indegree[pairs.get(i).x]--;                 \\n                    if (indegree[pairs.get(i).x] == 0) {// If in-degree = 0, add the character to the queue, and append it to the result string\\n                        res += (char) pairs.get(i).x; \\n                        queue.offer((char) pairs.get(i).x);\\n                    }\\n                }\\n            }\\n        }\\n        return res.length() == chs.size() ? res : \"\";// NOTE: res.length should equal the size of distinct characters, otherwise a cycle must exist \\n    }\\n\\n\\n  [1]: https://leetcode.com/problems/course-schedule-ii/\\n  [2]: https://en.wikipedia.org/wiki/Topological_sorting"
		}
	],
	"id":"269",
	"title":"Alien Dictionary",
	"content":"<p>\r\nThere is a new alien language which uses the latin alphabet. \r\nHowever, the order among letters are unknown to you. \r\nYou receive a list of <b>non-empty</b> words from the dictionary, where <b>words are sorted lexicographically by the rules of this new language</b>.\r\nDerive the order of letters in this language.\r\n</p>\r\n\r\n<p>\r\n<b>Example 1:</b><br>\r\nGiven the following words in dictionary,\r\n<pre>\r\n[\r\n  \"wrt\",\r\n  \"wrf\",\r\n  \"er\",\r\n  \"ett\",\r\n  \"rftt\"\r\n]\r\n</pre>\r\n</p>\r\n<p>\r\nThe correct order is: <code>\"wertf\"</code>.</p>\r\n\r\n<p>\r\n<b>Example 2:</b><br>\r\nGiven the following words in dictionary,\r\n<pre>\r\n[\r\n  \"z\",\r\n  \"x\"\r\n]\r\n</pre>\r\n</p>\r\n<p>\r\nThe correct order is: <code>\"zx\"</code>.</p>\r\n\r\n<p>\r\n<b>Example 3:</b><br>\r\nGiven the following words in dictionary,\r\n<pre>\r\n[\r\n  \"z\",\r\n  \"x\",\r\n  \"z\"\r\n]\r\n</pre>\r\n</p>\r\n<p>\r\nThe order is invalid, so return <code>\"\"</code>.</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>You may assume all letters are in lowercase.</li>\r\n<li>You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.</li>\r\n<li>If the order is invalid, return an empty string.</li>\r\n<li>There may be multiple valid order of letters, return any one of them is fine.</li>\r\n</ol>\r\n</p>",
	"frequency":"329",
	"ac_num":"36236"
}