{
	"difficulty":"3",
	"submit_num":"53224",
	"show_id":"272",
	"leetcode_id":"272",
	"answers":[
		{
			"lc_ans_id":"70511",
			"view":"23148",
			"top":"0",
			"title":"AC clean Java solution using two stacks",
			"vote":"145",
			"content":"The idea is to compare the predecessors and successors of the closest node to the target, we can use two stacks to track the predecessors and successors, then like what we do in merge sort, we compare and pick the closest one to the target and put it to the result list.\\n\\nAs we know, inorder traversal gives us sorted predecessors, whereas reverse-inorder traversal gives us sorted successors.\\n\\nWe can use iterative inorder traversal rather than recursion, but to keep the code clean, here is the recursion version.\\n\\n    public List<Integer> closestKValues(TreeNode root, double target, int k) {\\n      List<Integer> res = new ArrayList<>();\\n\\n      Stack<Integer> s1 = new Stack<>(); // predecessors\\n      Stack<Integer> s2 = new Stack<>(); // successors\\n\\n      inorder(root, target, false, s1);\\n      inorder(root, target, true, s2);\\n      \\n      while (k-- > 0) {\\n        if (s1.isEmpty())\\n          res.add(s2.pop());\\n        else if (s2.isEmpty())\\n          res.add(s1.pop());\\n        else if (Math.abs(s1.peek() - target) < Math.abs(s2.peek() - target))\\n          res.add(s1.pop());\\n        else\\n          res.add(s2.pop());\\n      }\\n      \\n      return res;\\n    }\\n    \\n    // inorder traversal\\n    void inorder(TreeNode root, double target, boolean reverse, Stack<Integer> stack) {\\n      if (root == null) return;\\n\\n      inorder(reverse ? root.right : root.left, target, reverse, stack);\\n      // early terminate, no need to traverse the whole tree\\n      if ((reverse && root.val <= target) || (!reverse && root.val > target)) return;\\n      // track the value of current node\\n      stack.push(root.val);\\n      inorder(reverse ? root.left : root.right, target, reverse, stack);\\n    }"
		},
		{
			"lc_ans_id":"70503",
			"view":"11649",
			"top":"1",
			"title":"O(logN) Java Solution with two stacks following hint",
			"vote":"83",
			"content":"    public class Solution {\\n        public List<Integer> closestKValues(TreeNode root, double target, int k) {\\n            List<Integer> ret = new LinkedList<>();\\n            Stack<TreeNode> succ = new Stack<>();\\n            Stack<TreeNode> pred = new Stack<>();\\n            initializePredecessorStack(root, target, pred);\\n            initializeSuccessorStack(root, target, succ);\\n            if(!succ.isEmpty() && !pred.isEmpty() && succ.peek().val == pred.peek().val) {\\n                getNextPredecessor(pred);\\n            }\\n            while(k-- > 0) {\\n                if(succ.isEmpty()) {\\n                    ret.add(getNextPredecessor(pred));\\n                } else if(pred.isEmpty()) {\\n                    ret.add(getNextSuccessor(succ));\\n                } else {\\n                    double succ_diff = Math.abs((double)succ.peek().val - target);\\n                    double pred_diff = Math.abs((double)pred.peek().val - target);\\n                    if(succ_diff < pred_diff) {\\n                        ret.add(getNextSuccessor(succ));\\n                    } else {\\n                        ret.add(getNextPredecessor(pred));\\n                    }\\n                }\\n            }\\n            return ret;\\n        }\\n    \\n        private void initializeSuccessorStack(TreeNode root, double target, Stack<TreeNode> succ) {\\n            while(root != null) {\\n                if(root.val == target) {\\n                    succ.push(root);\\n                    break;\\n                } else if(root.val > target) {\\n                    succ.push(root);\\n                    root = root.left;\\n                } else {\\n                    root = root.right;\\n                }\\n            }\\n        }\\n    \\n        private void initializePredecessorStack(TreeNode root, double target, Stack<TreeNode> pred) {\\n            while(root != null){\\n                if(root.val == target){\\n                    pred.push(root);\\n                    break;\\n                } else if(root.val < target){\\n                    pred.push(root);\\n                    root = root.right;\\n                } else{\\n                    root = root.left;\\n                }\\n            }\\n        }\\n        \\n        private int getNextSuccessor(Stack<TreeNode> succ) {\\n            TreeNode curr = succ.pop();\\n            int ret = curr.val;\\n            curr = curr.right;\\n            while(curr != null) {\\n                succ.push(curr);\\n                curr = curr.left;\\n            }\\n            return ret;\\n        }\\n    \\n        private int getNextPredecessor(Stack<TreeNode> pred) {\\n            TreeNode curr = pred.pop();\\n            int ret = curr.val;\\n            curr = curr.left;\\n            while(curr != null) {\\n                pred.push(curr);\\n                curr = curr.right;\\n            }\\n            return ret;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"70499",
			"view":"4274",
			"top":"2",
			"title":"Java 5ms iterative, following hint, O(klogn) time and space",
			"vote":"38",
			"content":"Following the hint, I use a predecessor stack and successor stack. I do a logn traversal to initialize them until I reach the null node. Then I use the getPredecessor and getSuccessor method to pop k closest nodes and update the stacks.\\n\\nTime complexity is O(klogn), since k BST traversals are needed and each is bounded by O(logn) time. Note that it is not O(logn + k) which is the time complexity for k closest numbers in a linear array.\\n\\nSpace complexity is O(klogn), since each traversal brings  O(logn) new nodes to the stack.\\n\\n\\n\\n    public class Solution {\\n        public List<Integer> closestKValues(TreeNode root, double target, int k) {\\n            List<Integer> result = new LinkedList<Integer>();\\n            // populate the predecessor and successor stacks \\n            Stack<TreeNode> pred = new Stack<TreeNode>();\\n            Stack<TreeNode> succ = new Stack<TreeNode>();\\n            TreeNode curr = root;\\n            while (curr != null) {\\n                if (target <= curr.val) {\\n                    succ.push(curr);\\n                    curr = curr.left;\\n                } else {\\n                    pred.push(curr);\\n                    curr = curr.right;\\n                }\\n            }\\n            while (k > 0) {\\n                if (pred.empty() && succ.empty()) {\\n                    break; \\n                } else if (pred.empty()) {\\n                    result.add( getSuccessor(succ) );\\n                } else if (succ.empty()) {\\n                    result.add( getPredecessor(pred) );\\n                } else if (Math.abs(target - pred.peek().val) < Math.abs(target - succ.peek().val)) {\\n                    result.add( getPredecessor(pred) );                    \\n                } else {\\n                    result.add( getSuccessor(succ) );\\n                }\\n                k--;\\n            }\\n            return result;\\n         }\\n    \\n        private int getPredecessor(Stack<TreeNode> st) {\\n            TreeNode popped = st.pop();\\n            TreeNode p = popped.left;\\n            while (p != null) {\\n                st.push(p);\\n                p = p.right;\\n            }\\n            return popped.val;\\n        }\\n    \\n        private int getSuccessor(Stack<TreeNode> st) {\\n            TreeNode popped = st.pop();\\n            TreeNode p = popped.right;\\n            while (p != null) {\\n                st.push(p);\\n                p = p.left;\\n            }\\n            return popped.val;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"70515",
			"view":"3966",
			"top":"3",
			"title":"Java in-order traversal 1ms solution",
			"vote":"27",
			"content":"    public class Solution {\\n        public List<Integer> closestKValues(TreeNode root, double target, int k) {\\n            LinkedList<Integer> list = new LinkedList<Integer>();\\n            closestKValuesHelper(list, root, target, k);\\n            return list;\\n        }\\n        \\n        /**\\n         * @return <code>true</code> if result is already found.\\n         */\\n        private boolean closestKValuesHelper(LinkedList<Integer> list, TreeNode root, double target, int k) {\\n            if (root == null) {\\n                return false;\\n            }\\n            \\n            if (closestKValuesHelper(list, root.left, target, k)) {\\n                return true;\\n            }\\n            \\n            if (list.size() == k) {\\n                if (Math.abs(list.getFirst() - target) < Math.abs(root.val - target)) {\\n                    return true;\\n                } else {\\n                    list.removeFirst();\\n                }\\n            }\\n            \\n            list.addLast(root.val);\\n            return closestKValuesHelper(list, root.right, target, k);\\n        }\\n    }"
		},
		{
			"lc_ans_id":"70595",
			"view":"2542",
			"top":"4",
			"title":"Java Two stacks Iterative solution",
			"vote":"17",
			"content":"    public List<Integer> closestKValues(TreeNode root, double target, int k) {\\n        Deque<TreeNode> bigger = new ArrayDeque<TreeNode>();\\n        Deque<TreeNode> smaller = new ArrayDeque<TreeNode>();\\n        TreeNode node = root;\\n        // log(n)\\n        while(node != null)\\n        {\\n            if(node.val > target)\\n            {\\n                bigger.push(node);\\n                node = node.left;\\n            }\\n            else\\n            {\\n                smaller.push(node);\\n                node = node.right;\\n            }\\n        }\\n        \\n        // k\\n        List<Integer> ret = new ArrayList<Integer>();\\n        while(ret.size() < k)\\n        {\\n            if(bigger.isEmpty() ||\\n               !smaller.isEmpty() &&\\n                ((bigger.peek().val - target) > (target - smaller.peek().val)))\\n            {\\n                node = smaller.pop();\\n                ret.add(node.val);\\n                \\n                // Get next smaller\\n                node = node.left;\\n                while(node != null)\\n                {\\n                    smaller.push(node);\\n                    node = node.right;\\n                }\\n            }\\n            else\\n            {\\n                node = bigger.pop();\\n                ret.add(node.val);\\n                \\n                // get next bigger\\n                node = node.right;\\n                while(node != null)\\n                {\\n                    bigger.push(node);\\n                    node = node.left;\\n                }                \\n            }\\n        }\\n        \\n        return ret;\\n    }"
		},
		{
			"lc_ans_id":"70488",
			"view":"3024",
			"top":"5",
			"title":"Simple C++ solution with priority queue",
			"vote":"15",
			"content":"There are many ways to solve this problem. Heap is one of them. \\n\\n\\n\\n    void dfs(TreeNode* root, priority_queue<pair<double, int>>& pq, double target, int k) {\\n        if(!root) return;\\n        \\n        pq.push(make_pair(fabs(target - double(root->val)), root->val));\\n        \\n        if(pq.size() > k) \\n            pq.pop();\\n            \\n        dfs(root->left, pq, target, k);\\n        dfs(root->right, pq, target, k);\\n    }\\n\\n    vector<int> closestKValues(TreeNode* root, double target, int k) {\\n        priority_queue<pair<double, int>> pq;\\n        vector<int> result;\\n        \\n        dfs(root, pq, target, k);\\n        while(!pq.empty()) {\\n            result.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        \\n        return result;\\n    }"
		},
		{
			"lc_ans_id":"70512",
			"view":"1093",
			"top":"6",
			"title":"Inorder One LinkedList Java solution beat 85%",
			"vote":"12",
			"content":"This solution is maintaining a linkedlist and break the travelsal when the rightmost is larger than the leftmost.\\n\\n\\n\\n    public List<Integer> closestKValues(TreeNode root, double target, int k) {\\n        List<Integer> res = new LinkedList<Integer>();\\n        helper(root, target, k, res);\\n        return res;\\n    }\\n    private void helper(TreeNode root, double target, int k, List<Integer> res) {\\n        if (root == null) {\\n            return;\\n        }\\n        helper(root.left,target,k,res);\\n        if (res.size()< k) {\\n            res.add(root.val);\\n        } else {\\n            if (Math.abs(res.get(0)-target) > Math.abs(root.val-target)) {\\n                res.remove(0);\\n                res.add(root.val);\\n            } else {\\n                return;\\n            }\\n        }\\n        helper(root.right,target,k,res);\\n    }"
		},
		{
			"lc_ans_id":"70594",
			"view":"1791",
			"top":"7",
			"title":"2 ms O(N) and 6 ms O(logN) java solution",
			"vote":"10",
			"content":"O(N), 2ms: In-order recursive traversal and maintaining a size k LinkedList which is sorted because of in-order\\n\\n    public List<Integer> closestKValues(TreeNode root, double target, int k) {\\n        LinkedList<Integer> list = new LinkedList<>();\\n        closestKValuesHelper(root, target, k, list);\\n        return list;\\n    }\\n    private void closestKValuesHelper(TreeNode root, double target, int k, LinkedList<Integer> list){\\n        if(root == null || list.size() == k && list.get(0) >= target)    return;\\n        closestKValuesHelper(root.left, target, k, list);\\n        if(list.size() == k && list.get(0) < target && target - list.get(0) > Math.abs(root.val - target)){\\n            list.removeFirst();\\n            list.addLast(root.val);\\n        }\\n        else if(list.size() < k)    list.addLast(root.val); \\n        closestKValuesHelper(root.right, target, k, list);\\n    }\\n\\n\\nO(logN), 6ms: The Stack initialization costs O(logN), and getPredecessor & getSuccessor actually cost O(MAX(logN, K)) in worst case, which will work better when logN is much greater than K.\\n    \\n    public List<Integer> closestKValues(TreeNode root, double target, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        Stack<TreeNode> pred = new Stack<>(), succ = new Stack<>();\\n        initStack(pred, succ, root, target);\\n        while(k-- > 0){\\n            if(succ.isEmpty() || !pred.isEmpty() && target - pred.peek().val < succ.peek().val - target){\\n                list.add(pred.peek().val);\\n                getPredecessor(pred);\\n            }\\n            else{//Since N > k, always have something to add\\n                list.add(succ.peek().val);\\n                getSuccessor(succ);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    private void initStack(Stack<TreeNode> pred, Stack<TreeNode> succ, TreeNode root, double target){\\n        while(root != null){\\n            if(root.val <= target){\\n                pred.push(root);\\n                root = root.right;\\n            }\\n            else{\\n                succ.push(root);\\n                root = root.left;\\n            }\\n        }\\n    }\\n    private void getPredecessor(Stack<TreeNode> st){\\n        TreeNode node = st.pop();\\n        if(node.left != null){\\n            st.push(node.left);\\n            while(st.peek().right != null)  st.push(st.peek().right);\\n        }\\n    }\\n    private void getSuccessor(Stack<TreeNode> st){\\n        TreeNode node = st.pop();\\n        if(node.right != null){\\n            st.push(node.right);\\n            while(st.peek().left != null)   st.push(st.peek().left);\\n        }\\n    }"
		},
		{
			"lc_ans_id":"70549",
			"view":"1025",
			"top":"8",
			"title":"Clear Java Solution with one stack one linkedlist",
			"vote":"9",
			"content":"    public List<Integer> closestKValues(TreeNode root, double target, int k) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        LinkedList<Integer> ret = new LinkedList<>();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            if (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else {\\n                curr = stack.pop();\\n                if(ret.size() < k) {\\n                    ret.addLast(curr.val);\\n                } else {\\n                    if(Math.abs(ret.getFirst()-target) > Math.abs(curr.val-target)) {\\n                        ret.removeFirst();\\n                        ret.addLast(curr.val);\\n                    } else break;\\n                }\\n                curr = curr.right;\\n            }\\n        }\\n        return ret;\\n    }"
		},
		{
			"lc_ans_id":"70506",
			"view":"2450",
			"top":"9",
			"title":"Efficient Python",
			"vote":"7",
			"content":"For the follow-up question, this is O(k log n) and maybe O(k + log n), haven't thought it through yet. Probably by far the longest solution I've posted here, I even felt the need to include comments :-P\\n\\nImagine you didn't have a BST but a simple sorted array. How would you find the k values closest to the target value? You could do binary search to find the closest value and then move outwards with two index variables, collecting the k closest values. That's what I do here, except instead of simple array indexes I have two tree iterators in the form of root-to-node paths.\\n\\nFinding the initial iterator=path to the closest value takes O(h) time, where h is the height of the tree. Increasing or decreasing these iterators=paths also takes O(h) time. So O(kh) overall. And maybe better, as moving an iterator=path will often be quick. I mean, it's just an inorder traversal, so I'd expect O(1) amortized moving time at least if we're traversing the entire tree.\\n\\n    def closestKValues(self, root, target, k):\\n\\n        # Helper, takes a path and makes it the path to the next node\\n        def nextpath(path, kid1, kid2):\\n            if path:\\n                if kid2(path):\\n                    path += kid2(path),\\n                    while kid1(path):\\n                        path += kid1(path),\\n                else:\\n                    kid = path.pop()\\n                    while path and kid is kid2(path):\\n                        kid = path.pop()\\n\\n        # These customize nextpath as forward or backward iterator\\n        kidleft = lambda path: path[-1].left\\n        kidright = lambda path: path[-1].right\\n\\n        # Build path to closest node\\n        path = []\\n        while root:\\n            path += root,\\n            root = root.left if target < root.val else root.right\\n        dist = lambda node: abs(node.val - target)\\n        path = path[:path.index(min(path, key=dist))+1]\\n\\n        # Get the path to the next larger node\\n        path2 = path[:]\\n        nextpath(path2, kidleft, kidright)\\n\\n        # Collect the closest k values by moving the two paths outwards\\n        vals = []\\n        for _ in range(k):\\n            if not path2 or path and dist(path[-1]) < dist(path2[-1]):\\n                vals += path[-1].val,\\n                nextpath(path, kidright, kidleft)\\n            else:\\n                vals += path2[-1].val,\\n                nextpath(path2, kidleft, kidright)\\n        return vals"
		}
	],
	"id":"272",
	"title":"Closest Binary Search Tree Value II",
	"content":"<p>\r\nGiven a non-empty binary search tree and a target value, find <i>k</i> values in the BST that are closest to the target.\r\n</p>\r\n<p><b>Note:</b><br>\r\n<ul>\r\n<li>Given target value is a floating point.</li>\r\n<li>You may assume <i>k</i> is always valid, that is: <i>k</i> &le; total nodes.</li>\r\n<li>You are guaranteed to have only one unique set of <i>k</i> values in the BST that are closest to the target.</li>\r\n</ul></p>\r\n<p><b>Follow up:</b><br>\r\nAssume that the BST is balanced, could you solve it in less than <i>O</i>(<i>n</i>) runtime (where <i>n</i> = total nodes)?\r\n</p>",
	"frequency":"170",
	"ac_num":"21163"
}