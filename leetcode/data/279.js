{
	"difficulty":"2",
	"submit_num":"263777",
	"show_id":"279",
	"leetcode_id":"279",
	"answers":[
		{
			"lc_ans_id":"71488",
			"view":"55945",
			"top":"0",
			"title":"Summary of 4 different solutions (BFS, DP, static DP and mathematics)",
			"vote":"269",
			"content":"Came up with the 2 solutions of breadth-first search and dynamic programming. Also \"copied\" StefanPochmann's static dynamic programming solution (https://leetcode.com/discuss/56993/static-dp-c-12-ms-python-172-ms-ruby-384-ms) and davidtan1890's mathematical solution (https://leetcode.com/discuss/57066/4ms-c-code-solve-it-mathematically) here with minor style changes and some comments. Thank Stefan and David for posting their nice solutions!\\n\\n**1.Dynamic Programming:** 440ms\\n\\n    class Solution \\n    {\\n    public:\\n        int numSquares(int n) \\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }\\n            \\n            // cntPerfectSquares[i] = the least number of perfect square numbers \\n            // which sum to i. Note that cntPerfectSquares[0] is 0.\\n            vector<int> cntPerfectSquares(n + 1, INT_MAX);\\n            cntPerfectSquares[0] = 0;\\n            for (int i = 1; i <= n; i++)\\n            {\\n                // For each i, it must be the sum of some number (i - j*j) and \\n                // a perfect square number (j*j).\\n                for (int j = 1; j*j <= i; j++)\\n                {\\n                    cntPerfectSquares[i] = \\n                        min(cntPerfectSquares[i], cntPerfectSquares[i - j*j] + 1);\\n                }\\n            }\\n            \\n            return cntPerfectSquares.back();\\n        }\\n    };\\n\\n**2.Static Dynamic Programming:** 12ms\\n\\n    class Solution \\n    {\\n    public:\\n        int numSquares(int n) \\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }\\n            \\n            // cntPerfectSquares[i] = the least number of perfect square numbers \\n            // which sum to i. Since cntPerfectSquares is a static vector, if \\n            // cntPerfectSquares.size() > n, we have already calculated the result \\n            // during previous function calls and we can just return the result now.\\n            static vector<int> cntPerfectSquares({0});\\n            \\n            // While cntPerfectSquares.size() <= n, we need to incrementally \\n            // calculate the next result until we get the result for n.\\n            while (cntPerfectSquares.size() <= n)\\n            {\\n                int m = cntPerfectSquares.size();\\n                int cntSquares = INT_MAX;\\n                for (int i = 1; i*i <= m; i++)\\n                {\\n                    cntSquares = min(cntSquares, cntPerfectSquares[m - i*i] + 1);\\n                }\\n                \\n                cntPerfectSquares.push_back(cntSquares);\\n            }\\n            \\n            return cntPerfectSquares[n];\\n        }\\n    };\\n\\n**3.Mathematical Solution:** 4ms\\n\\n    class Solution \\n    {  \\n    private:  \\n        int is_square(int n)\\n        {  \\n            int sqrt_n = (int)(sqrt(n));  \\n            return (sqrt_n*sqrt_n == n);  \\n        }\\n        \\n    public:\\n        // Based on Lagrange's Four Square theorem, there \\n        // are only 4 possible results: 1, 2, 3, 4.\\n        int numSquares(int n) \\n        {  \\n            // If n is a perfect square, return 1.\\n            if(is_square(n)) \\n            {\\n                return 1;  \\n            }\\n            \\n            // The result is 4 if and only if n can be written in the \\n            // form of 4^k*(8*m + 7). Please refer to \\n            // Legendre's three-square theorem.\\n            while ((n & 3) == 0) // n%4 == 0  \\n            {\\n                n >>= 2;  \\n            }\\n            if ((n & 7) == 7) // n%8 == 7\\n            {\\n                return 4;\\n            }\\n            \\n            // Check whether 2 is the result.\\n            int sqrt_n = (int)(sqrt(n)); \\n            for(int i = 1; i <= sqrt_n; i++)\\n            {  \\n                if (is_square(n - i*i)) \\n                {\\n                    return 2;  \\n                }\\n            }  \\n            \\n            return 3;  \\n        }  \\n    }; \\n\\n**4.Breadth-First Search:** 80ms\\n\\n    class Solution \\n    {\\n    public:\\n        int numSquares(int n) \\n        {\\n            if (n <= 0)\\n            {\\n                return 0;\\n            }\\n            \\n            // perfectSquares contain all perfect square numbers which \\n            // are smaller than or equal to n.\\n            vector<int> perfectSquares;\\n            // cntPerfectSquares[i - 1] = the least number of perfect \\n            // square numbers which sum to i.\\n            vector<int> cntPerfectSquares(n);\\n            \\n            // Get all the perfect square numbers which are smaller than \\n            // or equal to n.\\n            for (int i = 1; i*i <= n; i++)\\n            {\\n                perfectSquares.push_back(i*i);\\n                cntPerfectSquares[i*i - 1] = 1;\\n            }\\n            \\n            // If n is a perfect square number, return 1 immediately.\\n            if (perfectSquares.back() == n)\\n            {\\n                return 1;\\n            }\\n            \\n            // Consider a graph which consists of number 0, 1,...,n as\\n            // its nodes. Node j is connected to node i via an edge if  \\n            // and only if either j = i + (a perfect square number) or \\n            // i = j + (a perfect square number). Starting from node 0, \\n            // do the breadth-first search. If we reach node n at step \\n            // m, then the least number of perfect square numbers which \\n            // sum to n is m. Here since we have already obtained the \\n            // perfect square numbers, we have actually finished the \\n            // search at step 1.\\n            queue<int> searchQ;\\n            for (auto& i : perfectSquares)\\n            {\\n                searchQ.push(i);\\n            }\\n            \\n            int currCntPerfectSquares = 1;\\n            while (!searchQ.empty())\\n            {\\n                currCntPerfectSquares++;\\n                \\n                int searchQSize = searchQ.size();\\n                for (int i = 0; i < searchQSize; i++)\\n                {\\n                    int tmp = searchQ.front();\\n                    // Check the neighbors of node tmp which are the sum \\n                    // of tmp and a perfect square number.\\n                    for (auto& j : perfectSquares)\\n                    {\\n                        if (tmp + j == n)\\n                        {\\n                            // We have reached node n.\\n                            return currCntPerfectSquares;\\n                        }\\n                        else if ((tmp + j < n) && (cntPerfectSquares[tmp + j - 1] == 0))\\n                        {\\n                            // If cntPerfectSquares[tmp + j - 1] > 0, this is not \\n                            // the first time that we visit this node and we should \\n                            // skip the node (tmp + j).\\n                            cntPerfectSquares[tmp + j - 1] = currCntPerfectSquares;\\n                            searchQ.push(tmp + j);\\n                        }\\n                        else if (tmp + j > n)\\n                        {\\n                            // We don't need to consider the nodes which are greater ]\\n                            // than n.\\n                            break;\\n                        }\\n                    }\\n                    \\n                    searchQ.pop();\\n                }\\n            }\\n            \\n            return 0;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"71495",
			"view":"22806",
			"top":"1",
			"title":"An easy understanding DP solution in Java",
			"vote":"182",
			"content":"dp[n] indicates that the perfect squares count of the given n, and we have:\\n\\n    dp[0] = 0 \\n    dp[1] = dp[0]+1 = 1\\n    dp[2] = dp[1]+1 = 2\\n    dp[3] = dp[2]+1 = 3\\n    dp[4] = Min{ dp[4-1*1]+1, dp[4-2*2]+1 } \\n          = Min{ dp[3]+1, dp[0]+1 } \\n          = 1\\t\\t\\t\\t\\n    dp[5] = Min{ dp[5-1*1]+1, dp[5-2*2]+1 } \\n          = Min{ dp[4]+1, dp[1]+1 } \\n          = 2\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n    dp[13] = Min{ dp[13-1*1]+1, dp[13-2*2]+1, dp[13-3*3]+1 } \\n           = Min{ dp[12]+1, dp[9]+1, dp[4]+1 } \\n           = 2\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n    dp[n] = Min{ dp[n - i*i] + 1 },  n - i*i >=0 && i >= 1\\n\\n\\n\\nand the sample code is like below:\\n\\n    public int numSquares(int n) {\\n\\t\\tint[] dp = new int[n + 1];\\n\\t\\tArrays.fill(dp, Integer.MAX_VALUE);\\n\\t\\tdp[0] = 0;\\n\\t\\tfor(int i = 1; i <= n; ++i) {\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint j = 1;\\n\\t\\t\\twhile(i - j*j >= 0) {\\n\\t\\t\\t\\tmin = Math.min(min, dp[i - j*j] + 1);\\n\\t\\t\\t\\t++j;\\n\\t\\t\\t}\\n\\t\\t\\tdp[i] = min;\\n\\t\\t}\\t\\t\\n\\t\\treturn dp[n];\\n\\t}\\n\\nHope it can help to understand the DP solution."
		},
		{
			"lc_ans_id":"71475",
			"view":"10244",
			"top":"2",
			"title":"Short Python solution using BFS",
			"vote":"59",
			"content":"    def numSquares(self, n):\\n        if n < 2:\\n            return n\\n        lst = []\\n        i = 1\\n        while i * i <= n:\\n            lst.append( i * i )\\n            i += 1\\n        cnt = 0\\n        toCheck = {n}\\n        while toCheck:\\n            cnt += 1\\n            temp = set()\\n            for x in toCheck:\\n                for y in lst:\\n                    if x == y:\\n                        return cnt\\n                    if x < y:\\n                        break\\n                    temp.add(x-y)\\n            toCheck = temp\\n    \\n        return cnt\\n\\nThe basic idea of this solution is a BSF search for shortest path, take 12 as an example, as shown below, the shortest path is 12-8-4-0:\\n\\n![0_1467720854827_XCoQwiN.png](/uploads/files/1467720855285-xcoqwin.png)"
		},
		{
			"lc_ans_id":"71533",
			"view":"14741",
			"top":"3",
			"title":"O(sqrt(n)) in Ruby, C++, C",
			"vote":"51",
			"content":"These solutions use some number theory (see explanation further down).\\n\\n---\\n\\n**Ruby solution**\\n\\n    require 'prime'\\n    \\n    def num_squares(n)\\n      n /= 4 while n % 4 == 0\\n      return 4 if n % 8 == 7\\n      return 3 if n.prime_division.any? { |p, e| p % 4 == 3 && e.odd? }\\n      (n**0.5).to_i**2 == n ? 1 : 2\\n    end\\n\\nOr:\\n\\n    require 'prime'\\n    \\n    def num_squares(n)\\n      n /= 4 while n % 4 == 0\\n      return 4 if n % 8 == 7\\n      pd = n.prime_division\\n      return 3 if pd.any? { |p, e| p % 4 == 3 && e.odd? }\\n      pd.any? { |_, e| e.odd? } ? 2 : 1\\n    end\\n\\n---\\n\\n**C++ solution**\\n\\n    int numSquares(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        bool min2 = false;\\n        for (int i=2; i<=n; ++i) {\\n            if (i > n/i)\\n                i = n;\\n            int e = 0;\\n            while (n % i == 0)\\n                n /= i, ++e;\\n            if (e % 2 && i % 4 == 3)\\n                return 3;\\n            min2 |= e % 2;\\n        }\\n        return 1 + min2;\\n    }\\n\\n---\\n\\n**C solution**\\n\\nInspired by [kevin36's solution](https://leetcode.com/discuss/57020/java-solution-o-n-1-2-time-and-o-1-space). We don't really need to compute the prime factorization. Knowing that four squares always suffice and using the three-squares test is enough. Single-square and sum-of-two-squares cases can be done simpler.\\n\\n    int numSquares(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        for (int a=0; a*a<=n; ++a) {\\n            int b = sqrt(n - a*a);\\n            if (a*a + b*b == n)\\n                return 1 + !!a;\\n        }\\n        return 3;\\n    }\\n\\n---\\n\\n**Explanation**\\n\\nI happen to have given a little talk about just this topic a while back in a number theory seminar. This problem is completely solved, in the sense of being reduced to simple checks of a number's prime factorization. A natural number is...\\n\\n- ... a **square** if and only if each prime factor occurs to an even power in the number's prime factorization.\\n- ... a [**sum of two squares**](https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares) if and only if each prime factor that's 3 modulo 4 occurs to an even power in the number's prime factorization.\\n- ... a [**sum of three squares**](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem) if and only if it's not of the form 4<sup>a</sup>(8b+7) with integers a and b.\\n- ... a [**sum of four squares**](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem). Period. No condition. You never need more than four.\\n\\nOf course single squares can also be identified by comparing a given number with the square of the rounded root of the number.\\n\\nThe problem statement says *\"1, 4, 9, 16, ...\"*, for some reason apparently excluding 0, but it really is a perfect square and the above theorems do consider it one. With that, you can for example always extend a sum of two squares a<sup>2</sup>+b<sup>2</sup> to the sum of three squares a<sup>2</sup>+b<sup>2</sup>+0<sup>2</sup>. Put differently, if n isn't a sum of three squares, then it also isn't a sum of two squares. So you can read the above statements as *\"... a sum of m **(or fewer)** squares\"*. Thanks to ruben3 for asking about this in the comments.\\n\\nIn my above solutions, I first divide the given number by 4 as often as possible and then do the three-squares check. Dividing by 4 doesn't affect the other checks, and the n % 8 == 7 is cheaper than the prime factorization, so this saves time in cases where we do need four squares.\\n\\nArmed with just the knowledge that you never need more than four squares, it's also easy to write O(n) solutions, e.g.:\\n\\n    int numSquares(int n) {\\n        int ub = sqrt(n);\\n        for (int a=0; a<=ub; ++a) {\\n            for (int b=a; b<=ub; ++b) {\\n                int c = sqrt(n - a*a - b*b);\\n                if (a*a + b*b + c*c == n)\\n                    return !!a + !!b + !!c;\\n            }\\n        }\\n        return 4;\\n    }"
		},
		{
			"lc_ans_id":"71512",
			"view":"17348",
			"top":"4",
			"title":"Static DP, C++ 12 ms, Python 172 ms, Ruby 384 ms",
			"vote":"48",
			"content":"There are so **many** \"large\" test cases that it's worthwhile to keep data between test cases rather than recomputing from scratch all the time. At least in the slower languages. My `dp` tells the numbers of squares needed for the first integers, and when asked about a new `n`, I extend `dp` just as much as necessary.\\n\\n---\\n\\n**C++** ... 28 ms\\n\\n    int numSquares(int n) {\\n        static vector<int> dp {0};\\n        while (dp.size() <= n) {\\n            int m = dp.size(), squares = INT_MAX;\\n            for (int i=1; i*i<=m; ++i)\\n                squares = min(squares, dp[m-i*i] + 1);\\n            dp.push_back(squares);\\n        }\\n        return dp[n];\\n    }\\n\\n**C++** ... 12 ms\\n\\nSwitching the loops makes it less nice but faster:\\n\\n    int numSquares(int n) {\\n        static vector<int> dp {0};\\n        int m = dp.size();\\n        dp.resize(max(m, n+1), INT_MAX);\\n        for (int i=1, i2; (i2 = i*i)<=n; ++i)\\n            for (int j=max(m, i2); j<=n; ++j)\\n                if (dp[j] > dp[j-i2] + 1)\\n                    dp[j] = dp[j-i2] + 1;\\n        return dp[n];\\n    }\\n\\n---\\n\\n**Python** ... 172 ms\\n\\n    class Solution(object):\\n        _dp = [0]\\n        def numSquares(self, n):\\n            dp = self._dp\\n            while len(dp) <= n:\\n                dp += min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1,\\n            return dp[n]\\n\\n---\\n\\n**Ruby** ... 384 ms\\n\\n    $dp = [0]\\n    def num_squares(n)\\n      $dp << (1..$dp.size**0.5).map { |i| $dp[-i*i] }.min + 1 until $dp[n]\\n      $dp[n]\\n    end\\n\\nThere's probably a cleaner way than using a global variable, but I'm new to Ruby and don't know one."
		},
		{
			"lc_ans_id":"71505",
			"view":"6577",
			"top":"5",
			"title":"Simple Java DP Solution",
			"vote":"40",
			"content":"Just regular DP. Time Complexity: n * sqrt(n)   Space: O(n)\\n\\n    public class Solution {\\n        public int numSquares(int n) {\\n           int[] dp = new int[n + 1];\\n           Arrays.fill(dp, Integer.MAX_VALUE);\\n           dp[0] = 0;\\n           for(int i = 0; i <= n; i++){\\n               for(int j = 1; i + j * j <= n; j++){\\n                   dp[i  + j * j] = Math.min(dp[i + j * j], dp[i] + 1);\\n                }\\n           }\\n           return dp[n];\\n        }\\n    }"
		},
		{
			"lc_ans_id":"71618",
			"view":"7382",
			"top":"6",
			"title":"4ms C++ code - Solve it mathematically",
			"vote":"37",
			"content":"    class Solution {  \\n    public:  \\n        int is_square(int n){  \\n            int temp = (int) sqrt(n);  \\n            return temp * temp == n;  \\n        }  \\n        int numSquares(int n) {  \\n            while ((n & 3) == 0) //n%4 == 0  \\n                n >>= 2;  \\n            if ((n & 7) == 7) return 4; //n % 8 == 7  \\n            if(is_square(n)) return 1;  \\n            int sqrt_n = (int) sqrt(n);  \\n            for(int i = 1; i<= sqrt_n; i++){  \\n                if (is_square(n-i*i)) return 2;  \\n            }  \\n            return 3;  \\n        }  \\n    };  \\n\\nUPDATE: in order to understand, I suggest u read:\\n\\nhere is the Lagrange's Four Square theorem - Limit the result to <= 4:\\n[https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem)\\n\\nAnd this article, in which you can also find the way to present a number as a sum of four squares:\\n[http://www.alpertron.com.ar/4SQUARES.HTM](http://www.alpertron.com.ar/4SQUARES.HTM)"
		},
		{
			"lc_ans_id":"71605",
			"view":"3130",
			"top":"7",
			"title":"Java DP Solution with explanation",
			"vote":"31",
			"content":"    public class Solution {\\n    public int numSquares(int n) {\\n        int[] dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int sqrt = (int)Math.sqrt(i);\\n            \\n            // If the number is already a perfect square,\\n            // then dp[number] can be 1 directly. This is\\n            // just a optimization for this DP solution.\\n            if (sqrt * sqrt == i) {\\n                dp[i] = 1;\\n                continue;                \\n            }\\n            \\n            // To get the value of dp[n], we should choose the min\\n            // value from:\\n            //     dp[n - 1] + 1,\\n            //     dp[n - 4] + 1,\\n            //     dp[n - 9] + 1,\\n            //     dp[n - 16] + 1\\n            //     and so on...\\n            for (int j = 1; j <= sqrt; j++) {\\n                int dif = i - j * j;\\n                dp[i] = Math.min(dp[i], (dp[dif] + 1));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}"
		},
		{
			"lc_ans_id":"71632",
			"view":"2627",
			"top":"8",
			"title":"Beautiful 8 Lines Java Solution",
			"vote":"29",
			"content":"    public class Solution {\\n        public int numSquares(int n) {\\n            int[] record = new int[n+1];\\n            for(int i=0;i<=n;i++){\\n                record[i] = i;\\n                for(int j=1;j*j<=i;j++){\\n                    record[i] = Math.min(record[i-j*j]+1,record[i]);\\n                }\\n            }\\n            return record[n];\\n        }\\n    }"
		},
		{
			"lc_ans_id":"71532",
			"view":"6591",
			"top":"9",
			"title":"O(sqrt(n)), about 0.034 ms (and 0.018 ms)",
			"vote":"22",
			"content":"For better measurement, I wrapped the actual solution in a 10000-loop. This got accepted in 344 ms (every time in three submits), so without the wrapper it should take about 0.0344 ms. I tried a few variations and this is the fastest I managed to do.\\n\\n(**Update:** After qgambit2's challenge, I [optimized my my original approach](https://leetcode.com/discuss/57185/o-sqrt-n-about-0-03-ms?show=57682#c57682) and now that's my fastest, with about 180 ms.)\\n\\nFirst I use the fact that [four squares always suffice](https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem) and the fact that [four squares are only needed for numbers of the form 4<sup>a</sup>(8b+7)](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem). After that part, I know that the answer is 1, 2 or 3, and I try to build n as sum of one or two squares.\\n\\nFor that, I use a kind of two-pointers-approach. Instead of going through squares a<sup>2</sup> and checking whether n-a<sup>2</sup> is a square (which would involve computing lots of square roots), imagine you start with a=0<sup>2</sup> and b=floor(sqrt(n))<sup>2</sup> and as long as a<=b, either make `a` the next larger square or make `b` the next smaller square, depending on whether the sum of the two squares is too small or too large (or return 2, if it's exactly right).\\n\\nBut in order to improve speed further, I use that squares are sums of consecutive odd numbers starting at 1 (for example, 25=1+3+5+7+9), and my `a` and `b` aren't squares but the corresponding odd numbers. And instead of computing the sum of the two squares, I just add to or subtract from n, trying to reach zero. This way, my main part doesn't even have multiplications. Just simple addition/subtraction and comparisons.\\n\\nThe solution:\\n\\n    int numSquaresReal(int n) {\\n        while (n % 4 == 0)\\n            n /= 4;\\n        if (n % 8 == 7)\\n            return 4;\\n        int a = -1, b = sqrt(n);\\n        n -= b * b;\\n        b += b + 1;\\n        while (a <= b) {\\n            if (n < 0)\\n                n += b -= 2;\\n            else if (n > 0)\\n                n -= a += 2;\\n            else\\n                return a < 0 ? 1 : 2;\\n        }\\n        return 3;\\n    }\\n\\n    \\nThe wrapper for better time measurement:\\n\\n    int numSquares(int n) {\\n        int sum = 0;\\n        for (int i=0; i<10000; i++)\\n            sum += numSquaresReal(n);\\n        return sum / 10000;\\n    }"
		}
	],
	"id":"279",
	"title":"Perfect Squares",
	"content":"<p>\r\nGiven a positive integer <i>n</i>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <i>n</i>.\r\n</p>\r\n\r\n<p>\r\nFor example, given <i>n</i> = <code>12</code>, return <code>3</code> because <code>12 = 4 + 4 + 4</code>; given <i>n</i> = <code>13</code>, return <code>2</code> because <code>13 = 4 + 9</code>.\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/jianchao.li.fighter\">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>",
	"frequency":"474",
	"ac_num":"99441"
}