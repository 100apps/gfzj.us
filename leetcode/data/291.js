{
	"difficulty":"3",
	"submit_num":"52944",
	"show_id":"291",
	"leetcode_id":"291",
	"answers":[
		{
			"lc_ans_id":"73664",
			"view":"19030",
			"top":"0",
			"title":"Share my Java backtracking solution",
			"vote":"104",
			"content":"We can solve this problem using backtracking, we just have to keep trying to use a character in the pattern to match different length of substrings in the input string, keep trying till we go through the input string and the pattern.\\n\\nFor example, input string is `\"redblueredblue\"`, and the pattern is `\"abab\"`, first let's use `'a'` to match `\"r\"`, `'b'` to match `\"e\"`, then we find that `'a'` does not match `\"d\"`, so we do backtracking, use `'b'` to match `\"ed\"`, so on and so forth ...\\n\\nWhen we do the recursion, if the pattern character exists in the hash map already, we just have to see if we can use it to match the same length of the string. For example, let's say we have the following map:\\n\\n`'a': \"red\"`\\n\\n`'b': \"blue\"`\\n\\nnow when we see `'a'` again, we know that it should match `\"red\"`, the length is `3`, then let's see if `str[i ... i+3]` matches `'a'`, where `i` is the current index of the input string. Thanks to [StefanPochmann][1]'s suggestion, in Java we can elegantly use `str.startsWith(s, i)` to do the check.\\n\\nAlso thanks to [i-tikhonov][2]'s suggestion, we can use a hash set to avoid duplicate matches, if character `a` matches string `\"red\"`, then character `b` cannot be used to match `\"red\"`. In my opinion though, we can say apple (pattern `'a'`) is \"fruit\", orange (pattern `'o'`) is \"fruit\", so they can match the same string, anyhow, I guess it really depends on how the problem states.\\n\\nThe following code should pass OJ now, if we don't need to worry about the duplicate matches, just remove the code that associates with the hash set.\\n\\n    public class Solution {\\n      \\n      public boolean wordPatternMatch(String pattern, String str) {\\n        Map<Character, String> map = new HashMap<>();\\n        Set<String> set = new HashSet<>();\\n        \\n        return isMatch(str, 0, pattern, 0, map, set);\\n      }\\n      \\n      boolean isMatch(String str, int i, String pat, int j, Map<Character, String> map, Set<String> set) {\\n        // base case\\n        if (i == str.length() && j == pat.length()) return true;\\n        if (i == str.length() || j == pat.length()) return false;\\n        \\n        // get current pattern character\\n        char c = pat.charAt(j);\\n        \\n        // if the pattern character exists\\n        if (map.containsKey(c)) {\\n          String s = map.get(c);\\n          \\n          // then check if we can use it to match str[i...i+s.length()]\\n          if (!str.startsWith(s, i)) {\\n            return false;\\n          }\\n          \\n          // if it can match, great, continue to match the rest\\n          return isMatch(str, i + s.length(), pat, j + 1, map, set);\\n        }\\n        \\n        // pattern character does not exist in the map\\n        for (int k = i; k < str.length(); k++) {\\n          String p = str.substring(i, k + 1);\\n\\n          if (set.contains(p)) {\\n            continue;\\n          }\\n\\n          // create or update it\\n          map.put(c, p);\\n          set.add(p);\\n          \\n          // continue to match the rest\\n          if (isMatch(str, k + 1, pat, j + 1, map, set)) {\\n            return true;\\n          }\\n\\n          // backtracking\\n          map.remove(c);\\n          set.remove(p);\\n        }\\n        \\n        // we've tried our best but still no luck\\n        return false;\\n      }\\n      \\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/user/StefanPochmann\\n  [2]: https://leetcode.com/discuss/user/i-tikhonov"
		},
		{
			"lc_ans_id":"73681",
			"view":"7092",
			"top":"1",
			"title":"20 lines JAVA clean solution, easy to understand",
			"vote":"31",
			"content":"    public class Solution {\\n    Map<Character,String> map =new HashMap();\\n    Set<String> set =new HashSet();\\n    public boolean wordPatternMatch(String pattern, String str) {\\n        if(pattern.isEmpty()) return str.isEmpty();\\n        if(map.containsKey(pattern.charAt(0))){\\n            String value= map.get(pattern.charAt(0));\\n            if(str.length()<value.length() || !str.substring(0,value.length()).equals(value)) return false;\\n            if(wordPatternMatch(pattern.substring(1),str.substring(value.length()))) return true;\\n        }else{\\n            for(int i=1;i<=str.length();i++){\\n                if(set.contains(str.substring(0,i))) continue;\\n                map.put(pattern.charAt(0),str.substring(0,i));\\n                set.add(str.substring(0,i));\\n                if(wordPatternMatch(pattern.substring(1),str.substring(i))) return true;\\n                set.remove(str.substring(0,i));\\n                map.remove(pattern.charAt(0));\\n            }\\n        }\\n        return false;\\n    }\\n}"
		},
		{
			"lc_ans_id":"73675",
			"view":"4078",
			"top":"2",
			"title":"*Java* HashSet + backtracking (2ms beats 100%)",
			"vote":"28",
			"content":"The idea might not be so different, but I tried to optimize the solution as much as I could. In concrete:\\n\\n - Instead of using HashMap, I use a String array to store the character --> String mapping\\n - Instead of trying all combinations, I only try necessary/possible ones.\\n\\nI'd like to explain the second point a little bit more: Suppose we are successful in mapping the first `i` characters in `pattern`, and we are now at the `j` location of `str`. If `i+1`'s character in pattern is not already mapped, then we would want to try all possible substrings in `str`, that is, the substring could be of length 1 (`j`'s character), or length 2 (`j` and `j+1`), etc. Normally we would try up to the end of `str`, but this is really not necessary, because we have to spare enough space future characters in `pattern`. If this is not clear enough, let's take the following as an example:\\n\\n    pattern = \"abca\"\\n    str = \"xxxyyzzxxx\"\\n\\nSuppose we have successfully matched `a` to `xxx` and `b` to `yy`, and now we are at the third character of pattern, i.e., character `c`. We have not mapped `c` to anything, so we could try any of the following:\\n\\n    z\\n    zz\\n    zzx\\n    zzxx\\n    zzxxx\\n\\nBut do we really need to try them all? The answer is NO. Because we have already mapped `a` and `b`, and under this constraint, we have to save enough space for the fourth character of pattern, i.e., `a`. In other words, we can at most try `z` and `zz`, otherwise we are doomed to return false when we reach the fourth character `a`. This is what `endPoint` is about in the code.\\n\\nCode in Java:\\n\\n    public boolean wordPatternMatch(String pattern, String str) {\\n        String[] map = new String[26]; // mapping of characters 'a' - 'z'\\n        HashSet<String> set = new HashSet<>(); // mapped result of 'a' - 'z'\\n        return wordPatternMatch(pattern, str, map, set, 0, str.length()-1, 0, pattern.length()-1);\\n    }\\n    private boolean wordPatternMatch(String pattern, String str, String[] map, HashSet<String> set, int start, int end, int startP, int endP) {\\n    \\tif(startP==endP+1 && start==end+1) return true; // both pattern and str are exhausted\\n    \\tif((startP>endP && start<=end) || (startP<endP && start>end)) return false; // either of pattern or str is exhausted\\n\\n    \\tchar ch = pattern.charAt(startP);\\n    \\tString matched = map[ch-'a'];\\n    \\tif(matched!=null) { // ch is already mapped, then continue\\n    \\t\\tint count = matched.length();\\n    \\t\\treturn start+count<=end+1 && matched.equals(str.substring(start, start+count)) // substring equals previously mapped string\\n    \\t\\t\\t\\t&& wordPatternMatch(pattern, str, map, set, start+matched.length(), end, startP+1, endP); // moving forward\\n    \\t}\\n    \\telse {\\n    \\t    int endPoint = end;\\n    \\t    for(int i=endP; i>startP; i--) {\\n    \\t        endPoint -= map[pattern.charAt(i)-'a']==null ? 1 : map[pattern.charAt(i)-'a'].length();\\n    \\t    }\\n    \\t\\tfor(int i=start; i<=endPoint; i++) { // try every possible mapping, from 1 character to the end\\n    \\t\\t\\tmatched = str.substring(start, i+1);\\n    \\t\\t\\tif(set.contains(matched)) continue; // different pattern cannot map to same substring\\n\\n    \\t\\t\\tmap[ch-'a'] = matched; // move forward, add corresponding mapping and set content\\n    \\t\\t\\tset.add(matched);\\n\\n    \\t\\t\\tif(wordPatternMatch(pattern, str, map, set, i+1, end, startP+1, endP)) return true;\\n\\n    \\t\\t\\telse { // backtracking, remove corresponding mapping and set content\\n    \\t\\t\\t\\tmap[ch-'a'] = null;\\n    \\t\\t\\t\\tset.remove(matched);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn false; // exhausted\\n    }\\n\\nIf you are interested in my other posts, please feel free to check my Github page here: [https://github.com/F-L-A-G/Algorithms-in-Java][1]\\n\\n\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java"
		},
		{
			"lc_ans_id":"73669",
			"view":"3470",
			"top":"3",
			"title":"Python backtracking 48ms",
			"vote":"17",
			"content":"Use dictionary to store patterns, and backtrack when mismatch happens.\\n\\n    def wordPatternMatch(self, pattern, str):\\n        return self.dfs(pattern, str, {})\\n\\n    def dfs(self, pattern, str, dict):\\n        if len(pattern) == 0 and len(str) > 0:\\n            return False\\n        if len(pattern) == len(str) == 0:\\n            return True\\n        for end in range(1, len(str)-len(pattern)+2): # +2 because it is the \"end of an end\"\\n            if pattern[0] not in dict and str[:end] not in dict.values():\\n                dict[pattern[0]] = str[:end]\\n                if self.dfs(pattern[1:], str[end:], dict):\\n                    return True\\n                del dict[pattern[0]]\\n            elif pattern[0] in dict and dict[pattern[0]] == str[:end]:\\n                if self.dfs(pattern[1:], str[end:], dict):\\n                    return True\\n        return False"
		},
		{
			"lc_ans_id":"73722",
			"view":"651",
			"top":"4",
			"title":"My 0ms C++ solution with pruning",
			"vote":"7",
			"content":"The key is in lowerbound checking. lowerBound is the minimal length the str should be. It will increase every time we update the char to pattern map. \\n\\nThe place to check the lowerBound is also important. Here we check it every time it is increased. This allows us to break early from the pattern update loop, because we don't need to assign a longer pattern to this char if the lowerBound condition not met. \\n\\n    class Solution {\\n    private:\\n        array<int, 26> hist;        // number of each char in pattern, will be const after initialization\\n        array<string, 26> mp;       // char to pattern map\\n        unordered_set<string> used; // used pattern\\n        \\n        bool dfs(string &pattern, int pStep, string &str, int sStep, int lowerBound) {\\n            if(pStep == pattern.length() || sStep == str.length())\\n                return (pStep == pattern.length() && sStep == str.length());\\n    \\n            auto c = pattern[pStep];\\n            auto& s = mp[c - 'a'];\\n            \\n            // if the mapping exists, update char to string map and perform backtracking\\n            // else check if the mapping matches correctly\\n            if(s.empty()) {\\n                for(int len = 1; sStep + len <= str.length(); ++len) {\\n                    s += str[sStep + len - 1];\\n                    if(used.count(s)) continue;\\n                    \\n                    // 1. str's length should be at least lowerBound long\\n                    // 2. use len-1 here because we set the initial length to be 1\\n                    // 3. we do the lowerBound checking here because the len is increasing\\n                    //    no need to continue the loop if lowerBound test fails\\n                    auto newLowerBound = lowerBound + hist[c-'a'] * (len-1);\\n                    if(str.length() < newLowerBound) break;\\n                    \\n                    auto iter = used.insert(s).first;\\n                    if(dfs(pattern, pStep + 1, str, sStep + len, newLowerBound)) \\n                        return true;\\n                    used.erase(iter);\\n                }\\n                s.clear();\\n                return false;\\n            }\\n            else \\n                return str.substr(sStep, s.length()) == s \\n                    && dfs(pattern, pStep + 1, str, sStep + s.length(), lowerBound);\\n        }\\n    \\n    public:\\n        bool wordPatternMatch(string pattern, string str) {\\n            fill(hist.begin(), hist.end(), 0);\\n            for(auto c : pattern) \\n                ++hist[c - 'a'];\\n            return dfs(pattern, 0, str, 0, pattern.length());\\n        }\\n    };"
		},
		{
			"lc_ans_id":"73679",
			"view":"1322",
			"top":"5",
			"title":"Share my 32ms C++ DFS solution",
			"vote":"7",
			"content":"    class Solution {\\n    public:\\n    bool wordPatternMatch(string pattern, string str) {\\n        return dfs(pattern,0,str,0);\\n    }    \\n    bool dfs(string &pattern, int pp, string &str, int ps){\\n        if(pp==pattern.length()&&ps==str.length())\\n            return true;\\n        if((pattern.length()-pp>str.length()-ps)||pp==pattern.length())\\n            return false;\\n        if(pat2str.find(pattern[pp])==pat2str.end()){\\n            for(int i=1;ps+i<=str.length();i++){\\n                string tempstr=str.substr(ps,i);\\n                if(str2pat.find(tempstr)!=str2pat.end())\\n                    continue;\\n                pat2str[pattern[pp]]=str.substr(ps,i);\\n                str2pat[tempstr]=pattern[pp];\\n                if(dfs(pattern,pp+1,str,ps+i))\\n                    return true;\\n                str2pat.erase(tempstr);\\n            }\\n            pat2str.erase(pattern[pp]);\\n            return false;\\n        }\\n        else{\\n            string temp=pat2str[pattern[pp]];\\n            if(temp==str.substr(ps,temp.length()))\\n                return dfs(pattern,pp+1,str,ps+temp.length());\\n            else\\n                return false;\\n        }\\n    }\\n    private:\\n    unordered_map<char,string> pat2str;\\n    unordered_map<string,char> str2pat;\\n    };"
		},
		{
			"lc_ans_id":"73666",
			"view":"3110",
			"top":"6",
			"title":"Share my C++ backtracking solution",
			"vote":"7",
			"content":"    class Solution {\\n    public:\\n        unordered_map<char, string> pDict;\\n        unordered_map<string, char> sDict;\\n        bool wordPatternMatch(string pattern, string str) {\\n            return match(pattern, 0, str, 0);\\n        }\\n        \\n        bool match(string &pattern, int i, string &str, int j) {\\n            int m = pattern.size();\\n            int n = str.size();\\n            if (i == m || j == n) {\\n                if (i == m && j == n)\\n                    return true;\\n                return false;\\n            }\\n            bool ins = false;\\n            for (int k = j; k < n; k++) {\\n                string s = str.substr(j, k - j + 1);\\n                if (pDict.find(pattern[i]) != pDict.end()) {\\n                    if (pDict[pattern[i]] != s)\\n                        continue;\\n                } else if (sDict.find(s) != sDict.end()) {\\n                    if (sDict[s] != pattern[i])\\n                        continue;\\n                } else {\\n                    pDict[pattern[i]] = s;\\n                    sDict[s] = pattern[i];\\n                    ins = true;\\n                }\\n                if (match(pattern, i + 1, str, k + 1))\\n                    return true;\\n                if (ins) {\\n                    pDict.erase(pattern[i]);\\n                    sDict.erase(s);\\n                }\\n            }\\n            return false;\\n        }\\n    };\\n\\nC++ backtracking. ins indicates whether current round has inserted new mapping pair.\\nedited with two maps to ensure on-to-one mapping.\\n."
		},
		{
			"lc_ans_id":"73694",
			"view":"566",
			"top":"7",
			"title":"My short AC solution with backtracking",
			"vote":"4",
			"content":"```\\npublic class Solution {\\n    Map<Character, String> map = new HashMap<Character, String>(); //keep map of pattern and word\\n    Set<String> words = new HashSet<String>(); //keep list of word visited\\n    public boolean wordPatternMatch(String pattern, String str) {\\n  \\n        if(pattern.length()==0&&str.length()==0)  //if pattern and str both are empty, pattern matches str\\n        {\\n            return true;\\n        }\\n        \\n        //if both pattern and str are not empty, continue matching.\\n        if(pattern.length()>0&&str.length()>0){\\n            char c = pattern.charAt(0);\\n            if(map.get(c)!=null){  //if this char has a str matching\\n                if(str.startsWith(map.get(c))){  //continue with sub problem\\n                    return wordPatternMatch(pattern.substring(1),str.substring(map.get(c).length()));\\n                }\\n            } else {\\n                for(int i=1;i<=str.length();i++){  //this char can match any substring from 0 to 1 to 0 to end\\n                    String newword=str.substring(0,i);\\n                    if(words.contains(newword)){  //this the new word already been visited, skip\\n                        continue;\\n                    }\\n                    map.put(c,newword);\\n                    words.add(newword);\\n                    boolean r = wordPatternMatch(pattern.substring(1),str.substring(map.get(c).length()));\\n                    if(r) return true; //if this new mapping works, return true, otherwise continue mataching\\n                    map.remove(c);\\n                    words.remove(newword);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"73691",
			"view":"424",
			"top":"8",
			"title":"Java solution based on Word Pattern I",
			"vote":"3",
			"content":"This method is based on the solution of Word Pattern I\\nHere is the solution of Word Pattern I, one to one mapping check each character of pattern with each item of string\\n```\\npublic boolean wordPattern(String pattern, String str) {\\n        String[] array = str.split(\" \");\\n        if(pattern.length() != array.length) return false;\\n        Map map = new HashMap();\\n        for(Integer i = 0; i < array.length; ++i) {\\n            if(map.put(pattern.charAt(i), i) != map.put(array[i], i)) return false;\\n        }\\n        return true;\\n    }\\n```\\nBased on the first solution, we can use the same way to check if it is a valid result. Remember to set the mapping value back when current case is not working.\\n```\\npublic boolean wordPatternMatch(String pattern, String str) {\\n        if(pattern.length()==0 && str.length()==0) return true;\\n        if(pattern.length()==0) return false;\\n        HashMap map = new HashMap();\\n        return helper(pattern, str, 0, 0, map);\\n    }\\n    \\n    public boolean helper(String pattern, String str, Integer i, int j, HashMap map) {\\n        if(i==pattern.length() && j==str.length()) return true;\\n        if(i>=pattern.length() || j>=str.length()) return false;\\n        for(int k = j+1; k <= str.length(); ++k) {\\n            String temp = str.substring(j, k);\\n            char c = pattern.charAt(i);\\n            Object a = map.put(c, i);\\n            Object b = map.put(temp, i);\\n            if(a == b) {\\n                if(helper(pattern, str, i+1, k, map)) return true;\\n            }\\n            map.put(c, a);\\n            map.put(temp, b);\\n        }\\n        return false;\\n    }\\n```"
		},
		{
			"lc_ans_id":"73688",
			"view":"293",
			"top":"9",
			"title":"Python solution with detailed explanations",
			"vote":"2",
			"content":"**Solution**\\n\\n**Word Pattern II** https://leetcode.com/problems/word-pattern-ii/\\n\\n**Backtracking solution**\\n* We divide the sub-problem as self.helper(pattern, str, i, j) to answer if str[j:] follows the same pattern[i:].\\n* You need to be careful in the backtracking part where you delete ptable and stable. There are two conditions when you proceed with the recursion: when both ptable and stable have the right mapping and when both are empty. In the latter instance, you add the mapping, therefore,  you delete only when under those circumstances. Otherwise you can end up with an error.\\n```\\nclass Solution(object):\\n    def helper(self, pattern, str, i, j, ptable, stable):\\n        if i == len(pattern) and j == len(str):\\n            return True\\n        elif i == len(pattern) or j == len(str):\\n            return False\\n        else:\\n            p, added = pattern[i], False\\n            for k in range(j, len(str)):\\n                word = str[j:k+1]\\n                # Test is using the word violates the rules learned thus far!\\n                if (p in ptable and ptable[p] != word) or (word in stable and stable[word] != p):\\n                    continue\\n                # Either the rules are already learned or they need to be added.\\n                # added variable ensures we only remove from dictionary when we had previously added.\\n                if p not in ptable and word not in stable:\\n                    ptable[p], stable[word], added = word, p, True\\n                remainder = self.helper(pattern, str, i+1, k+1, ptable, stable)\\n                if added:\\n                    del ptable[p]\\n                    del stable[word]\\n                if remainder:\\n                    return True\\n        return False\\n    \\n    def wordPatternMatch(self, pattern, str):\\n        \"\"\"\\n        :type pattern: str\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        return self.helper(pattern, str, 0, 0, {}, {})\\n```\\n\\n**Backtracking without reusing tables**\\n* Very similar to the above solution except that we create new ptable and stable for every recursive call.\\n```\\nclass Solution(object):\\n    def helper(self, pattern, str, i, j, ptable, stable):\\n        if i == len(pattern) and j == len(str):\\n            return True\\n        elif i == len(pattern) or j == len(str):\\n            return False\\n        else:\\n            p = pattern[i]\\n            for k in range(j, len(str)):\\n                word = str[j:k+1]\\n                if (p in ptable and ptable[p] != word) or (word in stable and stable[word] != p):\\n                    continue\\n                n_ptable, n_stable = {k1:v1 for k1,v1 in ptable.items()}, {k1:v1 for k1,v1 in stable.items()}\\n                n_ptable[p], n_stable[word] = word, p\\n                remainder = self.helper(pattern, str, i+1, k+1, n_ptable, n_stable)\\n                if remainder:\\n                    return True\\n        return False\\n    \\n    def wordPatternMatch(self, pattern, str):\\n        \"\"\"\\n        :type pattern: str\\n        :type str: str\\n        :rtype: bool\\n        \"\"\"\\n        return self.helper(pattern, str, 0, 0, {}, {})\\n```"
		}
	],
	"id":"291",
	"title":"Word Pattern II",
	"content":"<p>Given a <code>pattern</code> and a string <code>str</code>, find if <code>str</code> follows the same pattern.</p>\r\n<p> Here <b>follow</b> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <b>non-empty</b> substring in <code>str</code>.</p>\r\n<p>\r\n<b>Examples:</b><br>\r\n<ol>\r\n<li>pattern = <code>\"abab\"</code>, str = <code>\"redblueredblue\"</code> should return true.</li>\r\n<li>pattern = <code>\"aaaa\"</code>, str = <code>\"asdasdasdasd\"</code> should return true.</li>\r\n<li>pattern = <code>\"aabb\"</code>, str = <code>\"xyzabcxzyabc\"</code> should return false.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\n<b>Notes:</b><br>\r\nYou may assume both <code>pattern</code> and <code>str</code> contains only lowercase letters.\r\n</p>",
	"frequency":"248",
	"ac_num":"20308"
}