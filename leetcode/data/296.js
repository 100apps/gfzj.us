{
	"difficulty":"3",
	"submit_num":"29993",
	"show_id":"296",
	"leetcode_id":"296",
	"answers":[
		{
			"lc_ans_id":"74186",
			"view":"14695",
			"top":"0",
			"title":"14ms java solution",
			"vote":"86",
			"content":"    public int minTotalDistance(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        List<Integer> I = new ArrayList<>(m);\\n        List<Integer> J = new ArrayList<>(n);\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){\\n                    I.add(i);\\n                    J.add(j);\\n                }\\n            }\\n        }\\n        \\n        return getMin(I) + getMin(J);\\n    }\\n    \\n    private int getMin(List<Integer> list){\\n        int ret = 0;\\n        \\n        Collections.sort(list);\\n        \\n        int i = 0;\\n        int j = list.size() - 1;\\n        while(i < j){\\n            ret += list.get(j--) - list.get(i++);\\n        }\\n        \\n        return ret;\\n    }"
		},
		{
			"lc_ans_id":"74189",
			"view":"6783",
			"top":"1",
			"title":"Am I the only person who don't know why median could give shortest distance?",
			"vote":"48",
			"content":"When I first saw this question, intuitively I know shortest meeting point should be found in two separate dimension, however, even if on 1-D, how could I find the shortest meeting point? Then I clicked discuss and found out everybody's solution was using median to get shortest meeting point? WHY?\\n\\nActually, there is a famous conclusion in statistics that [the median minimizes the sum of absolute deviations][1].\\n\\n\\n  [1]: http://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations"
		},
		{
			"lc_ans_id":"74188",
			"view":"8541",
			"top":"2",
			"title":"O(mn) Java, 2ms",
			"vote":"40",
			"content":"As long as you have different numbers of people on your left and on your right, moving a little to the side with more people decreases the sum of distances. So to minimize it, you must have equally many people on your left and on your right. Same with above/below.\\n\\n---\\n\\nTwo O(mn) solutions, both take 2ms.\\n\\nThe neat `total += Z[hi--] - Z[lo++]`-style summing is from [larrywang2014's solution](https://leetcode.com/discuss/65336/14ms-java-solution).  \\nOriginally I used `total += abs(Z[i] - median)`-style.\\n\\n---\\n\\n**Solution 1**\\n\\nNo need to sort the coordinates if we **collect** them in sorted order.\\n\\n    public int minTotalDistance(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int total = 0, Z[] = new int[m*n];\\n        for (int dim=0; dim<2; ++dim) {\\n            int i = 0, j = 0;\\n            if (dim == 0) {\\n                for (int x=0; x<n; ++x)\\n                    for (int y=0; y<m; ++y)\\n                        if (grid[y][x] == 1)\\n                            Z[j++] = x;\\n            } else {\\n                for (int y=0; y<m; ++y)\\n                    for (int g : grid[y])\\n                        if (g == 1)\\n                            Z[j++] = y;\\n            }\\n            while (i < --j)\\n                total += Z[j] - Z[i++];\\n        }\\n        return total;\\n    }\\n\\n---\\n\\n**Solution 2**\\n\\nBucketSort-ish. Count how many people live in each row and each column. Only O(m+n) space.\\n\\n    public int minTotalDistance(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[] I = new int[m], J = new int[n];\\n        for (int i=0; i<m; ++i)\\n            for (int j=0; j<n; ++j)\\n                if (grid[i][j] == 1) {\\n                    ++I[i];\\n                    ++J[j];\\n                }\\n        int total = 0;\\n        for (int[] K : new int[][]{ I, J }) {\\n            int i = 0, j = K.length - 1;\\n            while (i < j) {\\n                int k = Math.min(K[i], K[j]);\\n                total += k * (j - i);\\n                if ((K[i] -= k) == 0) ++i;\\n                if ((K[j] -= k) == 0) --j;\\n            }\\n        }\\n        return total;\\n    }\\n\\nNot sure Larry's way is actually better here. I'll have to try the other style as well..."
		},
		{
			"lc_ans_id":"74193",
			"view":"3431",
			"top":"3",
			"title":"Java 2ms/Python 40ms two pointers solution no median no sort with explanation",
			"vote":"37",
			"content":"Before solving the 2D problem we first consider a 1D case. The solution is quite simple. Just find the median of all the `x` coordinates and calculate the distance to the median.\\n\\nAlternatively, we can also use two pointers to solve the 1D problem. `left` and `right` are how many people one left/right side of coordinates `i`/`j`. If we have more people on the left we let `j` decrease otherwise increase `i`. The time complexity is `O(n)` and space is `O(1)`.\\n\\nTo be more clear, a better view is we can think `i` and `j` as two meet points. All the people in `[0, i]` go to meet at `i` and all the people in `[j, n - 1]` meet at `j`. We let `left = sum(vec[:i+1])`, `right = sum(vec[j:])`, which are the number of people at each meet point, and `d` is the total distance for the `left` people meet at `i` and `right` people meet at `j`.\\n\\nOur job is to let `i == j` with minimum `d`.\\n\\nIf we increase `i` by 1, the distance will increase by `left` since there are 'left' people at `i` and they just move 1 step. The same applies to `j`, when decrease `j` by 1, the distance will increase by `right`. To make sure the total distance `d` is minimized we certainly want to move the point with less people. And to make sure we do not skip any possible meet point options we need to move one by one.\\n\\nFor the 2D cases we first need to sum the columns and rows into two vectors and call the 1D algorithm.\\nThe answer is the sum of the two. The time is then `O(mn)` and extra space is `O(m+n)`\\n\\nMoreover, the solution is still `O(mn)` with the follow up:\\n\\n> What if there are people sharing same home? \\n> In other words the number in the grid can be more than 1.\\n\\n**Java**\\n\\n    public class Solution {\\n        public int minTotalDistance(int[][] grid) {\\n            int m = grid.length, n = grid[0].length;\\n            int[] row_sum = new int[n], col_sum = new int[m];\\n    \\n            for (int i = 0; i < m; ++i)\\n                for (int j = 0; j < n; ++j) {\\n                    row_sum[j] += grid[i][j];\\n                    col_sum[i] += grid[i][j];\\n                }\\n\\n            return minDistance1D(row_sum) + minDistance1D(col_sum);\\n        }\\n\\n        public int minDistance1D(int[] vector) {\\n            int i = -1, j = vector.length;\\n            int d = 0, left = 0, right = 0;\\n    \\n            while (i != j) {\\n                if (left < right) {\\n                    d += left;\\n                    left += vector[++i];\\n                }\\n                else {\\n                    d += right;\\n                    right += vector[--j];\\n                }\\n            }\\n            return d;\\n        }\\n\\n    }\\n    // Runtime: 2ms\\n\\n**Python**\\n\\n    def minTotalDistance(self, grid):\\n        row_sum = map(sum, grid)\\n        col_sum = map(sum, zip(*grid)) # syntax sugar learned from stefan :-)\\n\\n        def minTotalDistance1D(vec):\\n            i, j = -1, len(vec)\\n            d = left = right = 0\\n            while i != j:\\n                if left < right:\\n                    d += left\\n                    i += 1\\n                    left += vec[i]\\n                else:\\n                    d += right\\n                    j -= 1\\n                    right += vec[j]\\n            return d\\n\\n        return minTotalDistance1D(row_sum) + minTotalDistance1D(col_sum)\\n\\n\\n    # 57 / 57 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 40 ms"
		},
		{
			"lc_ans_id":"74217",
			"view":"1546",
			"top":"4",
			"title":"The theory behind (why the median works)",
			"vote":"14",
			"content":"I found a lot of questions about why the median could minimize the total manhattan distance. Here comes the explanation. The explanation in [the median minimizes the sum of absolute deviations][1] is not solid either.\\n\\n **1. Let's start from the 1-dimension case** \\n\\nSuppose we have n people living on a straight street and they want to find somewhere to meet. The total distance is \\n\\n![enter image description here][2]\\n\\nwhere ![enter image description here][3] is the location of each house and ![enter image description here][4]\\nis the meeting point. To minimize this problem, take the derivative of this equation. Each term will give you \\n\\n - 1, if ![enter image description here][5]\\n - -1, if ![enter image description here][6]\\n\\nTo reach the minimum, the derivative must be 0. To make the derivative 0, the number of 1s and -1s must equal. \\n\\n - If n is even, then m must be located between the middle two locations (Any locations between them will give you the minimum, **not necessarily** the median). \\n - If n is odd, then m must be located on the middle one house. That's the median.\\n\\n**2. Then we can discuss the 2-dimension case**\\n\\nLet's write down the equation directly.\\n\\n![enter image description here][7]\\n\\nSo this time, we have two variables - m and n. Recall what you've learned in multiple variables calculus. To find the minimum, we need to take the partial derivatives for the equation. And each partial derivative (or we can say, each dimension) will give you the same result as the 1-D case.\\n\\n**3. So we can even solve the problem in any dimension**\\n\\nBecause every dimension is independent to each other. Do every dimension as 1-D case.\\n\\n\\n  [1]: http://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations\\n  [2]: https://latex.codecogs.com/gif.latex?%5Csum_i%7B%7Cx_i-m%7C%7D\\n  [3]: https://latex.codecogs.com/gif.latex?x_i\\n  [4]: https://latex.codecogs.com/gif.latex?m\\n  [5]: https://latex.codecogs.com/gif.latex?m%20%3E%20x_i\\n  [6]: https://latex.codecogs.com/gif.latex?m%20%3C%20x_i\\n  [7]: https://latex.codecogs.com/gif.latex?%5Csum_i%20%7Cx_i-m%7C+%7Cy_i-n%7C"
		},
		{
			"lc_ans_id":"74198",
			"view":"1258",
			"top":"5",
			"title":"12 ms, c++ simple solution, easy understanding",
			"vote":"9",
			"content":"    int minTotalDistance(vector<vector<int>>& grid) {\\n        const int row = grid.size();\\n        if (0 == row) return 0;\\n        const int col = grid[0].size();\\n        int total = 0;\\n        vector<int> posR, posC;\\n        for (int i = 0; i < row; ++i) \\n         for (int j = 0; j < col; ++j) {\\n             if (grid[i][j] == 1) {\\n                 posR.emplace_back(i);\\n                 posC.emplace_back(j);\\n             }\\n         }\\n        int med1 = posR[posR.size() / 2];\\n        nth_element(posC.begin(), posC.begin() +  posC.size() / 2, posC.end());\\n        int med2 = posC[posC.size() / 2];\\n        for (auto pos1 : posR) total += abs(pos1 - med1);\\n        for (auto pos2 : posC) total += abs(pos2 - med2);\\n        return total;\\n    }"
		},
		{
			"lc_ans_id":"74232",
			"view":"1024",
			"top":"6",
			"title":"3-8 lines O(mn) Python",
			"vote":"9",
			"content":"**Solution 1**\\n\\nCollect everybody's x-coordinate in order, then sum the distances to the median. Do it for the original grid and for the diagonally flipped one.\\n\\n    def minTotalDistance(self, grid):\\n        total = 0\\n        for grid in grid, zip(*grid):\\n            X = []\\n            for x, row in enumerate(grid):\\n                X += [x] * sum(row)\\n            total += sum(abs(x - X[len(X)/2])\\n                         for x in X)\\n        return total\\n\\n**Solution 2**\\n\\nSame thing, just written with generator expressions and a list comprehension.\\n\\n    def minTotalDistance(self, grid):\\n        return sum(sum(abs(x - X[len(X)/2]) for x in X) for X in\\n                   ([x for x, row in enumerate(grid) for _ in range(sum(row))]\\n                    for grid in (grid, zip(*grid))))"
		},
		{
			"lc_ans_id":"74233",
			"view":"1019",
			"top":"7",
			"title":"Share my Java solution using quick select",
			"vote":"5",
			"content":"Normally we can sort the `x[]` and `y[]` and then either find the median point or calculate the total distance, sorting will take `O(nlog(n))` time, I think we can do it a little bit better.\\n\\nLet's say we have a `x[]: {2, 5, 1, 3, 4, 7, 6}`, to find the median `4`, we can use **Quick Select** algorithm, according to [Wikipedia][1], the average time complexity is `O(n)`. Once we find the median, we can calculate the Manhattan distance in `O(n)` time.\\n\\nNote: in quick sort, the performance is dependent on the pivot selection algorithm, to make the code run faster, normally we can randomly pick a pivot, otherwise, it can be slow. That's why I import the Random class.\\n\\n    import java.util.Random;\\n    \\n    public class Solution {\\n      public int minTotalDistance(int[][] grid) {\\n          List<Integer> x = new ArrayList<>();\\n          List<Integer> y = new ArrayList<>();\\n          \\n          for (int i = 0; i < grid.length; i++) {\\n              for (int j = 0; j < grid[0].length; j++) {\\n                  if (grid[i][j] == 1) {\\n                      x.add(i); y.add(j);\\n                  }\\n              }\\n          }\\n          \\n          // get median of x[] and y[] using quick select\\n          int mx = x.get(quickSelect(x, 0, x.size() - 1, x.size() / 2 + 1));\\n          int my = y.get(quickSelect(y, 0, y.size() - 1, y.size() / 2 + 1));\\n          \\n          // calculate the total Manhattan distance\\n          int total = 0;\\n          for (int i = 0; i < x.size(); i++) {\\n            total += Math.abs(x.get(i) - mx) + Math.abs(y.get(i) - my);\\n          }\\n          return total;\\n        }\\n        \\n        // return the index of the kth smallest number\\n        // avg. O(n) time complexity\\n        int quickSelect(List<Integer> a, int lo, int hi, int k) {\\n          // use quick sort's idea\\n          // randomly pick a pivot and put it to a[hi]\\n          // we need to do this, otherwise quick sort is slow!\\n          Random rand = new Random();\\n          int p = lo + rand.nextInt(hi - lo + 1);\\n          Collections.swap(a, p, hi);\\n          \\n          // put nums that are <= pivot to the left\\n          // put nums that are  > pivot to the right\\n          int i = lo, j = hi, pivot = a.get(hi);\\n          while (i < j) {\\n            if (a.get(i++) > pivot) Collections.swap(a, --i, --j);\\n          }\\n          Collections.swap(a, i, hi);\\n          \\n          // count the nums that are <= pivot from lo\\n          int m = i - lo + 1;\\n          \\n          // pivot is the one!\\n          if (m == k)     return i;\\n          // pivot is too big, so it must be on the left\\n          else if (m > k) return quickSelect(a, lo, i - 1, k);\\n          // pivot is too small, so it must be on the right\\n          else            return quickSelect(a, i + 1, hi, k - m);\\n        }\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Quickselect"
		},
		{
			"lc_ans_id":"74218",
			"view":"846",
			"top":"8",
			"title":"16ms, easy understandable, C++ solution",
			"vote":"4",
			"content":"It's my first time sharing a solution here. Quite nervous... \\n\\n    int minTotalDistance(vector<vector<int>>& grid) {\\n            if(grid.empty()) return 0;\\n            \\n            int NumOfRow = grid.size();\\n            int NumOfCol = grid[0].size();\\n            vector<int> rows;\\n            vector<int> cols;\\n            \\n            for(int indexOfRow = 0; indexOfRow < NumOfRow; indexOfRow++){\\n                for(int indexOfCol = 0; indexOfCol < NumOfCol; indexOfCol++){\\n                    if(grid[indexOfRow][indexOfCol]){\\n                        rows.push_back(indexOfRow);\\n                        cols.push_back(indexOfCol);\\n                    }\\n                }\\n            }\\n            \\n            // sort(rows.begin(), rows.end()); as this's already sorted \\n            sort(cols.begin(), cols.end());\\n            \\n            int idealRow = rows[rows.size() / 2];\\n            int idealCol = cols[cols.size() / 2];\\n            \\n            int result = 0;\\n            \\n            for(auto row: rows)\\n                result += abs(row - idealRow);\\n            for(auto col: cols)\\n                result += abs(col - idealCol);\\n    \\n            return result;\\n        }"
		},
		{
			"lc_ans_id":"74238",
			"view":"561",
			"top":"9",
			"title":"Java Best Meeting Point Solution",
			"vote":"4",
			"content":"/*\\n   while this is more like a math problem, not that hard.\\n*/\\n\\n\\npublic class Solution {\\n\\n    public int minTotalDistance(int[][] grid) {\\n\\n        if(grid == null || grid.length == 0){\\n            return 0;\\n        }\\n        \\n        //int minX = Integer.MAX_VALUE;\\n        //int maxX = Integer.MIN_VALUE;\\n        //int minY = Integer.MAX_VALUE;\\n        //int maxY = Integer.MIN_VALUE;\\n        List<Integer> listX = new ArrayList<Integer>();\\n        List<Integer> listY = new ArrayList<Integer>();\\n        \\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    listX.add(i);\\n                    listY.add(j);\\n                   // minX = Math.min(minX, i);\\n                   // maxX = Math.max(maxX, i);\\n                   // minY = Math.min(minY, j);\\n                   // maxY = Math.max(maxY, j);\\n                }\\n            }\\n        }\\n        int ret = 0;\\n        Collections.sort(listX);\\n        Collections.sort(listY);\\n        int pivotX = listX.get(listX.size() / 2);\\n        int pivotY = listY.get(listY.size() / 2);\\n        for(Integer x : listX){\\n            ret = ret + Math.abs(x - pivotX);\\n        }\\n        for(Integer y : listY){\\n            ret = ret + Math.abs(y - pivotY);\\n        }\\n        \\n        return ret;\\n    }\\n}"
		}
	],
	"id":"296",
	"title":"Best Meeting Point",
	"content":"<p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using <a href=\"http://en.wikipedia.org/wiki/Taxicab_geometry\" target=\"_blank\">Manhattan Distance</a>, where distance(p1, p2) = <code>|p2.x - p1.x| + |p2.y - p1.y|</code>.</p>\r\n\r\n<p>For example, given three people living at <code>(0,0)</code>, <code>(0,4)</code>, and <code>(2,2)</code>:</p>\r\n\r\n<pre>1 - 0 - 0 - 0 - 1\r\n|   |   |   |   |\r\n0 - 0 - 0 - 0 - 0\r\n|   |   |   |   |\r\n0 - 0 - 1 - 0 - 0</pre>\r\n\r\n<p>The point <code>(0,2)</code> is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.</p>",
	"frequency":"357",
	"ac_num":"15659"
}