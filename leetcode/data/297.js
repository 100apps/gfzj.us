{
	"difficulty":"3",
	"submit_num":"266026",
	"show_id":"297",
	"leetcode_id":"297",
	"answers":[
		{
			"lc_ans_id":"74253",
			"view":"53345",
			"top":"0",
			"title":"Easy to understand Java Solution",
			"vote":"199",
			"content":"The idea is simple: print the tree in pre-order traversal and use \"X\" to denote null node and split node with \",\". We can use a StringBuilder for building the string on the fly. For deserializing, we use a Queue to store the pre-order traversal and since we have \"X\" as null node, we know exactly how to where to end building subtress.\\n\\n    public class Codec {\\n        private static final String spliter = \",\";\\n        private static final String NN = \"X\";\\n    \\n        // Encodes a tree to a single string.\\n        public String serialize(TreeNode root) {\\n            StringBuilder sb = new StringBuilder();\\n            buildString(root, sb);\\n            return sb.toString();\\n        }\\n    \\n        private void buildString(TreeNode node, StringBuilder sb) {\\n            if (node == null) {\\n                sb.append(NN).append(spliter);\\n            } else {\\n                sb.append(node.val).append(spliter);\\n                buildString(node.left, sb);\\n                buildString(node.right,sb);\\n            }\\n        }\\n        // Decodes your encoded data to tree.\\n        public TreeNode deserialize(String data) {\\n            Deque<String> nodes = new LinkedList<>();\\n            nodes.addAll(Arrays.asList(data.split(spliter)));\\n            return buildTree(nodes);\\n        }\\n        \\n        private TreeNode buildTree(Deque<String> nodes) {\\n            String val = nodes.remove();\\n            if (val.equals(NN)) return null;\\n            else {\\n                TreeNode node = new TreeNode(Integer.valueOf(val));\\n                node.left = buildTree(nodes);\\n                node.right = buildTree(nodes);\\n                return node;\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"74259",
			"view":"27847",
			"top":"1",
			"title":"Recursive preorder, Python and C++, O(n)",
			"vote":"137",
			"content":"**Python**\\n\\n    class Codec:\\n    \\n        def serialize(self, root):\\n            def doit(node):\\n                if node:\\n                    vals.append(str(node.val))\\n                    doit(node.left)\\n                    doit(node.right)\\n                else:\\n                    vals.append('#')\\n            vals = []\\n            doit(root)\\n            return ' '.join(vals)\\n    \\n        def deserialize(self, data):\\n            def doit():\\n                val = next(vals)\\n                if val == '#':\\n                    return None\\n                node = TreeNode(int(val))\\n                node.left = doit()\\n                node.right = doit()\\n                return node\\n            vals = iter(data.split())\\n            return doit()\\n\\n---\\n\\n**C++**\\n\\n    class Codec {\\n    public:\\n    \\n        string serialize(TreeNode* root) {\\n            ostringstream out;\\n            serialize(root, out);\\n            return out.str();\\n        }\\n    \\n        TreeNode* deserialize(string data) {\\n            istringstream in(data);\\n            return deserialize(in);\\n        }\\n    \\n    private:\\n    \\n        void serialize(TreeNode* root, ostringstream& out) {\\n            if (root) {\\n                out << root->val << ' ';\\n                serialize(root->left, out);\\n                serialize(root->right, out);\\n            } else {\\n                out << \"# \";\\n            }\\n        }\\n    \\n        TreeNode* deserialize(istringstream& in) {\\n            string val;\\n            in >> val;\\n            if (val == \"#\")\\n                return nullptr;\\n            TreeNode* root = new TreeNode(stoi(val));\\n            root->left = deserialize(in);\\n            root->right = deserialize(in);\\n            return root;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"74264",
			"view":"16984",
			"top":"2",
			"title":"Short and straight forward BFS Java code with a queue",
			"vote":"68",
			"content":"Here I use typical BFS method to handle a binary tree. I use string `n` to represent null values. The string of the binary tree in the example will be `\"1 2 3 n n 4 5 n n n n \"`.\\n\\nWhen deserialize the string, I assign left and right child for each not-null node, and add the not-null children to the queue, waiting to be handled later.\\n\\n\\n\\n    public class Codec {\\n        public String serialize(TreeNode root) {\\n            if (root == null) return \"\";\\n            Queue<TreeNode> q = new LinkedList<>();\\n            StringBuilder res = new StringBuilder();\\n            q.add(root);\\n            while (!q.isEmpty()) {\\n                TreeNode node = q.poll();\\n                if (node == null) {\\n                    res.append(\"n \");\\n                    continue;\\n                }\\n                res.append(node.val + \" \");\\n                q.add(node.left);\\n                q.add(node.right);\\n            }\\n            return res.toString();\\n        }\\n\\n        public TreeNode deserialize(String data) {\\n            if (data == \"\") return null;\\n            Queue<TreeNode> q = new LinkedList<>();\\n            String[] values = data.split(\" \");\\n            TreeNode root = new TreeNode(Integer.parseInt(values[0]));\\n            q.add(root);\\n            for (int i = 1; i < values.length; i++) {\\n                TreeNode parent = q.poll();\\n                if (!values[i].equals(\"n\")) {\\n                    TreeNode left = new TreeNode(Integer.parseInt(values[i]));\\n                    parent.left = left;\\n                    q.add(left);\\n                }\\n                if (!values[++i].equals(\"n\")) {\\n                    TreeNode right = new TreeNode(Integer.parseInt(values[i]));\\n                    parent.right = right;\\n                    q.add(right);\\n                }\\n            }\\n            return root;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"74252",
			"view":"8182",
			"top":"3",
			"title":"Clean C++ solution",
			"vote":"43",
			"content":"    class Codec {\\n    public:\\n        // Encodes a tree to a single string.\\n        string serialize(TreeNode* root) {\\n            if (root == nullptr) return \"#\";\\n            return to_string(root->val)+\",\"+serialize(root->left)+\",\"+serialize(root->right);\\n        }\\n    \\n        // Decodes your encoded data to tree.\\n        TreeNode* deserialize(string data) {\\n            return mydeserialize(data);\\n        }\\n        TreeNode* mydeserialize(string& data) {\\n            if (data[0]=='#') {\\n                if(data.size() > 1) data = data.substr(2);\\n                return nullptr;\\n            } else {\\n                TreeNode* node = new TreeNode(helper(data));\\n                node->left = mydeserialize(data);\\n                node->right = mydeserialize(data);\\n                return node;\\n            }\\n        }\\n    private:\\n        int helper(string& data) {\\n            int pos = data.find(',');\\n            int val = stoi(data.substr(0,pos));\\n            data = data.substr(pos+1);\\n            return val;\\n        }\\n    };`"
		},
		{
			"lc_ans_id":"74260",
			"view":"9224",
			"top":"4",
			"title":"Recursive DFS, Iterative DFS and BFS",
			"vote":"33",
			"content":"This problem can solved in 3 different ways\\n\\n(1) Iterative DFS\\n\\n    public class Codec {\\n    \\n        // Encodes a tree to a single string.\\n        public String serialize(TreeNode root) {\\n            StringBuilder sb=new StringBuilder();\\n            TreeNode x=root;\\n            Deque<TreeNode> stack=new LinkedList<>();\\n            while (x!=null || !stack.isEmpty()) {\\n                if (x!=null) {\\n                    sb.append(String.valueOf(x.val));\\n                    sb.append(' ');\\n                    stack.push(x);\\n                    x=x.left;\\n                }\\n                else {\\n                    sb.append(\"null \");\\n                    x=stack.pop();\\n                    x=x.right;\\n                }\\n            }\\n            return sb.toString();\\n        }\\n    \\n        // Decodes your encoded data to tree.\\n        public TreeNode deserialize(String data) {\\n            if (data.length()==0) return null;\\n            String[] node=data.split(\" \");\\n            int n=node.length;\\n            Deque<TreeNode> stack=new LinkedList<>();\\n            TreeNode root=new TreeNode(Integer.valueOf(node[0]));\\n            TreeNode x=root;\\n            stack.push(x);\\n            \\n            int i=1;\\n            while (i<n) {\\n                while (i<n && !node[i].equals(\"null\")) {\\n                    x.left=new TreeNode(Integer.valueOf(node[i++]));\\n                    x=x.left;\\n                    stack.push(x);\\n                }\\n                while (i<n && node[i].equals(\"null\")) {\\n                    x=stack.pop();\\n                    i++;\\n                }\\n                if (i<n) {\\n                    x.right=new TreeNode(Integer.valueOf(node[i++]));\\n                    x=x.right;\\n                    stack.push(x);\\n                }\\n            }\\n            return root;\\n        }\\n    }\\n\\n(2) recursive DFS\\n\\n    public class Codec {\\n    \\n        // Encodes a tree to a single string.\\n        public String serialize(TreeNode root) {\\n            StringBuilder sb=new StringBuilder();\\n            dfs(root,sb);\\n            return sb.toString();\\n        }\\n        private void dfs(TreeNode x, StringBuilder sb) {\\n            if (x==null) {\\n                sb.append(\"null \");\\n                return;\\n            }\\n            sb.append(String.valueOf(x.val));\\n            sb.append(' ');\\n            dfs(x.left,sb);\\n            dfs(x.right,sb);\\n        }\\n    \\n        // Decodes your encoded data to tree.\\n        public TreeNode deserialize(String data) {\\n            String[] node=data.split(\" \");\\n            int[] d=new int[1];\\n            return dfs(node,d);\\n        }\\n        private TreeNode dfs(String[] node, int[] d) {\\n            if (node[d[0]].equals(\"null\")) {\\n                d[0]++;\\n                return null;\\n            }\\n            TreeNode x=new TreeNode(Integer.valueOf(node[d[0]]));\\n            d[0]++;\\n            x.left=dfs(node,d);\\n            x.right=dfs(node,d);\\n            return x;\\n        }\\n    }\\n\\n(3) BFS \\n\\n    public class Codec {\\n    \\n        // Encodes a tree to a single string.\\n        public String serialize(TreeNode root) {\\n            if (root==null) return \"\";\\n            Queue<TreeNode> qu=new LinkedList<>();\\n            StringBuilder sb=new StringBuilder();\\n            qu.offer(root);\\n            sb.append(String.valueOf(root.val));\\n            sb.append(' ');\\n            while (!qu.isEmpty()) {\\n                TreeNode x=qu.poll();\\n                if (x.left==null) sb.append(\"null \");\\n                else {\\n                    qu.offer(x.left);\\n                    sb.append(String.valueOf(x.left.val));\\n                    sb.append(' ');\\n                }\\n                if (x.right==null) sb.append(\"null \");\\n                else {\\n                    qu.offer(x.right);\\n                    sb.append(String.valueOf(x.right.val));\\n                    sb.append(' ');\\n                }\\n            }\\n            return sb.toString();\\n        }\\n    \\n        // Decodes your encoded data to tree.\\n        public TreeNode deserialize(String data) {\\n            if (data.length()==0) return null;\\n            String[] node=data.split(\" \");\\n            Queue<TreeNode> qu=new LinkedList<>();\\n            TreeNode root=new TreeNode(Integer.valueOf(node[0]));\\n            qu.offer(root);\\n            int i=1;\\n            while (!qu.isEmpty()) {\\n                Queue<TreeNode> nextQu=new LinkedList<>();\\n                while (!qu.isEmpty()) {\\n                    TreeNode x=qu.poll();\\n                    if (node[i].equals(\"null\")) x.left=null;\\n                    else {\\n                        x.left=new TreeNode(Integer.valueOf(node[i]));\\n                        nextQu.offer(x.left);\\n                    }\\n                    i++;\\n                    if (node[i].equals(\"null\")) x.right=null;\\n                    else {\\n                        x.right=new TreeNode(Integer.valueOf(node[i]));\\n                        nextQu.offer(x.right);\\n                    }\\n                    i++;\\n                }\\n                qu=nextQu;\\n            }\\n            return root;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"74417",
			"view":"1614",
			"top":"5",
			"title":"Short and clear recursive Java solution",
			"vote":"21",
			"content":"    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) \\n    {\\n        if(root == null) return \"#\";\\n        \\n        return \"\" + root.val + \" \" + serialize(root.left) + \" \" + serialize(root.right);\\n    }\\n    \\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) \\n    {\\n        return build(new Scanner(data));\\n    }\\n    \\n    private TreeNode build(Scanner sc)\\n    {\\n        if(!sc.hasNext()) return null;\\n        String tk = sc.next();\\n        if(tk.equals(\"#\")) return null;\\n        \\n        TreeNode root = new TreeNode(Integer.parseInt(tk));\\n        root.left = build(sc);\\n        root.right = build(sc);\\n        \\n        return root;\\n    }"
		},
		{
			"lc_ans_id":"74261",
			"view":"4787",
			"top":"6",
			"title":"Easy to understand java solution",
			"vote":"19",
			"content":"     public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();    \\n        helperS(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void helperS(TreeNode node, StringBuilder sb){\\n        if(node == null){\\n            sb.append(\"null\").append(\",\");\\n            return;\\n        }\\n        \\n        sb.append(node.val).append(\",\");\\n        \\n        helperS(node.left, sb);\\n        helperS(node.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] vals  = data.split(\"[,]\");\\n        int[]    index = new int[]{0};\\n        return helperD(vals, index);\\n    }\\n    \\n    private TreeNode helperD(String[] vals, int[] index){\\n        if(index[0] == vals.length){\\n            return null;\\n        }\\n        \\n        String visiting = vals[index[0]++];\\n        if(visiting.equals(\"null\")){\\n            return null;\\n        }\\n        \\n        TreeNode node = new TreeNode(Integer.valueOf(visiting));\\n        node.left     = helperD(vals, index);\\n        node.right    = helperD(vals, index);\\n        \\n        return node;\\n    }"
		},
		{
			"lc_ans_id":"74446",
			"view":"2762",
			"top":"7",
			"title":"C++ Accepted O(n) Easy Solution",
			"vote":"17",
			"content":"Idea: Level-order traversal. Use '#' to denote a nullptr. User ',' to separate entries. The output is very similar to Leetcode's default deserialization logic.\\n\\n\\n--\\n\\nTime Complexities: O(n) to serialize and O(n) to deserialize\\n\\nSpace Complexities: O(n) to serialize and O(n) to deserialize\\n\\n--\\n\\n    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Codec {\\n    public:\\n    \\n        // Encodes a tree to a single string.\\n        string serialize(TreeNode* root) {\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            string str;\\n            while (!q.empty()) {\\n                if (q.front() == nullptr) {\\n                    str = str + \"#,\";\\n                } else {\\n                    q.push(q.front()->left);\\n                    q.push(q.front()->right);\\n                    str = str + to_string(q.front()->val) + \",\";\\n                }\\n                q.pop();\\n            }\\n            return str;\\n        }\\n    \\n        // Decodes your encoded data to tree.\\n        TreeNode* deserialize(string data) {\\n            TreeNode* root = nullptr;\\n            queue<TreeNode**> q;\\n            q.push(&root);\\n            string::iterator first = data.begin();\\n            while (first != data.end()) {\\n                TreeNode** pp = q.front();\\n                if (*first == '#') {\\n                    // *pp = nullptr;\\n                    advance(first, 2);\\n                } else {\\n                    string::iterator last = find(first, data.end(), ',');\\n                    int val = stoi(string(first, last));\\n                    *pp = new TreeNode(val);\\n                    q.push(&((*pp)->left));\\n                    q.push(&((*pp)->right));\\n                    first = next(last);\\n                }\\n                q.pop();\\n            }\\n            return root;\\n        }\\n    };\\n    \\n    // Your Codec object will be instantiated and called as such:\\n    // Codec codec;\\n    // codec.deserialize(codec.serialize(root));"
		},
		{
			"lc_ans_id":"74432",
			"view":"2098",
			"top":"8",
			"title":"My Simple Java Solution #Preorder-Traversal #Recursive #Simple Logic",
			"vote":"14",
			"content":"public class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n        serializeHelper(root,result);\\n        return result.toString();\\n    }\\n    \\n    private void serializeHelper(TreeNode root, ArrayList<Integer> result){\\n        if (root == null) {\\n            result.add(null);\\n            return;\\n        }\\n        result.add(root.val);\\n        serializeHelper(root.left,result);\\n        serializeHelper(root.right,result);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] strArray = data.substring(1,data.length()-1).split(\", \");\\n        Deque<String> strList = new LinkedList<String>(Arrays.asList(strArray)); \\n        return deserializeHelper(strList);\\n    }\\n    \\n    private TreeNode deserializeHelper(Deque<String> strList){\\n        if (strList.size() == 0) return null;\\n        String str = strList.pop();\\n        if (str.equals(\"null\")) return null;\\n        TreeNode currentRoot = new TreeNode(Integer.parseInt(str));\\n        currentRoot.left = deserializeHelper(strList);\\n        currentRoot.right = deserializeHelper(strList);\\n        return currentRoot;\\n    }\\n}"
		},
		{
			"lc_ans_id":"74434",
			"view":"2250",
			"top":"9",
			"title":"Python preorder recursive traversal",
			"vote":"8",
			"content":"\\n    def serialize(self, root):\\n        preorder = ''\\n        if not root:\\n            preorder += ',None'\\n            return preorder\\n        preorder += ','+str(root.val)\\n        preorder += self.serialize(root.left)\\n        preorder += self.serialize(root.right)\\n        return preorder\\n\\n    def deserialize(self, encode_data):\\n        pos = -1\\n        data = encode_data[1:].split(',')\\n        for i in xrange(len(data)):\\n            if data[i] == 'None':\\n                data[i] = None\\n            else:\\n                data[i] = int(data[i])\\n        root, count = self.buildTree(data, pos)\\n        return root\\n        \\n    def buildTree(self, data, pos):\\n        pos += 1\\n        if pos >= len(data) or data[pos]==None:\\n            return None, pos\\n            \\n        root = TreeNode(data[pos])\\n        root.left, pos = self.buildTree(data, pos)\\n        root.right, pos = self.buildTree(data, pos)\\n        return root, pos"
		}
	],
	"id":"297",
	"title":"Serialize and Deserialize Binary Tree",
	"content":"<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\r\n\r\n<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\r\n\r\n<p>For example, you may serialize the following tree</p>\r\n\r\n<pre>\r\n    1\r\n   / \\\r\n  2   3\r\n     / \\\r\n    4   5\r\n</pre>\r\n\r\n<p>as <code>&quot;[1,2,3,null,null,4,5]&quot;</code>, just the same as <a href=\"https://leetcode.com/faq/#binary-tree\">how LeetCode OJ serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>\r\n\r\n<p><strong>Credits:</strong><br />\r\nSpecial thanks to <a href=\"https://leetcode.com/discuss/user/Louis1992\">@Louis1992</a> for adding this problem and creating all test cases.</p>\r\n",
	"frequency":"424",
	"ac_num":"91316"
}