{
	"difficulty":"3",
	"submit_num":"413899",
	"show_id":"30",
	"leetcode_id":"30",
	"answers":[
		{
			"lc_ans_id":"13656",
			"view":"49401",
			"top":"0",
			"title":"An O(N) solution with detailed explanation",
			"vote":"98",
			"content":"        // travel all the words combinations to maintain a window\\n        // there are wl(word len) times travel\\n        // each time, n/wl words, mostly 2 times travel for each word\\n        // one left side of the window, the other right side of the window\\n        // so, time complexity O(wl * 2 * N/wl) = O(2N)\\n        vector<int> findSubstring(string S, vector<string> &L) {\\n            vector<int> ans;\\n            int n = S.size(), cnt = L.size();\\n            if (n <= 0 || cnt <= 0) return ans;\\n            \\n            // init word occurence\\n            unordered_map<string, int> dict;\\n            for (int i = 0; i < cnt; ++i) dict[L[i]]++;\\n            \\n            // travel all sub string combinations\\n            int wl = L[0].size();\\n            for (int i = 0; i < wl; ++i) {\\n                int left = i, count = 0;\\n                unordered_map<string, int> tdict;\\n                for (int j = i; j <= n - wl; j += wl) {\\n                    string str = S.substr(j, wl);\\n                    // a valid word, accumulate results\\n                    if (dict.count(str)) {\\n                        tdict[str]++;\\n                        if (tdict[str] <= dict[str]) \\n                            count++;\\n                        else {\\n                            // a more word, advance the window left side possiablly\\n                            while (tdict[str] > dict[str]) {\\n                                string str1 = S.substr(left, wl);\\n                                tdict[str1]--;\\n                                if (tdict[str1] < dict[str1]) count--;\\n                                left += wl;\\n                            }\\n                        }\\n                        // come to a result\\n                        if (count == cnt) {\\n                            ans.push_back(left);\\n                            // advance one word\\n                            tdict[S.substr(left, wl)]--;\\n                            count--;\\n                            left += wl;\\n                        }\\n                    }\\n                    // not a valid word, reset all vars\\n                    else {\\n                        tdict.clear();\\n                        count = 0;\\n                        left = j + wl;\\n                    }\\n                }\\n            }\\n            \\n            return ans;\\n        }"
		},
		{
			"lc_ans_id":"13658",
			"view":"16554",
			"top":"1",
			"title":"Easy Two-Map Solution (C++/Java)",
			"vote":"82",
			"content":"I think the following code is self-explanatory enough. We use an `unordered_map<string, int> counts` to record the expected times of each word and another `unordered_map<string, int> seen` to record the times we have seen. Then we check for every possible position of `i`. Once we meet an unexpected word or the times of some word is larger than its expected times, we stop the check. If we finish the check successfully, push `i` to the result `indexes`.\\n\\n* C++\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& words) {\\n            unordered_map<string, int> counts;\\n            for (string word : words)\\n                counts[word]++;\\n            int n = s.length(), num = words.size(), len = words[0].length();\\n            vector<int> indexes;\\n            for (int i = 0; i < n - num * len + 1; i++) {\\n                unordered_map<string, int> seen;\\n                int j = 0;\\n                for (; j < num; j++) {\\n                    string word = s.substr(i + j * len, len);\\n                    if (counts.find(word) != counts.end()) {\\n                        seen[word]++;\\n                        if (seen[word] > counts[word])\\n                            break;\\n                    } \\n                    else break;\\n                }\\n                if (j == num) indexes.push_back(i);\\n            }\\n            return indexes;\\n        }\\n    };\\n\\n* Java\\n\\n```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        final Map<String, Integer> counts = new HashMap<>();\\n        for (final String word : words) {\\n            counts.put(word, counts.getOrDefault(word, 0) + 1);\\n        }\\n        final List<Integer> indexes = new ArrayList<>();\\n        final int n = s.length(), num = words.length, len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            final Map<String, Integer> seen = new HashMap<>();\\n            int j = 0;\\n            while (j < num) {\\n                final String word = s.substring(i + j * len, i + (j + 1) * len);\\n                if (counts.containsKey(word)) {\\n                    seen.put(word, seen.getOrDefault(word, 0) + 1);\\n                    if (seen.get(word) > counts.getOrDefault(word, 0)) {\\n                        break;\\n                    }\\n                } else {\\n                    break;\\n                }\\n                j++;\\n            }\\n            if (j == num) {\\n                indexes.add(i);\\n            }\\n        }\\n        return indexes;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"13673",
			"view":"14191",
			"top":"2",
			"title":"Accepted Java solution 12ms with explanation",
			"vote":"69",
			"content":"It's not too hard to find some resemblance between this problem and [minimum-window-substring][1]. Actually the main difference is the fact that we are interested at some interval length: we want intervals with fixed length K * M, where K is the number of strings in the \"words\" array and M the length of each target string. In order to apply the same idea we used for that problem, all we need to do is to map each string from the \"words\" array to something we are able to index (I prefer to use hashing for this). Also, in order to speed up the algorithm, we can find all occurrences of those strings in S (which is equivalent to do it on demand, but we will potentially do the same matching twice). Notice that, we can simply apply these occurrences as they appear because we are assured that no word is contained by some other. Finally, we use all this information to process each possibility. Notice here that, the fact that all strings has the same length, implies that we have just M (being M the length of each target string) possible starting points, hence we end up performing M linear scans over array with length O(N/M) (being N the length of S) and that makes the scanning stage of the algorithm to be linear on the length of S.\\n\\n\\tpublic List<Integer> findSubstring(String s, String[] words) {\\n\\t\\tint N = s.length();\\n\\t\\tList<Integer> indexes = new ArrayList<Integer>(s.length());\\n\\t\\tif (words.length == 0) {\\n\\t\\t\\treturn indexes;\\n\\t\\t}\\n\\t\\tint M = words[0].length();\\n\\t\\tif (N < M * words.length) {\\n\\t\\t\\treturn indexes;\\n\\t\\t}\\n\\t\\tint last = N - M + 1;\\n\\t\\t\\n\\t\\t//map each string in words array to some index and compute target counters\\n\\t\\tMap<String, Integer> mapping = new HashMap<String, Integer>(words.length);\\n\\t\\tint [][] table = new int[2][words.length];\\n\\t\\tint failures = 0, index = 0;\\n\\t\\tfor (int i = 0; i < words.length; ++i) {\\n\\t\\t\\tInteger mapped = mapping.get(words[i]);\\n\\t\\t\\tif (mapped == null) {\\n\\t\\t\\t\\t++failures;\\n\\t\\t\\t\\tmapping.put(words[i], index);\\n\\t\\t\\t\\tmapped = index++;\\n\\t\\t\\t}\\n\\t\\t\\t++table[0][mapped];\\n\\t\\t}\\n\\t\\t\\n\\t\\t//find all occurrences at string S and map them to their current integer, -1 means no such string is in words array\\n\\t\\tint [] smapping = new int[last];\\n\\t\\tfor (int i = 0; i < last; ++i) {\\n\\t\\t\\tString section = s.substring(i, i + M);\\n\\t\\t\\tInteger mapped = mapping.get(section);\\n\\t\\t\\tif (mapped == null) {\\n\\t\\t\\t\\tsmapping[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsmapping[i] = mapped;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t//fix the number of linear scans\\n\\t\\tfor (int i = 0; i < M; ++i) {\\n\\t\\t\\t//reset scan variables\\n\\t\\t\\tint currentFailures = failures; //number of current mismatches\\n\\t\\t\\tint left = i, right = i;\\n\\t\\t\\tArrays.fill(table[1], 0);\\n\\t\\t\\t//here, simple solve the minimum-window-substring problem\\n\\t\\t\\twhile (right < last) {\\n\\t\\t\\t\\twhile (currentFailures > 0 && right < last) {\\n\\t\\t\\t\\t\\tint target = smapping[right];\\n\\t\\t\\t\\t\\tif (target != -1 && ++table[1][target] == table[0][target]) {\\n\\t\\t\\t\\t\\t\\t--currentFailures;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tright += M;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile (currentFailures == 0 && left < right) {\\n\\t\\t\\t\\t\\tint target = smapping[left];\\n\\t\\t\\t\\t\\tif (target != -1 && --table[1][target] == table[0][target] - 1) {\\n\\t\\t\\t\\t\\t\\tint length = right - left;\\n\\t\\t\\t\\t\\t\\t//instead of checking every window, we know exactly the length we want\\n\\t\\t\\t\\t\\t\\tif ((length / M) ==  words.length) {\\n\\t\\t\\t\\t\\t\\t\\tindexes.add(left);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t++currentFailures;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tleft += M;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn indexes;\\n\\t}\\n\\n\\n  [1]: https://leetcode.com/problems/minimum-window-substring/"
		},
		{
			"lc_ans_id":"13664",
			"view":"16663",
			"top":"3",
			"title":"Simple Java Solution with Two Pointers and Map",
			"vote":"51",
			"content":"My idea is pretty simple. Just build a map for the words and their relative count in L. Then we traverse through S to check whether there is a match.\\n\\n    public static List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (S == null || L == null || L.length == 0) return res;\\n        int len = L[0].length(); // length of each word\\n        \\n        Map<String, Integer> map = new HashMap<String, Integer>(); // map for L\\n        for (String w : L) map.put(w, map.containsKey(w) ? map.get(w) + 1 : 1);\\n        \\n        for (int i = 0; i <= S.length() - len * L.length; i++) {\\n            Map<String, Integer> copy = new HashMap<String, Integer>(map);\\n            for (int j = 0; j < L.length; j++) { // checkc if match\\n                String str = S.substring(i + j*len, i + j*len + len); // next word\\n                if (copy.containsKey(str)) { // is in remaining words\\n                    int count = copy.get(str);\\n                    if (count == 1) copy.remove(str);\\n                    else copy.put(str, count - 1);\\n                    if (copy.isEmpty()) { // matches\\n                        res.add(i);\\n                        break;\\n                    }\\n                } else break; // not in L\\n            }\\n        }\\n        return res;\\n    }\\n\\nAt first I was gonna to use a set for words. Owing to the fact that duplicate is allowed in L, we need to use map instead."
		},
		{
			"lc_ans_id":"13700",
			"view":"10438",
			"top":"4",
			"title":"My AC c++ code, O(n) complexity, 26ms",
			"vote":"32",
			"content":"    class Solution {\\n    // The general idea:\\n    // Construct a hash function f for L, f: vector<string> -> int, \\n    // Then use the return value of f to check whether a substring is a concatenation \\n    // of all words in L.\\n    // f has two levels, the first level is a hash function f1 for every single word in L.\\n    // f1 : string -> double\\n    // So with f1, L is converted into a vector of float numbers\\n    // Then another hash function f2 is defined to convert a vector of doubles into a single int.\\n    // Finally f(L) := f2(f1(L))\\n    // To obtain lower complexity, we require f1 and f2 can be computed through moving window.\\n    // The following corner case also needs to be considered:\\n    // f2(f1([\"ab\", \"cd\"])) != f2(f1([\"ac\", \"bd\"]))\\n    // There are many possible options for f2 and f1. \\n    // The following code only shows one possibility (probably not the best), \\n    // f2 is the function \"hash\" in the class,\\n    // f1([a1, a2, ... , an]) := int( decimal_part(log(a1) + log(a2) + ... + log(an)) * 1000000000 )\\n    public:\\n        // The complexity of this function is O(nW).\\n        double hash(double f, double code[], string &word) {\\n            double result = 0.;\\n            for (auto &c : word) result = result * f + code[c];\\n            return result;\\n        }\\n        vector<int> findSubstring(string S, vector<string> &L) {\\n            uniform_real_distribution<double> unif(0., 1.);\\n            default_random_engine seed;\\n            double code[128];\\n            for (auto &d : code) d = unif(seed);\\n            double f = unif(seed) / 5. + 0.8;\\n            double value = 0;\\n\\n            // The complexity of the following for loop is O(L.size( ) * nW).\\n            for (auto &str : L) value += log(hash(f, code, str));\\n\\n            int unit = 1e9;\\n            int key = (value-floor(value))*unit;\\n            int nS = S.size(), nL = L.size(), nW = L[0].size();\\n            double fn = pow(f, nW-1.);\\n            vector<int> result;\\n            if (nS < nW) return result;\\n            vector<double> values(nS-nW+1);\\n            string word(S.begin(), S.begin()+nW);\\n            values[0] = hash(f, code, word);\\n\\n            // Use a moving window to hash every word with length nW in S to a float number, \\n            // which is stored in vector values[]\\n            // The complexity of this step is O(nS).\\n            for (int i=1; i<=nS-nW; ++i) values[i] = (values[i-1] - code[S[i-1]]*fn)*f + code[S[i+nW-1]];\\n\\n            // This for loop will run nW times, each iteration has a complexity O(nS/nW)\\n            // So the overall complexity is O(nW * (nS / nW)) = O(nS)\\n            for (int i=0; i<nW; ++i) {\\n                int j0=i, j1=i, k=0;\\n                double sum = 0.;\\n\\n                // Use a moving window to hash every L.size() continuous words with length nW in S.\\n                // This while loop will terminate within nS/nW iterations since the increasement of j1 is nW,\\n                // So the complexity of this while loop is O(nS / nW).\\n                while(j1<=nS-nW) {\\n                    sum += log(values[j1]);\\n                    ++k;\\n                    j1 += nW;\\n                    if (k==nL) {\\n                        int key1 = (sum-floor(sum)) * unit;\\n                        if (key1==key) result.push_back(j0);\\n                        sum -= log(values[j0]);\\n                        --k;\\n                        j0 += nW;\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    };\\n\\nThough theoretically it has a very small chance to fail."
		},
		{
			"lc_ans_id":"13812",
			"view":"6269",
			"top":"5",
			"title":"Hash Idea and exception case",
			"vote":"22",
			"content":"The following python code is accepted by OJ. It is based on the following idea (assumption)\\n\\n -  We know that two multisets consist of same elements and size of the multisets are equal. if sum of hashes of all elements are the same for these multisets ->  those multisets are identical\\n\\n \\nThis is not true for same very very rare cases. Please describe such a case.\\n\\n    def findSubstring(self, S, L):\\n        n = len(L) #num words\\n        w = len(L[0])  #length of each word\\n        t = n*w    # total length\\n    \\n        hashsum = sum([hash(x) for x in L])\\n        h = [hash(S[i:i+w])*(S[i:i+w] in L) for i in xrange(len(S)-w+1)]\\n        return [i for i in xrange(len(S)-t+1) if sum(h[i:i+t:w])==hashsum]"
		},
		{
			"lc_ans_id":"13691",
			"view":"3726",
			"top":"6",
			"title":"Java 12ms beats 100%",
			"vote":"20",
			"content":"The two pointers method with hashmap is known by many other solutions. The idea is to slide the scan window as far as possible, and keep throwing the impossible cases based on the length test.\\n\\n    public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Let n=s.length, k=words[0].length traverse s with indices i, i+k,\\n\\t\\t\\t * i+2k, ... for 0<=i<k, so that the time complexity is O(n).\\n\\t\\t\\t */\\n\\t\\t\\tList<Integer> res = new ArrayList<Integer>();\\n\\t\\t\\tint n = s.length(), m = words.length, k;\\n\\t\\t\\tif (n == 0 || m == 0 || (k = words[0].length()) == 0)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tHashMap<String, Integer> wDict = new HashMap<String, Integer>();\\n\\n\\t\\t\\tfor (String word : words) {\\n\\t\\t\\t\\tif (wDict.containsKey(word))\\n\\t\\t\\t\\t\\twDict.put(word, wDict.get(word) + 1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\twDict.put(word, 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint i, j, start, x, wordsLen = m * k;\\n\\t\\t\\tHashMap<String, Integer> curDict = new HashMap<String, Integer>();\\n\\t\\t\\tString test, temp;\\n\\t\\t\\tfor (i = 0; i < k; i++) {\\n\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\tfor (j = i; j + k <= n; j += k) {\\n\\t\\t\\t\\t\\ttest = s.substring(j, j + k);\\n\\n\\t\\t\\t\\t\\tif (wDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\tif (!curDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\t\\tcurDict.put(test, 1);\\n\\n\\t\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// curDict.containsKey(test)\\n\\t\\t\\t\\t\\t\\tx = curDict.get(test);\\n\\t\\t\\t\\t\\t\\tif (x < wDict.get(test)) {\\n\\t\\t\\t\\t\\t\\t\\tcurDict.put(test, x + 1);\\n\\n\\t\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// curDict.get(test)==wDict.get(test), slide start to\\n\\t\\t\\t\\t\\t\\t// the next word of the first same word as test\\n\\t\\t\\t\\t\\t\\twhile (!(temp = s.substring(start, start + k)).equals(test)) {\\n\\t\\t\\t\\t\\t\\t\\tdecreaseCount(curDict, temp);\\n\\t\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// totally failed up to index j+k, slide start and reset all\\n\\t\\t\\t\\t\\tstart = j + k;\\n\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic int checkFound(List<Integer> res, int start, int wordsLen, int j, int k,\\n\\t\\t\\t\\tHashMap<String, Integer> curDict, String s) {\\n\\t\\t\\tif (start + wordsLen == j + k) {\\n\\t\\t\\t\\tres.add(start);\\n\\t\\t\\t\\t// slide start to the next word\\n\\t\\t\\t\\tdecreaseCount(curDict, s.substring(start, start + k));\\n\\t\\t\\t\\treturn start + k;\\n\\t\\t\\t}\\n\\t\\t\\treturn start;\\n\\t\\t}\\n\\n\\t\\tpublic void decreaseCount(HashMap<String, Integer> curDict, String key) {\\n\\t\\t\\t// remove key if curDict.get(key)==1, otherwise decrease it by 1\\n\\t\\t\\tint x = curDict.get(key);\\n\\t\\t\\tif (x == 1)\\n\\t\\t\\t\\tcurDict.remove(key);\\n\\t\\t\\telse\\n\\t\\t\\t\\tcurDict.put(key, x - 1);\\n\\t\\t}"
		},
		{
			"lc_ans_id":"13667",
			"view":"3616",
			"top":"7",
			"title":"AC Python 80ms solution, dictionary and two pointers",
			"vote":"16",
			"content":"    def _findSubstring(self, l, r, n, k, t, s, req, ans):\\n        curr = {}\\n        while r + k <= n:\\n            w = s[r:r + k]\\n            r += k\\n            if w not in req:\\n                l = r\\n                curr.clear()\\n            else:\\n                curr[w] = curr[w] + 1 if w in curr else 1\\n                while curr[w] > req[w]:\\n                    curr[s[l:l + k]] -= 1\\n                    l += k\\n                if r - l == t:\\n                    ans.append(l)\\n\\n    def findSubstring(self, s, words):\\n        if not s or not words or not words[0]:\\n            return []\\n        n = len(s)\\n        k = len(words[0])\\n        t = len(words) * k\\n        req = {}\\n        for w in words:\\n            req[w] = req[w] + 1 if w in req else 1\\n        ans = []\\n        for i in xrange(min(k, n - t + 1)):\\n            self._findSubstring(i, i, n, k, t, s, req, ans)\\n        return ans\\n\\n\\n    # 169 / 169 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 80 ms\\n    # 98.60%\\n\\n\\nFirst of all consider s as several series of  words with length k starting at [0, k-1]. For example \"barfoothe\" with k = 3, can be view as [\"bar\", \"foo\", \"the\"] for i=0 and [\"arf\", \"oot\"] for i = 1 and [\"rfo\", \"oth\"] for i = 2.\\nThus we need to check each  of these series and find out the valid index by definition.\\n\\nFor each series, we just need to check if there exist a range [l, r) where the occurrence or \"spectrum\" of the words in the range is the same as our given word list's \"spectrum\". We use dictionary to store the spectrum and maintain it as we loop through s.\\n\\ncollections.Counter class may save a bit of code on updating the counts of the dictionary. However plain dict wins on the speed."
		},
		{
			"lc_ans_id":"13699",
			"view":"2572",
			"top":"8",
			"title":"92% JAVA O(N) with explaination",
			"vote":"15",
			"content":"```java\\npublic class Solution {\\n\\t\\n\\t/*\\n\\t\\tA time & space O(n) solution\\n\\t\\tRun a moving window for wordLen times.\\n\\t\\tEach time we keep a window of size windowLen (= wordLen * numWord), each step length is wordLen.\\n\\t\\tSo each scan takes O(sLen / wordLen), totally takes O(sLen / wordLen * wordLen) = O(sLen) time.\\n\\t\\t\\n\\t\\tOne trick here is use count to record the number of exceeded occurrences of word in current window\\n\\t*/\\n    public static List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> res = new ArrayList<>();\\n        if(words == null || words.length == 0 || s.length() == 0) return res;\\n        int wordLen = words[0].length();\\n        int numWord = words.length;\\n        int windowLen = wordLen * numWord;\\n        int sLen = s.length();\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\\n\\n        for(int i = 0; i < wordLen; i++) {  // Run wordLen scans\\n            HashMap<String, Integer> curMap = new HashMap<>();\\n            for(int j = i, count = 0, start = i; j + wordLen <= sLen; j += wordLen) {  // Move window in step of wordLen\\n                // count: number of exceeded occurences in current window\\n                // start: start index of current window of size windowLen\\n                if(start + windowLen > sLen) break;\\n                String word = s.substring(j, j + wordLen);\\n                if(!map.containsKey(word)) {\\n                    curMap.clear();\\n                    count = 0;\\n                    start = j + wordLen;\\n                }\\n                else {\\n                    if(j == start + windowLen) { // Remove previous word of current window\\n                        String preWord = s.substring(start, start + wordLen);\\n                        start += wordLen;\\n                        int val = curMap.get(preWord);\\n                        if(val == 1) curMap.remove(preWord);\\n                        else curMap.put(preWord, val - 1);\\n                        if(val - 1 >= map.get(preWord)) count--;  // Reduce count of exceeded word\\n                    }\\n                    // Add new word\\n                    curMap.put(word, curMap.getOrDefault(word, 0) + 1);\\n                    if(curMap.get(word) > map.get(word)) count++;  // More than expected, increase count\\n                    // Check if current window valid\\n                    if(count == 0 && start + windowLen == j + wordLen) {\\n                        res.add(start);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"13733",
			"view":"6957",
			"top":"9",
			"title":"Accepted short Java solution",
			"vote":"11",
			"content":"Hey, guys!\\n\\nActually, there's nothing special in my solution except the comparably short Java code. It's just a simple sliding window approach which is greatly described in other posts.\\n\\nIn short, we got the source histogram from the dictionary L and build the new histogram for each possible window comparing it with the help of Java's *equals* method to the source one. Additionally, for the sake of tiny optimization, we check the starting word for being in the dictionary. \\n\\n\\n    public List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> result = new ArrayList<>();\\n        int size = L[0].length();\\n        if (L.length == 0 || L[0].isEmpty() || L[0].length() > S.length()) \\n            return result;\\n        Map<String, Integer> hist = new HashMap<>();\\n        for (String w : L) {\\n            hist.put(w, !hist.containsKey(w) ? 1 : hist.get(w)+1);\\n        }\\n        for (int i = 0; i+size*L.length <= S.length(); i++) {\\n            if (hist.containsKey(S.substring(i, i+size))) {\\n                Map<String, Integer> currHist = new HashMap<>();\\n                for (int j = 0; j < L.length; j++) {\\n                    String word = S.substring(i+j*size, i+(j+1)*size);\\n                    currHist.put(word, !currHist.containsKey(word) ? \\n                            1 : currHist.get(word)+1);\\n                }\\n                if (currHist.equals(hist)) result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n\\nHope it helps!"
		}
	],
	"id":"30",
	"title":"Substring with Concatenation of All Words",
	"content":"<p>\r\nYou are given a string, <b>s</b>, and a list of words, <b>words</b>, that are all of the same length. Find all starting indices of substring(s) in <b>s</b> that is a concatenation of each word in <b>words</b> exactly once and without any intervening characters.\r\n</p>\r\n\r\n<p>\r\nFor example, given:<br />\r\n<b>s</b>: <code>\"barfoothefoobarman\"</code><br />\r\n<b>words</b>: <code>[\"foo\", \"bar\"]</code>\r\n</p>\r\n\r\n<p>\r\nYou should return the indices: <code>[0,9]</code>.<br />\r\n(order does not matter).\r\n</p>",
	"frequency":"388",
	"ac_num":"91907"
}