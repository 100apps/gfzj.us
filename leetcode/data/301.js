{
	"difficulty":"3",
	"submit_num":"171182",
	"show_id":"301",
	"leetcode_id":"301",
	"answers":[
		{
			"lc_ans_id":"75027",
			"view":"68702",
			"top":"0",
			"title":"Easy, Short, Concise and Fast Java DFS 3 ms solution",
			"vote":"349",
			"content":"For a better view [see here](http://algobox.org/remove-invalid-parentheses/)\\n\\nKey Points:\\n\\n1. Generate unique answer once and only once, do not rely on Set.\\n2. Do not need preprocess.\\n3. Runtime 3 ms.\\n\\nExplanation:\\nWe all know how to check a string of parentheses is valid using a stack. Or even simpler use a counter.\\nThe counter will increase when it is \\u2018(\\u2018 and decrease when it is \\u2018)\\u2019. Whenever the counter is negative, we have more \\u2018)\\u2019 than \\u2018(\\u2018 in the prefix.\\n\\nTo make the prefix valid, we need to remove a \\u2018)\\u2019. The problem is: which one? The answer is any one in the prefix. However, if we remove any one, we will generate duplicate results, for example: s = ()), we can remove s[1] or s[2] but the result is the same (). Thus, we restrict ourself to remove the first ) in a series of concecutive )s.\\n\\nAfter the removal, the prefix is then valid. We then call the function recursively to solve the rest of the string. However, we need to keep another information: the last removal position. If we do not have this position, we will generate duplicate by removing two \\u2018)\\u2019 in two steps only with a different order.\\nFor this, we keep tracking the last removal position and only remove \\u2018)\\u2019 after that.\\n\\nNow one may ask. What about \\u2018(\\u2018? What if s = \\u2018(()(()\\u2019 in which we need remove \\u2018(\\u2018?\\nThe answer is: do the same from right to left.\\nHowever a cleverer idea is: reverse the string and reuse the code!\\nHere is the final implement in Java.\\n\\n\\n\\n**Java**\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        remove(s, ans, 0, 0, new char[]{'(', ')'});\\n        return ans;\\n    }\\n\\n    public void remove(String s, List<String> ans, int last_i, int last_j,  char[] par) {\\n        for (int stack = 0, i = last_i; i < s.length(); ++i) {\\n            if (s.charAt(i) == par[0]) stack++;\\n            if (s.charAt(i) == par[1]) stack--;\\n            if (stack >= 0) continue;\\n            for (int j = last_j; j <= i; ++j)\\n                if (s.charAt(j) == par[1] && (j == last_j || s.charAt(j - 1) != par[1]))\\n                    remove(s.substring(0, j) + s.substring(j + 1, s.length()), ans, i, j, par);\\n            return;\\n        }\\n        String reversed = new StringBuilder(s).reverse().toString();\\n        if (par[0] == '(') // finished left to right\\n            remove(reversed, ans, 0, 0, new char[]{')', '('});\\n        else // finished right to left\\n            ans.add(reversed);\\n    }"
		},
		{
			"lc_ans_id":"75032",
			"view":"50481",
			"top":"1",
			"title":"Share my Java BFS solution",
			"vote":"289",
			"content":"The idea is straightforward, with the input string `s`, we generate all possible states by removing one `(` or `)`, check if they are valid, if found valid ones on the current level, put them to the final result list and we are done, otherwise, add them to a queue and carry on to the next level. \\n\\nThe good thing of using BFS is that we can guarantee the number of parentheses that need to be removed is minimal, also no recursion call is needed in BFS.\\n\\nThanks to [@peisi][1], we don't need stack to check valid parentheses.\\n\\nTime complexity: \\n\\nIn BFS we handle the states level by level, in the worst case, we need to handle all the levels, we can analyze the time complexity level by level and add them up to get the final complexity. \\n\\nOn the first level, there's only one string which is the input string `s`, let's say the length of it is `n`, to check whether it's valid, we need `O(n)` time. On the second level, we remove one `(` or `)` from the first level, so there are `C(n, n-1)` new strings, each of them has `n-1` characters, and for each string, we need to check whether it's valid or not, thus the total time complexity on this level is `(n-1)` x `C(n, n-1)`. Come to the third level, total time complexity is `(n-2)` x `C(n, n-2)`, so on and so forth...\\n\\nFinally we have this formula: \\n\\n`T(n)` = `n` x `C(n, n)` + `(n-1)` x `C(n, n-1)` + ... + `1` x `C(n, 1)` = `n` x `2^(n-1)`.\\n\\nFollowing is the Java solution:\\n\\n    public class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n          List<String> res = new ArrayList<>();\\n          \\n          // sanity check\\n          if (s == null) return res;\\n          \\n          Set<String> visited = new HashSet<>();\\n          Queue<String> queue = new LinkedList<>();\\n          \\n          // initialize\\n          queue.add(s);\\n          visited.add(s);\\n          \\n          boolean found = false;\\n          \\n          while (!queue.isEmpty()) {\\n            s = queue.poll();\\n            \\n            if (isValid(s)) {\\n              // found an answer, add to the result\\n              res.add(s);\\n              found = true;\\n            }\\n          \\n            if (found) continue;\\n          \\n            // generate all possible states\\n            for (int i = 0; i < s.length(); i++) {\\n              // we only try to remove left or right paren\\n              if (s.charAt(i) != '(' && s.charAt(i) != ')') continue;\\n            \\n              String t = s.substring(0, i) + s.substring(i + 1);\\n            \\n              if (!visited.contains(t)) {\\n                // for each state, if it's not visited, add it to the queue\\n                queue.add(t);\\n                visited.add(t);\\n              }\\n            }\\n          }\\n          \\n          return res;\\n        }\\n        \\n        // helper function checks if string s contains valid parantheses\\n        boolean isValid(String s) {\\n          int count = 0;\\n        \\n          for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == '(') count++;\\n            if (c == ')' && count-- == 0) return false;\\n          }\\n        \\n          return count == 0;\\n        }\\n    }\\n\\n  [1]: https://leetcode.com/discuss/user/peisi"
		},
		{
			"lc_ans_id":"75034",
			"view":"25140",
			"top":"2",
			"title":"Easiest 9ms Java Solution",
			"vote":"145",
			"content":"Here I share my `DFS` or `backtracking` solution. It's `10X` faster than optimized `BFS`.\\n\\n 1. Limit max removal  `rmL` and  `rmR` for backtracking boundary. Otherwise it will exhaust all possible valid substrings, not shortest ones.\\n 2. Scan from left to right, avoiding invalid strs (on the fly) by checking num of `open` parens.\\n 3. If it's `'('`, either use it, or remove it.\\n 4. If it's `'('`, either use it, or remove it.\\n 5. Otherwise just append it.\\n 6. Lastly set `StringBuilder` to the last decision point.\\n\\nIn each step, make sure:\\n\\n 1. `i` does not exceed `s.length()`.\\n 2. Max removal `rmL` `rmR` and num of `open` parens are non negative.\\n 3. De-duplicate by adding to a `HashSet`.\\n\\nCompared to `106 ms` `BFS (Queue & Set)`, it's faster and easier. Hope it helps! Thanks.\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        int rmL = 0, rmR = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == '(') {\\n                rmL++;\\n            } else if (s.charAt(i) == ')') {\\n                if (rmL != 0) {\\n                    rmL--;\\n                } else {\\n                    rmR++;\\n                }\\n            }\\n        }\\n        Set<String> res = new HashSet<>();\\n        dfs(s, 0, res, new StringBuilder(), rmL, rmR, 0);\\n        return new ArrayList<String>(res);\\n    }\\n    \\n    public void dfs(String s, int i, Set<String> res, StringBuilder sb, int rmL, int rmR, int open) {\\n        if (rmL < 0 || rmR < 0 || open < 0) {\\n            return;\\n        }\\n        if (i == s.length()) {\\n            if (rmL == 0 && rmR == 0 && open == 0) {\\n                res.add(sb.toString());\\n            }        \\n            return;\\n        }\\n    \\n        char c = s.charAt(i); \\n        int len = sb.length();\\n    \\n        if (c == '(') {\\n            dfs(s, i + 1, res, sb, rmL - 1, rmR, open);\\t\\t    // not use (\\n        \\tdfs(s, i + 1, res, sb.append(c), rmL, rmR, open + 1);       // use (\\n    \\n        } else if (c == ')') {\\n            dfs(s, i + 1, res, sb, rmL, rmR - 1, open);\\t            // not use  )\\n        \\tdfs(s, i + 1, res, sb.append(c), rmL, rmR, open - 1);  \\t    // use )\\n    \\n        } else {\\n            dfs(s, i + 1, res, sb.append(c), rmL, rmR, open);\\t\\n        }\\n    \\n        sb.setLength(len);        \\n    }"
		},
		{
			"lc_ans_id":"75050",
			"view":"12346",
			"top":"3",
			"title":"My C++ DFS Solution - 16ms",
			"vote":"39",
			"content":"    class Solution {\\n    public:\\n        vector<string> removeInvalidParentheses(string s) {\\n            unordered_set<string> result;\\n            int left_removed = 0;\\n            int right_removed = 0;\\n            for(auto c : s) {\\n                if(c == '(') {\\n                    ++left_removed;\\n                }\\n                if(c == ')') {\\n                    if(left_removed != 0) {\\n                        --left_removed;\\n                    }\\n                    else {\\n                        ++right_removed;\\n                    }\\n                }\\n            }\\n            helper(s, 0, left_removed, right_removed, 0, \"\", result);\\n            return vector<string>(result.begin(), result.end());\\n        }\\n    private:\\n        void helper(string s, int index, int left_removed, int right_removed, int pair, string path, unordered_set<string>& result) {\\n            if(index == s.size()) {\\n                if(left_removed == 0 && right_removed == 0 && pair == 0) {\\n                    result.insert(path);\\n                }\\n                return;\\n            }\\n            if(s[index] != '(' && s[index] != ')') {\\n                helper(s, index + 1, left_removed, right_removed, pair, path + s[index], result);\\n            }\\n            else {\\n                if(s[index] == '(') {\\n                    if(left_removed > 0) {\\n                        helper(s, index + 1, left_removed - 1, right_removed, pair, path, result);\\n                    }\\n                    helper(s, index + 1, left_removed, right_removed, pair + 1, path + s[index], result);\\n                }\\n                if(s[index] == ')') {\\n                    if(right_removed > 0) {\\n                        helper(s, index + 1, left_removed, right_removed - 1, pair, path, result);\\n                    }\\n                    if(pair > 0) {\\n                        helper(s, index + 1, left_removed, right_removed, pair - 1, path + s[index], result);\\n                    }\\n                }\\n            }\\n        }\\n    };"
		},
		{
			"lc_ans_id":"75028",
			"view":"9887",
			"top":"4",
			"title":"Short Python BFS",
			"vote":"36",
			"content":"**Solution 1**\\n\\nBeing lazy and using `eval` for checking:\\n\\n    def removeInvalidParentheses(self, s):\\n        level = {s}\\n        while True:\\n            valid = []\\n            for s in level:\\n                try:\\n                    eval('0,' + filter('()'.count, s).replace(')', '),'))\\n                    valid.append(s)\\n                except:\\n                    pass\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}\\n\\n---\\n\\nUpdate: Meh, ok, checking it myself isn't that much longer, and it's three times as fast:\\n\\n**Solution 2**\\n\\n    def removeInvalidParentheses(self, s):\\n        def isvalid(s):\\n            ctr = 0\\n            for c in s:\\n                if c == '(':\\n                    ctr += 1\\n                elif c == ')':\\n                    ctr -= 1\\n                    if ctr < 0:\\n                        return False\\n            return ctr == 0\\n        level = {s}\\n        while True:\\n            valid = filter(isvalid, level)\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}\\n\\n---\\n\\n**Solution 3**\\n\\nJust a mix of the above two.\\n\\n    def removeInvalidParentheses(self, s):\\n        def isvalid(s):\\n            try:\\n                eval('0,' + filter('()'.count, s).replace(')', '),'))\\n                return True\\n            except:\\n                pass\\n        level = {s}\\n        while True:\\n            valid = filter(isvalid, level)\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}\\n\\n---\\n\\n**Solution 4**\\n\\nYet another way to do `isvalid`.\\n\\n    def removeInvalidParentheses(self, s):\\n        def isvalid(s):\\n            s = filter('()'.count, s)\\n            while '()' in s:\\n                s = s.replace('()', '')\\n            return not s\\n        level = {s}\\n        while True:\\n            valid = filter(isvalid, level)\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}"
		},
		{
			"lc_ans_id":"75041",
			"view":"3521",
			"top":"5",
			"title":"Java BFS solution 16ms avoid generating duplicate strings",
			"vote":"31",
			"content":"The naive BFS solution is quite simple to implement. To speed up we can use a Set to record all the strings generated and avoid revisit. But a better and faster solution is to avoid generate duplicate strings all together.\\n\\n\\nThe first observation is when we want to remove a ')' or '(' from several consecutive ones we only remove the first one, because remove any one the result will be the same. For example\\n\\n    \"())\" ---> \"()\"\\n    only remove the first one of '))'\\n\\nThe second observation is when we remove a character it must behind it's parent removal position. For example\\n\\n    we need remove 2 from \"(())((\"\\n    we want to remove positions combination i,j with no duplicate\\n    so we let i < j then it will not generate duplicate combinations\\n    in practice, we record the position i and put it in to queue\\n    which is then polled out and used as the starting point of the next removal\\n\\nA third observation is if the previous step we removed a \"(\", we should never remove a \")\" in the following steps. This is obvious since otherwise we could just save these two removals and still be valid with less removals. With this observation all the possible removals will be something like this\\n\\n    \")))))))))(((((((((\"\\n\\nAll the removed characters forming a string with consecutive left bracket followed by consecutive right bracket.\\n\\nBy applying these restrictions, we can avoid generate duplicate strings and the need of a set which saves a lot of space.\\n\\n\\nUltimately we can further improve the algorithm to eliminate isValid calls. To do this we need to remove and only remove those characters that would lead us to valid strings. This needs some preprocess and can reduce the time to around 3ms.\\n\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        if (isValid(s))\\n            return Collections.singletonList(s);\\n        List<String> ans = new ArrayList<>();\\n        //The queue only contains invalid middle steps\\n        Queue<Tuple> queue = new LinkedList<>();\\n        //The 3-Tuple is (string, startIndex, lastRemovedChar)\\n        queue.add(new Tuple(s, 0, ')'));\\n        while (!queue.isEmpty()) {\\n            Tuple x = queue.poll();\\n            //Observation 2, start from last removal position\\n            for (int i = x.start; i < x.string.length(); ++i) {\\n                char ch = x.string.charAt(i);\\n                //Not parentheses\\n                if (ch != '(' && ch != ')') continue;\\n                //Observation 1, do not repeatedly remove from consecutive ones\\n                if (i != x.start && x.string.charAt(i - 1) == ch) continue;\\n                //Observation 3, do not remove a pair of valid parentheses\\n                if (x.removed == '(' && ch == ')') continue;\\n                String t = x.string.substring(0, i) + x.string.substring(i + 1);\\n                //Check isValid before add\\n                if (isValid(t))\\n                    ans.add(t);\\n                //Avoid adding leaf level strings\\n                else if (ans.isEmpty())\\n                    queue.add(new Tuple(t, i, ch));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (c == '(') ++count;\\n            if (c == ')' && count-- == 0) return false;\\n        }\\n        return count == 0;\\n    }\\n\\n    private class Tuple {\\n        public final String string;\\n        public final int start;\\n        public final char removed;\\n\\n        public Tuple(String string, int start, char removed) {\\n            this.string = string;\\n            this.start = start;\\n            this.removed = removed;\\n        }\\n    }\\n    //  125 / 125 test cases passed.\\n    //  Status: Accepted\\n    //  Runtime: 16 ms"
		},
		{
			"lc_ans_id":"75048",
			"view":"3978",
			"top":"6",
			"title":"[recommend for beginners]clean C++ implementation with detailed explaination",
			"vote":"23",
			"content":"    class Solution {\\n    public:\\n        vector<string> removeInvalidParentheses(string s) {\\n            int remove_left=0, remove_right=0, pair=0;\\n            /*** use the unordered_set to deal with the duplicate cases ***/\\n            unordered_set<string> result;\\n            /***  calculate the remained # of left and right parentheses  ***/\\n            for(int i=0; i<s.size(); i++){\\n                if(s[i]=='(')   remove_left++;\\n                else if(s[i]==')'){\\n                    if(remove_left > 0) remove_left--;\\n                    else    remove_right++;\\n                }\\n            }\\n            help(0, 0, remove_left, remove_right, s, \"\", result);\\n            /*** change the unordered_set to vector ***/\\n            return vector<string>(result.begin(), result.end());\\n        }\\n        \\n        /***\\n        pair : record the () pair count in the solution\\n        index : record the cur-position int the string s\\n        remove_left : the number of left parentheses needed to delete\\n        remove_right : the number of right parentheses needed to delete\\n        s : origninal input string    solution : the current produced string\\n        result : stores all the satisfied solution string\\n        ***/\\n        void help(int pair, int index, int remove_left, int remove_right, const string& s, string solution, unordered_set<string>& result){\\n            /***   end condition       ***/\\n            if(index==s.size()){\\n                /*** check whether the remained string solution is right  ***/\\n                if(pair==0 && remove_left==0 && remove_right==0)    result.insert(solution);\\n                return;\\n            }\\n            /***    left-half-parentheses     ***/\\n            if(s[index]=='('){\\n                /***    remove the left-half-parentheses     ***/\\n                if(remove_left > 0)     help(pair, index+1, remove_left-1, remove_right, s, solution, result);\\n                /***    keep  the  left-half-parentheses     ***/\\n                help(pair+1, index+1, remove_left, remove_right, s, solution+s[index], result);\\n            }\\n            /***    right-half-parentheses     ***/\\n            else if(s[index]==')'){\\n                /***    remove the right-half-parentheses     ***/\\n                if(remove_right > 0)     help(pair, index+1, remove_left, remove_right-1, s, solution, result);\\n                /***    keep  the  right-half-parentheses     ***/\\n                if(pair > 0) help(pair-1, index+1, remove_left, remove_right, s, solution+s[index], result);\\n            }\\n            /***    other-characters     ***/\\n            else{\\n                help(pair, index+1, remove_left, remove_right, s, solution+s[index], result);\\n            }\\n        }\\n    };"
		},
		{
			"lc_ans_id":"75095",
			"view":"4024",
			"top":"7",
			"title":"Java optimized DFS solution 3 ms",
			"vote":"20",
			"content":"DFS solution with optimizations:\\n\\n1. Before starting DFS, calculate the total numbers of opening and closing parentheses that need to be removed in the final solution, then these two numbers could be used to speed up the DFS process.\\n2. Use while loop to avoid duplicate result in DFS, instead of using HashSet.\\n3. Use count variable to validate the parentheses dynamically.\\n\\n----------\\n     public class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n            int count = 0, openN = 0, closeN = 0;\\n\\n            // calculate the total numbers of opening and closing parentheses\\n            // that need to be removed in the final solution\\n            for (char c : s.toCharArray()) {\\n                if (c == '(') {\\n                    count++;\\n                } else if (c == ')') {\\n                    if (count == 0) closeN++;\\n                    else count--;\\n                }\\n            }\\n            openN = count;\\n            count = 0;\\n    \\n            if (openN == 0 && closeN == 0) return Arrays.asList(s);\\n    \\n            List<String> result = new ArrayList<>();\\n            StringBuilder sb = new StringBuilder();\\n    \\n            dfs(s.toCharArray(), 0, count, openN, closeN, result, sb);\\n    \\n            return result;\\n        }\\n    \\n        private void dfs(char[] s, int p, int count, int openN, int closeN, List<String> result, StringBuilder sb) {\\n            if (count < 0) return; // the parentheses is invalid\\n\\n            if (p == s.length) {\\n                if (openN == 0 && closeN == 0) { // the minimum number of invalid parentheses have been removed\\n                    result.add(sb.toString());\\n                }\\n                return;\\n            }\\n    \\n            if (s[p] != '(' && s[p] != ')') {\\n                sb.append(s[p]);\\n                dfs(s, p + 1, count, openN, closeN, result, sb);\\n                sb.deleteCharAt(sb.length() - 1);\\n            } else if (s[p] == '(') {\\n                int i = 1;\\n                while (p + i < s.length && s[p + i] == '(') i++; // use while loop to avoid duplicate result in DFS, instead of using HashSet\\n                sb.append(s, p, i);\\n                dfs(s, p + i, count + i, openN, closeN, result, sb);\\n                sb.delete(sb.length() - i, sb.length());\\n    \\n                if (openN > 0) {\\n                    // remove the current opening parenthesis\\n                    dfs(s, p + 1, count, openN - 1, closeN, result, sb);\\n                }\\n            } else {\\n                int i = 1;\\n                while (p + i < s.length && s[p + i] == ')') i++; // use while loop to avoid duplicate result in DFS, instead of using HashSet\\n                sb.append(s, p, i);\\n                dfs(s, p + i, count - i, openN, closeN, result, sb);\\n                sb.delete(sb.length() - i, sb.length());\\n    \\n                if (closeN > 0) {\\n                    // remove the current closing parenthesis\\n                    dfs(s, p + 1, count, openN, closeN - 1, result, sb);\\n                }\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"75046",
			"view":"3801",
			"top":"8",
			"title":"C++ Depth limited DFS 3ms. Eliminate duplicates without hashmap.",
			"vote":"12",
			"content":"num1 and num2 stand for the number of '(' and ')' to remove respectively. Duplicates arise from consecutive '(' or ')'. We only get rid of the first one before going a level further.\\n\\n    class Solution {\\n    private:\\n        bool isValid(string s) {\\n            int sum = 0;\\n            for(char &c : s) {\\n                if(c == '(') ++sum;\\n                else if(c == ')') --sum;\\n                if(sum < 0) return false;\\n            }\\n            return sum == 0;\\n        }\\n    public:\\n        vector<string> removeInvalidParentheses(string s) {\\n            int num1 = 0, num2 = 0;\\n            for(char &c : s) {\\n                num1 += c == '(';\\n                if (num1 == 0) {\\n                    num2 += c == ')';\\n                } else {\\n                    num1 -= c == ')';\\n                }\\n            }\\n            vector<string> ret;\\n            dfs(s, 0, num1, num2, ret);\\n            return ret;\\n        }\\n        void dfs(string s, int beg, int num1, int num2, vector<string> &ret) {\\n            if(num1 == 0 && num2 == 0) {\\n                if(isValid(s))\\n                    ret.push_back(s);\\n            } else {\\n                for(int i = beg; i < s.size(); ++i) {\\n                    string tmp = s;\\n                    if(num2 == 0 && num1 > 0 && tmp[i] == '(') {\\n                        if(i == beg || tmp[i] != tmp[i - 1]) {\\n                            tmp.erase(i, 1);\\n                            dfs(tmp, i, num1 - 1, num2, ret);\\n                        }\\n                    }\\n                    if(num2 > 0 && tmp[i] == ')') {\\n                        if(i == beg || tmp[i] != tmp[i - 1]) {\\n                            tmp.erase(i, 1);\\n                            dfs(tmp, i, num1, num2 - 1, ret);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    };"
		},
		{
			"lc_ans_id":"75038",
			"view":"758",
			"top":"9",
			"title":"Evolve from intuitive solution to optimal - a review of all solutions",
			"vote":"11",
			"content":"There are three challenges. Remove minimum parenthesis, the result is valid and without duplicates.  All BFS and DFS solutions look like O(n2^n), but the performance is different depending on how they solve the challenges. \\n\\nBFS Solutions\\n1. BFS guarantees shortest path. Since the problem asks to remove minimum parenthesis, it is natural think of BFS. A straightforward approach is to remove a parenthesis from the current string until we get a valid string. It generates both duplicate and invalid strings. We can use a hash table to remove duplicates and check each string for validity. [The idea is from @jeantimex.](https://discuss.leetcode.com/topic/28827/share-my-java-bfs-solution) \\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        queue<string> q;\\n        unordered_set<string> ht;\\n        q.push(s);\\n        vector<string> res;\\n        while(!q.empty()) {\\n            string ss = q.front();\\n            q.pop();\\n            if(ht.count(ss)) continue;\\n            ht.insert(ss);\\n            if(isValid(ss)) res.push_back(ss);\\n            else if (res.empty()) \\n                for(int i=0;i<ss.size();i++) \\n                    if(ss[i]==')'|| ss[i]=='(') q.push(ss.substr(0,i)+ss.substr(i+1));\\n        }\\n        return res;\\n    }\\n    bool isValid(string &s) {\\n        int count=0;\\n        for(auto c:s) {\\n            if(c=='(') count++;\\n            if(c==')')\\n                if(count>0) count--;\\n                else return false;\\n        }\\n        return !count;\\n    }\\n```\\n2. We can speed up and get rid of the hash table by generating unique strings only. There are two types of duplicates. First is due to removing the same set of characters in different order. For example, \"**(**()**(**()\", remove 0th then 3rd or remove 3rd then 0th both generates \"()()\". So we can enforce an order by keeping the last removal index and remove after it only. The other is handling consecutive same chars, say, \"(()\". We get the same string by removing either the 0th or 1st '('. We can just remove the 0th.  [The idea is from @dietpepsi.](https://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution)\\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        queue<pair<string,int>> q;\\n        q.push(make_pair(s,0));\\n        vector<string> res;\\n        while(!q.empty()) {\\n            auto p=q.front();\\n            q.pop();\\n            string ss=p.first;\\n            if(isValid(ss)) res.push_back(ss);\\n            else if (res.empty()) \\n                for(int i=p.second;i<ss.size();i++) \\n                    if((ss[i]==')'|| ss[i]=='(') && (i==p.second || ss[i]!=ss[i-1])) \\n                        q.push(make_pair(ss.substr(0,i)+ss.substr(i+1),i));\\n        }\\n        return res;\\n    }\\n```\\n3. The optimal BFS should not generate invalid strings either. Again, [the idea is from @dietpepsi.](https://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution)\\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        queue<tuple<string,int,int,char>> q;\\n        q.push(make_tuple(s,0,0,'('));\\n        vector<string> res;\\n        while(!q.empty()) {\\n            auto t=q.front();\\n            q.pop();\\n            string str=get<0>(t);\\n            int start =get<1>(t), lastRm=get<2>(t), count = 0;\\n            char l = get<3>(t), r = l=='('?')':'(';\\n            for(int i=start; i<str.size();i++) {\\n                if(str[i] == l) count++;\\n                else if(str[i]==r) count--;\\n                if(count>=0) continue;\\n                for(int j=lastRm;j<=i;j++)\\n                    if(str[j]==r && (j==lastRm || str[j-1]!=r))\\n                        q.push(make_tuple(str.substr(0,j)+str.substr(j+1),i,j,l));\\n                break;\\n            }\\n            if(count < 0) continue;\\n            reverse(str.begin(),str.end());\\n            if(l=='(') q.push(make_tuple(str,0,0,')'));\\n            else res.push_back(str);\\n        }\\n        return res;\\n    }\\n```\\nDFS solutions\\n1. A naive DFS is to generate all the 2^n substr. We use hash table to remove duplicates. and then return the longest ones. It is less efficient than BFS because DFS does not guarantee shortest path. So we cannot stop after the first valid strings as in BFS.\\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        unordered_set<string> ht;\\n        string cur;\\n        dfs(0,cur,s,ht);\\n        size_t ml = 0;\\n        for(auto& str:ht) ml = max(ml,str.size());\\n        vector<string> res;\\n        for(auto& str:ht) if(str.size()==ml) res.push_back(str);\\n        return res;\\n    }\\n    void dfs(int p, string& cur, string& s, unordered_set<string>& res) {\\n        if(p==s.size()) {\\n            if(isValid(cur)) res.insert(cur);\\n            return;\\n        }\\n        cur+=s[p];\\n        dfs(p+1,cur,s,res);\\n        cur.pop_back();\\n        if(s[p]=='('||s[p]==')') dfs(p+1,cur,s,res); \\n    }\\n```\\n2. The naive DFS searches from a lot of duplicate states. We can use a hash table to avoid it.\\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        unordered_map<string,int> vstd;\\n        string cur;\\n        unordered_set<string> ht;\\n        dfs(0,cur,s, ht, vstd);\\n        size_t ml = 0;\\n        for(auto& str:ht) ml = max(ml,str.size());\\n        vector<string> res;\\n        for(auto& str:ht) if(str.size()==ml) res.push_back(str);\\n        return res;\\n    }\\n    void dfs(int p, string& cur, string& s, unordered_set<string>& res, unordered_map<string,int>& vstd) {\\n        auto it = vstd.find(cur);\\n        if(it!=vstd.end() && it->second <= p) return;\\n        if(p==s.size()) {\\n            if(isValid(cur)) res.insert(cur);\\n            return;\\n        }\\n        cur+=s[p];\\n        dfs(p+1,cur,s,res,vstd);\\n        cur.pop_back();\\n        if(s[p]=='('||s[p]==')') dfs(p+1,cur,s,res,vstd);\\n        if(it == vstd.end()) vstd[cur] = p;\\n        else it->second = min(it->second,p);\\n    }\\n```\\n3. The above DFS approaches are not efficient at all since they generate strings of all lengths. BFS only removes the minimum number of strings so we should be able to do the same thing in DFS. Since the problem asks to remove minimum number of parenthesis, it is natural to compute the min number first and then use it to guide the DFS. This guarantees we only generate valid strings. The other challenge is to handle duplicate strings. We still use hash table to remove duplicates. The disadvantage is that duplicates are generated so the search space is not minimal. [The idea is from @yavinci](https://discuss.leetcode.com/topic/30743/easiest-9ms-java-solution), \\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        int rmL=0,rmR=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i]=='(') rmL++;\\n            if(s[i]==')') {\\n                if(rmL>0) rmL--;\\n                else rmR++;\\n            } \\n        }\\n        unordered_set<string> res; \\n        string one;\\n        dfs(s, 0, rmL, rmR, 0, one, res);\\n        return vector<string> (res.begin(),res.end());\\n    }\\n    void dfs(string &s, int i, int rmL, int rmR, int pl, string &one, unordered_set<string> &res) {\\n        if(i == s.size() || rmL<0 || rmR<0 ||pl<0) {\\n            if(rmL==0 && rmR==0 && pl==0) res.insert(one);\\n            return;\\n        }\\n        if(s[i]=='(') {\\n            dfs(s,i+1,rmL-1,rmR,pl,one,res);\\n            one+='(';\\n            dfs(s,i+1,rmL,rmR,pl+1,one,res);\\n        } else if(s[i]==')') {\\n            dfs(s,i+1,rmL,rmR-1,pl,one,res);\\n            one+=')';\\n            dfs(s,i+1,rmL,rmR,pl-1,one,res);\\n        } else {\\n            one+=s[i];\\n            dfs(s,i+1,rmL,rmR,pl,one,res);\\n        }\\n        one.pop_back();\\n    } \\n```\\n4. [DFS of unique strings from @cqnkxy ](https://discuss.leetcode.com/topic/28819/c-depth-limited-dfs-3ms-eliminate-duplicates-without-hashmap). Search space is not optimal because it expands from invalid strings.\\n5. [DFS of unique and valid strings from @dietpepsi ](https://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution) This is the optimal solution and source of all the ideas.\\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> res;\\n        dfs(0,0,\"()\",s,res);\\n        return res;\\n    }\\n    void dfs(int p, int lastRm, char dir[], string s, vector<string>& res) {\\n        for(int i=p, count=0;i<s.size();i++) {\\n            if(s[i]==dir[0]) count++;\\n            else if(s[i]==dir[1]) count--;\\n            if(count>=0) continue;\\n            for(int j=lastRm;j<=i;j++)\\n                if(s[j]==dir[1] && (j==lastRm || s[j-1]!=dir[1]))\\n                    dfs(i,j,dir,s.substr(0,j)+s.substr(j+1),res);\\n            return;        \\n        }\\n        reverse(s.begin(),s.end());\\n        if(dir[0]=='(') dfs(0,0,\")(\",s,res);\\n        else res.push_back(s);\\n    }\\n```"
		}
	],
	"id":"301",
	"title":"Remove Invalid Parentheses",
	"content":"<p>\r\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p>\r\n\r\n<p>Note: The input string may contain letters other than the parentheses <code>(</code> and <code>)</code>. \r\n</p>\r\n\r\n<p>\r\n<b>Examples:</b><br/>\r\n<pre>\r\n\"()())()\" -> [\"()()()\", \"(())()\"]\r\n\"(a)())()\" -> [\"(a)()()\", \"(a())()\"]\r\n\")(\" -> [\"\"]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/hpplayer\">@hpplayer</a> for adding this problem and creating all test cases.</p>",
	"frequency":"417",
	"ac_num":"61278"
}