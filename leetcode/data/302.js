{
	"difficulty":"3",
	"submit_num":"35376",
	"show_id":"302",
	"leetcode_id":"302",
	"answers":[
		{
			"lc_ans_id":"75127",
			"view":"17142",
			"top":"0",
			"title":"C++/Java/Python Binary Search solution with explanation",
			"vote":"154",
			"content":"Suppose we have a 2D array\\n\\n    \"000000111000000\"\\n    \"000000101000000\"\\n    \"000000101100000\"\\n    \"000001100100000\"\\n\\n\\nImagine we project the 2D array to the bottom axis with the rule \"if a column has any black pixel it's projection is black otherwise white\". The projected 1D array is\\n    \\n    \"000001111100000\"\\n\\n> **Theorem**\\n>\\n> If there are only one black pixel region, then in a projected 1D array all the black pixels are connected.\\n> \\n> **Proof by contradiction**\\n> \\n> Assume to the contrary that there are disconnected black pixels at `i`\\n> and `j` where `i < j` in the 1D projection array. Thus there exists one\\n> column `k`, `k in (i, j)` and and the column `k` in the 2D array has no\\n> black pixel. Therefore in the 2D array there exists at least 2 black\\n> pixel regions separated by column `k` which contradicting the condition\\n> of \"only one black pixel region\". \\n> \\n> Therefore we conclude that all the black pixels in the 1D projection\\n> array is connected.\\n\\nThis means we can do a binary search in each half to find the boundaries, if we know one black pixel's position. And we do know that.\\n\\nTo find the left boundary, do the binary search in the `[0, y)` range and find the first column vector who has any black pixel. \\n\\nTo determine if a column vector has a black pixel is `O(m)` so the search in total is `O(m log n)`\\n\\nWe can do the same for the other boundaries. The area is then calculated by the boundaries.\\nThus the algorithm runs in `O(m log n + n log m)`\\n\\n\\n**Java**\\n\\n    private char[][] image;\\n    public int minArea(char[][] iImage, int x, int y) {\\n        image = iImage;\\n        int m = image.length, n = image[0].length;\\n        int left = searchColumns(0, y, 0, m, true);\\n        int right = searchColumns(y + 1, n, 0, m, false);\\n        int top = searchRows(0, x, left, right, true);\\n        int bottom = searchRows(x + 1, m, left, right, false);\\n        return (right - left) * (bottom - top);\\n    }\\n    private int searchColumns(int i, int j, int top, int bottom, boolean opt) {\\n        while (i != j) {\\n            int k = top, mid = (i + j) / 2;\\n            while (k < bottom && image[k][mid] == '0') ++k;\\n            if (k < bottom == opt)\\n                j = mid;\\n            else\\n                i = mid + 1;\\n        }\\n        return i;\\n    }\\n    private int searchRows(int i, int j, int left, int right, boolean opt) {\\n        while (i != j) {\\n            int k = left, mid = (i + j) / 2;\\n            while (k < right && image[mid][k] == '0') ++k;\\n            if (k < right == opt)\\n                j = mid;\\n            else\\n                i = mid + 1;\\n        }\\n        return i;\\n    }\\n    //  Runtime: 1 ms\\n\\n\\n\\n**C++**\\n\\n    vector<vector<char>> *image;\\n    int minArea(vector<vector<char>> &iImage, int x, int y) {\\n        image = &iImage;\\n        int m = int(image->size()), n = int((*image)[0].size());\\n        int top = searchRows(0, x, 0, n, true);\\n        int bottom = searchRows(x + 1, m, 0, n, false);\\n        int left = searchColumns(0, y, top, bottom, true);\\n        int right = searchColumns(y + 1, n, top, bottom, false);\\n        return (right - left) * (bottom - top);\\n    }\\n    int searchRows(int i, int j, int low, int high, bool opt) {\\n        while (i != j) {\\n            int k = low, mid = (i + j) / 2;\\n            while (k < high && (*image)[mid][k] == '0') ++k;\\n            if (k < high == opt)\\n                j = mid;\\n            else\\n                i = mid + 1;\\n        }\\n        return i;\\n    }\\n    int searchColumns(int i, int j, int low, int high, bool opt) {\\n        while (i != j) {\\n            int k = low, mid = (i + j) / 2;\\n            while (k < high && (*image)[k][mid] == '0') ++k;\\n            if (k < high == opt)\\n                j = mid;\\n            else\\n                i = mid + 1;\\n        }\\n        return i;\\n    }\\n    // Runtime: 20 ms\\n\\n**Python**\\n\\n\\n    def minArea(self, image, x, y):\\n        top = self.searchRows(image, 0, x, True)\\n        bottom = self.searchRows(image, x + 1, len(image), False)\\n        left = self.searchColumns(image, 0, y, top, bottom, True)\\n        right = self.searchColumns(image, y + 1, len(image[0]), top, bottom, False)\\n        return (right - left) * (bottom - top)\\n\\n    def searchRows(self, image, i, j, opt):\\n        while i != j:\\n            m = (i + j) / 2\\n            if ('1' in image[m]) == opt:\\n                j = m\\n            else:\\n                i = m + 1\\n        return i\\n\\n    def searchColumns(self, image, i, j, top, bottom, opt):\\n        while i != j:\\n            m = (i + j) / 2\\n            if any(image[k][m] == '1' for k in xrange(top, bottom)) == opt:\\n                j = m\\n            else:\\n                i = m + 1\\n        return i\\n    # Runtime: 56 ms\\n\\n\\n**Java (DRY)**\\n\\n\\n    private char[][] image;\\n    public int minArea(char[][] iImage, int x, int y) {\\n        image = iImage;\\n        int m = image.length, n = image[0].length;\\n        int top = search(0, x, 0, n, true, true);\\n        int bottom = search(x + 1, m, 0, n, false, true);\\n        int left = search(0, y, top, bottom, true, false);\\n        int right = search(y + 1, n, top, bottom, false, false);\\n        return (right - left) * (bottom - top);\\n    }\\n    private boolean isWhite(int mid, int k, boolean isRow) {\\n        return ((isRow) ? image[mid][k] : image[k][mid]) == '0';\\n    }\\n    private int search(int i, int j, int low, int high, boolean opt, boolean isRow) {\\n        while (i != j) {\\n            int k = low, mid = (i + j) / 2;\\n            while (k < high && isWhite(mid, k, isRow)) ++k;\\n            if (k < high == opt)\\n                j = mid;\\n            else\\n                i = mid + 1;\\n        }\\n        return i;\\n    }\\n    //  Runtime: 2 ms\\n\\n**C++ (DRY)**\\n\\n    vector<vector<char>> *image;\\n    int minArea(vector<vector<char>> &iImage, int x, int y) {\\n        image = &iImage;\\n        int m = int(image->size()), n = int((*image)[0].size());\\n        int top = search(0, x, 0, n, true, true);\\n        int bottom = search(x + 1, m, 0, n, false, true);\\n        int left = search(0, y, top, bottom, true, false);\\n        int right = search(y + 1, n, top, bottom, false, false);\\n        return (right - left) * (bottom - top);\\n    }\\n    bool isWhite(int mid, int k, bool isRow) {\\n        return ((isRow) ? (*image)[mid][k]:(*image)[k][mid]) == '0';\\n    }\\n    int search(int i, int j, int low, int high, bool opt, bool isRow) {\\n        while (i != j) {\\n            int k = low, mid = (i + j) / 2;\\n            while (k < high && isWhite(mid, k, isRow)) ++k;\\n            if (k < high == opt)\\n                j = mid;\\n            else\\n                i = mid + 1;\\n        }\\n        return i;\\n    }\\n    // Runtime: 24 ms\\n\\n\\n\\n**Python (DRY, from Stefan's cool [solution][1])**\\n\\n    def minArea(self, image, x, y):\\n        top = self.search(0, x, lambda mid: '1' in image[mid])\\n        bottom = self.search(x + 1, len(image), lambda mid: '1' not in image[mid])\\n        left = self.search(0, y, lambda mid: any(image[k][mid] == '1' for k in xrange(top, bottom)))\\n        right = self.search(y + 1, len(image[0]), lambda mid: all(image[k][mid] == '0' for k in xrange(top, bottom)))\\n        return (right - left) * (bottom - top)\\n\\n    def search(self, i, j, check):\\n        while i != j:\\n            mid = (i + j) / 2\\n            if check(mid):\\n                j = mid\\n            else:\\n                i = mid + 1\\n        return i\\n    # Runtime: 56 ms\\n\\n\\n  [1]: https://leetcode.com/discuss/68407/clear-binary-search-python"
		},
		{
			"lc_ans_id":"75128",
			"view":"5965",
			"top":"1",
			"title":"1ms Concise Java Binary Search (DFS is 4ms)",
			"vote":"47",
			"content":"If we don't know programming, how do we find the 4 boundaries  given a black pixel?\\n\\nDo we need to search every black cell? Absolutely not. \\n\\nIntuitively, we would expand from the given `1 * 1` black cell, \"aggressively\" expand to the 4 boundaries, roughly half of the remaining space. If we don't \"cut\" any black pixel, we know we go too far and should go back half. \\n\\nThis is exactly the process of binary search. \\n\\nOne simple way without any worry about boundary, is as follows:\\n* Use a vertical line, to jump to the `leftmost` black pixel , in the range of `[0, y]`\\n* Use a vertical line, to jump to the `rightmost` black pixel, in the range of `[y, n - 1]`\\n* Use a horizontal line, to jump to the `topmost` black pixel, in the range of `[0, x]`\\n* Use a horizontal line, to jump to the `bottommost` black pixel, in the range of `[x, m - 1]`\\n\\nHope it helps!\\n\\n    public int minArea(char[][] image, int x, int y) {\\n        int left = leftmost(image, 0, y, true);\\n        int right = rightmost(image, y, image[0].length - 1, true);\\n        int top = leftmost(image, 0, x, false);\\n        int bottom = rightmost(image, x, image.length - 1, false);\\n        return (right - left + 1) * (bottom - top + 1);\\n    }\\n    \\n    int leftmost(char[][] image, int min, int max, boolean horizontal) {\\n        int l = min, r = max;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (!hasBlack(image, mid, horizontal)) {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    int rightmost(char[][] image, int min, int max, boolean horizontal) {\\n        int l = min, r = max;\\n        while (l < r) {\\n            int mid = l + (r - l + 1) / 2;\\n            if (!hasBlack(image, mid, horizontal)) {\\n                r = mid - 1;\\n            } else {\\n                l = mid;\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    boolean hasBlack(char[][] image, int mid, boolean horizontal) {\\n        if (horizontal) {\\n            for (int i = 0; i < image.length; i++) {\\n                if (image[i][mid] == '1') {\\n                    return true;\\n                }\\n            }\\n        } else {\\n            for (int j = 0; j < image[0].length; j++) {\\n                if (image[mid][j] == '1') {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n<hr>\\nVersion 2: Another harder but more compact way is as follows:\\n\\n    public int minArea(char[][] image, int x, int y) {\\n        int m = image.length, n = image[0].length;\\n        int colMin = binarySearch(image, true, 0, y, 0, m, true);\\n        int colMax = binarySearch(image, true, y + 1, n, 0, m, false);\\n        int rowMin = binarySearch(image, false, 0, x, colMin, colMax, true);\\n        int rowMax = binarySearch(image, false, x + 1, m, colMin, colMax, false);\\n        return (rowMax - rowMin) * (colMax - colMin);\\n    }\\n\\n    public int binarySearch(char[][] image, boolean horizontal, int lower, int upper, int min, int max, boolean goLower) {\\n        while(lower < upper) {\\n            int mid = lower + (upper - lower) / 2;\\n            boolean inside = false;\\n            for(int i = min; i < max; i++) {\\n                if((horizontal ? image[i][mid] : image[mid][i]) == '1') {\\n                    inside = true; \\n                    break;\\n                }\\n            }\\n            if(inside == goLower) {\\n                upper = mid;\\n            } else {\\n                lower = mid + 1;\\n            }\\n        }\\n        return lower;\\n    }"
		},
		{
			"lc_ans_id":"75130",
			"view":"3996",
			"top":"2",
			"title":"Clear binary search Python",
			"vote":"20",
			"content":"Based on my [**shorter Ruby version**](https://leetcode.com/discuss/68335/ruby-binary-search). Still using ruichang's idea to use binary search.\\n\\n    def minArea(self, image, x, y):\\n        def first(lo, hi, check):\\n            while lo < hi:\\n                mid = (lo + hi) / 2\\n                if check(mid):\\n                    hi = mid\\n                else:\\n                    lo = mid + 1\\n            return lo\\n        top    = first(0, x,             lambda x: '1' in image[x])\\n        bottom = first(x, len(image),    lambda x: '1' not in image[x])\\n        left   = first(0, y,             lambda y: any(row[y] == '1' for row in image))\\n        right  = first(y, len(image[0]), lambda y: all(row[y] == '0' for row in image))\\n        return (bottom - top) * (right - left)\\n\\nThe `first` function could also use the `bisect` module, for example:\\n\\n        def first(lo, hi, check):\\n            self.__getitem__ = check\\n            return bisect.bisect(self, False, lo, hi)\\n\\n        def first(lo, hi, check):\\n            class Checker: __getitem__ = staticmethod(check)\\n            return bisect.bisect(Checker(), False, lo, hi)\\n\\nThe first one is a bit dirtier, and requires `class Solution:` instead of `class Solution(object):`."
		},
		{
			"lc_ans_id":"75173",
			"view":"2754",
			"top":"3",
			"title":"Java DFS Solution and seeking for a binary search solution.",
			"vote":"15",
			"content":"DFS or BFS is the intuitive solution for this problem while the problem is with a tag \"binary search\". So can anyone provide a binary search answer. DFS complexity is O(m * n) and if binary search it would be O(n * lgm  + m * lgn)\\n\\n    public class Solution {\\n        private int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE, maxX = 0, maxY = 0;\\n        public int minArea(char[][] image, int x, int y) {\\n            if(image == null || image.length == 0 || image[0].length == 0) return 0;\\n            dfs(image, x, y);\\n            return(maxX - minX + 1) * (maxY - minY + 1);\\n        }\\n        private void dfs(char[][] image, int x, int y){\\n            int m = image.length, n = image[0].length;\\n            if(x < 0 || y < 0 || x >= m || y >= n || image[x][y] == '0') return;\\n            image[x][y] = '0';\\n            minX = Math.min(minX, x);\\n            maxX = Math.max(maxX, x);\\n            minY = Math.min(minY, y);\\n            maxY = Math.max(maxY, y);\\n            dfs(image, x + 1, y);\\n            dfs(image, x - 1, y);\\n            dfs(image, x, y - 1);\\n            dfs(image, x, y + 1);\\n        }\\n        \\n    }"
		},
		{
			"lc_ans_id":"75146",
			"view":"1587",
			"top":"4",
			"title":"Very easy DFS JAVA solution with comments",
			"vote":"8",
			"content":"    public class Solution {\\n        public int minArea (char[][] image, int x, int y) {\\n            int column = image.length; // vertical\\n            if (column == 0) return 0;\\n            int row = image[0].length; // horizontal\\n            \\n            int[] res = new int[4];\\n            res[0] = column-1; // initial upper bound value\\n            res[1] = 0;        // initial bottom bound value\\n            res[2] = row - 1;  // initial left bound value\\n            res[3] = 0;        // initial right bound value\\n            dfs(image, x, y, res);\\n            return (res[1]-res[0]+1) * (res[3]-res[2]+1); // (bot - upper + 1) * (right - left + 1)\\n        }\\n        \\n        public void dfs(char[][] image, int x, int y, int[] res) {\\n            int column = image.length;\\n            int row = image[0].length;\\n            if (x < 0 || x > column-1 || y < 0 || y > row-1) return; \\n            if (image[x][y] == '0') return;\\n            image[x][y] = '0';          // once visit, set to 0\\n            \\n            if (x < res[0]) res[0] = x; // update upper bound\\n            if (x > res[1]) res[1] = x; // update bottom bound\\n            if (y < res[2]) res[2] = y; // update left bound\\n            if (y > res[3]) res[3] = y; // update right bound\\n            \\n            dfs(image, x+1, y, res);\\n            dfs(image, x, y+1, res);\\n            dfs(image, x-1, y, res);\\n            dfs(image, x, y-1, res);\\n        }\\n    }"
		},
		{
			"lc_ans_id":"75129",
			"view":"253",
			"top":"5",
			"title":"If do DFS on this problem, isn't the time complexity O(n)?",
			"vote":"2",
			"content":"I read many binary search solution, good, but time complexity is n*O(n)\\nI feel like DSF on this problem is O(n), am I wrong,\\nwe only go thru '1' grids and once for each, so it is O(n) ?"
		},
		{
			"lc_ans_id":"75166",
			"view":"461",
			"top":"6",
			"title":"Please update the function's declaration",
			"vote":"2",
			"content":"    public class Solution {\\n          public int minArea(char[][] image, int x, int y) {\\n          }\\n    }\\n\\nx and y are really confusing here, could admin update those to row and col? Because row actually is \"y\" and col actually is  \"x\". I think the declaration below is much clear.\\n\\n    public class Solution {\\n          public int minArea(char[][] image, int row, int col) {\\n          }  \\n    }"
		},
		{
			"lc_ans_id":"75169",
			"view":"1255",
			"top":"7",
			"title":"DFS, BFS, binary search and brute force interation.",
			"vote":"2",
			"content":"I will show four algorithms and corresponding complexity;\\n\\n - DFS : roughly 4k * n^2, k means the factor of num of '1' cell versus image size;  This algorithm performs well while k  << log2(N) / N;\\n - BFS : same as DFS\\n - Binary Search: search for the bounding row and col which has '1', which performs well while many cells are filled with '1'\\n - brute force: just iterate all of the cells and calc the min_x, min_y, max_x, max_y;\\n\\nDFS\\n\\n    class Solution {\\n        vector<pair<int, int>> dirs;\\n    public:\\n        Solution(){\\n            dirs = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n        }\\n        int minArea(vector<vector<char>>& image, int x, int y) {\\n            image[x][y] = '2';\\n            fill_to_boundary(image, x, y);\\n            \\n            int xdim, ydim;\\n            xdim = ydim = 0;\\n            \\n            for(int i = 0; i <= image.size() - 1; ++i){\\n                if (image[i][y] == '2'){\\n                    ++xdim;\\n                }\\n            }\\n            for(int i = 0; i <= image[0].size() - 1; ++i){\\n                if (image[x][i] == '2'){\\n                    ++ydim;\\n                }\\n            }\\n            return  xdim * ydim;\\n        }\\n    \\n        void fill_to_boundary(vector<vector<char>>& image, int x, int y){\\n            for(int i = 0; i < dirs.size(); ++i){\\n                int row = x + dirs[i].first;\\n                int col = y + dirs[i].second;\\n                if (row >=0 && row <= image.size() - 1 && col >= 0 && col <= image[0].size() - 1 && need_change(image, row, col)){\\n                    image[row][col] = '2';\\n                    fill_to_boundary(image, row, col);\\n                }\\n            }\\n        }\\n        bool need_change(vector<vector<char>>& image, int x, int y){\\n            if (image[x][y] == '1') return true;\\n            if (image[x][y] == '2') return false;\\n            int count = 0;\\n            for(int i = 0; i < dirs.size(); ++i){\\n                int row = x + dirs[i].first;\\n                int col = y + dirs[i].second;\\n                if (row >=0 && row <= image.size() - 1 && col >= 0 && col <= image[0].size() - 1 && (image[row][col] == '1' || image[row][col] == '2')){\\n                    ++ count;\\n                }\\n            }\\n            if (count > 1){\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n    };\\n\\n\\nBrute Force\\n\\n    class Solution {\\n    public:\\n        int minArea(vector<vector<char>>& image, int x, int y) {\\n            int x_min = INT_MAX, y_min = INT_MAX, x_max = INT_MIN, y_max = INT_MIN;\\n            for(int i = 0; i < image.size(); ++i){\\n                for(int j = 0; j < image[0].size(); ++j){\\n                    if (image[i][j] == '1'){\\n                        x_min = min(x_min, i);\\n                        y_min = min(y_min, j);\\n                        x_max = max(x_max, i);\\n                        y_max = max(y_max, j);\\n                    }\\n                }\\n            }\\n            return (x_max - x_min + 1) * (y_max - y_min + 1);\\n        }\\n    };\\n\\n\\nBinary Search:\\n\\nMaybe you can refer to https://leetcode.com/discuss/68246/c-java-python-binary-search-solution-with-explanation"
		},
		{
			"lc_ans_id":"75177",
			"view":"760",
			"top":"8",
			"title":"C++ DFS Solution - Have no idea how to apply binary search in a proper way for this problem",
			"vote":"2",
			"content":"    class Solution {\\n    public:\\n        int minArea(vector<vector<char>>& image, int x, int y) {\\n            if(image.size() == 0)\\n                return 0;\\n            int n = image.size(), m = image[0].size();\\n            int miny = m - 1, maxy = 0, maxx = 0, minx = n;\\n            dfs(image, minx, maxx, miny, maxy, x, y);\\n            return (maxx - minx + 1)*(maxy - miny + 1);\\n        }\\n    private:\\n        void dfs(vector<vector<char>>& image, int &minx, int &maxx, int &miny, int &maxy, int x, int y){\\n            minx = min(minx, x);\\n            maxx = max(maxx, x);\\n            miny = min(miny, y);\\n            maxy = max(maxy, y);\\n            image[x][y] = '0';\\n            if(x >= 1 && image[x - 1][y] == '1')\\n                dfs(image, minx, maxx, miny, maxy, x - 1, y);\\n            if(x < image.size() - 1 && image[x + 1][y] == '1')\\n                dfs(image, minx, maxx, miny, maxy, x + 1, y);\\n            if(y >= 1 && image[x][y - 1] == '1')\\n                dfs(image, minx, maxx, miny, maxy, x, y - 1);\\n            if(y < image[0].size() - 1 && image[x][y + 1] == '1')\\n                dfs(image, minx, maxx, miny, maxy, x, y + 1);\\n        }\\n    };"
		},
		{
			"lc_ans_id":"75141",
			"view":"120",
			"top":"9",
			"title":"What is the purpose of  x and y?",
			"vote":"1",
			"content":"<b>For this problem, what is the purpose of x and y ??</b>\\nI think these two parameters are redundant , considering  all the black pixels are connected.\\nThere is only one black block existed in the matrix, so the result is unique."
		}
	],
	"id":"302",
	"title":"Smallest Rectangle Enclosing Black Pixels",
	"content":"<p>An image is represented by a binary matrix with <code>0</code> as a white pixel and <code>1</code> as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location <code>(x, y)</code> of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.</p>\r\n\r\n<p>\r\nFor example, given the following image:\r\n<pre>\r\n[\r\n  \"0010\",\r\n  \"0110\",\r\n  \"0100\"\r\n]\r\n</pre>\r\nand <code>x = 0</code>, <code>y = 2</code>,\r\n</p>\r\n\r\n<p>\r\nReturn <code>6</code>.\r\n</p>",
	"frequency":"85",
	"ac_num":"16420"
}