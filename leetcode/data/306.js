{
	"difficulty":"2",
	"submit_num":"105569",
	"show_id":"306",
	"leetcode_id":"306",
	"answers":[
		{
			"lc_ans_id":"75567",
			"view":"16689",
			"top":"0",
			"title":"Java Recursive and Iterative Solutions",
			"vote":"73",
			"content":"The idea is quite straight forward. Generate the first and second of the sequence, check if the rest of the string match the sum recursively. `i` and `j` are length of the first and second number. `i` should in the range of `[0, n/2]`. The length of their sum should `>= max(i,j)`\\n\\n**Java Recursive**\\n\\n    import java.math.BigInteger;\\n\\n    public class Solution {\\n        public boolean isAdditiveNumber(String num) {\\n            int n = num.length();\\n            for (int i = 1; i <= n / 2; ++i) {\\n                if (num.charAt(0) == '0' && i > 1) return false;\\n                BigInteger x1 = new BigInteger(num.substring(0, i));\\n                for (int j = 1; Math.max(j, i) <= n - i - j; ++j) {\\n                    if (num.charAt(i) == '0' && j > 1) break;\\n                    BigInteger x2 = new BigInteger(num.substring(i, i + j));\\n                    if (isValid(x1, x2, j + i, num)) return true;\\n                }\\n            }\\n            return false;\\n        }\\n        private boolean isValid(BigInteger x1, BigInteger x2, int start, String num) {\\n            if (start == num.length()) return true;\\n            x2 = x2.add(x1);\\n            x1 = x2.subtract(x1);\\n            String sum = x2.toString();\\n            return num.startsWith(sum, start) && isValid(x1, x2, start + sum.length(), num);\\n        }\\n    }\\n    // Runtime: 8ms\\n\\nSince `isValid` is a tail recursion it is very easy to turn it into a loop.\\n\\n**Java Iterative**\\n\\n    public class Solution {\\n        public boolean isAdditiveNumber(String num) {\\n            int n = num.length();\\n            for (int i = 1; i <= n / 2; ++i)\\n                for (int j = 1; Math.max(j, i) <= n - i - j; ++j)\\n                    if (isValid(i, j, num)) return true;\\n            return false;\\n        }\\n        private boolean isValid(int i, int j, String num) {\\n            if (num.charAt(0) == '0' && i > 1) return false;\\n            if (num.charAt(i) == '0' && j > 1) return false;\\n            String sum;\\n            BigInteger x1 = new BigInteger(num.substring(0, i));\\n            BigInteger x2 = new BigInteger(num.substring(i, i + j));\\n            for (int start = i + j; start != num.length(); start += sum.length()) {\\n                x2 = x2.add(x1);\\n                x1 = x2.subtract(x1);\\n                sum = x2.toString();\\n                if (!num.startsWith(sum, start)) return false;\\n            }\\n            return true;\\n        }\\n    }\\n    // Runtime: 9ms\\n\\n\\nIf no overflow, instead of BigInteger we can consider to use Long which is a lot faster.\\n\\n**Java Iterative Using Long**\\n\\n    public class Solution {\\n        public boolean isAdditiveNumber(String num) {\\n            int n = num.length();\\n            for (int i = 1; i <= n / 2; ++i)\\n                for (int j = 1; Math.max(j, i) <= n - i - j; ++j)\\n                    if (isValid(i, j, num)) return true;\\n            return false;\\n        }\\n        private boolean isValid(int i, int j, String num) {\\n            if (num.charAt(0) == '0' && i > 1) return false;\\n            if (num.charAt(i) == '0' && j > 1) return false;\\n            String sum;\\n            Long x1 = Long.parseLong(num.substring(0, i));\\n            Long x2 = Long.parseLong(num.substring(i, i + j));\\n            for (int start = i + j; start != num.length(); start += sum.length()) {\\n                x2 = x2 + x1;\\n                x1 = x2 - x1;\\n                sum = x2.toString();\\n                if (!num.startsWith(sum, start)) return false;\\n            }\\n            return true;\\n        }\\n    }\\n    // Runtime: 3ms"
		},
		{
			"lc_ans_id":"75576",
			"view":"13476",
			"top":"1",
			"title":"0ms concise C++ solution (perfectly handles the follow-up and leading 0s)",
			"vote":"67",
			"content":"use a helper function to add two strings. \\n\\nChoose first two number then recursively check.\\n\\n**Note that the length of first two numbers can't be longer than half of the initial string, so the two loops in the first function will end when *i>num.size()/2*  and *j>(num.size()-i)/2*, this will actually save a lot of time.**\\n\\n\\n**Update the case of heading 0s\\ne.g. \"100010\" should return false**\\n\\n\\n    class Solution {\\n    public:\\n            bool isAdditiveNumber(string num) {\\n                for(int i=1; i<=num.size()/2; i++){\\n                    for(int j=1; j<=(num.size()-i)/2; j++){\\n                        if(check(num.substr(0,i), num.substr(i,j), num.substr(i+j))) return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            bool check(string num1, string num2, string num){\\n                if(num1.size()>1 && num1[0]=='0' || num2.size()>1 && num2[0]=='0') return false;\\n                string sum=add(num1, num2);\\n                if(num==sum) return true;\\n                if(num.size()<=sum.size() || sum.compare(num.substr(0,sum.size()))!=0) return false;\\n                else return check(num2, sum, num.substr(sum.size()));\\n            } \\n            string add(string n, string m){\\n                string res;\\n                int i=n.size()-1, j=m.size()-1, carry=0;\\n                while(i>=0 || j>=0){\\n                    int sum=carry+(i>=0 ? (n[i--]-'0') : 0) + (j>=0?  (m[j--]-'0') : 0);\\n                    res.push_back(sum%10+'0');\\n                    carry=sum/10;\\n                }\\n                if(carry) res.push_back(carry+'0');\\n                reverse(res.begin(), res.end());\\n                return res;\\n            }\\n        };"
		},
		{
			"lc_ans_id":"75572",
			"view":"9198",
			"top":"2",
			"title":"*Java* very straightforward solution with detailed explanation",
			"vote":"49",
			"content":"The idea is quite straightforward:\\n\\n1. Choose the first number `A`, it can be the leftmost `1` up to `i` digits. `i<=(L-1)/2` because the third number should be at least as long as the first number\\n\\n2. Choose the second number `B`, it can be the leftmost `1` up to `j` digits excluding the first number. the limit for `j` is a little bit tricky, because we don't know whether `A` or `B` is longer. The remaining string (with length `L-j`) after excluding `A` and `B` should have a length of at least max(length `A`, length `B`), where length `A` = `i` and length `B` = `j-i`, thus `L-j >= max(j-i, i)`\\n\\n3. Calls the recursive checker function and returns true if passes the checker function, or continue to the next choice of `B` (`A`) until there is no more choice for `B` or `A`, in which case returns a false.\\n\\nHere is the code in Java:\\n\\n        public boolean isAdditiveNumber(String num) {\\n            int L = num.length();\\n\\n            // choose the first number A\\n            for(int i=1; i<=(L-1)/2; i++) {\\n                // A cannot start with a 0 if its length is more than 1\\n                if(num.charAt(0) == '0' && i>=2) break; //previous code: continue;\\n            \\n                // choose the second number B\\n                for(int j=i+1; L-j>=j-i && L-j>=i; j++) {\\n                    // B cannot start with a 0 if its length is more than 1\\n                    if(num.charAt(i) == '0' && j-i>=2) break; // previous: continue;\\n                \\n                    long num1 = Long.parseLong(num.substring(0, i)); // A\\n                    long num2 = Long.parseLong(num.substring(i, j)); // B\\n                    String substr = num.substring(j); // remaining string\\n                \\n                    if(isAdditive(substr, num1, num2)) return true; // return true if passes isAdditive test\\n                    // else continue; // continue for loop if does not pass isAdditive test\\n                }\\n            }\\n            return false; // does not pass isAdditive test, thus is not additive\\n        }\\n    \\n        // Recursively checks if a string is additive\\n        public boolean isAdditive(String str, long num1, long num2) {\\n            if(str.equals(\"\")) return true; // reaches the end of string means a yes\\n        \\n            long sum = num1+num2;\\n            String s = ((Long)sum).toString();\\n            if(!str.startsWith(s)) return false; // if string does not start with sum of num1 and num2, returns false\\n        \\n            return isAdditive(str.substring(s.length()), num2, sum); // recursively checks the remaining string\\n        }\\n\\nIf you are interested in my other posts, please feel free to check my Github page here: [https://github.com/F-L-A-G/Algorithms-in-Java][1]\\n\\n\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java"
		},
		{
			"lc_ans_id":"75578",
			"view":"6205",
			"top":"3",
			"title":"Python solution",
			"vote":"31",
			"content":"Just trying all possibilities for the first two numbers and checking whether the rest fits.\\n\\n    def isAdditiveNumber(self, num):\\n        n = len(num)\\n        for i, j in itertools.combinations(range(1, n), 2):\\n            a, b = num[:i], num[i:j]\\n            if b != str(int(b)):\\n                continue\\n            while j < n:\\n                c = str(int(a) + int(b))\\n                if not num.startswith(c, j):\\n                    break\\n                j += len(c)\\n                a, b = b, c\\n            if j == n:\\n                return True\\n        return False"
		},
		{
			"lc_ans_id":"75651",
			"view":"3991",
			"top":"4",
			"title":"Backtracking with Pruning: Java 3 ms Solution and Python 48 ms Solution",
			"vote":"16",
			"content":"Backtracking with Pruning.\\n\\nJava (3 ms):\\n    \\n    public class Solution {\\n        public boolean isAdditiveNumber(String num) {\\n            if (num == null || num.length() < 3) return false;\\n            int n = num.length();\\n            for (int i = 1; i < n; i++) {\\n                if (i > 1 && num.charAt(0) == '0') break;\\n                for (int j = i+1; j < n; j++) {\\n                    int first = 0, second = i, third = j;\\n                    if (num.charAt(second) == '0' && third > second+1) break;\\n                    while (third < n) {\\n                        Long result = (Long.parseLong(num.substring(first, second)) + \\n                                       Long.parseLong(num.substring(second, third)) );\\n                        if (num.substring(third).startsWith(result.toString())) {\\n                            first = second; second = third; third += result.toString().length();\\n                        }\\n                        else {\\n                            break;\\n                        }\\n                    }\\n                    if (third == n) return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n\\n Python (48 ms):\\n\\n    class Solution(object):\\n        def isAdditiveNumber(self, num):\\n            \"\"\"\\n            :type num: str\\n            :rtype: bool\\n            \"\"\"\\n            if num is None or len(num) < 3:\\n                return False\\n            n = len(num)\\n            for i in range(1, n):\\n                if i > 1 and num[0] == '0':\\n                    break\\n                for j in range(i+1, n):\\n                    first, second, third = 0, i, j\\n                    if num[second] == '0' and third > second + 1:\\n                        break\\n                    while third < n:\\n                        result = str(int(num[first:second]) + int(num[second:third]))\\n                        if num[third:].startswith(result):\\n                            first, second, third = second, third, third + len(result)\\n                        else:\\n                            break\\n                    if third == n:\\n                        return True\\n            return False"
		},
		{
			"lc_ans_id":"75697",
			"view":"1566",
			"top":"5",
			"title":"Java Easy Understand DFS",
			"vote":"14",
			"content":"    public class Solution {\\n        public boolean isAdditiveNumber(String s) {\\n            int n = s.length();\\n            for (int i=1; i<n; i++) {\\n                for (int j=i+1; j<n; j++) {\\n                    long a = parse(s.substring(0, i));\\n                    long b = parse(s.substring(i, j));\\n                    if (a == -1 || b == -1) continue;\\n                    if (dfs(s.substring(j), a, b))   return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        boolean dfs(String s, long a, long b) {\\n            if (s.length() == 0)    return true;\\n            \\n            for (int i=1; i<=s.length(); i++) {\\n                long c = parse(s.substring(0, i));\\n                if (c == -1)    continue;\\n                if (c-a == b && dfs(s.substring(i), b, c)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        long parse(String s) {\\n            if (!s.equals(\"0\") && s.startsWith(\"0\"))    return -1;\\n            long result = 0;\\n            try {\\n                result = Long.parseLong(s);\\n            } catch (NumberFormatException e) {\\n                return -1;\\n            }\\n            return result;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"75617",
			"view":"871",
			"top":"6",
			"title":"Best solution enclosed with detailed explanation in C++",
			"vote":"10",
			"content":"### Solution\\n\\n#### Analysis\\nFirst let's do some analysis:\\n\\n- backtracking is quite direct choice here, select different lengths for the preceding two numbers and the third number but there are some conditions should be taken into account; \\n- the sum of preceding two numbers should be equal to the third number, so we have to clearly specify the three numbers in the string; simply we can use a index `pos` to point to the start of the three numbers, the length of the first and second number then the third number will be started at the index `pos+len1+len2`, if this checking `num3 == num1+num3` passes, then we should move further and now the first number should be the previous second number and the second number should be the previous third number and the starting `pos` should be `pos+len1`;\\n- the termination condition will be that the `starting position of the third number` is the end of the string but since we at least should check three numbers, so if encountering the termination while the `starting position of the current first number` is 0 then return false;\\n- as the problem indicates, no `leading zero`; so if the length of the first and second number is larger than 1 and if the first character of the number is zero, then directly we should return false;\\n- overflow is another issue here, preceding numbers' upper limit can be INT_MAX but the third should be loose comparably; so we have to take advantage of `atol` instead of `atoi` here to convert string to long integer.\\n\\n#### Improvements\\n\\nActually we don't need to check each possibility for the numbers, the following are some cases for us to accelerate the checking.\\n- the length of first number should be less then `len/2` since the third is the sum of the first two; the length of the second number should also follow the rule;\\n- as for the third number, as soon as the third number is bigger than the sum of the first two we can just directly return false to terminate further checking;\\n- just as analysis presented, we can take advantage of the `leading zero` to accelerate the third number checking process; once the length of the third number is bigger than 1 and there is a leading zero, then just return false to terminate further checking in third number.\\n- another consideration is the starting length of the third number, since it's the sum of the previous two numbers, so the length of it should be at least the maximal of the previous two, which also accelerate the checking process.\\n\\nThe whole solution in C++ lies below.\\n\\n```\\nclass Solution {\\nprivate:\\n    bool check(const string& s, int pos, int len1, int len2)\\n    {\\n        int start = pos+len1+len2;\\n        if(start == s.length()) { if(pos==0) return false; return true; }\\n        int minLen = max(len1, len2);\\n        if((s[pos]=='0'&&len1>1) || (s[pos+len1]=='0'&&len2>1)) return false;\\n        long num1 = atol(s.substr(pos, len1).c_str()), num2 = atol(s.substr(pos+len1, len2).c_str());\\n        if(num1>INT_MAX || num2>INT_MAX) return false;\\n        for(int l = minLen; l <= (int)s.length()-start; ++l)\\n        {\\n            if(l>1 && s[start]=='0') return false;\\n            long num3 = atol(s.substr(start, l).c_str());\\n            if(num3 > num1+num2) return false;\\n            if(num3==num1+num2 && check(s, pos+len1, len2, l)) return true; \\n        }\\n        return false;\\n    }\\npublic:\\n    bool isAdditiveNumber(string s) \\n    {\\n        int len = s.length();\\n        for(int l1 = 1; l1 <= len/2; ++l1)\\n            for(int l2 = 1; l2 < len-max(l1, l2); ++l2)\\n                if(check(s, 0, l1, l2)) return true;\\n        return false;\\n    }\\n};\\n```\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!"
		},
		{
			"lc_ans_id":"75704",
			"view":"845",
			"top":"7",
			"title":"My Simple C++ Non-recursion Solution",
			"vote":"10",
			"content":"    class Solution {\\n    public:\\n        bool isAdditiveNumber(string num) {\\n            for (int i = 1; i < num.size(); ++i) {\\n                for (int j = i + 1; j < num.size(); ++j) {\\n                    string s1 = num.substr(0, i);\\n                    string s2 = num.substr(i, j - i);\\n                    long long d1 = atoll(s1.c_str()), d2 = atoll(s2.c_str());\\n    \\t\\t\\t\\tif ((s1.size() > 1 && s1[0] == '0') || (s2.size() > 1 && s2[0] == '0')) continue;\\n                    long long next = d1 + d2;\\n                    string nexts = to_string(next);\\n                    string now = s1 + s2 + nexts;\\n                    while (now.size() < num.size()) {\\n                        d1 = d2;\\n                        d2 = next;\\n                        next = d1 + d2;\\n                        nexts = to_string(next);\\n                        now += nexts;\\n                    }\\n                    if (now == num) return true;\\n                }\\n            }\\n            return false;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"75570",
			"view":"1628",
			"top":"8",
			"title":"Simple java solution",
			"vote":"9",
			"content":"    public boolean isAdditiveNumber(String num) {\\n        String a = \"\";\\n        String b = \"\";\\n        for (int i = 0; i < num.length()/3; i++) {\\n            a = num.substring(0, i + 1);\\n            if (a.length() > 1 && a.charAt(0) == '0') {\\n                continue;\\n            }\\n            for (int j = i + 1; j < num.length(); j++) {\\n                b = num.substring(i + 1, j + 1);\\n                if (b.charAt(0) == '0' && b.length() > 1) {continue;}\\n                if (valid(num.substring(j + 1), Long.parseLong(a), Long.parseLong(b))) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    public boolean valid(String str, long a, long b) {\\n        long sum = a + b;\\n        String tempStr = String.valueOf(sum);\\n        int len = tempStr.length();\\n        if (str.length() < len) {return false;}\\n        if (str.length() == len && str.equals(tempStr)) {return true;}\\n        if (str.substring(0, len).equals(tempStr)) {\\n            return valid(str.substring(len), b, sum);\\n        }\\n        return false;\\n    }"
		},
		{
			"lc_ans_id":"75650",
			"view":"968",
			"top":"9",
			"title":"C++ implementation, easy understanding.",
			"vote":"5",
			"content":"    bool isAdditiveNumber(string num) {\\n      for(int i = 1; i <= num.size()/2; i++) {\\n       for(int j = 1; j <= (num.size()-i)/2; j++) {\\n         if (i >= 2 && num[0] == '0' || j >= 2 && num[i] == '0' || num[i+j] == '0') \\n             continue;\\n         if (addNum(stol(num.substr(0,i)), stol(num.substr(i,j)), num.substr(i+j))) \\n             return true;\\n        }\\n      }\\n      return false;\\n    }\\n    bool addNum(long num1, long num2, string num){\\n       if (num.size() > 1 && num[0] == '0') return false;\\n       long sum = num1 + num2, numI = stol(num);\\n       long len = static_cast<long>(log10(sum)) + 1;\\n       if (numI == sum) return true;\\n       if (numI < sum || sum != stol(num.substr(0, len))) return false;\\n       else return addNum(num2, sum, num.substr(len));\\n    }"
		}
	],
	"id":"306",
	"title":"Additive Number",
	"content":"<p>Additive number is a string whose digits can form additive sequence.</p>\r\n\r\n<p>A valid additive sequence should contain <b>at least</b> three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>\r\n\r\n<p>\r\nFor example:<br>\r\n<code>\"112358\"</code> is an additive number because the digits can form an additive sequence: <code>1, 1, 2, 3, 5, 8</code>.\r\n<pre>1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</pre>\r\n<code>\"199100199\"</code> is also an additive number, the additive sequence is: <code>1, 99, 100, 199</code>.\r\n<pre>1 + 99 = 100, 99 + 100 = 199</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b> Numbers in the additive sequence <b>cannot</b> have leading zeros, so sequence <code>1, 2, 03</code> or <code>1, 02, 3</code> is invalid.\r\n</p>\r\n\r\n<p>Given a string containing only digits <code>'0'-'9'</code>, write a function to determine if it's an additive number.</p>\r\n\r\n<p>\r\n<b>Follow up:</b><br>\r\nHow would you handle overflow for very large input integers?\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/jeantimex\">@jeantimex</a> for adding this problem and creating all test cases.</p>",
	"frequency":"437",
	"ac_num":"29250"
}