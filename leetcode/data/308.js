{
	"difficulty":"3",
	"submit_num":"79399",
	"show_id":"308",
	"leetcode_id":"308",
	"answers":[
		{
			"lc_ans_id":"75870",
			"view":"27573",
			"top":"0",
			"title":"Java 2D Binary Indexed Tree Solution clean and short 17ms",
			"vote":"104",
			"content":"    public class NumMatrix {\\n    \\n        int[][] tree;\\n        int[][] nums;\\n        int m;\\n        int n;\\n        \\n        public NumMatrix(int[][] matrix) {\\n            if (matrix.length == 0 || matrix[0].length == 0) return;\\n            m = matrix.length;\\n            n = matrix[0].length;\\n            tree = new int[m+1][n+1];\\n            nums = new int[m][n];\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    update(i, j, matrix[i][j]);\\n                }\\n            }\\n        }\\n    \\n        public void update(int row, int col, int val) {\\n            if (m == 0 || n == 0) return;\\n            int delta = val - nums[row][col];\\n            nums[row][col] = val;\\n            for (int i = row + 1; i <= m; i += i & (-i)) {\\n                for (int j = col + 1; j <= n; j += j & (-j)) {\\n                    tree[i][j] += delta;\\n                }\\n            }\\n        }\\n    \\n        public int sumRegion(int row1, int col1, int row2, int col2) {\\n            if (m == 0 || n == 0) return 0;\\n            return sum(row2+1, col2+1) + sum(row1, col1) - sum(row1, col2+1) - sum(row2+1, col1);\\n        }\\n        \\n        public int sum(int row, int col) {\\n            int sum = 0;\\n            for (int i = row; i > 0; i -= i & (-i)) {\\n                for (int j = col; j > 0; j -= j & (-j)) {\\n                    sum += tree[i][j];\\n                }\\n            }\\n            return sum;\\n        }\\n    }\\n    // time should be O(log(m) * log(n))\\n\\nExplanation of Binary Indexed Tree : \\nhttps://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/"
		},
		{
			"lc_ans_id":"75852",
			"view":"13263",
			"top":"1",
			"title":"15ms easy to understand java solution",
			"vote":"57",
			"content":"We use colSums[i][j] =  the sum of ( matrix[0][j], matrix[1][j], matrix[2][j],......,matrix[i - 1][j] ).   \\n\\n\\n\\n    private int[][] colSums;\\n    private int[][] matrix;\\n\\n    public NumMatrix(int[][] matrix) {\\n        if(   matrix           == null\\n           || matrix.length    == 0\\n           || matrix[0].length == 0   ){\\n            return;   \\n         }\\n         \\n         this.matrix = matrix;\\n         \\n         int m   = matrix.length;\\n         int n   = matrix[0].length;\\n         colSums = new int[m + 1][n];\\n         for(int i = 1; i <= m; i++){\\n             for(int j = 0; j < n; j++){\\n                 colSums[i][j] = colSums[i - 1][j] + matrix[i - 1][j];\\n             }\\n         }\\n    }\\n    //time complexity for the worst case scenario: O(m)\\n    public void update(int row, int col, int val) {\\n        for(int i = row + 1; i < colSums.length; i++){\\n            colSums[i][col] = colSums[i][col] - matrix[row][col] + val;\\n        }\\n        \\n        matrix[row][col] = val;\\n    }\\n    //time complexity for the worst case scenario: O(n)\\n    public int sumRegion(int row1, int col1, int row2, int col2) {\\n        int ret = 0;\\n        \\n        for(int j = col1; j <= col2; j++){\\n            ret += colSums[row2 + 1][j] - colSums[row1][j];\\n        }\\n        \\n        return ret;\\n    }"
		},
		{
			"lc_ans_id":"75863",
			"view":"3655",
			"top":"2",
			"title":"Segment Tree Solution in Java",
			"vote":"13",
			"content":"    TreeNode root;\\n    public NumMatrix(int[][] matrix) {\\n        if (matrix.length == 0) {\\n            root = null;\\n        } else {\\n            root = buildTree(matrix, 0, 0, matrix.length-1, matrix[0].length-1);\\n        }\\n    }\\n\\n    public void update(int row, int col, int val) {\\n        update(root, row, col, val);\\n    }\\n    \\n    private void update(TreeNode root, int row, int col, int val) {\\n        if (root.row1 == root.row2 && root.row1 == row && root.col1 == root.col2 && root.col1 == col) {\\n            root.sum = val;\\n            return;\\n        }\\n        int rowMid = (root.row1 + root.row2) / 2;\\n        int colMid = (root.col1 + root.col2) / 2;\\n        TreeNode next;\\n        if (row <= rowMid) {\\n            if (col <= colMid) {\\n                next = root.c1;\\n            } else {\\n                next = root.c2;\\n            }\\n        } else {\\n            if (col <= colMid) {\\n                next = root.c3;\\n            } else {\\n                next = root.c4;\\n            }\\n        }\\n        root.sum -= next.sum;\\n        update(next, row, col, val);\\n        root.sum += next.sum;\\n    }\\n\\n    public int sumRegion(int row1, int col1, int row2, int col2) {\\n        return sumRegion(root, row1, col1, row2, col2);\\n    }\\n    \\n    private int sumRegion(TreeNode root, int row1, int col1, int row2, int col2) {\\n        if (root.row1 == row1 && root.col1 == col1 && root.row2 == row2 && root.col2 == col2)\\n            return root.sum;\\n        int rowMid = (root.row1 + root.row2) / 2;\\n        int colMid = (root.col1 + root.col2) / 2;\\n        if (rowMid >= row2) {\\n            if (colMid >= col2) {\\n                return sumRegion(root.c1, row1, col1, row2, col2);\\n            } else if (colMid + 1 <= col1) {\\n                return sumRegion(root.c2, row1, col1, row2, col2);\\n            } else {\\n                return sumRegion(root.c1, row1, col1, row2, colMid) + sumRegion(root.c2, row1, colMid+1, row2, col2);\\n            }\\n        } else if (rowMid + 1 <= row1) {\\n            if (colMid >= col2) {\\n                return sumRegion(root.c3, row1, col1, row2, col2);\\n            } else if (colMid + 1 <= col1) {\\n                return sumRegion(root.c4, row1, col1, row2, col2);\\n            } else {\\n                return sumRegion(root.c3, row1, col1, row2, colMid) + sumRegion(root.c4, row1, colMid+1, row2, col2);\\n            }\\n        } else {\\n            if (colMid >= col2) {\\n                return sumRegion(root.c1, row1, col1, rowMid, col2) + sumRegion(root.c3, rowMid+1, col1, row2, col2);\\n            } else if (colMid + 1 <= col1) {\\n                return sumRegion(root.c2, row1, col1, rowMid, col2) + sumRegion(root.c4, rowMid+1, col1, row2, col2);\\n            } else {\\n                return sumRegion(root.c1, row1, col1, rowMid, colMid) + sumRegion(root.c2, row1, colMid+1, rowMid, col2) + sumRegion(root.c3, rowMid+1, col1, row2, colMid) + sumRegion(root.c4, rowMid+1, colMid+1, row2, col2);\\n            }\\n        }\\n    }\\n    \\n    private TreeNode buildTree(int[][] matrix, int row1, int col1, int row2, int col2) {\\n        if (row2 < row1 || col2 < col1)\\n            return null;\\n        TreeNode node = new TreeNode(row1, col1, row2, col2);\\n        if (row1 == row2 && col1 == col2) {\\n            node.sum = matrix[row1][col1];\\n            return node;\\n        }\\n        int rowMid = (row1 + row2) / 2;\\n        int colMid = (col1 + col2) / 2;\\n        node.c1 = buildTree(matrix, row1, col1, rowMid, colMid);\\n        node.c2 = buildTree(matrix, row1, colMid+1, rowMid, col2);\\n        node.c3 = buildTree(matrix, rowMid+1, col1, row2, colMid);\\n        node.c4 = buildTree(matrix, rowMid+1, colMid+1, row2, col2);\\n        node.sum += node.c1 != null ? node.c1.sum : 0;\\n        node.sum += node.c2 != null ? node.c2.sum : 0;\\n        node.sum += node.c3 != null ? node.c3.sum : 0;\\n        node.sum += node.c4 != null ? node.c4.sum : 0;\\n        return node;\\n    }\\n    \\n    public class TreeNode {\\n        int row1, row2, col1, col2, sum;\\n        TreeNode c1, c2, c3, c4;\\n        public TreeNode (int row1, int col1, int row2, int col2) {\\n            this.row1 = row1;\\n            this.col1 = col1;\\n            this.row2 = row2;\\n            this.col2 = col2;\\n            this.sum = 0;\\n        }\\n    }\\n\\nBinary Indexed Tree solution is faster and easier compared to this. Just share Segment Tree Solution here. The idea is quite similar to 1D solution. The major difference is that each TreeNode now has 4 children instead of 2."
		},
		{
			"lc_ans_id":"75872",
			"view":"2954",
			"top":"3",
			"title":"Python 94.5% Simple sum array on one dimension, O(n) for both update and sum",
			"vote":"13",
			"content":"    class NumMatrix(object):\\n        def __init__(self, matrix):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type matrix: List[List[int]]\\n            \"\"\"\\n            for row in matrix:\\n                for col in xrange(1, len(row)):\\n                    row[col] += row[col-1]\\n            self.matrix = matrix\\n            \\n    \\n        def update(self, row, col, val):\\n            \"\"\"\\n            update the element at matrix[row,col] to val.\\n            :type row: int\\n            :type col: int\\n            :type val: int\\n            :rtype: void\\n            \"\"\"\\n            original = self.matrix[row][col]\\n            if col != 0:\\n                original -= self.matrix[row][col-1]\\n                \\n            diff = original - val\\n            \\n            for y in xrange(col, len(self.matrix[0])):\\n                self.matrix[row][y] -= diff\\n    \\n        def sumRegion(self, row1, col1, row2, col2):\\n            \"\"\"\\n            sum of elements matrix[(row1,col1)..(row2,col2)], inclusive.\\n            :type row1: int\\n            :type col1: int\\n            :type row2: int\\n            :type col2: int\\n            :rtype: int\\n            \"\"\"\\n            sum = 0\\n            for x in xrange(row1, row2+1):\\n                sum += self.matrix[x][col2]\\n                if col1 != 0:\\n                    sum -= self.matrix[x][col1-1]\\n            return sum"
		},
		{
			"lc_ans_id":"75905",
			"view":"2616",
			"top":"4",
			"title":"15ms Very Concise Java Code Using BIT",
			"vote":"9",
			"content":"Salute to https://leetcode.com/discuss/71169/java-2d-binary-indexed-tree-solution-clean-and-short-17ms\\n\\n    public class NumMatrix {\\n        // Using 2D Binary Indexed Tree, 2D BIT Def:\\n        // bit[i][j] saves the rangeSum of [i-(i&-i), i] x [j-(j&-j), j]\\n        // note bit index == matrix index + 1\\n        int n, m;\\n        int[][] bit, a;\\n    \\n        public NumMatrix(int[][] matrix) {\\n            if (matrix.length < 1) return;\\n            n = matrix.length; m = matrix[0].length;\\n            bit = new int[n + 1][m + 1]; a = new int[n][m];\\n            \\n            for (int i = 0; i < n; i++)\\n                for (int j = 0; j < m; j++)\\n                    update(i, j, matrix[i][j]);\\n        }\\n    \\n        public void update(int row, int col, int val) {\\n            int diff = val - a[row][col];\\n            a[row][col] = val;\\n            for (int i = row + 1; i <= n; i += i & -i)\\n                for (int j = col + 1; j <= m; j += j & -j)\\n                    bit[i][j] += diff;\\n        }\\n    \\n        public int sumRegion(int row1, int col1, int row2, int col2) {\\n            return sum(row2, col2) + sum(row1 - 1, col1 - 1) - sum(row1 - 1, col2) - sum(row2, col1 - 1);\\n        }\\n        \\n        public int sum(int row, int col) {\\n            int tot = 0;\\n            for (int i = row + 1; i > 0; i -= i & -i)\\n                for (int j = col + 1; j > 0; j -= j & -j)\\n                    tot += bit[i][j];\\n            return tot;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"75899",
			"view":"5536",
			"top":"5",
			"title":"C++ Quad tree (736ms ) and indexed tree (492ms) based solutions",
			"vote":"9",
			"content":"I have written both the Quad tree based solution and the indexed tree based solution for c++. \\n\\nBoth are very straight-forward. I have made some mistake for my previous analysis of the quad-tree solution. The indexed tree solution is more efficient in general.\\n\\nMethod 1: Quad-tree based solution. Essentially, it is a divide and conquer algorithm that divide the whole matrix into 4 sub-matrices recursively. It can be shown that the algorithm is O(max(m, n)) per update/query.\\n\\n    class NumMatrix {\\n        struct TreeNode {\\n            int val = 0;\\n            TreeNode* neighbor[4] = {NULL, NULL, NULL, NULL};\\n            pair<int, int> leftTop = make_pair(0,0);\\n            pair<int, int> rightBottom = make_pair(0,0);\\n            TreeNode(int v):val(v){}\\n        };\\n    public:\\n        NumMatrix(vector<vector<int>> &matrix) {\\n            nums = matrix;\\n            if (matrix.empty()) return;\\n            int row = matrix.size();\\n            if (row == 0) return;\\n            int col= matrix[0].size();\\n            root = createTree(matrix, make_pair(0,0), make_pair(row-1, col-1));\\n        }\\n        \\n        void update(int row, int col, int val) {\\n            int diff = val - nums[row][col];\\n            if (diff == 0) return;\\n            nums[row][col] = val;\\n            updateTree(row, col, diff, root);\\n        }\\n        \\n        int sumRegion(int row1, int col1, int row2, int col2) {\\n            int res = 0;\\n            if (root != NULL)\\n                sumRegion(row1, col1, row2, col2, root, res);\\n            return res;\\n        }\\n        \\n    private:\\n        TreeNode* root = NULL;\\n        vector<vector<int>> nums;\\n        TreeNode* createTree(vector<vector<int>> &matrix, pair<int, int> start, pair<int, int> end) {\\n            if (start.first > end.first || start.second > end.second)\\n                return NULL;\\n            TreeNode* cur = new TreeNode(0);\\n            cur->leftTop = start;\\n            cur->rightBottom = end;\\n            if (start == end) {\\n                cur->val = matrix[start.first][start.second];\\n                return cur;\\n            }\\n        \\n            int midx = ( start.first + end.first ) / 2;\\n            int midy = (start.second + end.second) / 2;\\n            cur->neighbor[0] = createTree(matrix, start, make_pair(midx, midy));\\n            cur->neighbor[1] = createTree(matrix, make_pair(start.first, midy+1), make_pair(midx, end.second));\\n            cur->neighbor[2] = createTree(matrix, make_pair(midx+1, start.second), make_pair(end.first, midy));\\n            cur->neighbor[3] = createTree(matrix, make_pair(midx+1, midy+1), end);\\n            for (int i = 0; i < 4; i++) {\\n                if (cur->neighbor[i])\\n                    cur->val += cur->neighbor[i]->val;\\n            }\\n            return cur;\\n        }\\n        \\n        void sumRegion(int row1, int col1, int row2, int col2, TreeNode* ptr, int &res) {\\n            pair<int, int> start = ptr->leftTop;\\n            pair<int, int> end = ptr->rightBottom;\\n            // determine whether there is overlapping\\n            int top = max(start.first, row1);\\n            int bottom = min(end.first, row2);\\n            if (bottom < top) return;\\n            int left = max(start.second, col1);\\n            int right = min(end.second, col2);\\n            if (left > right) return;\\n            \\n            \\n            if (row1 <= start.first && col1 <= start.second && row2 >= end.first && col2 >= end.second) {\\n                res += ptr->val;\\n                return;\\n            }\\n            \\n            for (int i = 0; i < 4; i ++) \\n                if (ptr->neighbor[i]) \\n                    sumRegion(row1, col1, row2, col2, ptr->neighbor[i], res);\\n                \\n        }\\n        \\n        \\n        void updateTree(int row, int col, int diff, TreeNode* ptr){\\n            if (row >= (ptr->leftTop).first && row <= (ptr->rightBottom).first &&\\n                col >= (ptr->leftTop).second && col <= (ptr->rightBottom).second)\\n            {\\n                ptr->val += diff;\\n                for (int i = 0; i < 4; i++)\\n                    if (ptr->neighbor[i])\\n                        updateTree(row, col, diff, ptr->neighbor[i]);\\n                \\n            }\\n        }\\n    };\\n\\n\\n\\nMethod 2: the 2D indexed-tree solution. It is a simple generalization of the 1D indexed tree solution. The complexity should be O(log(m)log(n)).\\n\\n    class NumMatrix {\\n    public:\\n        NumMatrix(vector<vector<int>> &matrix) {\\n            if (matrix.size() == 0 || matrix[0].size() == 0) return;\\n            nrow = matrix.size();\\n            ncol = matrix[0].size();\\n            nums = matrix;\\n            BIT = vector<vector<int>> (nrow+1, vector<int>(ncol+1, 0));\\n            for (int i = 0; i < nrow; i++)\\n                for (int j = 0; j < ncol; j++)\\n                    add(i, j, matrix[i][j]);\\n                \\n        }\\n    \\n        void update(int row, int col, int val) {\\n            int diff = val - nums[row][col];\\n            add(row, col,diff);\\n            nums[row][col] = val;\\n        }\\n    \\n        int sumRegion(int row1, int col1, int row2, int col2) {\\n            int regionL = 0, regionS = 0;\\n            int regionLeft = 0, regionTop = 0;\\n\\n            regionL = region(row2, col2);\\n            \\n            if (row1 > 0 && col1 > 0) regionS = region(row1-1, col1-1);\\n            \\n            if (row1 > 0) regionTop  = region(row1-1, col2);\\n                \\n            if (col1 > 0) regionLeft = region(row2, col1-1);       \\n     \\n            return regionL - regionTop - regionLeft + regionS;\\n        }\\n    private:\\n        vector<vector<int>> nums;\\n        vector<vector<int>> BIT;\\n        int nrow = 0;\\n        int ncol = 0;\\n        void add(int row, int col, int val) {\\n            row++;\\n            col++;\\n            while(row <= nrow) {\\n                int colIdx = col;\\n                while(colIdx <= ncol) {\\n                    BIT[row][colIdx] += val;\\n                    colIdx += (colIdx & (-colIdx));\\n                }\\n                row +=  (row & (-row));\\n            }\\n        }\\n        \\n        int region(int row, int col) {\\n            row++;\\n            col++;\\n            int res = 0;\\n            while(row > 0) {\\n                int colIdx = col;\\n                while(colIdx > 0) {\\n                    res += BIT[row][colIdx];\\n                    colIdx -= (colIdx & (-colIdx));\\n                }\\n                row -= (row & (-row));\\n            }\\n            return res;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"75917",
			"view":"1815",
			"top":"6",
			"title":"Share my Java 2-D Binary Indexed Tree Solution",
			"vote":"8",
			"content":"Based on the [1-D solution][1] in problem [Range Sum Query - Mutable][2], we can extend it to solve this 2-D problem. \\n\\nInitializing the binary indexed tree takes `O(mn*logm*logn)` time, both `update()` and `getSum()` take `O(logm*logn)` time. The `arr[][]` is used to keep a backup of the `matrix[][]` so that we know the difference of the updated element and use that to update the binary indexed tree. The idea of calculating  `sumRegion()` is the same as in [Range Sum Query 2D - Immutable][3]. \\n\\n    public class NumMatrix {\\n      int m, n;\\n      int[][] arr;    // stores matrix[][]\\n      int[][] BITree; // 2-D binary indexed tree\\n      \\n      public NumMatrix(int[][] matrix) {\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n        \\n        m = matrix.length;\\n        n = matrix[0].length;\\n        \\n        arr = new int[m][n];\\n        BITree = new int[m + 1][n + 1];\\n        \\n        for (int i = 0; i < m; i++) {\\n          for (int j = 0; j < n; j++) {\\n            update(i, j, matrix[i][j]); // init BITree[][]\\n            arr[i][j] = matrix[i][j];   // init arr[][]\\n          }\\n        }\\n      }\\n      \\n      public void update(int i, int j, int val) {\\n        int diff = val - arr[i][j];  // get the diff\\n        arr[i][j] = val;             // update arr[][]\\n          \\n        i++; j++;\\n        while (i <= m) {\\n          int k = j;\\n          while (k <= n) {\\n            BITree[i][k] += diff; // update BITree[][]\\n            k += k & (-k); // update column index to that of parent\\n          }\\n          i += i & (-i);   // update row index to that of parent\\n        }\\n      }\\n      \\n      int getSum(int i, int j) {\\n        int sum = 0;\\n        \\n        i++; j++;\\n        while (i > 0) {\\n          int k = j;\\n          while (k > 0) {\\n            sum += BITree[i][k]; // accumulate the sum\\n            k -= k & (-k); // move column index to parent node\\n          }\\n          i -= i & (-i);   // move row index to parent node\\n        }\\n        return sum;\\n      }\\n      \\n      public int sumRegion(int i1, int j1, int i2, int j2) {\\n        return getSum(i2, j2) - getSum(i1-1, j2) - getSum(i2, j1-1) + getSum(i1-1, j1-1);\\n      }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/72551/share-my-java-binary-indexed-tree-solution\\n  [2]: https://leetcode.com/problems/range-sum-query-mutable/\\n  [3]: https://leetcode.com/problems/range-sum-query-2d-immutable/"
		},
		{
			"lc_ans_id":"75900",
			"view":"1066",
			"top":"7",
			"title":"Python 2D binary indexed tree",
			"vote":"6",
			"content":"Translated this [java solution][1]\\n\\n    class NumMatrix(object):\\n    def __init__(self, matrix):\\n        if not matrix:\\n            return\\n        self.m, self.n = len(matrix), len(matrix[0])\\n        self.matrix, self.bit = [[0]*(self.n) for _ in range(self.m)], [[0]*(self.n+1) for _ in range(self.m+1)]\\n        for i in range(self.m):\\n            for j in range(self.n):\\n                self.update(i, j, matrix[i][j])\\n\\n    def update(self, row, col, val):\\n        diff, self.matrix[row][col], i = val-self.matrix[row][col], val, row+1\\n        while i <= self.m:\\n            j = col+1\\n            while j <= self.n:\\n                self.bit[i][j] += diff\\n                j += (j & -j)\\n            i += (i & -i)\\n        \\n    def sumRegion(self, row1, col1, row2, col2):\\n        return self.sumCorner(row2, col2) + self.sumCorner(row1-1, col1-1) - self.sumCorner(row1-1, col2) - self.sumCorner(row2, col1-1)\\n        \\n    def sumCorner(self, row, col):\\n        res, i = 0, row+1\\n        while i:\\n            j = col+1\\n            while j:\\n                res += self.bit[i][j]\\n                j -= (j & -j)\\n            i -= (i & -i)\\n        return res\\n\\nSigh, java is so much faster\\n\\n\\n  [1]: https://leetcode.com/discuss/71169/java-2d-binary-indexed-tree-solution-clean-and-short-17ms"
		},
		{
			"lc_ans_id":"75913",
			"view":"956",
			"top":"8",
			"title":"C++ Binary indexed Tree implementation",
			"vote":"6",
			"content":"      \\nFor Binary Indexed Tree, please see [https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/][1] and vedio [https://www.youtube.com/watch?v=CWDQJGaN1gY][2]\\n\\n\\n    NumMatrix(vector<vector<int>> &matrix) {\\n        _row = matrix.size();\\n        if (0 == _row) return;\\n        _col = matrix[0].size();\\n        num = vector<vector<int>>(matrix);\\n        tree = vector<vector<int>>(_row + 1, vector<int>(_col + 1, 0));\\n        for (int i = 0; i < _row; i++) \\n         for (int j = 0; j < _col; j++) {\\n            updateTree(i, j, num[i][j]);\\n        }\\n    }\\n\\n    void update(int row, int col, int val) {\\n        updateTree(row, col, val - num[row][col]);\\n        num[row][col] = val;\\n    }\\n\\n    int sumRegion(int row1, int col1, int row2, int col2) {\\n        return read(row2+1, col2+1) - read(row1, col2+1) - read(row2+1, col1) + read(row1, col1);\\n    }\\n    \\n    void updateTree(int row, int col, int val) {\\n        for (int i = row + 1; i <= _row; i += i & (-i)) \\n          for (int j = col + 1; j <= _col; j += j & (-j)) {\\n                tree[i][j] += val;\\n        }\\n    }\\n    \\n    int read(int row, int col) {\\n        int sum = 0;\\n        for (int i = row; i > 0; i -= i & (-i))\\n         for (int j = col; j > 0; j -= j & (-j)) {\\n                sum += tree[i][j];\\n        }\\n        return sum;\\n    }\\n    \\n    vector<vector<int>> tree;\\n    vector<vector<int>> num;\\n    int _row;\\n    int _col;\\n\\n\\n  [1]: https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/\\n  [2]: http://%20https://www.youtube.com/watch?v=CWDQJGaN1gY"
		},
		{
			"lc_ans_id":"75912",
			"view":"938",
			"top":"9",
			"title":"BIT python clean code",
			"vote":"5",
			"content":"    class BinaryIndexedTree(object):\\n        def __init__(self, matrix):\\n            m, n = len(matrix), len(matrix[0]) if matrix else 0\\n    \\n            self.matrix = matrix\\n            self.sums = [[0] * (n + 1) for _ in xrange(m + 1)]\\n    \\n            [operator.setitem(\\n                self.sums[row], col,\\n                self.sums[row][col] + self.matrix[i - 1][j - 1]\\n            )\\n            for row in xrange(1, len(self.sums))\\n            for col in xrange(1, len(self.sums[0]))\\n            for i in xrange(row + 1 - (row & -row), row + 1)\\n            for j in xrange(col + 1 - (col & -col), col + 1)]\\n    \\n        def update(self, row, col, val):\\n            i = row + 1\\n            while i < len(self.sums):\\n                j = col + 1\\n                while j < len(self.sums[0]):\\n                    self.sums[i][j] += val - self.matrix[row][col]\\n                    j += j & -j\\n                i += i & -i\\n            self.matrix[row][col] = val\\n    \\n        def sum(self, row, col):\\n            r, i = 0, row\\n            while i > 0:\\n                j = col\\n                while j > 0:\\n                    r += self.sums[i][j]\\n                    j -= j & -j\\n                i -= i & -i\\n            return r\\n    \\n    \\n    class NumMatrix(object):\\n        def __init__(self, matrix):\\n            self.tree = BinaryIndexedTree(matrix)\\n    \\n        def update(self, row, col, val):\\n            self.tree.update(row, col, val)\\n    \\n        def sumRegion(self, row1, col1, row2, col2):\\n            return (\\n                self.tree.sum(row2 + 1, col2 + 1) +\\n                self.tree.sum(row1, col1) -\\n                self.tree.sum(row1, col2 + 1) -\\n                self.tree.sum(row2 + 1, col1))"
		}
	],
	"id":"308",
	"title":"Range Sum Query 2D - Mutable",
	"content":"<p>Given a 2D matrix <i>matrix</i>, find the sum of the elements inside the rectangle defined by its upper left corner (<i>row</i>1, <i>col</i>1) and lower right corner (<i>row</i>2, <i>col</i>2).</p>\r\n\r\n<p>\r\n<img src=\"/static/images/courses/range_sum_query_2d.png\" border=\"0\" alt=\"Range Sum Query 2D\" /><br />\r\n<small>The above rectangle (with the red border) is defined by (row1, col1) = <b>(2, 1)</b> and (row2, col2) = <b>(4, 3)</b>, which contains sum = <b>8</b>.</small>\r\n</p>\r\n\r\n<p><b>Example:</b><br>\r\n<pre>\r\nGiven matrix = [\r\n  [3, 0, 1, 4, 2],\r\n  [5, 6, 3, 2, 1],\r\n  [1, 2, 0, 1, 5],\r\n  [4, 1, 0, 1, 7],\r\n  [1, 0, 3, 0, 5]\r\n]\r\n\r\nsumRegion(2, 1, 4, 3) -> 8\r\nupdate(3, 2, 2)\r\nsumRegion(2, 1, 4, 3) -> 10\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The matrix is only modifiable by the <i>update</i> function.</li>\r\n<li>You may assume the number of calls to <i>update</i> and <i>sumRegion</i> function is distributed evenly.</li>\r\n<li>You may assume that <i>row</i>1 &le; <i>row</i>2 and <i>col</i>1 &le; <i>col</i>2.</li>\r\n</ol>\r\n</p>",
	"frequency":"263",
	"ac_num":"19918"
}