{
	"difficulty":"2",
	"submit_num":"476953",
	"show_id":"31",
	"leetcode_id":"31",
	"answers":[
		{
			"lc_ans_id":"13866",
			"view":"44713",
			"top":"0",
			"title":"Share my O(n) time solution",
			"vote":"141",
			"content":"My idea is for an array:\\n\\n 1. Start from its last element, traverse backward to find the first one with index i that satisfy  num[i-1] < num[i]. So, elements from num[i] to num[n-1] is reversely sorted. \\n 2. To find the next permutation, we have to swap some numbers at different positions, to minimize the increased amount, we have to make the highest changed position as high as possible. Notice that index larger than or equal to i is not possible as num[i,n-1] is reversely sorted. So, we want to increase the number at index i-1, clearly, swap it with the smallest number between num[i,n-1] that is larger than num[i-1]. For example, original number is 121543321, we want to swap the '1' at position 2 with '2' at position 7. \\n 3. The last step is to make the remaining higher position part as small as possible, we just have to reversely sort the num[i,n-1]\\n\\nThe following is my code:\\n\\n        \\n    public void nextPermutation(int[] num) {\\n        int n=num.length;\\n        if(n<2)\\n            return;\\n        int index=n-1;        \\n        while(index>0){\\n            if(num[index-1]<num[index])\\n                break;\\n            index--;\\n        }\\n        if(index==0){\\n            reverseSort(num,0,n-1);\\n            return;\\n        }\\n        else{\\n            int val=num[index-1];\\n            int j=n-1;\\n            while(j>=index){\\n                if(num[j]>val)\\n                    break;\\n                j--;\\n            }\\n            swap(num,j,index-1);\\n            reverseSort(num,index,n-1);\\n            return;\\n        }\\n    }\\n    \\n    public void swap(int[] num, int i, int j){\\n        int temp=0;\\n        temp=num[i];\\n        num[i]=num[j];\\n        num[j]=temp;\\n    }\\n    \\n    public void reverseSort(int[] num, int start, int end){   \\n        if(start>end)\\n            return;\\n        for(int i=start;i<=(end+start)/2;i++)\\n            swap(num,i,start+end-i);\\n    }"
		},
		{
			"lc_ans_id":"13867",
			"view":"16682",
			"top":"1",
			"title":"A simple algorithm from Wikipedia with C++ implementation (can be used in Permutations and Permutations II)",
			"vote":"126",
			"content":"Well, in fact the problem of next permutation has been studied long ago. From the [Wikipedia page][1], in the 14th century, a man named Narayana Pandita gives the following classic and yet quite simple algorithm (with minor modifications in notations to fit the problem statement):\\n\\n 1. Find the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, the permutation is sorted in descending order, just reverse it  to ascending order and we are done. For example, the next permutation of `[3, 2, 1]` is `[1, 2, 3]`.\\n 2. Find the largest index `l` greater than `k` such that `nums[k] < nums[l]`.\\n 3. Swap the value of `nums[k]` with that of `nums[l]`.\\n 4. Reverse the sequence from `nums[k + 1]` up to and including the final element `nums[nums.size() - 1]`.\\n\\nQuite simple, yeah? Now comes the following code, which is barely a translation.\\n\\nWell, a final note here, the above algorithm is indeed powerful --- **it can handle the cases of duplicates**! If you have tried the problems [Permutations][2] and [Permutations II][3], then the following function is also useful. Both of [Permutations][4] and [Permutations II][5] can be solved easily using this function. Hints: sort `nums` in ascending order, add it to the result of all permutations and then repeatedly generate the next permutation and add it ... until we get back to the original sorted condition. If you want to learn more, please visit [this solution][6] and [that solution][7].\\n\\n    class Solution {\\n        void nextPermutation(vector<int>& nums) {\\n        \\tint k = -1;\\n        \\tfor (int i = nums.size() - 2; i >= 0; i--) {\\n        \\t\\tif (nums[i] < nums[i + 1]) {\\n        \\t\\t\\tk = i;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t} \\n        \\tif (k == -1) {\\n        \\t    reverse(nums.begin(), nums.end());\\n        \\t    return;\\n        \\t}\\n        \\tint l = -1;\\n        \\tfor (int i = nums.size() - 1; i > k; i--) {\\n        \\t\\tif (nums[i] > nums[k]) {\\n        \\t\\t\\tl = i;\\n        \\t\\t\\tbreak;\\n        \\t\\t} \\n        \\t} \\n        \\tswap(nums[k], nums[l]);\\n        \\treverse(nums.begin() + k + 1, nums.end()); \\n        }\\n    }; \\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Permutation\\n  [2]: https://leetcode.com/problems/permutations/\\n  [3]: https://leetcode.com/problems/permutations-ii/\\n  [4]: https://leetcode.com/problems/permutations/\\n  [5]: https://leetcode.com/problems/permutations-ii/\\n  [6]: https://leetcode.com/discuss/38255/solution-nextpermutation-permutations-without-modification\\n  [7]: https://leetcode.com/discuss/38260/easy-solution-using-code-in-nextpermutation"
		},
		{
			"lc_ans_id":"13865",
			"view":"14233",
			"top":"2",
			"title":"Sharing my clean and easy-understand java code with explanation",
			"vote":"106",
			"content":"    public class Solution {\\n        public void nextPermutation(int[] nums) {\\n          if(nums.length<=1){\\n              return;\\n          }\\n          \\n          int i= nums.length-1;\\n          \\n          for(;i>=1;i--){\\n             \\n             if(nums[i]>nums[i-1]){ //find first number which is smaller than it's after number\\n                 break;\\n             }\\n          }\\n          \\n          if(i!=0){\\n              swap(nums,i-1); //if the number exist,which means that the nums not like{5,4,3,2,1}\\n          }\\n          \\n          reverse(nums,i);    \\n        }\\n        \\n        private void swap(int[] a,int i){\\n            for(int j = a.length-1;j>i;j--){\\n                if(a[j]>a[i]){\\n                    int t = a[j];\\n                    a[j] = a[i];\\n                    a[i] = t;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        private void reverse(int[] a,int i){//reverse the number after the number we have found\\n            int first = i;\\n            int last = a.length-1;\\n            while(first<last){\\n                int t = a[first];\\n                a[first] = a[last];\\n                a[last] = t;\\n                first ++;\\n                last --;\\n            }\\n        }\\n        \\n    }\\n\\n\\u5728\\u5f53\\u524d\\u5e8f\\u5217\\u4e2d\\uff0c\\u4ece\\u5c3e\\u7aef\\u5f80\\u524d\\u5bfb\\u627e\\u4e24\\u4e2a\\u76f8\\u90bb\\u5143\\u7d20\\uff0c\\u524d\\u4e00\\u4e2a\\u8bb0\\u4e3afirst\\uff0c\\u540e\\u4e00\\u4e2a\\u8bb0\\u4e3asecond\\uff0c\\u5e76\\u4e14\\u6ee1\\u8db3first \\u5c0f\\u4e8e second\\u3002\\u7136\\u540e\\u518d\\u4ece\\u5c3e\\u7aef\\u5bfb\\u627e\\u53e6\\u4e00\\u4e2a\\u5143\\u7d20number\\uff0c\\u5982\\u679c\\u6ee1\\u8db3first \\u5c0f\\u4e8enumber\\uff0c\\u5373\\u5c06\\u7b2cfirst\\u4e2a\\u5143\\u7d20\\u4e0enumber\\u5143\\u7d20\\u5bf9\\u8c03\\uff0c\\u5e76\\u5c06second\\u5143\\u7d20\\u4e4b\\u540e\\uff08\\u5305\\u62ecsecond\\uff09\\u7684\\u6240\\u6709\\u5143\\u7d20\\u98a0\\u5012\\u6392\\u5e8f\\uff0c\\u5373\\u6c42\\u51fa\\u4e0b\\u4e00\\u4e2a\\u5e8f\\u5217\\n\\nexample:\\n6\\uff0c3\\uff0c4\\uff0c9\\uff0c8\\uff0c7\\uff0c1\\n\\u6b64\\u65f6 first \\uff1d 4\\uff0csecond = 9\\n\\u4ece\\u5c3e\\u5df4\\u5230\\u524d\\u627e\\u5230\\u7b2c\\u4e00\\u4e2a\\u5927\\u4e8efirst\\u7684\\u6570\\u5b57\\uff0c\\u5c31\\u662f7\\n\\u4ea4\\u63624\\u548c7\\uff0c\\u5373\\u4e0a\\u9762\\u7684swap\\u51fd\\u6570\\uff0c\\u6b64\\u65f6\\u5e8f\\u5217\\u53d8\\u62106\\uff0c3\\uff0c7\\uff0c9\\uff0c8\\uff0c4\\uff0c1\\n\\u518d\\u5c06second\\uff1d9\\u4ee5\\u53ca\\u4ee5\\u540e\\u7684\\u5e8f\\u5217\\u91cd\\u65b0\\u6392\\u5e8f\\uff0c\\u8ba9\\u5176\\u4ece\\u5c0f\\u5230\\u5927\\u6392\\u5e8f\\uff0c\\u4f7f\\u5f97\\u6574\\u4f53\\u6700\\u5c0f\\uff0c\\u5373reverse\\u4e00\\u4e0b\\uff08\\u56e0\\u4e3a\\u6b64\\u65f6\\u80af\\u5b9a\\u662f\\u9012\\u51cf\\u5e8f\\u5217\\uff09\\n\\u5f97\\u5230\\u6700\\u7ec8\\u7684\\u7ed3\\u679c\\uff1a6\\uff0c3\\uff0c7\\uff0c1\\uff0c4\\uff0c8\\uff0c9"
		},
		{
			"lc_ans_id":"13872",
			"view":"8034",
			"top":"3",
			"title":"Easiest JAVA Solution",
			"vote":"50",
			"content":"Using a simple example, we can derive the following steps:\\n\\n    public void nextPermutation(int[] A) {\\n        if(A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while(i >= 0 && A[i] >= A[i + 1]) i--; // Find 1st id i that breaks descending order\\n        if(i >= 0) {                           // If not entirely descending\\n            int j = A.length - 1;              // Start from the end\\n            while(A[j] <= A[i]) j--;           // Find rightmost first larger id j\\n            swap(A, i, j);                     // Switch i and j\\n        }\\n        reverse(A, i + 1, A.length - 1);       // Reverse the descending sequence\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while(i < j) swap(A, i++, j--);\\n    }"
		},
		{
			"lc_ans_id":"13921",
			"view":"5847",
			"top":"4",
			"title":"1, 4, 11 lines C++",
			"vote":"47",
			"content":"**Solution 1**\\n\\nJust for info: There's a library function that does the job, even going from totally reverse sorted to sorted:\\n\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums), end(nums));\\n    }\\n\\n---\\n\\n**Solution 2**\\n\\nUsing library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of `+1`/`-1`, it all fits exactly.\\n\\n    void nextPermutation(vector<int>& nums) {\\n        auto i = is_sorted_until(nums.rbegin(), nums.rend());\\n        if (i != nums.rend())\\n            swap(*i, *upper_bound(nums.rbegin(), i, *i));\\n        reverse(nums.rbegin(), i);\\n    }\\n\\n---\\n\\n**Solution 3**\\n\\nDoing it all on my own (except `swap`, let's not be silly):\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            swap(nums[j], nums[k]);\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            swap(nums[i], nums[k]);\\n        }\\n    }\\n\\n---\\n\\n**Solution 4**\\n\\nOk, let's be silly after all and not even use `swap` :-)\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i, tmp;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            tmp = nums[j], nums[j] = nums[k], nums[k] = tmp;\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            tmp = nums[i], nums[i] = nums[k], nums[k] = tmp;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"13885",
			"view":"6496",
			"top":"5",
			"title":"9 Lines of C++ code with Comments",
			"vote":"42",
			"content":"    class Solution {\\n    public:\\n        void nextPermutation(vector<int> &num) \\n        {\\n            if (num.empty()) return;\\n            \\n            // in reverse order, find the first number which is in increasing trend (we call it violated number here)\\n            int i;\\n            for (i = num.size()-2; i >= 0; --i)\\n            {\\n                if (num[i] < num[i+1]) break;\\n            }\\n            \\n            // reverse all the numbers after violated number\\n            reverse(begin(num)+i+1, end(num));\\n            // if violated number not found, because we have reversed the whole array, then we are done!\\n            if (i == -1) return;\\n            // else binary search find the first number larger than the violated number\\n            auto itr = upper_bound(begin(num)+i+1, end(num), num[i]);\\n            // swap them, done!\\n            swap(num[i], *itr);\\n        }\\n    };\\n\\nYou might need to think for a while why this would work."
		},
		{
			"lc_ans_id":"13994",
			"view":"1249",
			"top":"6",
			"title":"Readable code without confusing i/j, and with explanation",
			"vote":"28",
			"content":"Implementation based on description from [Project Nayuki](http://www.nayuki.io/page/next-lexicographical-permutation-algorithm). I cannot describe it better than them:\\n\\n![next permutation steps][1]\\n\\n\\tpublic class Solution {\\n\\t/*0*/ public void nextPermutation(int[] nums) {\\n\\t        // pivot is the element just before the non-increasing (weakly decreasing) suffix\\n\\t/*2*/   int pivot = indexOfLastPeak(nums) - 1;\\n\\t        // paritions nums into [prefix pivot suffix]\\n\\t        if (pivot != -1) {\\n\\t            int nextPrefix = lastIndexOfGreater(nums, nums[pivot]); // in the worst case it's suffix[0]\\n\\t            // next prefix must exist because pivot < suffix[0], otherwise pivot would be part of suffix\\n\\t/*4*/       swap(nums, pivot, nextPrefix); // this minimizes the change in prefix\\n\\t        }\\n\\t/*5*/   reverseSuffix(nums, pivot + 1); // reverses the whole list if there was no pivot\\n\\t/*6*/ }\\n\\t    \\n\\t    /**\\n\\t     * Find the last element which is a peak.\\n\\t     * In case there are multiple equal peaks, return the first of those.\\n\\t     * @return first index of last peak\\n\\t     */\\n\\t/*1*/ int indexOfLastPeak(int[] nums) {\\n\\t        for (int i = nums.length - 1; 0 < i; --i) {\\n\\t            if (nums[i - 1] < nums[i]) return i;\\n\\t        }\\n\\t        return 0;\\n\\t    }\\n\\n\\t    /** @return last index where the {@code num > threshold} or -1 if not found */\\n\\t/*3*/ int lastIndexOfGreater(int[] nums, int threshold) {\\n\\t        for (int i = nums.length - 1; 0 <= i; --i) {\\n\\t            if (threshold < nums[i]) return i;\\n\\t        }\\n\\t        return -1;\\n\\t    }\\n\\n\\t    /** Reverse numbers starting from an index till the end. */\\n\\t    void reverseSuffix(int[] nums, int start) {\\n\\t        int end = nums.length - 1;\\n\\t        while (start < end) {\\n\\t            swap(nums, start++, end--);\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    void swap(int[] nums, int i, int j) {\\n\\t        int temp = nums[i];\\n\\t        nums[i] = nums[j];\\n\\t        nums[j] = temp;\\n\\t    }\\n\\t}\\n\\n\\n  [1]: http://www.nayuki.io/res/next-lexicographical-permutation-algorithm/next-permutation-algorithm-thumb.png"
		},
		{
			"lc_ans_id":"13890",
			"view":"3287",
			"top":"7",
			"title":"Sharing my really simple solution with explanation",
			"vote":"23",
			"content":"    void nextPermutation(vector<int> &num) {\\n        for(int i = num.size() - 2; i >= 0; i--){\\n            if(num[i] < num[i + 1]){\\n                int pos;\\n                int diff = INT_MAX;\\n                for(int j = i + 1; j < num.size(); j++){\\n                    if(num[j] > num[i] && abs(num[i] - num[j]) < diff){\\n                        diff = abs(num[i] - num[j]);\\n                        pos = j;\\n                    }\\n                }\\n                swap(num[i], num[pos]);\\n                sort(num.begin() + i + 1, num.end());\\n                return;\\n            }\\n        }\\n        sort(num.begin(), num.end());\\n    }\\n\\nFor this problem, coding is not a big deal. Algorithm is!\\n\\nNow let's pick a number, for example, 24387651.\\n\\nwhat is the next permutation? 24513678.\\n\\nHow can I get the answer? \\n\\nFirst step: find the first ascending digit from the back of the number. 3 < 8 > 7 > 6 > 5 > 1. Then 3 is the digit.\\n\\nSecond step: swap that digit with the next big digit in following digits. Which one is the next big digit in 87651? 5! So swap them. Now the number becomes 24587631.\\n\\nThird step: sort 87631 into 13678. The final answer is 24513678."
		},
		{
			"lc_ans_id":"13907",
			"view":"2416",
			"top":"8",
			"title":"Easy python solution based on lexicographical permutation algorithm",
			"vote":"21",
			"content":"For the detailed algorithm and demonstration, please go to https://www.nayuki.io/page/next-lexicographical-permutation-algorithm\\n\\nThe steps are shown in the picture below.\\n![alt text](https://www.nayuki.io/res/next-lexicographical-permutation-algorithm/next-permutation-algorithm.png)\\n\\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # find longest non-increasing suffix\\n        right = len(nums)-1\\n        while nums[right] <= nums[right-1] and right-1 >=0:\\n            right -= 1\\n        if right == 0:\\n            return self.reverse(nums,0,len(nums)-1)\\n        # find pivot\\n        pivot = right-1\\n        successor = 0\\n        # find rightmost succesor\\n        for i in range(len(nums)-1,pivot,-1):\\n            if nums[i] > nums[pivot]:\\n                successor = i\\n                break\\n        # swap pivot and successor\\n        nums[pivot],nums[successor] = nums[successor],nums[pivot]  \\n        # reverse suffix\\n        self.reverse(nums,pivot+1,len(nums)-1)\\n        \\n    def reverse(self,nums,l,r):\\n        while l < r:\\n            nums[l],nums[r] = nums[r],nums[l]\\n            l += 1\\n            r -= 1\\n```"
		},
		{
			"lc_ans_id":"13894",
			"view":"2984",
			"top":"9",
			"title":"Two-pointer solution in python with detail expalanation",
			"vote":"8",
			"content":"Credit goes to http://blog.csdn.net/m6830098/article/details/17291259\\n\\n    class Solution(object):\\n        def nextPermutation(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            # Use two-pointers: two pointers start from back\\n            # first pointer j stop at descending point\\n            # second pointer i stop at value > nums[j]\\n            # swap and sort rest\\n            if not nums: return None\\n            i = len(nums)-1\\n            j = -1 # j is set to -1 for case `4321`, so need to reverse all in following step\\n            while i > 0:\\n                if nums[i-1] < nums[i]: # first one violates the trend\\n                  j = i-1\\n                  break\\n                i-=1\\n            for i in xrange(len(nums)-1, -1, -1):\\n                if nums[i] > nums[j]: # \\n                    nums[i], nums[j] = nums[j], nums[i] # swap position\\n                    nums[j+1:] = sorted(nums[j+1:]) # sort rest\\n                    return"
		}
	],
	"id":"31",
	"title":"Next Permutation",
	"content":"<p>\r\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\r\n</p>\r\n<p>\r\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\r\n</p>\r\n<p>\r\nThe replacement must be in-place, do not allocate extra memory.\r\n</p>\r\n<p>\r\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br />\r\n<code>1,2,3</code> &#8594; <code>1,3,2</code><br />\r\n<code>3,2,1</code> &#8594; <code>1,2,3</code><br />\r\n<code>1,1,5</code> &#8594; <code>1,5,1</code><br />\r\n</p>",
	"frequency":"457",
	"ac_num":"138263"
}