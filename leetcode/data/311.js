{
	"difficulty":"2",
	"submit_num":"79844",
	"show_id":"311",
	"leetcode_id":"311",
	"answers":[
		{
			"lc_ans_id":"76154",
			"view":"38350",
			"top":"0",
			"title":"Easiest JAVA solution",
			"vote":"106",
			"content":"\\nUPDATE: Thanks to @stpeterh we have this `70ms` concise solution:\\n<hr>\\n\\n\\n    public class Solution {\\n        public int[][] multiply(int[][] A, int[][] B) {\\n            int m = A.length, n = A[0].length, nB = B[0].length;\\n            int[][] C = new int[m][nB];\\n    \\n            for(int i = 0; i < m; i++) {\\n                for(int k = 0; k < n; k++) {\\n                    if (A[i][k] != 0) {\\n                        for (int j = 0; j < nB; j++) {\\n                            if (B[k][j] != 0) C[i][j] += A[i][k] * B[k][j];\\n                        }\\n                    }\\n                }\\n            }\\n            return C;   \\n        }\\n    }\\n\\n<hr>\\n\\nThe followings is the original `75ms` solution:\\n\\nThe idea is derived from [a CMU lecture.][1]\\n\\n>A sparse matrix can be represented as a sequence of rows, each of which is a sequence of (column-number, value) pairs of the nonzero values in the row.\\n\\nSo let's create a non-zero array for A, and do multiplication on B. \\n\\nHope it helps!\\n\\n<hr>\\n\\n\\n    public int[][] multiply(int[][] A, int[][] B) {\\n        int m = A.length, n = A[0].length, nB = B[0].length;\\n        int[][] result = new int[m][nB];\\n    \\n        List[] indexA = new List[m];\\n        for(int i = 0; i < m; i++) {\\n            List<Integer> numsA = new ArrayList<>();\\n            for(int j = 0; j < n; j++) {\\n                if(A[i][j] != 0){\\n                    numsA.add(j); \\n                    numsA.add(A[i][j]);\\n                }\\n            }\\n            indexA[i] = numsA;\\n        }\\n    \\n        for(int i = 0; i < m; i++) {\\n            List<Integer> numsA = indexA[i];\\n            for(int p = 0; p < numsA.size() - 1; p += 2) {\\n                int colA = numsA.get(p);\\n                int valA = numsA.get(p + 1);\\n                for(int j = 0; j < nB; j ++) {\\n                    int valB = B[colA][j];\\n                    result[i][j] += valA * valB;\\n                }\\n            }\\n        }\\n    \\n        return result;   \\n    }\\n\\n\\n  [1]: http://www.cs.cmu.edu/~scandal/cacm/node9.html"
		},
		{
			"lc_ans_id":"76150",
			"view":"12473",
			"top":"1",
			"title":"Java and Python Solutions with and without Tables",
			"vote":"38",
			"content":"Given A and B are sparse matrices, we could use lookup tables to speed up.  At the beginining I thought two lookup tables would be necessary.  After [discussing with @yavinci][1], I think one lookup table for B would be enough.  Surprisingly, it seems like detecting non-zero elements for both A and B on the fly without additional data structures provided the fastest performance on current test set.\\n\\nHowever, I think such fastest performance could due to an imperfect test set we have for OJ right now: there are only 12 test cases.  And, for an element `B[k, j]`, it would be detected for non-zero elements several times if we detecting both A and B on the fly, depending on how many `i`'s make elements `A[i, k]` non-zero.  With this point, the additional data structures, like lookup tables, should save our time by focusing on only non-zero elements.  If it is not, I am worried the set of OJ test cases probably is not good enough.\\n\\nAnyway, I am posting my respective solutions below.  Comments are welcome. Thanks @yavinci again for discussing with me.\\n\\nPython solution with only one table for B (~196ms):\\n\\n    class Solution(object):\\n        def multiply(self, A, B):\\n            \"\"\"\\n            :type A: List[List[int]]\\n            :type B: List[List[int]]\\n            :rtype: List[List[int]]\\n            \"\"\"\\n            if A is None or B is None: return None\\n            m, n, l = len(A), len(A[0]), len(B[0])\\n            if len(B) != n:\\n                raise Exception(\"A's column number must be equal to B's row number.\")\\n            C = [[0 for _ in range(l)] for _ in range(m)]\\n            tableB = {}\\n            for k, row in enumerate(B):\\n                tableB[k] = {}\\n                for j, eleB in enumerate(row):\\n                    if eleB: tableB[k][j] = eleB\\n            for i, row in enumerate(A):\\n                for k, eleA in enumerate(row):\\n                    if eleA:\\n                        for j, eleB in tableB[k].iteritems():\\n                            C[i][j] += eleA * eleB\\n            return C\\n\\nJava solution with only one table for B (~150ms):\\n\\n    public class Solution {\\n        public int[][] multiply(int[][] A, int[][] B) {\\n            if (A == null || A[0] == null || B == null || B[0] == null) return null;\\n            int m = A.length, n = A[0].length, l = B[0].length;\\n            int[][] C = new int[m][l];\\n            Map<Integer, HashMap<Integer, Integer>> tableB = new HashMap<>();\\n            \\n            for(int k = 0; k < n; k++) {\\n                tableB.put(k, new HashMap<Integer, Integer>());\\n                for(int j = 0; j < l; j++) {\\n                    if (B[k][j] != 0){\\n                        tableB.get(k).put(j, B[k][j]);\\n                    }\\n                }\\n            }\\n    \\n            for(int i = 0; i < m; i++) {\\n                for(int k = 0; k < n; k++) {\\n                    if (A[i][k] != 0){\\n                        for (Integer j: tableB.get(k).keySet()) {\\n                            C[i][j] += A[i][k] * tableB.get(k).get(j);\\n                        }\\n                    }\\n                }\\n            }\\n            return C;   \\n        }\\n    }\\n\\n\\nPython solution without table (~156ms):\\n\\n    class Solution(object):\\n        def multiply(self, A, B):\\n            \"\"\"\\n            :type A: List[List[int]]\\n            :type B: List[List[int]]\\n            :rtype: List[List[int]]\\n            \"\"\"\\n            if A is None or B is None: return None\\n            m, n, l = len(A), len(A[0]), len(B[0])\\n            if len(B) != n:\\n                raise Exception(\"A's column number must be equal to B's row number.\")\\n            C = [[0 for _ in range(l)] for _ in range(m)]\\n            for i, row in enumerate(A):\\n                for k, eleA in enumerate(row):\\n                    if eleA:\\n                        for j, eleB in enumerate(B[k]):\\n                            if eleB: C[i][j] += eleA * eleB\\n            return C\\n\\nJava solution without table (~70ms):\\n\\n    public class Solution {\\n        public int[][] multiply(int[][] A, int[][] B) {\\n            int m = A.length, n = A[0].length, l = B[0].length;\\n            int[][] C = new int[m][l];\\n    \\n            for(int i = 0; i < m; i++) {\\n                for(int k = 0; k < n; k++) {\\n                    if (A[i][k] != 0){\\n                        for (int j = 0; j < l; j++) {\\n                            if (B[k][j] != 0) C[i][j] += A[i][k] * B[k][j];\\n                        }\\n                    }\\n                }\\n            }\\n            return C;   \\n        }\\n    }\\n\\nPython solution with two tables (~196ms):\\n\\n    class Solution(object):\\n        def multiply(self, A, B):\\n            \"\"\"\\n            :type A: List[List[int]]\\n            :type B: List[List[int]]\\n            :rtype: List[List[int]]\\n            \"\"\"\\n            if A is None or B is None: return None\\n            m, n = len(A), len(A[0])\\n            if len(B) != n:\\n                raise Exception(\"A's column number must be equal to B's row number.\")\\n            l = len(B[0])\\n            table_A, table_B = {}, {}\\n            for i, row in enumerate(A):\\n                for j, ele in enumerate(row):\\n                    if ele:\\n                        if i not in table_A: table_A[i] = {}\\n                        table_A[i][j] = ele\\n            for i, row in enumerate(B):\\n                for j, ele in enumerate(row):\\n                    if ele:\\n                        if i not in table_B: table_B[i] = {}\\n                        table_B[i][j] = ele\\n            C = [[0 for j in range(l)] for i in range(m)]\\n            for i in table_A:\\n                for k in table_A[i]:\\n                    if k not in table_B: continue\\n                    for j in table_B[k]:\\n                        C[i][j] += table_A[i][k] * table_B[k][j]\\n            return C\\n          \\nJava solution with two tables (~160ms):\\n\\n    public class Solution {\\n        public int[][] multiply(int[][] A, int[][] B) {\\n            if (A == null || B == null) return null;\\n            if (A[0].length != B.length) \\n                throw new IllegalArgumentException(\"A's column number must be equal to B's row number.\");\\n            Map<Integer, HashMap<Integer, Integer>> tableA = new HashMap<>();\\n            Map<Integer, HashMap<Integer, Integer>> tableB = new HashMap<>();\\n            int[][] C = new int[A.length][B[0].length];\\n            for (int i = 0; i < A.length; i++) {\\n                for (int j = 0; j < A[i].length; j++) {\\n                    if (A[i][j] != 0) {\\n                        if(tableA.get(i) == null) tableA.put(i, new HashMap<Integer, Integer>());\\n                        tableA.get(i).put(j, A[i][j]);\\n                    }\\n                }\\n            }\\n            \\n            for (int i = 0; i < B.length; i++) {\\n                for (int j = 0; j < B[i].length; j++) {\\n                    if (B[i][j] != 0) {\\n                        if(tableB.get(i) == null) tableB.put(i, new HashMap<Integer, Integer>());\\n                        tableB.get(i).put(j, B[i][j]);\\n                    }\\n                }\\n            }\\n            \\n            for (Integer i: tableA.keySet()) {\\n                for (Integer k: tableA.get(i).keySet()) {\\n                    if (!tableB.containsKey(k)) continue;\\n                    for (Integer j: tableB.get(k).keySet()) {\\n                        C[i][j] += tableA.get(i).get(k) * tableB.get(k).get(j);\\n                    }\\n                }\\n            }\\n            return C;\\n        }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/71912/easiest-76ms-java-solution"
		},
		{
			"lc_ans_id":"76151",
			"view":"3163",
			"top":"2",
			"title":"[54ms ] Detailed Summary of Easiest JAVA solutions Beating 99.9%",
			"vote":"28",
			"content":"@yavinci  Talked about the \"smart\"/Easiest solution in his thread page ([here](https://discuss.leetcode.com/topic/30625/easiest-java-solution/12)), and most explanation down that page is not really touching why the smart solution is smart, So i am making this post to 1)explain in detail why the smart solution is smart and 2)make some improvements/tweaks on the smart solution code to show you which part is essential, 3) also i will briefly mention why [Sparse Matrix Manipulation](http://www.cs.cmu.edu/~scandal/cacm/node9.html) can help make some improvements on top of the smart solution.\\n\\na) Originally, the normal way to calculate the multiplication of two metrics A, and B is as follow:\\n        We take the the all values from the first line of A, and all values from the first column of B, and multiply the corresponding values and sum them up, the final sum is the value for the location of first column and first row in final result matrix.  Similarly, the value at [ i ][ j ] of result matrix C, which is C[ i ][ j ] is calculated as:\\n     \\nC[ i ][ j ] = A[ i ][0]*B[0][j]  +  A[i][1]*B[1][j] + A[i][2]*B[2][j] + ... A[i][K]*B[K][j]\\n( which is the sum of each multiplication of corresponding K values from row i of A and K values from column j of B )\\n```The Key is: if we calculate it this way, we finishing calculating the final value for the result matrix at once ```\\nThen the brute force solution is as follow:\\n\\n\\n    public class Solution {\\n            public int[][] multiply(int[][] A, int[][] B) {\\n                int m = A.length, n = A[0].length, nB = B[0].length;\\n                int[][] C = new int[m][nB];\\n\\n                for(int i = 0; i < m; i++) {\\n                        for (int j = 0; j < nB; j++) {\\n                            for(int k = 0; k < n; k++) {\\n                                 C[i][j] += A[i][k] * B[k][j];\\n                            }\\n                        }\\n                }\\n                return C;  \\n            }\\n    }\\n\\nb) ****The smart solution****, the key part of smart solution is that: it does not calculate the final result at once, and it takes each value from A, and calculate and partial sum and accumulate it into the final spot:\\nFor example, for each value A[i][k], if it is not zero, it will be used at most nB times ( n is B[0].length ), which can be illustrated as follow:\\nGenerally for the following equation:\\nC[ i ][ j ] = A[ i ][0]*B[0][j]  +  A[i][1]*B[1][j] + A[i][2]*B[2][j] + ... A[i][k]*B[k][j] ....  A[i][K]*B[K][j]\\nj can be from 0 to nB, if we write all of them down, it will like following:\\n[For i from 0 to nB \\nC[ i ][ 0 ]=A[ i ][0]*B[0][0]  +  A[i][1]*B[1][0] + A[i][2]*B[2][0] + ... A[i][k]B[k][0] ....  A[i][K]*B[K][0]\\nC[ i ][ 1 ]=A[ i ][0]*B[0][1]  +  A[i][1]*B[1][1] + A[i][2]*B[2][1] + ... A[i][k]B[k][0] ....  A[i][K]*B[K][1]\\n...\\nC[ i ][ nB ]=A[ i ][0]*B[0][nB]  +  A[i][1]*B[1][nB] + A[i][2]*B[2][nB] + ... A[i][k]B[k][nB] ....  A[i][K]*B[K][nB]\\n\\nAs you can see from above: for the same value A[i][k] from the first matrix, it will be used at most nB times if A[i][k] is not zero.  And the smart solution is taking advantage of that!!!, the smart solution can be described as:\\n\\nFor each value A[i][k] in matrix A, if it is not zero, we calculate A[i][k] * B[k][j] and accumulate it into C[ i ][ j ] (```Key part: the C[ i ][ j ] by now is not the final value in the result matrix !! Remember, in the brute force solution, the final value of C[i][j], takes sum of all multiplication values of K corresponding values from A and B? here C[ i ][ j ] is only sum of some multiplication values, NOT ALL until the program is done``` )\\n\\n**BY NOW, it is very clear that, if the value A[ i ][ k ] from matrix is zero, we skip a For-loop- calculation, which is a loop iterating nB times, and this is the key part of why the smart solution is smart!!!**\\n \\nThe smart Solution Code is as follow:\\n\\n\\n    public class Solution {\\n        public int[][] multiply(int[][] A, int[][] B) {\\n            int m = A.length, n = A[0].length, nB = B[0].length;\\n            int[][] C = new int[m][nB];\\n\\n            for(int i = 0; i < m; i++) {\\n                for(int k = 0; k < n; k++) {\\n                    if (A[i][k] != 0) {\\n                        for (int j = 0; j < nB; j++) {\\n                            if (B[k][j] != 0) C[i][j] += A[i][k] * B[k][j];\\n                        }\\n                    }\\n                }\\n            }\\n            return C;   \\n        }\\n    }\\n\\n( Credit:@yavinci , I am having a different version, so I am directly referencing the original version )\\n\\nBased on the discussion above, the inner checking ( ```if (B[k][j] != 0) ```  )  is actually not necessary, because whether or not we have that check, we still iterate nB times, ( since the operation ```C[i][j] += A[i][k] * B[k][j];``` inside the if-check is O(1) time)\\n\\nSo the smart solution can also be written as follow by removing the check ( which is my version ):\\n\\n\\n    public class Solution {\\n        public int[][] multiply(int[][] A, int[][] B) {\\n            int m = A.length, n = A[0].length, nB = B[0].length;\\n            int[][] C = new int[m][nB];\\n\\n            for(int i = 0; i < m; i++) {\\n                for(int k = 0; k < n; k++) {\\n                    if (A[i][k] != 0) {\\n                        for (int j = 0; j < nB; j++) {\\n                            if (B[k][j] != 0) C[i][j] += A[i][k] * B[k][j];\\n                        }\\n                    }\\n                }\\n            }\\n            return C;   \\n        }\\n    }\\n\\n\\nc) \"Sparse matrix manipultion\" helps, if we compress the first sparse matrix into rows of lists( in each row list, it contains ( value, index ) pair ), we actually don't need to go over all values in a row in matrix A when are calculating the final result matrix. But Overall, it does not help improve run time algorithmatically!!"
		},
		{
			"lc_ans_id":"76184",
			"view":"3907",
			"top":"3",
			"title":"The problem description is wrong. It should ask you to design data structure.",
			"vote":"22",
			"content":"It should be a data structure design problem. \\n\\nYou should give a reasonable data structure to present sparse matrix and multiplication method."
		},
		{
			"lc_ans_id":"76214",
			"view":"7758",
			"top":"4",
			"title":"Regular 28 ms math solution (6-8 lines)",
			"vote":"17",
			"content":"    class Solution {\\n    public:\\n        vector<vector<int>> multiply(vector<vector<int>>& A, vector<vector<int>>& B) {\\n            int m = A.size(), n = A[0].size();\\n            vector<vector<int>> res(m, vector<int>(B[0].size(),0));\\n            \\n            // for(int i = 0; i < m; i++){\\n            //     for(int k = 0; k < n; k++){\\n            //          for(int j = 0; j < n; j++){\\n            //              res[i][j] += A[i][k] * B[k][j];\\n            //          }\\n            //     }\\n            // }\\n            // imporved on upper version, this is a math solution\\n            for(int i = 0; i < m; i++){\\n                for(int k = 0; k < n; k++){\\n                    if(A[i][k] != 0)\\n                        for(int j = 0; j < B[0].size(); j++){\\n                            res[i][j] += A[i][k] * B[k][j];\\n                        }\\n                }\\n            }\\n            return res;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"76215",
			"view":"1915",
			"top":"5",
			"title":"The test cases need to be expanded",
			"vote":"13",
			"content":"Well, I think the test cases for this problem are too weak as the following buggy code adapted from [this link][1] gets accepted!\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> multiply(vector<vector<int>>& A, vector<vector<int>>& B) {\\n            int m = A.size(), n = B.size(), p = B[0].size();\\n            vector<vector<int>> C(m, vector<int>(p, 0));\\n            for (int i = 0; i < m; i++)\\n                for (int j = 0; j < n; j++)\\n                    if (A[i][j])\\n                        for (int k = 0; k < n; k++) // bug: k < n should be k < p\\n                            C[i][k] += A[i][j] * B[j][k];\\n            return C;\\n        }\\n    };\\n\\nSuppose `A` is of `m * n` and `B` is of `n * p`, I would suggest designing the test cases by considering all possible relationships of `m, n, p`:\\n\\n 1. `m > n > p`;\\n 2. `m > p > n`;\\n 3. `p > m > n`;\\n 4. ...\\n\\nMoreover, some test cases of non-sparse matrices could be added to verify that the solution is at least correct for multiplying two matrices. Sparse matrices may let many bugs slip through...\\n\\n[1]: https://leetcode.com/discuss/71968/regular-28-ms-math-solution-6-8-lines"
		},
		{
			"lc_ans_id":"76220",
			"view":"1610",
			"top":"6",
			"title":"My Java Solution",
			"vote":"9",
			"content":"         class Node {\\n            int x,y;\\n            Node(int x, int y) {\\n                this.x=x;\\n                this.y=y;\\n            }\\n        }\\n        public int[][] multiply(int[][] A, int[][] B) {\\n            int[][] result = new int[A.length][B[0].length];\\n            List<Node> listA = new ArrayList<>();\\n            List<Node> listB = new ArrayList<>();\\n            for (int i=0;i<A.length;i++) {\\n                for (int j=0; j<A[0].length; j++) {\\n                    if (A[i][j]!=0) listA.add(new Node(i,j));\\n                }\\n            }\\n            for (int i=0;i<B.length;i++) {\\n                for (int j=0;j<B[0].length;j++) {\\n                    if (B[i][j]!=0) listB.add(new Node(i,j));\\n                }\\n            }\\n    \\n            for (Node nodeA : listA) {\\n                for (Node nodeB: listB) {\\n                    if (nodeA.y==nodeB.x) {\\n                        result[nodeA.x][nodeB.y] += A[nodeA.x][nodeA.y] * B[nodeB.x][nodeB.y];\\n                    }\\n                }\\n            }\\n    \\n            return result;"
		},
		{
			"lc_ans_id":"76175",
			"view":"2940",
			"top":"7",
			"title":"C++ Straight Forward method",
			"vote":"9",
			"content":"First scan the two matrix to find the index of non-zeros entries, push these entries to vector. \\nWhen computing the result, just consider \\n1. when index equal, then increment both index\\n2. otherwise increment smaller index\\n\\n    vector<vector<int>> multiply(vector<vector<int>>& A, vector<vector<int>>& B) {\\n        \\n        int am = A.size();//2\\n        int bm = B.size();//3\\n        //if(!am || !bm)\\n        //    return result;\\n        int an = A[0].size();//3\\n        int bn = B[0].size();//3 2*3 3*3 => 2*3\\n        vector<vector<int>> result(am,vector<int>(bn,0));\\n        vector<vector<int>> A_non_zero(am);\\n        vector<vector<int>> B_non_zero(bn);\\n        //an == bm\\n        for(int i=0;i<am;i++)\\n            for(int j=0;j<an;j++)\\n                if(A[i][j])A_non_zero[i].push_back(j);\\n                \\n        for(int j=0;j<bn;j++)\\n            for(int i=0;i<bm;i++)\\n                if(B[i][j])B_non_zero[j].push_back(i);\\n        \\n        for(int i=0;i<am;i++)\\n            for(int j=0;j<bn;j++){\\n                int m=0,n=0;\\n                while(m<A_non_zero[i].size() && n<B_non_zero[j].size()){\\n                    int idx_A = A_non_zero[i][m];\\n                    int idx_B = B_non_zero[j][n];\\n                    if(idx_A == idx_B){\\n                        result[i][j]+= (A[i][idx_A]*B[idx_B][j]);\\n                        m++;\\n                        n++;\\n                    }\\n                    else if(idx_A > idx_B)\\n                        n++;\\n                    else \\n                        m++;\\n                }\\n            }\\n        return result;\\n            \\n                \\n    }"
		},
		{
			"lc_ans_id":"76165",
			"view":"770",
			"top":"8",
			"title":"Python Solution Fast",
			"vote":"4",
			"content":"```\\nclass Solution(object):\\n    def multiply(self, A, B):\\n        mA,nA,nB = len(A),len(A[0]),len(B[0])\\n        res = [[0]*len(B[0]) for _ in xrange(mA)]\\n        for i in xrange(mA):\\n            for j in xrange(nA):\\n                if A[i][j]:\\n                    for k in xrange(nB):\\n                        res[i][k] += A[i][j]*B[j][k]\\n        return res"
		},
		{
			"lc_ans_id":"76178",
			"view":"2692",
			"top":"9",
			"title":"Short Python solution",
			"vote":"4",
			"content":"    def multiply(self, A, B):\\n        cols = [[(j, b) for j, b in enumerate(col) if b]\\n                for col in zip(*B)]\\n        return [[sum(row[j]*b for j, b in col)\\n                 for col in cols]\\n                for row in A]"
		}
	],
	"id":"311",
	"title":"Sparse Matrix Multiplication",
	"content":"<p>Given two <a href=\"https://en.wikipedia.org/wiki/Sparse_matrix\" target=\"_blank\">sparse matrices</a> <b>A</b> and <b>B</b>, return the result of <b>AB</b>.</p>\r\n\r\n<p>You may assume that <b>A</b>'s column number is equal to <b>B</b>'s row number.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>A</b> = [\r\n  [ 1, 0, 0],\r\n  [-1, 0, 3]\r\n]\r\n\r\n<b>B</b> = [\r\n  [ 7, 0, 0 ],\r\n  [ 0, 0, 0 ],\r\n  [ 0, 0, 1 ]\r\n]\r\n\r\n\r\n     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |\r\n<b>AB</b> = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |\r\n                  | 0 0 1 |\r\n</pre>",
	"frequency":"331",
	"ac_num":"41689"
}