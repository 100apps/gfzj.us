{
	"difficulty":"3",
	"submit_num":"121400",
	"show_id":"315",
	"leetcode_id":"315",
	"answers":[
		{
			"lc_ans_id":"76580",
			"view":"34964",
			"top":"0",
			"title":"9ms  short Java BST solution get answer when building BST",
			"vote":"192",
			"content":"Every node will maintain a val **sum** recording the total of number on it's left bottom side, **dup** counts the duplication. For example, [3, 2, 2, 6, 1], from back to beginning,we would have:\\n\\n                    1(0, 1)\\n                         \\\\\\n                         6(3, 1)\\n                         /\\n                       2(0, 2)\\n                           \\\\\\n                            3(0, 1)\\n\\nWhen we try to insert a number, the total number of smaller number would be **adding dup and sum of the nodes where we turn right**.\\nfor example, if we insert 5, it should be inserted on the way down to the right of 3, the nodes where we turn right is 1(0,1), 2,(0,2), 3(0,1), so the answer should be (0 + 1)+(0 + 2)+ (0 + 1) = 4\\n \\nif we insert 7, the right-turning nodes are 1(0,1), 6(3,1), so answer should be (0 + 1) + (3 + 1) = 5\\n\\n    public class Solution {\\n        class Node {\\n            Node left, right;\\n            int val, sum, dup = 1;\\n            public Node(int v, int s) {\\n                val = v;\\n                sum = s;\\n            }\\n        }\\n        public List<Integer> countSmaller(int[] nums) {\\n            Integer[] ans = new Integer[nums.length];\\n            Node root = null;\\n            for (int i = nums.length - 1; i >= 0; i--) {\\n                root = insert(nums[i], root, ans, i, 0);\\n            }\\n            return Arrays.asList(ans);\\n        }\\n        private Node insert(int num, Node node, Integer[] ans, int i, int preSum) {\\n            if (node == null) {\\n                node = new Node(num, 0);\\n                ans[i] = preSum;\\n            } else if (node.val == num) {\\n                node.dup++;\\n                ans[i] = preSum + node.sum;\\n            } else if (node.val > num) {\\n                node.sum++;\\n                node.left = insert(num, node.left, ans, i, preSum);\\n            } else {\\n                node.right = insert(num, node.right, ans, i, preSum + node.dup + node.sum);\\n            }\\n            return node;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"76584",
			"view":"33160",
			"top":"1",
			"title":"Mergesort solution",
			"vote":"109",
			"content":"The smaller numbers on the right of a number are exactly those that jump from its right to its left during a stable sort. So I do mergesort with added tracking of those right-to-left jumps.\\n\\n**Update, new version**\\n\\n    def countSmaller(self, nums):\\n        def sort(enum):\\n            half = len(enum) / 2\\n            if half:\\n                left, right = sort(enum[:half]), sort(enum[half:])\\n                for i in range(len(enum))[::-1]:\\n                    if not right or left and left[-1][1] > right[-1][1]:\\n                        smaller[left[-1][0]] += len(right)\\n                        enum[i] = left.pop()\\n                    else:\\n                        enum[i] = right.pop()\\n            return enum\\n        smaller = [0] * len(nums)\\n        sort(list(enumerate(nums)))\\n        return smaller\\n\\n---\\n\\n**Old version**\\n\\n    def countSmaller(self, nums):\\n        def sort(enum):\\n            half = len(enum) / 2\\n            if half:\\n                left, right = sort(enum[:half]), sort(enum[half:])\\n                m, n = len(left), len(right)\\n                i = j = 0\\n                while i < m or j < n:\\n                    if j == n or i < m and left[i][1] <= right[j][1]:\\n                        enum[i+j] = left[i]\\n                        smaller[left[i][0]] += j\\n                        i += 1\\n                    else:\\n                        enum[i+j] = right[j]\\n                        j += 1\\n            return enum\\n        smaller = [0] * len(nums)\\n        sort(list(enumerate(nums)))\\n        return smaller"
		},
		{
			"lc_ans_id":"76583",
			"view":"11760",
			"top":"2",
			"title":"11ms JAVA solution using merge sort with explanation",
			"vote":"76",
			"content":"The basic idea is to do merge sort to nums[]. To record the result, we need to keep the index of each number in the original array. So instead of sort the number in nums, we sort the indexes of each number. \\nExample: nums = [5,2,6,1],  indexes = [0,1,2,3]\\n                After sort:             indexes = [3,1,0,2]\\n\\nWhile doing the merge part, say that we are merging left[] and right[], left[] and right[] are already sorted.\\n\\nWe keep a **rightcount** to record how many numbers from right[] we have added and keep an array **count[]** to record the result.\\n\\nWhen we move a number from right[] into the new sorted array, we increase rightcount by 1.\\n\\nWhen we move a number from left[] into the new sorted array, we increase count[ index of the number ] by **rightcount**.\\n\\n\\n\\n    int[] count;\\n    public List<Integer> countSmaller(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();     \\n\\n        count = new int[nums.length];\\n        int[] indexes = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++){\\n        \\tindexes[i] = i;\\n        }\\n        mergesort(nums, indexes, 0, nums.length - 1);\\n        for(int i = 0; i < count.length; i++){\\n        \\tres.add(count[i]);\\n        }\\n        return res;\\n    }\\n    private void mergesort(int[] nums, int[] indexes, int start, int end){\\n    \\tif(end <= start){\\n    \\t\\treturn;\\n    \\t}\\n    \\tint mid = (start + end) / 2;\\n    \\tmergesort(nums, indexes, start, mid);\\n    \\tmergesort(nums, indexes, mid + 1, end);\\n    \\t\\n    \\tmerge(nums, indexes, start, end);\\n    }\\n    private void merge(int[] nums, int[] indexes, int start, int end){\\n    \\tint mid = (start + end) / 2;\\n    \\tint left_index = start;\\n    \\tint right_index = mid+1;\\n    \\tint rightcount = 0;    \\t\\n    \\tint[] new_indexes = new int[end - start + 1];\\n\\n    \\tint sort_index = 0;\\n    \\twhile(left_index <= mid && right_index <= end){\\n    \\t\\tif(nums[indexes[right_index]] < nums[indexes[left_index]]){\\n    \\t\\t\\tnew_indexes[sort_index] = indexes[right_index];\\n    \\t\\t\\trightcount++;\\n    \\t\\t\\tright_index++;\\n    \\t\\t}else{\\n    \\t\\t\\tnew_indexes[sort_index] = indexes[left_index];\\n    \\t\\t\\tcount[indexes[left_index]] += rightcount;\\n    \\t\\t\\tleft_index++;\\n    \\t\\t}\\n    \\t\\tsort_index++;\\n    \\t}\\n    \\twhile(left_index <= mid){\\n\\t\\t\\tnew_indexes[sort_index] = indexes[left_index];\\n    \\t\\tcount[indexes[left_index]] += rightcount;\\n    \\t\\tleft_index++;\\n    \\t\\tsort_index++;\\n    \\t}\\n    \\twhile(right_index <= end){\\n\\t\\t\\tnew_indexes[sort_index++] = indexes[right_index++];\\n    \\t}\\n    \\tfor(int i = start; i <= end; i++){\\n    \\t\\tindexes[i] = new_indexes[i - start];\\n    \\t}\\n    }"
		},
		{
			"lc_ans_id":"76576",
			"view":"20503",
			"top":"3",
			"title":"My simple AC Java Binary Search code",
			"vote":"76",
			"content":"Traverse from the back to the beginning of the array, maintain an sorted array of numbers have been visited. Use findIndex() to find the first element in the sorted array which is larger or equal to target number. For example, [5,2,3,6,1], when we reach 2, we have a sorted array[1,3,6], findIndex() returns 1, which is the index where 2 should be inserted and is also the number smaller than 2. Then we insert 2 into the sorted array to form [1,2,3,6].\\n\\n    public List<Integer> countSmaller(int[] nums) {\\n        Integer[] ans = new Integer[nums.length];\\n        List<Integer> sorted = new ArrayList<Integer>();\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            int index = findIndex(sorted, nums[i]);\\n            ans[i] = index;\\n            sorted.add(index, nums[i]);\\n        }\\n        return Arrays.asList(ans);\\n    }\\n    private int findIndex(List<Integer> sorted, int target) {\\n        if (sorted.size() == 0) return 0;\\n        int start = 0;\\n        int end = sorted.size() - 1;\\n        if (sorted.get(end) < target) return end + 1;\\n        if (sorted.get(start) >= target) return 0;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (sorted.get(mid) < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        if (sorted.get(start) >= target) return start;\\n        return end;\\n    }\\n\\nDue to the O(n) complexity of ArrayList insertion, the total runtime complexity is not very fast, but anyway it got AC for around 53ms."
		},
		{
			"lc_ans_id":"76607",
			"view":"12259",
			"top":"4",
			"title":"C++ O(nlogn)-Time O(n)-Space MergeSort Solution with Detail Explanation",
			"vote":"71",
			"content":"MergeSort-based solution is a standard way to solve problems related to inverse numbers.\\n\\nHere is an example to illustrate the general idea of MergeSort-based algorithm:\\n\\nNow we want to consider an array\\n\\n                6 4 1 8 7 5 2 9\\n\\nFirst thing first, split the array into to subarrays:\\n\\n                6 4 1 8\\n                7 5 2 9\\n\\nand then calculate the inverse numbers within the group:\\n\\n                      1 4(1) 6(1,4) 8\\n                      2 5(2) 7(2,5) 9\\n\\nwhere the numbers in the parentheses are the numbers that should be counted when we calculate the inverse number.\\nNow we need to merge these two arrays into one sorted array. The first element to be put into the sorted destination array is the \"1\" in the first array.\\n\\n     1                  4(1) 6(1,4) 8\\n                      2 5(2) 7(2,5) 9               merged elements in the 2nd array = ()\\n\\nThe second element to merge is the \"2\" in the second array:\\n\\n     1 2                4(1) 6(1,4) 8\\n                        5(2) 7(2,5) 9               merged elements in the 2nd array = (2)\\n\\n\\nThe third element to merge is the \"4\" in the first array:\\n\\n     1 2 4(1,2)              6(1,4) 8\\n                        5(2) 7(2,5) 9               merged elements in the 2nd array = (2)\\n\\nWhen we merge the \"4(1)\", we found that \"4\" is actually greater than all merged elements in the second array (i.e. [2]). Therefore, we also need to consider those elements. Therefore, the numbers in the parenthese of 2 become (1)+(2) = (1,2). Next step:\\n\\n     1 2 4(1,2) 5(2)         6(1,4) 8\\n                             7(2,5) 9               merged elements in the 2nd array = (2,5)\\n\\nNext (add the inverse number of element \"6\" by 2)\\n\\n     1 2 4(1,2) 5(2) 6(1,4,2,5)     8\\n                             7(2,5) 9               merged elements in the 2nd array = (2,5)\\n\\nSo and so forth, finally reach\\n            \\n     1 2 4(1,2) 5(2) 6(1,4,2,5) 7(2,5) 8(2,5,7) 9\\n                                                    merged elements in the 2nd array = (2,5,7,9)\\n\\nAdditionally, when we need to count the inverse number, we do not need to record the exact elements, we only need to record the numbers. So, we can use a variable to record the number of \"merged elements in the 2nd array\" (for example, `semilen` in the code beneath) and the number of smaller elements of each element (for example, `results[idx]` in the code beneath).\\n\\n-\\n\\n**Complexities:**\\n\\n- Time: O(n log n)\\n\\n- Space: O(n)\\n\\n\\n-\\n\\n**C++ Accepted Code:**\\n\\n    class Solution {\\n    protected:\\n        void merge_countSmaller(vector<int>& indices, int first, int last, \\n                                vector<int>& results, vector<int>& nums) {\\n            int count = last - first;\\n            if (count > 1) {\\n                int step = count / 2;\\n                int mid = first + step;\\n                merge_countSmaller(indices, first, mid, results, nums);\\n                merge_countSmaller(indices, mid, last, results, nums);\\n                vector<int> tmp;\\n                tmp.reserve(count);\\n                int idx1 = first;\\n                int idx2 = mid;\\n                int semicount = 0;\\n                while ((idx1 < mid) || (idx2 < last)) {\\n                    if ((idx2 == last) || ((idx1 < mid) &&\\n                           (nums[indices[idx1]] <= nums[indices[idx2]]))) {\\n    \\t\\t\\t\\t\\ttmp.push_back(indices[idx1]);\\n                        results[indices[idx1]] += semicount;\\n                        ++idx1;\\n                    } else {\\n    \\t\\t\\t\\t\\ttmp.push_back(indices[idx2]);\\n                        ++semicount;\\n                        ++idx2;\\n                    }\\n                }\\n                move(tmp.begin(), tmp.end(), indices.begin()+first);\\n            }\\n        }\\n    public:\\n        vector<int> countSmaller(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<int> results(n, 0);\\n            vector<int> indices(n, 0);\\n            iota(indices.begin(), indices.end(), 0);\\n            merge_countSmaller(indices, 0, n, results, nums);\\n            return results;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"76587",
			"view":"8071",
			"top":"5",
			"title":"Easiest Java solution",
			"vote":"48",
			"content":"Traverse from `nums[len - 1]` to `nums[0]`,  and build a binary search tree, which stores:\\n\\n1. `val`: value of `nums[i]`\\n2. `count`: if `val == root.val`, there will be `count` number of smaller numbers on the right\\n\\nRun time is `10ms`. Hope it helps!\\n\\n    public class Solution {\\n    \\tpublic List<Integer> countSmaller(int[] nums) {\\n    \\t\\tList<Integer> res = new ArrayList<>();\\n    \\t\\tif(nums == null || nums.length == 0) return res;\\n    \\t\\tTreeNode root = new TreeNode(nums[nums.length - 1]);\\n    \\t\\tres.add(0);\\n    \\t\\tfor(int i = nums.length - 2; i >= 0; i--) {\\n    \\t\\t\\tint count = insertNode(root, nums[i]);\\n    \\t\\t\\tres.add(count);\\n    \\t\\t}\\n    \\t\\tCollections.reverse(res);\\n    \\t\\treturn res;\\n    \\t}\\n    \\n    \\tpublic int insertNode(TreeNode root, int val) {\\n    \\t\\tint thisCount = 0;\\n    \\t\\twhile(true) {\\n    \\t\\t\\tif(val <= root.val) {\\n    \\t\\t\\t\\troot.count++;\\n    \\t\\t\\t\\tif(root.left == null) {\\n    \\t\\t\\t\\t\\troot.left = new TreeNode(val); break;\\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tthisCount += root.count;\\n    \\t\\t\\t\\tif(root.right == null) {\\n    \\t\\t\\t\\t\\troot.right = new TreeNode(val); break;\\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn thisCount;\\n    \\t}\\n    }\\n    \\n    class TreeNode {\\n    \\tTreeNode left; \\n    \\tTreeNode right;\\n    \\tint val;\\n    \\tint count = 1;\\n    \\tpublic TreeNode(int val) {\\n    \\t\\tthis.val = val;\\n    \\t}\\n    }"
		},
		{
			"lc_ans_id":"76611",
			"view":"7905",
			"top":"6",
			"title":"Short Java Binary Index Tree BEAT 97.33% With Detailed Explanation",
			"vote":"30",
			"content":"This is the Binary Index Tree.\\n\\nHere is a very good explanation. \\n\\n [What is Binary Index Tree ][1]\\n\\nThe basic idea is:\\n\\n    1, we should build an array with the length equals to the max element of the nums array as BIT.\\n    2, To avoid minus value in the array, we should first add the (min+1) for every elements \\n    (It may be out of range, where we can use long to build another array. But no such case in the test cases so far.)\\n    3, Using standard BIT operation to solve it.\\n\\nHere is the code, welcome to judge me:\\n\\n\\n    public class Solution {\\n        public List<Integer> countSmaller(int[] nums) {\\n            List<Integer> res = new LinkedList<Integer>();\\n            if (nums == null || nums.length == 0) {\\n                return res;\\n            }\\n            // find min value and minus min by each elements, plus 1 to avoid 0 element\\n            int min = Integer.MAX_VALUE;\\n            int max = Integer.MIN_VALUE;\\n            for (int i = 0; i < nums.length; i++) {\\n                min = (nums[i] < min) ? nums[i]:min;\\n            }\\n            int[] nums2 = new int[nums.length];\\n            for (int i = 0; i < nums.length; i++) {\\n                nums2[i] = nums[i] - min + 1;\\n                max = Math.max(nums2[i],max);\\n            }\\n            int[] tree = new int[max+1];\\n            for (int i = nums2.length-1; i >= 0; i--) {\\n                res.add(0,get(nums2[i]-1,tree));\\n                update(nums2[i],tree);\\n            }\\n            return res;\\n        }\\n        private int get(int i, int[] tree) {\\n            int num = 0;\\n            while (i > 0) {\\n                num +=tree[i];\\n                i -= i&(-i);\\n            }\\n            return num;\\n        }\\n        private void update(int i, int[] tree) {\\n            while (i < tree.length) {\\n                tree[i] ++;\\n                i += i & (-i);\\n            }\\n        }\\n    }\\n\\n  [1]: https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/"
		},
		{
			"lc_ans_id":"76657",
			"view":"6646",
			"top":"7",
			"title":"3 ways (Segment Tree, Binary Indexed Tree, Binary Search Tree) clean python code",
			"vote":"27",
			"content":"**Segment Tree**\\n\\n    class SegmentTreeNode(object):\\n        def __init__(self, val, start, end):\\n            self.val = val\\n            self.start = start\\n            self.end = end\\n            self.children = []\\n    \\n    \\n    class SegmentTree(object):\\n        def __init__(self, n):\\n            self.root = self.build(0, n - 1)\\n    \\n        def build(self, start, end):\\n            if start > end:\\n                return\\n    \\n            root = SegmentTreeNode(0, start, end)\\n            if start == end:\\n                return root\\n    \\n            mid = start + end >> 1\\n            root.children = filter(None, [\\n                self.build(start, end)\\n                for start, end in ((start, mid), (mid + 1, end))])\\n            return root\\n    \\n        def update(self, i, val, root=None):\\n            root = root or self.root\\n            if i < root.start or i > root.end:\\n                return root.val\\n    \\n            if i == root.start == root.end:\\n                root.val += val\\n                return root.val\\n    \\n            root.val = sum([self.update(i, val, c) for c in root.children])\\n            return root.val\\n    \\n        def sum(self, start, end, root=None):\\n            root = root or self.root\\n            if end < root.start or start > root.end:\\n                return 0\\n    \\n            if start <= root.start and end >= root.end:\\n                return root.val\\n    \\n            return sum([self.sum(start, end, c) for c in root.children])\\n    \\n    \\n    class Solution(object):\\n        def countSmaller(self, nums):\\n            hashTable = {v: i for i, v in enumerate(sorted(set(nums)))}\\n    \\n            tree, r = SegmentTree(len(hashTable)), []\\n            for i in xrange(len(nums) - 1, -1, -1):\\n                r.append(tree.sum(0, hashTable[nums[i]] - 1))\\n                tree.update(hashTable[nums[i]], 1)\\n            return r[::-1]\\n    \\n\\n**Binary Indexed Tree** \\n\\n\\n    class BinaryIndexedTree(object):\\n        def __init__(self, n):\\n            self.sums = [0] * (n + 1)\\n    \\n        def update(self, i, val):\\n            while i < len(self.sums):\\n                self.sums[i] += 1\\n                i += i & -i\\n    \\n        def sum(self, i):\\n            r = 0\\n            while i > 0:\\n                r += self.sums[i]\\n                i -= i & -i\\n            return r\\n    \\n    \\n    class Solution(object):\\n        def countSmaller(self, nums):\\n            hashTable = {v: i for i, v in enumerate(sorted(set(nums)))}\\n    \\n            tree, r = BinaryIndexedTree(len(hashTable)), []\\n            for i in xrange(len(nums) - 1, -1, -1):\\n                r.append(tree.sum(hashTable[nums[i]]))\\n                tree.update(hashTable[nums[i]] + 1, 1)\\n            return r[::-1]\\n\\n\\n**Binary Search Tree**    \\n\\n\\n    class BinarySearchTreeNode(object):\\n        def __init__(self, val):\\n            self.val = val\\n            self.left = None\\n            self.right = None\\n            self.count = 1\\n            self.leftTreeSize = 0\\n    \\n    \\n    class BinarySearchTree(object):\\n        def __init__(self):\\n            self.root = None\\n    \\n        def insert(self, val, root):\\n            if not root:\\n                self.root = BinarySearchTreeNode(val)\\n                return 0\\n    \\n            if val == root.val:\\n                root.count += 1\\n                return root.leftTreeSize\\n    \\n            if val < root.val:\\n                root.leftTreeSize += 1\\n\\n                if not root.left:\\n                    root.left = BinarySearchTreeNode(val)\\n                    return 0\\n                return self.insert(val, root.left)\\n    \\n            if not root.right:\\n                root.right = BinarySearchTreeNode(val)\\n                return root.count + root.leftTreeSize\\n    \\n            return root.count + root.leftTreeSize + self.insert(\\n                val, root.right)\\n    \\n    \\n    class Solution(object):\\n        def countSmaller(self, nums):\\n            tree = BinarySearchTree()\\n            return [\\n                tree.insert(nums[i], tree.root)\\n                for i in xrange(len(nums) - 1, -1, -1)\\n            ][::-1]"
		},
		{
			"lc_ans_id":"76729",
			"view":"3216",
			"top":"8",
			"title":"O(NlogN) divide and conquer java solution based on bit by bit comparison",
			"vote":"14",
			"content":"Before I actually get into the solution, let me first ask the question: given two integers, how would you determine which one is larger and which is smaller? \\n\\nOh, you would say, use the built-in relational operators that come with the programming languages. True, it will give you the right answer, at a relatively higher level. But now imagine you were the computer, how would you actually do the comparison? **Remember now all you can see are two series of binary bits representing the two integers**. You have no better ways but start from the most significant bit and check bit by bit towards the least significant bit. The first bit will tell you the sign of the two numbers and you know positive numbers (with sign bit value of `0`) will be greater than negative numbers (with sign bit value `1`). If they have the same sign, then you continue to the next bit with the idea in mind that numbers with bit value `1` will be greater than those with bit value `0`. You compare the two series of binary bits in this manner until at some point you can distinguish them or end up with no more bits to check(means the two integers are equal). \\n\\nWhat if we have an array of integers? It doesn't matter. We can proceed in the same way. First check the sign of each integer and partition them into two groups: positive integers and negative ones. Then for each group, we partition the integers further into two groups depending on the next-bit value: those with bit value `1` and those with bit value `0` (to unify sign partition and other bits partitions, we will call the two groups after each partition as `highGroup` and `lowGroup` to indicate that all the integers in the `highGroup` will be greater than those in the `lowGroup`). And so on until we either have no numbers to partition or no bits to check. (Here we assume the integers have finite length of bits)\\n\\nNow let's turn to our problem: for each integer in an array, count the number of integers to its right that are smaller than it. Based on the analysis above, we will have a group of integers as the input (initially the group will be the same as the input array). we then divide the integers into `highGroup` and `lowGroup` according to either the sign bit or other-bit values. Since for each integer in the group, we only care about integers to its right, it would be better if we scan the group from right to left. For each integer currently being checked, if it belongs to the `highGroup`, we know it will be greater than all those in the `lowGroup` accumulated so far. We proceed in this fashion until either the group is empty or have no more bits to check.\\n\\nNotes: \\n\\n 1. To unify sign bit partition and other-bit partition, we used a variable called `highBit` to distinguish these two cases.\\n 2. we store the **indices** of the elements instead of the elements themselves as it would be easier to set the results.\\n3. I used a customized `ListNode` instead of the Java built-in lists to avoid reallocation of space for each partition. So after each partition, all elements belonging to the `lowGroup` will be detached from the input group (which is assumed to be `highGroup` by default) and form the `lowGroup` while the remaining elements will be the `highGroup`.\\n4. I reversed the order of the elements when adding them to the list due to list performance consideration.\\n\\nThe time complexity can be analyzed as follows:\\n\\nLet T(n) be the total run time and after the partition, we have b*n number in one group and (1-b)*n in the other with 0 <= b <= 1. Now the original problem is divided into two smaller subproblems with size given by b*n and (1-b)*n. And the solution to the original problem can be obtained by combining the solutions to the two subproblems in O(n) time, then we have:  \\n\\nT(n) = T(b*n) + T((1-b)*n) + O(n) \\n\\nThe solution to the characteristic equation b^x + (1-b)^x = 1 is x = 1 so the runtime complexity will be O(nlogn) according to the master theorem (one tricky scenario is b = 0 or b = 1. In this case the runtime is essentially linear provided the total number of bits in each integer is constant). By the way the space complexity is apparently O(n) due to the partition.\\n\\n**Update**: The time complexity analysis above is based on the assumption that the number of partition is logarithmically dependent on the input array size, which is not the case for this problem. The number of partition is constant provided the integer bit size is constant (See @**StefanPochmann**'s answer below). \\nTherefore O(nlogn) is a relaxed upper bound while the algorithm can run in linear time.\\n\\nHere is the complete Java program:\\n\\n\\n```\\nclass ListNode {\\n    int val, size;\\n    ListNode next;\\n    \\t\\n    ListNode(int val) {\\n    \\tthis.val = val;\\n    }\\n}\\n    \\npublic List<Integer> countSmaller(int[] nums) {\\n    Integer[] res = new Integer[nums.length];\\n    Arrays.fill(res, 0);\\n        \\n    ListNode highGroup = new ListNode(-1), itr = highGroup;\\n    \\n    for (int i = nums.length - 1; i >= 0; i--) {\\n        itr.next = new ListNode(i);\\n        itr = itr.next;\\n        highGroup.size++;\\n    }\\n        \\n    countSmallerSub(nums, highGroup, 1 << 31, res);\\n    return Arrays.asList(res);\\n}\\n    \\nprivate void countSmallerSub(int[] nums, ListNode highGroup, int mask, Integer[] res) {\\n    if (mask != 0 && highGroup.size > 1) {\\n    \\tListNode lowGroup = new ListNode(-1);\\n    \\t\\n    \\tint highBit = (mask < 0 ? 0 : mask);\\n    \\t    \\n    \\tfor (ListNode i1 = highGroup, i2 = lowGroup; i1.next != null;) {\\n    \\t    if ((nums[i1.next.val] & mask) == highBit) {\\n    \\t\\tres[i1.next.val] += lowGroup.size;\\n    \\t\\ti1 = i1.next;\\n    \\t\\t        \\n    \\t    } else {\\n    \\t\\ti2.next = i1.next;\\n    \\t\\ti1.next = i1.next.next;\\n    \\t\\ti2 = i2.next;\\n    \\t\\ti2.next = null;\\n    \\t\\tlowGroup.size++;\\n    \\t\\thighGroup.size--;\\n    \\t    }\\n    \\t}\\n    \\t    \\n    \\tcountSmallerSub(nums, highGroup, mask >>> 1, res);\\n    \\tcountSmallerSub(nums, lowGroup, mask >>> 1, res);\\n    }\\n}"
		},
		{
			"lc_ans_id":"76708",
			"view":"2479",
			"top":"9",
			"title":"C++ 14 line solution",
			"vote":"13",
			"content":"    class Solution {\\n    public:\\n        vector<int> countSmaller(vector<int>& nums) {\\n            vector<int> db;\\n            vector<int> result(nums.size());\\n            for(int i = nums.size()-1; i >= 0; i--)\\n            {\\n                auto it = lower_bound(db.begin(), db.end(), nums[i]);\\n                result[i] = it - db.begin();\\n                db.insert(it, nums[i]);\\n            }\\n            return result;\\n        }\\n    };"
		}
	],
	"id":"315",
	"title":"Count of Smaller Numbers After Self",
	"content":"<p>\r\nYou are given an integer array <i>nums</i> and you have to return a new <i>counts</i> array.\r\nThe <i>counts</i> array has the property where <code>counts[i]</code> is \r\nthe number of smaller elements to the right of <code>nums[i]</code>.\r\n</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\nGiven <i>nums</i> = [5, 2, 6, 1]\r\n\r\nTo the right of 5 there are <b>2</b> smaller elements (2 and 1).\r\nTo the right of 2 there is only <b>1</b> smaller element (1).\r\nTo the right of 6 there is <b>1</b> smaller element (1).\r\nTo the right of 1 there is <b>0</b> smaller element.\r\n</pre>\r\n\r\n<p>\r\nReturn the array <code>[2, 1, 1, 0]</code>.\r\n</p>",
	"frequency":"388",
	"ac_num":"42423"
}