{
	"difficulty":"3",
	"submit_num":"61987",
	"show_id":"317",
	"leetcode_id":"317",
	"answers":[
		{
			"lc_ans_id":"76880",
			"view":"19284",
			"top":"0",
			"title":"36 ms C++ solution",
			"vote":"81",
			"content":"I also tested the other three C++ solutions posted so far, they took 340-1812 ms. I think mine is faster because I don't use a fresh \"`visited`\" for each BFS. Instead, I walk only onto the cells that were reachable from all previous buildings. From the first building I only walk onto cells where `grid` is 0, and make them -1. From the second building I only walk onto cells where `grid` is -1, and I make them -2. And so on.\\n\\n    int shortestDistance(vector<vector<int>> grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        auto total = grid;\\n        int walk = 0, mindist, delta[] = {0, 1, 0, -1, 0};\\n        for (int i=0; i<m; ++i) {\\n            for (int j=0; j<n; ++j) {\\n                if (grid[i][j] == 1) {\\n                    mindist = -1;\\n                    auto dist = grid;\\n                    queue<pair<int, int>> q;\\n                    q.emplace(i, j);\\n                    while (q.size()) {\\n                        auto ij = q.front();\\n                        q.pop();\\n                        for (int d=0; d<4; ++d) {\\n                            int i = ij.first + delta[d];\\n                            int j = ij.second + delta[d+1];\\n                            if (i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == walk) {\\n                                grid[i][j]--;\\n                                dist[i][j] = dist[ij.first][ij.second] + 1;\\n                                total[i][j] += dist[i][j] - 1;\\n                                q.emplace(i, j);\\n                                if (mindist < 0 || mindist > total[i][j])\\n                                    mindist = total[i][j];\\n                            }\\n                        }\\n                    }\\n                    walk--;\\n                }\\n            }\\n        }\\n        return mindist;\\n    }"
		},
		{
			"lc_ans_id":"76891",
			"view":"16494",
			"top":"1",
			"title":"Java solution with explanation and time complexity analysis",
			"vote":"62",
			"content":"Inspired by previous solution.\\nThe main idea is the following:\\n\\nTraverse the matrix. For each building, use BFS to compute the shortest distance from each '0' to\\n this building. After we do this for all the buildings, we can get the sum of shortest distance\\n from every '0' to all reachable buildings. This value is stored\\n in 'distance[][]'. For example, if grid[2][2] == 0, distance[2][2] is the sum of shortest distance from this block to all reachable buildings.\\nTime complexity: O(number of 1)*O(number of 0) ~ O(m^2*n^2)\\n    \\nWe also count how many building each '0' can be reached. It is stored in reach[][]. This can be done during the BFS. We also need to count how many total buildings are there in the matrix, which is stored in 'buildingNum'.\\n\\nFinally, we can traverse the distance[][] matrix to get the point having shortest distance to all buildings. O(m*n)\\n    \\nThe total time complexity will be O(m^2*n^2), which is quite high!. Please let me know if I did the analysis wrong or you have better solution.\\n\\n\\n    public class Solution {\\n        public int shortestDistance(int[][] grid) {\\n            if (grid == null || grid[0].length == 0) return 0;\\n            final int[] shift = new int[] {0, 1, 0, -1, 0};\\n            \\n            int row  = grid.length, col = grid[0].length;\\n            int[][] distance = new int[row][col];\\n            int[][] reach = new int[row][col];\\n            int buildingNum = 0;\\n            \\n            for (int i = 0; i < row; i++) {\\n                for (int j =0; j < col; j++) {\\n                    if (grid[i][j] == 1) {\\n                        buildingNum++;\\n                        Queue<int[]> myQueue = new LinkedList<int[]>();\\n                        myQueue.offer(new int[] {i,j});\\n    \\n                        boolean[][] isVisited = new boolean[row][col];\\n                        int level = 1;\\n                        \\n                        while (!myQueue.isEmpty()) {\\n                            int qSize = myQueue.size();\\n                            for (int q = 0; q < qSize; q++) {\\n                                int[] curr = myQueue.poll();\\n                                \\n                                for (int k = 0; k < 4; k++) {\\n                                    int nextRow = curr[0] + shift[k];\\n                                    int nextCol = curr[1] + shift[k + 1];\\n                                    \\n                                    if (nextRow >= 0 && nextRow < row && nextCol >= 0 && nextCol < col\\n                                        && grid[nextRow][nextCol] == 0 && !isVisited[nextRow][nextCol]) {\\n                                            //The shortest distance from [nextRow][nextCol] to thic building\\n                                            // is 'level'.\\n                                            distance[nextRow][nextCol] += level;\\n                                            reach[nextRow][nextCol]++;\\n                                            \\n                                            isVisited[nextRow][nextCol] = true;\\n                                            myQueue.offer(new int[] {nextRow, nextCol});\\n                                        }\\n                                }\\n                            }\\n                            level++;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            int shortest = Integer.MAX_VALUE;\\n            for (int i = 0; i < row; i++) {\\n                for (int j = 0; j < col; j++) {\\n                    if (grid[i][j] == 0 && reach[i][j] == buildingNum) {\\n                        shortest = Math.min(shortest, distance[i][j]);\\n                    }\\n                }\\n            }\\n            \\n            return shortest == Integer.MAX_VALUE ? -1 : shortest;\\n            \\n            \\n        }\\n    }"
		},
		{
			"lc_ans_id":"76886",
			"view":"6525",
			"top":"2",
			"title":"Share a Java implement",
			"vote":"30",
			"content":"Short version: BFS from every building, calculate the distances and find the minimum distance in the end.\\n\\nKey optimization : we do not go into a land, if it is not accessible by at least one of previous buildings.\\n\\nFor a long explanation see [here](http://algobox.org/shortest-distance-from-all-buildings/) in my blog.\\n\\nIt runs in 13 ms.\\n\\nIt is the same idea as stefan's c++ solution. I didn't see it until now. I did this myself.\\n\\nAlso one may want to make a copy of `grid` if it is not suppose to be modified.\\n\\n**Java**\\n\\n    int[] dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\\n\\n    public int shortestDistance(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n];\\n        // Initialize building list and accessibility matrix `grid`\\n        List<Tuple> buildings = new ArrayList<>();\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 1)\\n                    buildings.add(new Tuple(i, j, 0));\\n                grid[i][j] = -grid[i][j];\\n            }\\n        // BFS from every building\\n        for (int k = 0; k < buildings.size(); ++k)\\n            bfs(buildings.get(k), k, dist, grid, m, n);\\n        // Find the minimum distance\\n        int ans = -1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (grid[i][j] == buildings.size() && (ans < 0 || dist[i][j] < ans))\\n                    ans = dist[i][j];\\n        return ans;\\n    }\\n\\n    public void bfs(Tuple root, int k, int[][] dist, int[][] grid, int m, int n) {\\n        Queue<Tuple> q = new ArrayDeque<>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            Tuple b = q.poll();\\n            dist[b.y][b.x] += b.dist;\\n            for (int i = 0; i < 4; ++i) {\\n                int x = b.x + dx[i], y = b.y + dy[i];\\n                if (y >= 0 && x >= 0 && y < m && x < n && grid[y][x] == k) {\\n                    grid[y][x] = k + 1;\\n                    q.add(new Tuple(y, x, b.dist + 1));\\n                }\\n            }\\n        }\\n    }\\n    class Tuple {\\n        public int y;\\n        public int x;\\n        public int dist;\\n\\n        public Tuple(int y, int x, int dist) {\\n            this.y = y;\\n            this.x = x;\\n            this.dist = dist;\\n        }\\n    }\\n    // 72 / 72 test cases passed.\\n    // Status: Accepted\\n    // Runtime: 13 ms\\n    // 99.22%"
		},
		{
			"lc_ans_id":"76942",
			"view":"5255",
			"top":"3",
			"title":"My BFS Java Solution",
			"vote":"14",
			"content":"    public class Solution {\\n    public int shortestDistance(int[][] grid) {\\n        int row = grid.length;\\n        if (row == 0) {\\n            return -1;\\n        }\\n        int col = grid[0].length;\\n        int[][] record1 = new int[row][col]; // visited num\\n        int[][] record2 = new int[row][col]; // distance\\n        int num1 = 0;\\n        for (int r = 0; r < row; r++) {\\n            for (int c = 0; c < col; c++) {\\n                if (grid[r][c] == 1) {\\n                    num1 ++;\\n                    boolean[][] visited = new boolean[row][col];\\n                    Queue<int[]> queue = new LinkedList<int[]>();\\n                    queue.offer(new int[]{r, c});\\n                    int dist = 0;\\n                    while (!queue.isEmpty()) {\\n                        int size = queue.size();\\n                        for (int i = 0; i < size; i++) {\\n                            int[] node = queue.poll();\\n                            int x = node[0];\\n                            int y = node[1];\\n                            record2[x][y] += dist;\\n                            record1[x][y] ++;\\n                            if (x > 0 && grid[x - 1][y] == 0 && !visited[x - 1][y]) {\\n                                queue.offer(new int[]{x - 1, y});\\n                                visited[x - 1][y] = true;\\n                            }\\n                            if (x + 1 < row && grid[x + 1][y] == 0 && !visited[x + 1][y]) {\\n                                queue.offer(new int[]{x + 1, y});\\n                                visited[x + 1][y] = true;\\n                            }\\n                            if (y > 0 && grid[x][y - 1] == 0 && !visited[x][y - 1]) {\\n                                queue.offer(new int[]{x, y - 1});\\n                                visited[x][y - 1] = true;\\n                            }\\n                            if (y + 1 < col && grid[x][y + 1] == 0 && !visited[x][y + 1]) {\\n                                queue.offer(new int[]{x, y + 1});\\n                                visited[x][y + 1] = true;\\n                            }\\n                        }\\n                        dist ++;\\n                    }\\n                }\\n            }\\n        }\\n        int result = Integer.MAX_VALUE;\\n        for (int r = 0; r < row; r++) {\\n            for (int c = 0; c < col; c++) {\\n                if (grid[r][c] == 0 && record1[r][c] == num1 && record2[r][c] < result) {\\n                    result = record2[r][c];\\n                }\\n            }\\n        }\\n        return result == Integer.MAX_VALUE ? -1 : result;\\n    }\\n}"
		},
		{
			"lc_ans_id":"76930",
			"view":"1781",
			"top":"4",
			"title":"9~10ms JAVA solution beats 98%",
			"vote":"12",
			"content":"    public class Solution {\\n    \\n    /*\\n    - beats 98% 9ms JAVA BFS \\n    - basically use lee-algroithm, bfs each 1 to find out min distance to each 0, accumulate this distances to each 0 location: distance[][], finally find out min value from distance[][]\\n    - In the case of cannot find a house to each all house: \\n        - not all 0s can reach each house: reachCount[][] to count the # of house each 0 can reach, only >= houseCount valid\\n        - [~~improve speed~~]\\uff1anot all house can reach each house, in this case, we cannot build such house, \\n            -count reachable house #, if < houseCount, return -1 directly!!!!!\\n    */\\n    \\n    public int shortestDistance(int[][] grid) {\\n        \\n        if (grid.length == 0 || grid[0].length == 0) {\\n            return -1;\\n        }\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] distance = new int[m][n];  //accumulated distance of each house (1) to each 0\\n        int[][] reachCount = new int[m][n]; //count reachable house for each 0\\n        int houseCount = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    houseCount++;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    //houseCount++;\\n                    if (!bfs(grid, distance, reachCount, houseCount, m, n, i, j)) {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n        int minDistance = Integer.MAX_VALUE;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0 && reachCount[i][j] == houseCount) {\\n                    minDistance = Math.min(minDistance, distance[i][j]);\\n                }\\n            }\\n        }\\n        return minDistance == Integer.MAX_VALUE ? -1 : minDistance;\\n        \\n    }\\n    \\n    private boolean bfs(int[][] grid, int[][] distance, int[][] reachCount, int houseCount, int m, int n, int x, int y) {\\n        \\n        int[][] visited = new int[m][n];\\n        Queue<int[]> q = new LinkedList<int[]>();\\n        q.offer(new int[]{x, y});  \\n        int[] dx = new int[]{0, 0, -1, 1};\\n        int[] dy = new int[]{1, -1, 0, 0};\\n        int level = 0;\\n        int count = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            level++;               \\n            for (int i = 0; i < size; i++) {//level by level\\n                int[] curr = q.poll();\\n                for (int k = 0; k < 4; k++) { //visit all neighbors & accumulate distance\\n                    int nx = curr[0] + dx[k];\\n                    int ny = curr[1] + dy[k];\\n                    if (nx >=0 && ny >= 0 && nx < m && ny < n  && visited[nx][ny] == 0) {\\n                        if (grid[nx][ny] == 0) {\\n                            distance[nx][ny] += level;\\n                            visited[nx][ny] = 1;\\n                            reachCount[nx][ny]++;\\n                            q.offer(new int[]{nx, ny});\\n                        } else if (grid[nx][ny] == 1) {\\n                            count++;\\n                            visited[nx][ny] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count == houseCount;\\n    }\\n}"
		},
		{
			"lc_ans_id":"76877",
			"view":"3754",
			"top":"5",
			"title":"Python solution 72ms beats 100%, BFS with pruning",
			"vote":"12",
			"content":"Use `hit` to record how many times a `0` grid has been reached and use `distSum` to record the sum of distance from all `1` grids to this `0` grid. A powerful pruning is that during the BFS we use `count1` to count how many `1` grids we reached. If `count1 < buildings` then we know not all `1` grids are connected are we can return `-1` immediately, which greatly improved speed (beat 100% submissions).\\n\\n    def shortestDistance(self, grid):\\n        if not grid or not grid[0]: return -1\\n        M, N, buildings = len(grid), len(grid[0]), sum(val for line in grid for val in line if val == 1)\\n        hit, distSum = [[0] * N for i in range(M)], [[0] * N for i in range(M)]\\n        \\n        def BFS(start_x, start_y):\\n            visited = [[False] * N for k in range(M)]\\n            visited[start_x][start_y], count1, queue = True, 1, collections.deque([(start_x, start_y, 0)])\\n            while queue:\\n                x, y, dist = queue.popleft()\\n                for i, j in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):\\n                    if 0 <= i < M and 0 <= j < N and not visited[i][j]:\\n                        visited[i][j] = True\\n                        if not grid[i][j]:\\n                            queue.append((i, j, dist + 1))\\n                            hit[i][j] += 1\\n                            distSum[i][j] += dist + 1\\n                        elif grid[i][j] == 1:\\n                            count1 += 1\\n            return count1 == buildings  \\n        \\n        for x in range(M):\\n            for y in range(N):\\n                if grid[x][y] == 1:\\n                    if not BFS(x, y): return -1\\n        return min([distSum[i][j] for i in range(M) for j in range(N) if not grid[i][j] and hit[i][j] == buildings] or [-1])"
		},
		{
			"lc_ans_id":"76944",
			"view":"2897",
			"top":"6",
			"title":"C++ BFS clean solution, easy understanding with simple explanation.",
			"vote":"10",
			"content":"        int shortestDistance(vector<vector<int>>& grid) {\\n        const int row = grid.size();\\n        if (0 == row) return -1;\\n        const int col = grid[0].size();\\n        \\n        vector<vector<int> > distance(row, vector<int>(col, 0));\\n        vector<vector<int>> reach(row, vector<int>(col, 0));\\n        int building = 0, res = INT_MAX;\\n        \\n        for (int i = 0; i < row; i++) \\n            for (int j = 0; j < col; j++) {\\n            // check from the building node, extend to all 0 node with distance\\n            if (1 == grid[i][j]) {\\n                ++building;\\n                int dist = 0;\\n                vector<vector<bool>> visited(row, vector<bool>(col, false));\\n                queue<pair<int, int>> curLevel, nextLevel;\\n                curLevel.emplace(i, j);\\n                // bfs search for each current building\\n                while (!curLevel.empty()) {\\n                    ++dist;\\n                    while (!curLevel.empty()) {\\n                        pair<int, int> cur = curLevel.front(); \\n                        curLevel.pop();\\n                        int x = cur.first, y = cur.second;\\n                        ++reach[x][y];\\n                        vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n                        for (auto dir : dirs) {\\n                            int i = x + dir.first, j = y + dir.second;\\n                            if (i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size() && 0 == grid[i][j] && !visited[i][j]) \\n                            {\\n                                distance[i][j] += dist;\\n                                nextLevel.emplace(i, j);\\n                                visited[i][j] = true;\\n                            }\\n                        }\\n                    }\\n                    swap(curLevel, nextLevel);\\n                }\\n            }\\n        }\\n    for (int i = 0; i < row; i++) {\\n        for (int j = 0; j < col; j++) {\\n            if (0 == grid[i][j] && reach[i][j] == building) {\\n                res = min(res, distance[i][j]);\\n            }\\n        }\\n    }\\n    return res == INT_MAX ? -1 : res;\\n}"
		},
		{
			"lc_ans_id":"76943",
			"view":"1202",
			"top":"7",
			"title":"16ms c++, fastest? improvement of StefanPorsche's code",
			"vote":"8",
			"content":"/* firstly, stefan has done great job optimizing by reducing empty land. link:\\nhttps://leetcode.com/discuss/74453/36-ms-c-solution\\n\\nhowever in processing each building, he creates whole board to store distance:\\nauto dist = grid;\\n\\nwhich is replaced by one variable level in my code. the running time is reduced to 16ms from 36ms. */\\n\\n    class Solution {\\n    public:\\n        int shortestDistance(vector<vector<int>>& grid) {\\n            int m=grid.size(), n=grid[0].size(), mark=0, ans;\\n            \\n            vector<vector<int>> dist(m, vector<int>(n, 0));\\n            \\n            int dx[4] = {0, 1, 0, -1}; // up, right, down, left\\n            int dy[4] = {1, 0, -1, 0};\\n            \\n            for (int i=0; i<n; i++)\\n                for (int j=0; j<m; j++)\\n                    if (grid[j][i]==1) {\\n                        vector<pair<int, int>> bfs(1, make_pair(j, i)), bfs2;\\n                        int level=1;\\n                        ans=INT_MAX;\\n                        while (!bfs.empty()) {\\n                            for (auto p : bfs) {\\n                                int y=p.first, x=p.second;\\n                                for (int d=0; d<4; d++) {\\n                                    int nx=x+dx[d], ny=y+dy[d];\\n                                    if (0<=nx && nx<n && 0<=ny && ny<m && grid[ny][nx]==mark) {\\n                                        grid[ny][nx] = mark-1;\\n                                        dist[ny][nx] += level;\\n                                        ans = min(ans, dist[ny][nx]);\\n                                        bfs2.push_back(make_pair(ny, nx));\\n                                    }\\n                                }\\n                            }\\n                            level++;\\n                            std::swap(bfs, bfs2);\\n                            bfs2.clear();\\n                        }\\n                        mark -= 1;\\n                    }\\n            return ans==INT_MAX ? -1 : ans;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"76946",
			"view":"879",
			"top":"8",
			"title":"BFS java solution",
			"vote":"4",
			"content":"    public class Solution {\\n        int m, n;\\n        public int shortestDistance(int[][] grid) {\\n            if( grid == null || grid.length ==0 || grid[0].length == 0) return -1;\\n            m = grid.length;\\n            n = grid[0].length;\\n            int[][] dist = new int [m][n];\\n            int buildNo = 0;\\n            int[][] reach = new int[m][n];\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (grid[i][j] == 1) {\\n                        buildNo++;\\n                        bfs(grid, dist, reach, i, j);\\n                    }\\n                }\\n            }\\n            int min = Integer.MAX_VALUE;\\n            for(int i = 0; i < m; i++){\\n                for(int j = 0; j < n; j++){\\n                    if(grid[i][j] == 0 && reach[i][j] == buildNo) {\\n                        min = Math.min(min, dist[i][j]);\\n                    }\\n                }\\n            }\\n            if(min == Integer.MAX_VALUE) return -1;\\n            return min;\\n        }\\n        \\n        public void bfs(int[][] grid, int[][] dist, int[][] reach, int i, int j) {\\n            int[] x = {0, 1, -1, 0};\\n            int[] y = {1, 0, 0, -1};\\n            LinkedList<int[]> queue = new LinkedList<int[]>();\\n            queue.offer(new int[] {i, j});\\n            boolean[][] visited = new boolean[m][n];\\n            int step = 1;\\n            int[][] cur_dist = new int[m][n];\\n            while (!queue.isEmpty()){\\n                int size = queue.size();\\n                for (int a = 0; a < size; a++) {\\n                    int[] cur = queue.poll();\\n                    for (int b = 0; b < 4; b++){\\n                        int ii = cur[0] + x[b];\\n                        int jj = cur[1] + y[b];\\n                        if (ii >= 0 && ii < m && jj >= 0 && jj < n && grid[ii][jj] == 0 && !visited[ii][jj]) {\\n                            cur_dist[ii][jj] = step;\\n                            reach[ii][jj]++;\\n                            visited[ii][jj] = true;\\n                            queue.offer(new int[] {ii, jj});\\n                            dist[ii][jj] += cur_dist[ii][jj];\\n                        }\\n                    }\\n                }\\n                step++;\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"76937",
			"view":"976",
			"top":"9",
			"title":"Java and Python Solutions with BFS",
			"vote":"4",
			"content":"Java Solution:\\n\\n    public class Solution {\\n        public int shortestDistance(int[][] grid) {\\n            if (grid == null || grid.length == 0 || grid[0] == null || grid[0].length == 0) \\n                return -1; \\n            List<int[]> emptyLands = new ArrayList<>();\\n            List<int[]> buildings = new ArrayList<>();\\n            int nrow = grid.length;\\n            int ncol = grid[0].length;\\n            int[][] dists = new int[nrow][ncol];\\n            int[][] visitedNums = new int[nrow][ncol];\\n            int minimalDist = Integer.MAX_VALUE;\\n    \\n            // Find Buildings and Empty Lands\\n            for (int i = 0; i < nrow; i++) {\\n                for (int j = 0; j < ncol; j++) {\\n                    if (grid[i][j] == 0) {\\n                        emptyLands.add(new int[]{i, j});\\n                    }\\n                    else if (grid[i][j] == 1) {\\n                        buildings.add(new int[]{i, j});\\n                    }\\n                }\\n            }\\n            //BFS for each Building\\n            for (int[] indices: buildings) {\\n                Queue<int[]> queue = new ArrayDeque<>();\\n                boolean[][] visited = new boolean[nrow][ncol];\\n                queue.offer(new int[]{indices[0], indices[1], 0});\\n                while (!queue.isEmpty()) {\\n                    int[] current = queue.poll();\\n                    int x = current[0], y = current[1], dist = current[2];\\n                    if (x+1 < nrow && grid[x+1][y] == 0 && !visited[x+1][y]) {\\n                        dists[x+1][y] += dist + 1;\\n                        queue.offer(new int[]{x+1, y, dist+1});\\n                        visited[x+1][y] = true;\\n                        visitedNums[x+1][y]++;\\n                    }\\n                    if (x-1 >= 0 && grid[x-1][y] == 0 && !visited[x-1][y]) {\\n                        dists[x-1][y] += dist + 1;\\n                        queue.offer(new int[]{x-1, y, dist+1});\\n                        visited[x-1][y] = true;\\n                        visitedNums[x-1][y]++;\\n                    }\\n                    if (y+1 < ncol && grid[x][y+1] == 0 && !visited[x][y+1]) {\\n                        dists[x][y+1] += dist + 1;\\n                        queue.offer(new int[]{x, y+1, dist+1});\\n                        visited[x][y+1] = true;\\n                        visitedNums[x][y+1]++;\\n                    }\\n                    if (y-1 >= 0 && grid[x][y-1] == 0 && !visited[x][y-1]) {\\n                        dists[x][y-1] += dist + 1;\\n                        queue.offer(new int[]{x, y-1, dist+1});\\n                        visited[x][y-1] = true;\\n                        visitedNums[x][y-1]++;\\n                    }\\n                }\\n            }\\n            \\n            //Find the Empty Land with smallest total dist\\n            int size = buildings.size();\\n            for (int[] indices: emptyLands) {\\n                int x = indices[0], y = indices[1];\\n                if (dists[x][y] < minimalDist && visitedNums[x][y] == size) {\\n                    minimalDist = dists[x][y];\\n                }\\n            }\\n            return minimalDist == Integer.MAX_VALUE ? -1 : minimalDist;\\n        }\\n    }\\n\\nPython Solution:\\n\\n    class Solution(object):\\n        def shortestDistance(self, grid):\\n            \"\"\"\\n            :type grid: List[List[int]]\\n            :rtype: int\\n            \"\"\"\\n            if grid is None or len(grid) == 0 or grid[0] is None or len(grid[0]) == 0:\\n                return -1\\n            nrow, ncol = len(grid), len(grid[0])\\n            dists, visited_nums, building_num = {}, {}, 0\\n            min_dist = float(\"inf\")\\n            \\n            for i, row in enumerate(grid):\\n                for j, ele in enumerate(row):\\n                    if ele == 1:\\n                        building_num += 1\\n                        queue = collections.deque()\\n                        queue.append((i, j, 0))\\n                        visited = {}\\n                        while queue:\\n                            x, y, dist = queue.popleft()\\n                            if x+1 < nrow and grid[x+1][y] == 0 and (x+1, y) not in visited:\\n                                dists[(x+1, y)] = dists.get((x+1, y), 0) + dist + 1\\n                                visited_nums[(x+1, y)] = visited_nums.get((x+1, y), 0) + 1\\n                                visited[(x+1, y)] = True\\n                                queue.append((x+1, y, dist+1))\\n                            if x-1 >= 0 and grid[x-1][y] == 0 and (x-1, y) not in visited:\\n                                dists[(x-1, y)] = dists.get((x-1, y), 0) + dist + 1\\n                                visited_nums[(x-1, y)] = visited_nums.get((x-1, y), 0) + 1\\n                                visited[(x-1, y)] = True\\n                                queue.append((x-1, y, dist+1))\\n                            if y+1 < ncol and grid[x][y+1] == 0 and (x, y+1) not in visited:\\n                                dists[(x, y+1)] = dists.get((x, y+1), 0) + dist + 1\\n                                visited_nums[(x, y+1)] = visited_nums.get((x, y+1), 0) + 1\\n                                visited[(x, y+1)] = True\\n                                queue.append((x, y+1, dist+1))\\n                            if y-1 >= 0 and grid[x][y-1] == 0 and (x, y-1) not in visited:\\n                                dists[(x, y-1)] = dists.get((x, y-1), 0) + dist + 1\\n                                visited_nums[(x, y-1)] = visited_nums.get((x, y-1), 0) + 1\\n                                visited[(x, y-1)] = True\\n                                queue.append((x, y-1, dist+1))\\n            \\n            \\n            for x, y in dists:\\n                if dists[(x, y)] < min_dist and visited_nums[(x, y)] == building_num:\\n                    min_dist = dists[(x, y)]\\n            \\n            if min_dist == float(\"inf\"):\\n                return -1\\n            \\n            return min_dist"
		}
	],
	"id":"317",
	"title":"Shortest Distance from All Buildings",
	"content":"<p>You want to build a house on an <i>empty</i> land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values <b>0</b>, <b>1</b> or <b>2</b>, where:</p>\r\n<ul>\r\n<li>Each <b>0</b> marks an empty land which you can pass by freely.</li>\r\n<li>Each <b>1</b> marks a building which you cannot pass through.</li>\r\n<li>Each <b>2</b> marks an obstacle which you cannot pass through.</li>\r\n</ul>\r\n\r\n<p>For example, given three buildings at <code>(0,0)</code>, <code>(0,4)</code>, <code>(2,2)</code>, and an obstacle at <code>(0,2)</code>:</p>\r\n\r\n<pre>1 - 0 - 2 - 0 - 1\r\n|   |   |   |   |\r\n0 - 0 - 0 - 0 - 0\r\n|   |   |   |   |\r\n0 - 0 - 1 - 0 - 0</pre>\r\n\r\n<p>The point <code>(1,2)</code> is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.</p>\r\n\r\n<p><b>Note:</b><br>\r\nThere will be at least one building. If it is not possible to build such house according to the above rules, return -1.</p>",
	"frequency":"194",
	"ac_num":"21494"
}