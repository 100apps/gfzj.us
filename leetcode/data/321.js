{
	"difficulty":"3",
	"submit_num":"88110",
	"show_id":"321",
	"leetcode_id":"321",
	"answers":[
		{
			"lc_ans_id":"77285",
			"view":"35228",
			"top":"0",
			"title":"Share my greedy solution",
			"vote":"171",
			"content":"Many of the posts have the same algorithm. In short we can first solve 2 simpler problem\\n\\n1. Create the maximum number of one array \\n2. Create the maximum number of two array using all of their digits.\\n\\nFor an long and detailed explanation see my blog [here][1].\\n\\nThe algorithm is O((m+n)^3) in the worst case. It runs in 22 ms.\\n\\n**Java**\\n\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int[] ans = new int[k];\\n        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {\\n            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\\n            if (greater(candidate, 0, ans, 0)) ans = candidate;\\n        }\\n        return ans;\\n    }\\n    private int[] merge(int[] nums1, int[] nums2, int k) {\\n        int[] ans = new int[k];\\n        for (int i = 0, j = 0, r = 0; r < k; ++r)\\n            ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n        return ans;\\n    }\\n    public boolean greater(int[] nums1, int i, int[] nums2, int j) {\\n        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\\n            i++;\\n            j++;\\n        }\\n        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\\n    }\\n    public int[] maxArray(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] ans = new int[k];\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            while (n - i + j > k && j > 0 && ans[j - 1] < nums[i]) j--;\\n            if (j < k) ans[j++] = nums[i];\\n        }\\n        return ans;\\n    }\\n\\n\\n  [1]: http://algobox.org/create-maximum-number/"
		},
		{
			"lc_ans_id":"77287",
			"view":"14184",
			"top":"1",
			"title":"C++ 16ms, FASTEST, beats 97%.",
			"vote":"104",
			"content":"The basic idea:\\n\\nTo create max number of length k from two arrays, you need to create max number of length i from array one and max number of length k-i from array two, then combine them together. After trying all possible i, you will get the max number created from two arrays.\\n\\nOptimization: \\n\\n1. Suppose nums1 = [3, 4, 6, 5], nums2 = [9, 1, 2, 5, 8, 3], the maximum number you can create from nums1 is [6, 5] with length 2. For nums2, it's [9, 8, 3] with length 3. Merging the two sequence, we have [9, 8, 6, 5, 3], which is the max number we can create from two arrays without length constraint. If the required length k<=5, we can simply trim the result to required length from front. For instance, if k=3, then [9, 8, 6] is the result. \\n\\n2. Suppose we need to create max number with length 2 from num = [4, 5, 3, 2, 1, 6, 0, 8]. The simple way is to use a stack, first we push 4 and have stack [4], then comes 5 > 4, we pop 4 and push 5, stack becomes [5], 3 < 5, we push 3, stack becomes [5, 3]. Now we have the required length 2, but we need to keep going through the array in case a larger number comes, 2 < 3, we discard it instead of pushing it because the stack already grows to required size 2. 1 < 3, we discard it. 6 > 3, we pop 3, since 6 > 5 and there are still elements left, we can continue to pop 5 and push 6, the stack becomes [6], since 0 < 6, we push 0, the stack becomes [6, 0], the stack grows to required length again. Since 8 > 0, we pop 0, although 8 > 6, we can't continue to pop 6 since there is only one number, which is 8, left, if we pop 6 and push 8, we can't get to length 2, so we push 8 directly, the stack becomes [6, 8]. \\n\\n3. In the basic idea, we mentioned trying all possible length i. If we create max number for different i from scratch each time, that would be a waste of time. Suppose num = [4, 9, 3, 2, 1, 8, 7, 6], we need to create max number with length from 1 to 8. For i==8, result is the original array. For i==7, we need to drop 1 number from array, since 9 > 4, we drop 4, the result is [9, 3, 2, 1, 8, 7, 6]. For i==6, we need to drop 1 more number, 3 < 9, skip, 2 < 3, skip, 1 < 2, skip, 8 > 1, we drop 1, the result is [9, 3, 2, 8, 7, 6]. For i==5, we need to drop 1 more, but this time, we needn't check from beginning, during last scan, we already know [9, 3, 2] is monotonically non-increasing, so we check 8 directly, since 8 > 2, we drop 2, the result is [9, 3, 8, 7, 6]. For i==4, we start with 8, 8 > 3, we drop 3, the result is [9, 8, 7, 6]. For i==3, we start with 8, 8 < 9, skip, 7 < 8, skip, 6 < 7, skip, by now, we've got maximum number we can create from num without length constraint. So from now on, we can drop a number from the end each time. The result is [9, 8, 7], For i==2, we drop last number 7 and have [9, 8]. For i==1, we drop last number 8 and have [9].\\n\\n#\\n\\n    class Solution {\\n    public:\\n        #define MIN(a,b) (a<b?a:b)\\n        #define MAX(a,b) (a>b?a:b)\\n        // create max number of length t from single non-empty vector\\n        void getMax(int* num, int& len, int* result, int& t, int& sortedLen)\\n        {\\n        \\tint n, top = 0;\\n        \\tresult[0] = num[0];\\n        \\tconst int need2drop = len - t;\\n        \\tfor (int i = 1; i < len; ++i){\\n        \\t\\tn = num[i];\\n        \\t\\twhile (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numbers\\n        \\t\\tif (i - top > need2drop){\\n        \\t\\t\\tsortedLen = MAX(1,top);\\n        \\t\\t\\twhile (++top < t) result[top] = num[i++];\\n        \\t\\t\\treturn;\\n        \\t\\t}\\n        \\t\\tif (++top < t) result[top] = n;\\n        \\t\\telse top = t - 1;\\n        \\t}\\n        }\\n        // create max number of different length from single vector\\n        void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){\\n        \\tint  j, *head, *prevhead = res;\\n        \\tconst int soi = sizeof(int);\\n        \\tgetMax(num, len, res, maxL,sortedLen);\\n        \\tfor (int l = maxL; l > MAX(minL,1); --l){\\n        \\t\\thead = prevhead + k;\\n        \\t\\tmemcpy(head, prevhead, l*soi);\\n        \\t\\tfor (j = sortedLen; j < l; ++j){\\n        \\t\\t\\tif (head[j] > head[j - 1]){\\n        \\t\\t\\t\\tsortedLen = MAX(1, j - 1);\\n        \\t\\t\\t\\tmemcpy(head + j - 1, prevhead + j, soi*(l - j));\\n        \\t\\t\\t\\tbreak;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\tif (j == l) sortedLen = l;\\n        \\t\\tprevhead = head;\\n        \\t}\\n        }\\n        // merge max number created from single vector\\n        void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){\\n        \\tint i = 0, j = 0, k = 0;\\n        \\twhile (i < resSize){\\n        \\t\\tif (j < len1 && k < len2){\\n        \\t\\t\\tif (num1[j] > num2[k])\\n        \\t\\t\\t\\tresult[i++] = num1[j++];\\n        \\t\\t\\telse if (num1[j] < num2[k])\\n        \\t\\t\\t\\tresult[i++] = num2[k++];\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\tint remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];\\n        \\t\\t\\t\\tint flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));\\n        \\t\\t\\t\\tflag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);\\n        \\t\\t\\t\\tint * num = flag > 0 ? num1 : num2;\\n        \\t\\t\\t\\tint & cnt = flag > 0 ? j : k;\\n        \\t\\t\\t\\tint len = flag > 0 ? len1 : len2;\\n        \\t\\t\\t\\twhile (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\telse if (j < len1) result[i++] = num1[j++];\\n        \\t\\telse result[i++] = num2[k++];\\n        \\t}\\n        }\\n        \\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){\\n        \\tint soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;\\n        \\tint minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;\\n        \\tint * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;\\n        \\tmemset(res, 0, step);\\n        \\tint sortedLen1 = 1, sortedLen2 = 1;\\n        \\tif (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);\\n        \\telse if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);\\n        \\telse if (len1 > 0 && len2 > 0){\\n        \\t\\tdp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);\\n        \\t\\tdp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);\\n        \\t\\tif (sortedLen1 + sortedLen2 > k){\\n        \\t\\t\\tmerge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);\\n        \\t\\t\\tvector<int> resv(tmp, tmp + k);\\n        \\t\\t\\tdelete[] res;\\n        \\t\\t\\treturn resv;\\n        \\t\\t}\\n        \\t\\tfor (int i = minL1; i <= maxL1; ++i){\\n        \\t\\t\\tmerge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);\\n        \\t\\t\\tif (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);\\n        \\t\\t}\\n        \\t}\\n        \\tvector<int> resv(res, res + k);\\n        \\tdelete[] res;\\n        \\treturn resv;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"77286",
			"view":"14011",
			"top":"2",
			"title":"Short Python / Ruby / C++",
			"vote":"61",
			"content":"**Python**\\n\\n    def maxNumber(self, nums1, nums2, k):\\n\\n        def prep(nums, k):\\n            drop = len(nums) - k\\n            out = []\\n            for num in nums:\\n                while drop and out and out[-1] < num:\\n                    out.pop()\\n                    drop -= 1\\n                out.append(num)\\n            return out[:k]\\n\\n        def merge(a, b):\\n            return [max(a, b).pop(0) for _ in a+b]\\n\\n        return max(merge(prep(nums1, i), prep(nums2, k-i))\\n                   for i in range(k+1)\\n                   if i <= len(nums1) and k-i <= len(nums2))\\n\\nSolved it on my own but now I see others already posted this idea. Oh well, at least it's short, particularly my `merge` function.\\n\\nThe last two lines can be combined, but I find it rather ugly and not worth it:  \\n`for i in range(max(k-len(nums2), 0), min(k, len(nums1))+1))`\\n\\n---\\n\\n**Ruby**\\n\\n    def prep(nums, k)\\n      drop = nums.size - k\\n      out = [9]\\n      nums.each do |num|\\n        while drop > 0 && out[-1] < num\\n          out.pop\\n          drop -= 1\\n        end\\n        out << num\\n      end\\n      out[1..k]\\n    end\\n    \\n    def max_number(nums1, nums2, k)\\n      ([k-nums2.size, 0].max .. [nums1.size, k].min).map { |k1|\\n        parts = [prep(nums1, k1), prep(nums2, k-k1)]\\n        (1..k).map { parts.max.shift }\\n      }.max\\n    end\\n\\n---\\n\\n**C++**\\n\\nTranslated it to C++ as well now. Not as short anymore, but still decent. And C++ allows different functions with the same name, so I chose to do that here to show how nicely the `maxNumber(nums1, nums2, k)` problem can be based on the problems `maxNumber(nums, k)` and `maxNumber(nums1, nums2)`, which would make fine problems on their own.\\n\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        vector<int> best;\\n        for (int k1=max(k-n2, 0); k1<=min(k, n1); ++k1)\\n            best = max(best, maxNumber(maxNumber(nums1, k1),\\n                                       maxNumber(nums2, k-k1)));\\n        return best;\\n    }\\n\\n    vector<int> maxNumber(vector<int> nums, int k) {\\n        int drop = nums.size() - k;\\n        vector<int> out;\\n        for (int num : nums) {\\n            while (drop && out.size() && out.back() < num) {\\n                out.pop_back();\\n                drop--;\\n            }\\n            out.push_back(num);\\n        }\\n        out.resize(k);\\n        return out;\\n    }\\n\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        vector<int> out;\\n        while (nums1.size() + nums2.size()) {\\n            vector<int>& now = nums1 > nums2 ? nums1 : nums2;\\n            out.push_back(now[0]);\\n            now.erase(now.begin());\\n        }\\n        return out;\\n    }\\n\\nAn alternative for `maxNumber(nums1, nums2)`:\\n\\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\\n        vector<int> out;\\n        auto i1 = nums1.begin(), end1 = nums1.end();\\n        auto i2 = nums2.begin(), end2 = nums2.end();\\n        while (i1 != end1 || i2 != end2)\\n            out.push_back(lexicographical_compare(i1, end1, i2, end2) ? *i2++ : *i1++);\\n        return out;\\n    }"
		},
		{
			"lc_ans_id":"77283",
			"view":"9664",
			"top":"3",
			"title":"Share my 21ms java solution with comments",
			"vote":"34",
			"content":"To find the maximum ,we can enumerate how digits we should get from nums1 , we suppose it is i.\\n\\nSo ,  the digits from nums2 is K - i.\\n\\nAnd we can use a stack to get the get maximum number(x digits) from one array.\\n\\nOK, Once we choose two maximum subarray , we should combine it to the answer.\\n\\nIt is just like merger sort, but we should pay attention to the case: the two digital are equal.\\n\\nwe should find the digits behind it to judge which digital we should choose now.\\n\\nIn other words,we should judge which subarry is bigger than the other.\\n\\nThat's all.\\n\\nIf you have any question or suggest, I am happy you can comment on my blog : [Create Maximum Number][1].\\n\\nThanks, merry christmas :)\\n\\n *update:use stack to find max sub array and it runs 21ms now.( thanks to @dietpepsi )*\\n\\n   \\n\\n     /**  * Created by hrwhisper on 2015/11/23.  * http://www.hrwhisper.me/leetcode-create-maximum-number/  */\\n    \\n    \\n    public class Solution {\\n        public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n            int get_from_nums1 = Math.min(nums1.length, k);\\n            int[] ans = new int[k];\\n            for (int i = Math.max(k - nums2.length, 0); i <= get_from_nums1; i++) {\\n                int[] res1 = new int[i];\\n                int[] res2 = new int[k - i];\\n                int[] res = new int[k];\\n                res1 = solve(nums1, i);\\n                res2 = solve(nums2, k - i);\\n                int pos1 = 0, pos2 = 0, tpos = 0;\\n                \\n                while (res1.length > 0 && res2.length > 0 && pos1 < res1.length && pos2 < res2.length) {\\n                    if (compare(res1, pos1, res2, pos2))\\n                        res[tpos++] = res1[pos1++];\\n                    else\\n                        res[tpos++] = res2[pos2++];\\n                }\\n                while (pos1 < res1.length)\\n                    res[tpos++] = res1[pos1++];\\n                while (pos2 < res2.length)\\n                    res[tpos++] = res2[pos2++];\\n    \\n                if (!compare(ans, 0, res, 0))\\n                    ans = res;\\n            }\\n    \\n            return ans;\\n        }\\n    \\n        public boolean compare(int[] nums1, int start1, int[] nums2, int start2) {\\n            for (; start1 < nums1.length && start2 < nums2.length; start1++, start2++) {\\n                if (nums1[start1] > nums2[start2]) return true;\\n                if (nums1[start1] < nums2[start2]) return false;\\n            }\\n            return start1 != nums1.length;\\n        }\\n    \\n        public int[] solve(int[] nums, int k) {\\n            int[] res = new int[k];\\n            int len = 0;\\n            for (int i = 0; i < nums.length; i++) {\\n                while (len > 0 && len + nums.length - i > k && res[len - 1] < nums[i]) {\\n                    len--;\\n                }\\n                if (len < k)\\n                    res[len++] = nums[i];\\n            }\\n            return res;\\n        } }\\n\\n\\n  [1]: http://www.hrwhisper.me/leetcode-create-maximum-number/"
		},
		{
			"lc_ans_id":"77291",
			"view":"3123",
			"top":"4",
			"title":"Share my Python solution with explanation",
			"vote":"19",
			"content":"To create the max number from num1 and nums2 with k elements, we assume the final result combined by i numbers (denotes as **left**) from num1 and j numbers (denotes as **right**) from nums2, where i+j==k.\\n\\nObviously, left and right must be the maximum possible number in num1 and num2 respectively. i.e. num1 = [6,5,7,1] and i == 2, then left must be [7,1]. \\n\\nThe final result is the maximum possible merge of all left and right. \\n\\nSo there're 3 steps:\\n\\n 1. **iterate i from 0 to k.**\\n 2. **find max number from num1, num2 by select i , k-i numbers, denotes as left, right**\\n 3. **find max merge of left, right**\\n\\nfunction **maxSingleNumber** select i elements from num1 that is maximum. The idea find the max number one by one. i.e. assume nums [6,5,7,1,4,2], selects = 3.\\n1st digit: find max digit in [6,5,7,1], the last two digits [4, 2] can not be selected at this moment.\\n2nd digits: find max digit in [1,4], since we have already selects 7, we should consider elements after it, also, we should leave one element out.\\n3rd digits: only one left [2], we select it. and function output [7,4,2]\\n\\nfunction **mergeMax**  find the maximum combination of left, and right. \\n\\n\\n    class Solution(object):\\n    def maxNumber(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n, m= len(nums1),len(nums2)\\n        ret = [0] * k\\n        for i in range(0, k+1):\\n            j = k - i\\n            if i > n or j > m: continue\\n            left = self.maxSingleNumber(nums1, i)\\n            right = self.maxSingleNumber(nums2, j)\\n            num = self.mergeMax(left, right)\\n            ret = max(num, ret)\\n        return ret\\n\\n\\n    def mergeMax(self, nums1, nums2):\\n        ans = []\\n        while nums1 or nums2:\\n            if nums1 > nums2:\\n                ans += nums1[0],\\n                nums1 = nums1[1:]\\n            else:\\n                ans += nums2[0],\\n                nums2 = nums2[1:]\\n        return ans\\n\\n    def maxSingleNumber(self, nums, selects):\\n        n = len(nums)\\n        ret = [-1]\\n        if selects > n : return ret\\n        while selects > 0:\\n            start = ret[-1] + 1 #search start\\n            end = n-selects + 1 #search end\\n            ret.append( max(range(start, end), key = nums.__getitem__))\\n            selects -= 1\\n        ret = [nums[item] for item in ret[1:]]\\n        return ret"
		},
		{
			"lc_ans_id":"77325",
			"view":"2737",
			"top":"5",
			"title":"Clean and easy to understand C++ solution",
			"vote":"10",
			"content":"    vector<int> maxVector(vector<int> nums, int k) {\\n        while (nums.size() > k) {\\n            int i = 0, n = nums.size();\\n            for (; i < n - 1; ++i) {\\n                if (nums[i] < nums[i + 1]) {\\n                    nums.erase(nums.begin() + i);\\n                    break;\\n                }\\n            }\\n            if (i == n - 1) nums.erase(nums.begin() + i);\\n        }\\n    \\n        return nums;\\n    }\\n    \\n    bool compare(vector<int> &nums1, int i, vector<int> &nums2, int j) {\\n        while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j]) {\\n            ++i;\\n            ++j;\\n        }\\n        if (j == nums2.size()) return true;\\n        if (i < nums1.size() && nums1[i] > nums2[j]) return true;\\n        return false;\\n    }\\n    \\n    vector<int> merge(vector<int> &nums1, vector<int> &nums2, int k) {\\n        vector<int> res(k, 0);\\n        for (int i = 0, j = 0, r = 0; r < k; ++r) {\\n            res[r] = compare(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\\n        }\\n    \\n        return res;\\n    }\\n    \\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m = nums1.size(), n = nums2.size();\\n        vector<int> res(k, 0);\\n    \\n        for (int i = max(0, k - n); i <= min(k, m); ++i) {\\n            auto v1 = maxVector(nums1, i);\\n            auto v2 = maxVector(nums2, k - i);\\n            auto tmp = merge(v1, v2, k);\\n            if (compare(tmp, 0, res, 0)) res = tmp;\\n        }\\n    \\n        return res;\\n    }"
		},
		{
			"lc_ans_id":"77299",
			"view":"650",
			"top":"6",
			"title":"divide to three subproblem solution, beat 98%",
			"vote":"6",
			"content":"subproblem1: \\nget the largest k numbers when keeping the relative order\\n\\nsubproblem2: \\nmerge two arrays which are from subproblem1.\\n\\nsubproblem3: \\ncompare two arrays.\\n\\n```\\npublic class Solution {\\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\\n        int len1 = nums1.length;\\n        int len2 = nums2.length;\\n        int[] result = new int[k];\\n        if(len1+len2 < k) {\\n            return result;//bad case\\n        }else if(len1+len2 == k){\\n            result = mergeTwoArrays(nums1, nums2, k);//edge case\\n        }else{\\n            for (int i = 0; i <= k; i++) {\\n                if(i<=len1 && (k-i)<=len2){\\n                    int[] maxNumbers1 = maxNumberOfSingleArray(nums1, i);\\n                    int[] maxNumbers2 = maxNumberOfSingleArray(nums2, k - i);\\n                    int[] maxNumbers = mergeTwoArrays(maxNumbers1, maxNumbers2, k);\\n                    if (compareTwoArrays(maxNumbers, 0, result, 0)) result = maxNumbers;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] mergeTwoArrays(int[] nums1, int[] nums2, int k) {\\n        int[] result = new int[k];\\n        int idx1 = 0, idx2 = 0;\\n        int idx = 0;\\n        while(idx < k){\\n            //check the two remain arrays to see which one is larger.\\n            if(compareTwoArrays(nums1, idx1, nums2, idx2)){\\n                result[idx] = nums1[idx1++];\\n            }else{\\n                result[idx] = nums2[idx2++];\\n            }\\n            idx++;\\n        }\\n        return result;\\n    }\\n    \\n    //get the largest k numbers when keeping the relative order\\n    private int[] maxNumberOfSingleArray(int[] nums, int k){\\n        int[] result = new int[k];\\n        if(k == 0) return result;\\n\\n        int len = nums.length;\\n        int idx = 0;\\n        for(int i = 0; i < len; i++){\\n            while((len-i-1) + (idx+1) > k && idx>0 && nums[i] > result[idx-1]) idx--;\\n            if(idx < k) result[idx++] = nums[i];\\n        }\\n        return result;\\n    }\\n    \\n    //compare two arrays at the \"start\" index\\n    public boolean compareTwoArrays(int[] nums1, int startIdx1, int[] nums2, int startIdx2) {\\n        int len1 = nums1.length - startIdx1;\\n        if(len1 <= 0) return false;\\n        int len2 = nums2.length - startIdx2;\\n        if(len2 <= 0) return true;\\n        int len = Math.max(len1, len2);\\n        for (int i = 0; i< len; i++) {\\n        \\tint digit1 = startIdx1 + i < nums1.length ? nums1[startIdx1 + i] : 0;\\n        \\tint digit2 = startIdx2 + i < nums2.length ? nums2[startIdx2 + i] : 0;\\n        \\tif(digit1 != digit2){\\n        \\t    return digit1 > digit2;\\n        \\t}\\n        }\\n        return true;//equal, choose either one is ok\\n    }\\n}\\n````"
		},
		{
			"lc_ans_id":"77294",
			"view":"1001",
			"top":"7",
			"title":"An Accepted Python Solution",
			"vote":"5",
			"content":"This problem could be divided into 2 sub-problems:\\n\\n1. **function getMax(nums, t):**\\n\\n  get t numbers from list *nums* to form one single maximized sub-list, with relative orders preserved\\n\\n2. **function merge(nums1, nums2):**\\n\\n  merge *nums1* and *nums2* to form one single maximized list, with relative orders preserved\\n\\nThe final result could be solved by enumerate the length of sub-list *nums1* and *nums2*, and record the max merged list.\\n\\nPython Code:\\n\\n    class Solution(object):\\n        def maxNumber(self, nums1, nums2, k):\\n            \"\"\"\\n            :type nums1: List[int]\\n            :type nums2: List[int]\\n            :type k: int\\n            :rtype: List[int]\\n            \"\"\"\\n            def getMax(nums, t):\\n                ans = []\\n                size = len(nums)\\n                for x in range(size):\\n                    while ans and len(ans) + size - x > t and ans[-1] < nums[x]:\\n                        ans.pop()\\n                    if len(ans) < t:\\n                        ans += nums[x],\\n                return ans\\n    \\n            def merge(nums1, nums2):\\n                ans = []\\n                while nums1 or nums2:\\n                    if nums1 > nums2:\\n                        ans += nums1[0],\\n                        nums1 = nums1[1:]\\n                    else:\\n                        ans += nums2[0],\\n                        nums2 = nums2[1:]\\n                return ans\\n            \\n            len1, len2 = len(nums1), len(nums2)\\n            res = []\\n            for x in range(max(0, k - len2), min(k, len1) + 1):\\n                tmp = merge(getMax(nums1, x), getMax(nums2, k - x))\\n                res = max(tmp, res)\\n            return res\\n\\nRef: [http://bookshadow.com/weblog/2015/12/24/leetcode-create-maximum-number/][1]\\n\\n\\n  [1]: http://bookshadow.com/weblog/2015/12/24/leetcode-create-maximum-number/"
		},
		{
			"lc_ans_id":"77353",
			"view":"1602",
			"top":"8",
			"title":"Share C++ 72ms with simple comments",
			"vote":"5",
			"content":"    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        const int size1 = nums1.size();\\n        const int size2 = nums2.size();\\n        if (size1 + size2 < k) return vector<int>();\\n        vector<int> res(k, 0);\\n        vector<vector<int>> dp1(k+1, vector<int>()), dp2(k+1, vector<int>());\\n        getDp(nums1, k, dp1);\\n        getDp(nums2, k, dp2);\\n        for (int i = 0; i <= min(k, size1); i++) {\\n            int j = k - i;\\n            vector<int> temp_res(k, 0);\\n            myMerge(dp1[i].begin(), dp1[i].end(), dp2[j].begin(), dp2[j].end(), temp_res.begin());\\n            if (j <= size2 && compareVector(temp_res, res)) {\\n                res = temp_res;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    template <class container>\\n    bool compareVector ( container vec1, container vec2)\\n        {\\n          typename container::iterator first1 = vec1.begin(), last1 = vec1.end();\\n          typename container::iterator first2 = vec2.begin(), last2 = vec2.end();\\n          while (first1 != last1 && first2 != last2) {\\n            if (*first1 > *first2)\\n              return true;\\n            else if (*first1 < *first2) return false;\\n            ++first1; ++first2;\\n          }\\n          if (first1 == last1) return false;\\n          else return true;\\n        }\\n        \\n    void getDp(vector<int> nums, int k, vector<vector<int>> &dp) {\\n          while (nums.size() > k) {\\n                int j = 0;\\n                for (; j < nums.size() - 1; ++j) {\\n                    if (nums[j] < nums[j + 1]) {\\n                        nums.erase(nums.begin() + j); \\n                        break;\\n                    }\\n                }\\n                if (j == nums.size() - 1) nums.erase(nums.begin() + j); \\n           }\\n           dp[nums.size()] = nums;\\n           const int size1 = nums.size();\\n           for (int i = k; i > 0; i--) {\\n            if (i >= size1) continue; \\n            else {\\n                dp[i] = dp[i+1];\\n                int j = 0;\\n                const int size_dp = dp[i].size();\\n                for (; j < size_dp - 1; ++j) {\\n                    if (dp[i][j] < dp[i][j + 1]) {\\n                        dp[i].erase(dp[i].begin() + j); \\n                        break;\\n                    }\\n                }\\n                if (j == size_dp - 1) dp[i].erase(dp[i].begin() + j); \\n            }\\n            \\n        }\\n    }\\n    template <class InputIterator1, class InputIterator2, class OutputIterator>\\n    OutputIterator myMerge (InputIterator1 first1, InputIterator1 last1,\\n                        InputIterator2 first2, InputIterator2 last2,\\n                        OutputIterator result)\\n    {\\n      while (true) {\\n        if (first1==last1) return std::copy(first2,last2,result);\\n        if (first2==last2) return std::copy(first1,last1,result);\\n        if (*first2 > *first1) *result++ = *first2++;\\n        else if (*first2 < *first1) *result++ = *first1++;\\n        else { // *first1 == *first2\\n            auto pos1 = first1, pos2 = first2;\\n            while (true) {\\n                int f1 = (++pos1 != last1) ? *(pos1) : INT_MIN;\\n                int f2 = (++pos2 != last2) ? *(pos2) : INT_MIN;\\n                if (f1 > f2) { *result++ = *first1++; break;}\\n                else if (f1 < f2) {*result++ = *first2++; break;}\\n            }\\n        }\\n      }\\n    }"
		},
		{
			"lc_ans_id":"77310",
			"view":"4465",
			"top":"9",
			"title":"Strictly O(NK) C++ Solution with detailed explanation",
			"vote":"4",
			"content":"    class list1\\n    {\\n        vector<int> a;\\n        vector<vector<int>> f;\\n    public:\\n        list1() = delete;\\n        inline int size() {return a.size();}\\n        inline int next(int x,int d) {return f[x][d];}\\n        list1(vector<int>& a0)\\n        {\\n            a = a0;\\n            f = vector<vector<int>>(a0.size() + 1,vector<int>(10,INT_MAX));\\n            for (int i = 0;i<a0.size();i++)\\n            {\\n                f[i][a[i]] = i;\\n                for (int j = i-1;j>=0;j--)\\n                {\\n                    if (a[j] == a[i]) break;\\n                    f[j][a[i]] = i;\\n                }\\n            }\\n        }\\n    };\\n    \\n    //dmd for detect_max_digit\\n    // dmd(a,x,rem) -> (max_digit, pos) , where a[pos-1] == max_digit\\n    // list a , from x, need rem numbers, x not included.\\n        \\n    pair<int,int> dmd(list1& a,int x,int rem)\\n    {\\n        for (int d = 9;d >= 0;d--)\\n        {\\n            int pos = a.next(x,d);\\n            if (pos == INT_MAX) continue;\\n            if (a.size() - (pos + 1) >= rem)\\n            return make_pair(d,pos + 1);\\n        }\\n    }\\n    \\n    \\n    class Solution {\\n    public:\\n        vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n            list1 a1 = list1(nums1);\\n            int N1 = nums1.size();\\n            list1 a2 = list1(nums2);\\n            int N2 = nums2.size();\\n            \\n            auto ret = vector<int>(k,0);\\n            auto f = vector<int>(N1 + 1,0); \\n            //f[i] denote a1[0..i-1] need a2[0..f[i]-1] to reach the current maximal number, and can expand to length k\\n            // in other words, the state is : the number is current maximal and can be expanded, list1 begin with a1[i] and list2 with a2[f[i]] \\n            for (int d = 1;d <= k;d++)\\n            {\\n                int maxDigit = -1;\\n                auto tmpf = vector<int>(N1 + 1,INT_MAX);\\n                for (int x = 0;x<=N1;x++)\\n                {\\n                    int y = f[x];\\n                    if (y == INT_MAX) continue;\\n                    auto m1 = dmd(a1,x,k-d-(N2-y)); \\n                    auto m2 = dmd(a2,y,k-d-(N1-x));\\n                    maxDigit = max(maxDigit,m1.first);\\n                    maxDigit = max(maxDigit,m2.first);\\n                }\\n                ret[d-1] = maxDigit;\\n                for (int x = 0;x<=N1;x++)\\n                {\\n                    int y = f[x];\\n                    if (y == INT_MAX) continue;\\n                    auto m1 = dmd(a1,x,k-d-(N2-y));\\n                    if (m1.first == maxDigit)\\n                    tmpf[m1.second] = min(tmpf[m1.second],y);\\n                    auto m2 = dmd(a2,y,k-d-(N1-x));\\n                    if (m2.first == maxDigit)\\n                    tmpf[x] = min(tmpf[x],m2.second);\\n                }\\n                f = tmpf;\\n            }\\n            return ret;\\n        }\\n    };\\n\\nAny Question is welcome and will be answered as soon as possible.\\nDetailed explanation is coming soon!\\nYou may firstly read my code, it's quite easy to understand.\\n\\n## Detailed Solution ##\\nLet a1,a2 be the two list from where we construct the maximal number.\\nLet N1,N2 denote the size of a1,a2.\\nWe construct the maximal number digit by digit.\\n\\nSuppose we are constructing the d-th digit(ret[0..d-1] is done)  and we have a set of states S = {(a1,b1),(a2,b2),...(a_N,b_N)},For each state (x,y) in S, it means we use a1[0..(x-1)] and a2[0..(y-1)] to construct ret[0..d-1] and a1[x..N1] and a2[y..N2] are avaliabe to construct the remaining digits.\\n\\nIn the iteration, we need to construct the d-th digit as well as the set S', that is from where we can construct the d+1-th digit.\\n\\nFor every state (x,y) in S, we use the function \"dmd\" to obtain the biggest d-th digit we can get from it. \\nLet maxdigit = {max(dmd(x,y)[1])|(x,y) in S}, it is the d-th digit.\\n\\nAs we now the d-th digit,\\nWe scan S again,\\nFor every state (x,y) in S, we use the function \"dmd\" to obtain the (x',y) and (x,y') it extands to, \\nif a1[x'-1] == maxdigit, we add (x',y) to S'.\\nif a2[y'-1] == maxdigit, we add (x,y') to S'.\\n\\nNow we can construct the d+1-th digit from S', note that the size of S' is at most N1, for(x,y1) and (x,y2), y1 < y2, (x,y2) is needless to be recorded.\\n\\nFinally I'd like to use an typical example to illustrate the process.\\n\\n> a1 = [8,1] a2 = [8,9] k = 4\\n> \\n> S = {(0,0)}\\n\\nthe first digit is 8,\\n\\n> S' = {(0,1),(1,0)}\\n\\nthe second digit is 9, we construct it from (0,1)\\n\\n>S'' = {(0,2)}\\n\\nthe remain digits are 8 and 1,\\nwe finally reach 8981."
		}
	],
	"id":"321",
	"title":"Create Maximum Number",
	"content":"<p>\r\n    Given two arrays of length <code>m</code> and <code>n</code> with digits <code>0-9</code> representing two numbers.\r\n    Create the maximum number of length <code>k <= m + n</code> from digits of the two. The relative order of the digits\r\n    from the same array must be preserved. Return an array of the <code>k</code> digits. You should try to optimize your time and space complexity.\r\n</p>\r\n\r\n<p>\r\n    <b>Example 1:</b><br/>\r\n</p>\r\n<p>\r\n    nums1 = <code>[3, 4, 6, 5]</code><br/>\r\n    nums2 = <code>[9, 1, 2, 5, 8, 3]</code><br/>\r\n    k = <code>5</code><br/>\r\n    return <code>[9, 8, 6, 5, 3]</code>\r\n</p>\r\n<p>\r\n    <b>Example 2:</b><br/>\r\n</p>\r\n<p>\r\n    nums1 = <code>[6, 7]</code><br/>\r\n    nums2 = <code>[6, 0, 4]</code><br/>\r\n    k = <code>5</code><br/>\r\n    return <code>[6, 7, 6, 0, 4]</code>\r\n</p>\r\n<p>\r\n    <b>Example 3:</b><br/>\r\n</p>\r\n<p>\r\n    nums1 = <code>[3, 9]</code><br/>\r\n    nums2 = <code>[8, 9]</code><br/>\r\n    k = <code>3</code><br/>\r\n    return <code>[9, 8, 9]</code>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/dietpepsi\">@dietpepsi</a> for adding this problem and creating all test cases.</p>",
	"frequency":"273",
	"ac_num":"21874"
}