{
	"difficulty":"2",
	"submit_num":"136198",
	"show_id":"324",
	"leetcode_id":"324",
	"answers":[
		{
			"lc_ans_id":"77677",
			"view":"72923",
			"top":"0",
			"title":"O(n)+O(1) after median --- Virtual Indexing",
			"vote":"242",
			"content":"This post is mainly about what I call \"virtual indexing\" technique (I'm sure I'm not the first who came up with this, but I couldn't find anything about it, so I made up a name as well. If you know better, let me know).\\n\\n---\\n\\nSolution\\n---\\n\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Find a median.\\n        auto midptr = nums.begin() + n / 2;\\n        nth_element(nums.begin(), midptr, nums.end());\\n        int mid = *midptr;\\n        \\n        // Index-rewiring.\\n        #define A(i) nums[(1+2*(i)) % (n|1)]\\n\\n        // 3-way-partition-to-wiggly in O(n) time with O(1) space.\\n        int i = 0, j = 0, k = n - 1;\\n        while (j <= k) {\\n            if (A(j) > mid)\\n                swap(A(i++), A(j++));\\n            else if (A(j) < mid)\\n                swap(A(j), A(k--));\\n            else\\n                j++;\\n        }\\n    }\\n\\n---\\n\\nExplanation\\n---\\n\\nFirst I find a median using `nth_element`. That only guarantees O(n) **average** time complexity and I don't know about space complexity. I might write this myself using O(n) time and O(1) space, but that's not what I want to show here.\\n\\nThis post is about what comes **after** that. We can use [three-way partitioning](https://en.wikipedia.org/wiki/Dutch_national_flag_problem#Pseudocode) to arrange the numbers so that those *larger than* the median come first, then those *equal to* the median come next, and then those *smaller than* the median come last.\\n\\nOrdinarily, you'd then use one more phase to bring the numbers to their final positions to reach the overall wiggle-property. But I don't know a nice O(1) space way for this. Instead, I embed this right into the partitioning algorithm. That algorithm simply works with indexes 0 to n-1 as usual, but sneaky as I am, I rewire those indexes where I want the numbers to actually end up. The partitioning-algorithm doesn't even know that I'm doing that, it just works like normal (it just uses `A(x)` instead of `nums[x]`).\\n\\nLet's say `nums` is `[10,11,...,19]`. Then after nth_element and ordinary partitioning, we might have this (15 is my median):\\n\\n    index:     0  1  2  3   4   5  6  7  8  9\\n    number:   18 17 19 16  15  11 14 10 13 12\\n\\nI rewire it so that the first spot has index 5, the second spot has index 0, etc, so that I might get this instead:\\n\\n    index:     5  0  6  1  7  2  8  3  9  4\\n    number:   11 18 14 17 10 19 13 16 12 15\\n\\nAnd 11 18 14 17 10 19 13 16 12 15 is perfectly wiggly. And the whole partitioning-to-wiggly-arrangement (everything after finding the median) only takes O(n) time and O(1) space.\\n\\n---\\n\\nIf the above description is unclear, maybe this explicit listing helps:\\n\\nAccessing `A(0)` actually accesses `nums[1]`.  \\nAccessing `A(1)` actually accesses `nums[3]`.  \\nAccessing `A(2)` actually accesses `nums[5]`.  \\nAccessing `A(3)` actually accesses `nums[7]`.  \\nAccessing `A(4)` actually accesses `nums[9]`.  \\nAccessing `A(5)` actually accesses `nums[0]`.  \\nAccessing `A(6)` actually accesses `nums[2]`.  \\nAccessing `A(7)` actually accesses `nums[4]`.  \\nAccessing `A(8)` actually accesses `nums[6]`.  \\nAccessing `A(9)` actually accesses `nums[8]`.\\n\\n---\\n\\nProps to [apolloydy's solution](https://leetcode.com/discuss/77053/time-and-cheating-space-solution-will-there-be-real-solution?show=77054#a77054), I knew the partitioning algorithm already but I didn't know the name. And apolloydy's idea to partition to reverse order happened to make the index rewiring simpler."
		},
		{
			"lc_ans_id":"77682",
			"view":"31264",
			"top":"1",
			"title":"Step by step explanation of index mapping in Java",
			"vote":"178",
			"content":"The virtual index idea in the post https://leetcode.com/discuss/77133/o-n-o-1-after-median-virtual-indexing\\nis very brilliant! However, it takes me a while to understand why and how it works. There is no 'nth_element' in Java, but you can use 'findKthLargest' function from \"https://leetcode.com/problems/kth-largest-element-in-an-array/\" to get the median element in average O(n) time and O(1) space.\\n\\n\\nAssume your original array is {6,13,5,4,5,2}. After you get median element, the 'nums' is partially sorted such that the first half is larger or equal to the median, the second half is smaller or equal to the median, i.e\\n\\n\\n    13   6   5   5   4   2\\n\\n             M\\nIn the post https://leetcode.com/discuss/76965/3-lines-python-with-explanation-proof, we have learned that , to get wiggle sort, you want to put the number in the following way such that\\n \\n(1) elements smaller than the 'median' are put into the last even slots\\n\\n(2) elements larger than the 'median' are put into the first odd slots\\n\\n(3) the  medians are put into the remaining slots.\\n\\n    Index :       0   1   2   3   4   5\\n    Small half:   M       S       S    \\n    Large half:       L       L       M\\n \\nM - Median, S-Small, L-Large. In this example, we want to put {13, 6, 5} in index 1,3,5 and {5,4,2} in index {0,2,4}\\n\\nThe index mapping, (1 + 2*index) % (n | 1) combined with 'Color sort',  will do the job. \\n\\nAfter selecting the median element, which is 5 in this example, we continue as the following\\n\\n    Mapped_idx[Left] denotes the position where the next smaller-than median element  will be inserted.\\n    Mapped_idx[Right] denotes the position where the next larger-than median element  will be inserted.\\n\\n\\n    Step 1: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    5    5    4    2 \\n                 Left\\n                  i\\n                                          Right\\n     nums[Mapped_idx[i]] = nums[1] = 6 > 5, so it is ok to put 6 in the first odd index 1. We increment i and left.\\n\\n\\n    Step 2: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    5    5    4    2 \\n                      Left\\n                       i\\n                                          Right\\n     nums[3] = 5 = 5, so it is ok to put 6 in the index 3. We increment i.\\n\\n\\n    Step 3: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    5    5    4    2 \\n                      Left\\n                            i\\n                                         Right\\n     nums[5] = 2 < 5, so we want to put it to the last even index 4 (pointed by Right). So, we swap nums[Mapped_idx[i]] with nums[Mapped_idx[Right]], i.e. nums[5] with nums[4], and decrement Right. \\n\\n\\n\\n\\n    Step 4: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    5    5    2    4 \\n                      Left\\n                            i\\n                                   Right\\n     nums[5] = 4 < 5, so we want to put it to the second last even index 2. So, we swap nums[5] with nums[2], and decrement Right. \\n\\n\\n\\n\\n    Step 5: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    4    5    2    5 \\n                      Left\\n                            i\\n                                Right\\n     nums[5] = 5 < 5, it is ok to put it there, we increment i.\\n\\n\\n    Step 6: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        13   6    4    5    2    5 \\n                      Left\\n                                 i\\n                                Right\\n     nums[0] = 13 > 5, so, we want to put it to the next odd index which is 3 (pointed by 'Left'). So, we swap nums[0] with nums[3], and increment 'Left' and 'i'.\\n\\n\\n    Step Final: \\n    Original idx: 0    1    2    3    4    5  \\n    Mapped idx:   1    3    5    0    2    4 \\n    Array:        5    6    4    13   2    5 \\n                          Left\\n                                      i\\n                                Right\\n    i > Right, we get the final wiggle array 5 6 4 13 2 5 !\\n\\nThe code is the following:\\n\\n\\n\\n       public void wiggleSort(int[] nums) {\\n            int median = findKthLargest(nums, (nums.length + 1) / 2);\\n            int n = nums.length;\\n    \\n            int left = 0, i = 0, right = n - 1;\\n    \\n            while (i <= right) {\\n    \\n                if (nums[newIndex(i,n)] > median) {\\n                    swap(nums, newIndex(left++,n), newIndex(i++,n));\\n                }\\n                else if (nums[newIndex(i,n)] < median) {\\n                    swap(nums, newIndex(right--,n), newIndex(i,n));\\n                }\\n                else {\\n                    i++;\\n                }\\n            }\\n    \\n    \\n        }\\n    \\n        private int newIndex(int index, int n) {\\n            return (1 + 2*index) % (n | 1);\\n        }"
		},
		{
			"lc_ans_id":"77678",
			"view":"22032",
			"top":"2",
			"title":"3 lines Python, with Explanation / Proof",
			"vote":"120",
			"content":"Solution\\n---\\n\\nRoughly speaking I put the smaller half of the numbers on the even indexes and the larger half on the odd indexes.\\n\\n    def wiggleSort(self, nums):\\n        nums.sort()\\n        half = len(nums[::2])\\n        nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]\\n\\nAlternative, maybe nicer, maybe not:\\n\\n    def wiggleSort(self, nums):\\n        nums.sort()\\n        half = len(nums[::2]) - 1\\n        nums[::2], nums[1::2] = nums[half::-1], nums[:half:-1]\\n\\n---\\n\\n**Explanation / Proof**\\n---\\n\\nI put the smaller half of the numbers on the even indexes and the larger half on the odd indexes, both from right to left:\\n\\n    Example nums = [1,2,...,7]      Example nums = [1,2,...,8] \\n\\n    Small half:  4 . 3 . 2 . 1      Small half:  4 . 3 . 2 . 1 .\\n    Large half:  . 7 . 6 . 5 .      Large half:  . 8 . 7 . 6 . 5\\n    --------------------------      --------------------------\\n    Together:    4 7 3 6 2 5 1      Together:    4 8 3 7 2 6 1 5\\n\\nI want:\\n\\n- Odd-index numbers are larger than their neighbors.\\n\\nSince I put the larger numbers on the odd indexes, clearly I already have:\\n\\n- Odd-index numbers are larger than **or equal to** their neighbors.\\n\\nCould they be \"equal to\"? That would require some number M to appear both in the smaller and the larger half. It would be the largest in the smaller half and the smallest in the larger half. Examples again, where S means some number smaller than M and L means some number larger than M.\\n\\n    Small half:  M . S . S . S      Small half:  M . S . S . S .\\n    Large half:  . L . L . M .      Large half:  . L . L . L . M\\n    --------------------------      --------------------------\\n    Together:    M L S L S M S      Together:    M L S L S L S M\\n\\nYou can see the two M are quite far apart. Of course M could appear more than just twice, for example:\\n\\n    Small half:  M . M . S . S      Small half:  M . S . S . S .\\n    Large half:  . L . L . M .      Large half:  . L . M . M . M\\n    --------------------------      --------------------------\\n    Together:    M L M L S M S      Together:    M L S M S M S M\\n\\nYou can see that with seven numbers, three M are no problem. And with eight numbers, four M are no problem. Should be easy to see that in general, with n numbers, floor(n/2) times M is no problem. Now, if there were more M than that, then my method would fail. But... it would also be impossible:\\n\\n- If n is even, then having more than n/2 times the same number clearly is unsolvable, because you'd have to put two of them next to each other, no matter how you arrange them.\\n- If n is odd, then the only way to successfully arrange a number appearing more than floor(n/2) times is if it appears exactly floor(n/2)+1 times and you put them on all the even indexes. And to have the wiggle-property, all the other numbers would have to be larger. But then we wouldn't have an M in both the smaller and the larger half.\\n\\nSo if the input has a valid answer at all, then my code will find one."
		},
		{
			"lc_ans_id":"77681",
			"view":"18916",
			"top":"3",
			"title":"O(n)-time O(1)-space solution with detail explanations",
			"vote":"43",
			"content":"**Methodology:**\\n\\n**Idea 1.**\\n\\nAs **@whnzinc** pointed out in [this thread](https://leetcode.com/discuss/77085/clean-average-o-n-time-in-c), all elements in nums can be classified into three categories:\\n\\n(1) Larger than the median;\\n\\n(2) Equal to the median;\\n\\n(3) Smaller than the median.\\n\\nNote that it's possible to find the median within O(n)-time and O(1)-space.\\n\\nNote: We can use `nth_element` to find the median, but it's not O(n)-time and O(1)-space. For the sake of simplicity, I might use `nth_element` as well.\\n\\n**Idea 2.** \\n\\nAs **@StefanPochmann** pointed out in [this thread](https://leetcode.com/discuss/76965/3-lines-python-with-explanation-proof), we can arrange the elements in the three categories in a deterministic way.\\n\\n(1) Elements that are larger than the median: we can put them in the first few odd slots;\\n\\n(2) Elements that are smaller than the median: we can put them in the last few even slots;\\n\\n(3) Elements that equal the median: we can put them in the remaining slots.\\n\\n**Update:** According to [**@StefanPochmann**'s thread](https://leetcode.com/discuss/77133/o-n-o-1-after-median-virtual-indexing), we can use a one-pass three-way partition to rearrange all elements. His idea is to re-map the indices into its destined indices, odd indices first and even indices follow.\\n\\nExample:\\n\\n    Original Indices:    0  1  2  3  4  5  6  7  8  9 10 11\\n    Mapped Indices:      1  3  5  7  9 11  0  2  4  6  8 10\\n\\n(its reverse mapping is)\\n\\n    Mapped Indices:      0  1  2  3  4  5  6  7  8  9 10 11\\n    Original Indices:    6  0  7  1  8  2  9  3 10  4 11  5   (wiggled)\\n\\n\\nIn order to achieve this, we can use a function alike\\n\\n    int map_index(int idx, int n) {\\n        return (2 * idx + 1) % (n | 1);\\n    }\\n\\nwhere `(n | 1)` calculates the nearest odd that is not less than `n`.\\n\\n--------\\n\\n**Complexities:** (On the condition that finding median is O(n)-time and O(1)-space)\\n\\n- Time: *O*(n)\\n\\n- Space: *O*(1)\\n\\n--------\\n\\n**C++ (Updated, 44ms):**\\n\\n\\n    class Solution {\\n    public:\\n    \\tvoid wiggleSort(vector<int>& nums) {\\n    \\t\\tif (nums.empty()) {\\n    \\t\\t\\treturn;\\n    \\t\\t}    \\n    \\t\\tint n = nums.size();\\n    \\t\\t\\n    \\t\\t// Step 1: Find the median    \\t\\t\\n    \\t\\tvector<int>::iterator nth = next(nums.begin(), n / 2);\\n    \\t\\tnth_element(nums.begin(), nth, nums.end());\\n    \\t\\tint median = *nth;\\n    \\n    \\t\\t// Step 2: Tripartie partition within O(n)-time & O(1)-space.    \\t\\t\\n    \\t\\tauto m = [n](int idx) { return (2 * idx + 1) % (n | 1); };    \\t\\t\\n    \\t\\tint first = 0, mid = 0, last = n - 1;\\n    \\t\\twhile (mid <= last) {\\n    \\t\\t\\tif (nums[m(mid)] > median) {\\n    \\t\\t\\t\\tswap(nums[m(first)], nums[m(mid)]);\\n    \\t\\t\\t\\t++first;\\n    \\t\\t\\t\\t++mid;\\n    \\t\\t\\t}\\n    \\t\\t\\telse if (nums[m(mid)] < median) {\\n    \\t\\t\\t\\tswap(nums[m(mid)], nums[m(last)]);\\n    \\t\\t\\t\\t--last;\\n    \\t\\t\\t}\\t\\t\\t\\t\\n    \\t\\t\\telse {\\n    \\t\\t\\t\\t++mid;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}    \\n    };"
		},
		{
			"lc_ans_id":"77706",
			"view":"8923",
			"top":"4",
			"title":"Short simple C++",
			"vote":"26",
			"content":"    void wiggleSort(vector<int>& nums) {\\n        vector<int> sorted(nums);\\n        sort(sorted.begin(), sorted.end());\\n        for (int i=nums.size()-1, j=0, k=i/2+1; i>=0; i--)\\n            nums[i] = sorted[i&1 ? k++ : j++];\\n    }\\n\\nSort and then write the smaller half of the numbers on the even indexes and the larger half of the numbers on the odd indexes, both from the back. Example:\\n\\n    Small half:    4 . 3 . 2 . 1 . 0 .\\n    Large half:    . 9 . 8 . 7 . 6 . 5\\n    ----------------------------------\\n    Together:      4 9 3 8 2 7 1 6 0 5\\n\\nSo write `nums` from the back, interweaving `sorted[0..4]` (indexed by `j`) and `sorted[5..9]` (indexed by `k`).\\n\\nFor more explanation/proof, see [my equivalent Python solution](https://leetcode.com/discuss/76965/3-lines-python-with-explanation-proof)."
		},
		{
			"lc_ans_id":"77684",
			"view":"999",
			"top":"5",
			"title":"Summary of the various solutions to Wiggle Sort for your reference",
			"vote":"18",
			"content":"This is a quick summary of all the solutions to this problem. Thanks to [stefanpochmann](https://discuss.leetcode.com/user/stefanpochmann), [shuoshankou](https://discuss.leetcode.com/user/shuoshankou) and others for their contributions.\\n\\n---\\n**`I -- Basic ideas`**\\n\\nSuppose the array is already \"wiggly-sorted\", we can divide the elements into two groups: \\n\\n* `odd group`: those collected from elements with **odd** indices\\n* `even group`: those collected from elements with **even** indices\\n\\nAnd from the property of \"wiggle-sort\", we know every element in the `odd group` will be greater than its neighbor(s). But note this is only a **local relation**, i.e., for any element from the `odd group`, except for its neighbor(s), we have no idea about the relationship between it and those from the `even group` which are not its neighbors.\\n\\nThis local relation makes it rather difficult to \"wiggly-sort\" all the elements from scratch. Fortunately there is a way to impose a **global relation** for elements in the two groups, specifically, for every \"wiggly-sorted\" array, it is possible to transform it into a new array such that every element in the `odd group` is no less than those in the `even group` while maintaining the \"wiggle-sort\" property. The proof is as follows.\\n\\nSuppose we have this element `a` from the `odd group` which are less than some element `b` from the `even group`, i.e., `a < b`. Let `c`, `d` be the two neighbors of `a`, and `e`, `f` be the two neighbors of `b`, from the \"wiggle-sort\" property, we have `c < a, d < a` and `b < e, b < f`. Now if we switch `a` and `b`, we still have `c < b, d < b` and `a < e, a < f`, therefore switching `a` and `b` won't break the \"wiggle-sort\" property but will transfer the larger element to the `odd group`and the smaller element to the `even group`. After a finite sequence of switching, all elements in the `odd group` will be no less than those in the `even group` and we say the array has reached the **global relation** state (otherwise it's in the **local relation** state ).\\n\\nBuilding a \"wiggly-sorted\" array in the **global relation** state is much more tractable than its **local relation** state counterpart. And it can be done in two steps:\\n\\n* **Partition**: this will partition the array (with a total of `n` elements) into two groups which will be called `S` and `L`, respectively. The `S` group will have `m` (integer part of `(n+1)/2`) elements and the `L` group contains the rest. Also all elements in the `L` group is no less than those in the `S` group. (Note for this partition, `S` and `L` group will have the same number of elements as the `even group` and `odd group`, respectively. And the size of `L` group is no more than that of `S` group.)\\n\\n* **Placement**: if all elements in the `L` group is greater than those in the `S` group, we can simply place elements in the `L` group at odd indices (thus form the `odd group`) and those in the `S` group at even indices (form the `even group`). The tricky case is when there are overlapping (or equal) elements between the two groups, which will be dealt with as follows.\\n\\nFirst we prove that if the array can be \"wiggly-sorted\", the total number of such overlapping elements is no more than the size of the `S` group, which is `m`. Just assume we do have more such elements than `m`. After the array is \"wiggly-sorted\", all these elements can not be neighbors to each other (note they are equal). Therefore they will occupy either all the even indices or all the odd ones. However, even so we will still have residual such elements since the total number of even or odd indices is no more than `m`. And there is no way to place these excessive elements without breaking the \"wiggle-sort\" property.\\n\\nSecond we show that if we arrange these overlapping elements in such a way that they will occupy the smallest even indices possible if they come from the `S` group and will take the largest odd indices possible if they are from the `L` group, then none of them will be neighbors of others. Let `k1` and `k2` be the total number of such elements in the `S` and `L` groups, respectively, and `k = k1 + k2` is the total number of such elements in the array. First assume `n` is even, then we have `k <= m = n/2`. After the arrangement, the index of the last such element from `S` group will be `2 * (k1 - 1)` while the index of the last one from the `L` group will be `(n - 1) - 2 * (k2 - 1)`. If the former index is less than the latter by at least `1`, then none of the elements will be neighbors of others, which is indeed the case:  `2 * (k1 - 1) + 1 < (n - 1) - 2 * (k2 - 1)  <==> k1 + k2 < [n/2] + 1` and `k1 + k2 = k <= n/2 = [n/2] < [n/2] + 1`. Now assume `n` is odd. If `k = (n + 1)/2`, then the array can be \"wiggly-sorted\"only if `k2 = 0`, i.e., all such elements are in the `S` group and will take all the even indices. Else we have `k1 + k2 = k < (n + 1)/2 = [n/2] + 1`. In either case, our arrangement will scatter the overlapping elements in such a way that none of them will be neighbors of others. \\n\\nOnce the overlapping elements are placed according to the above rules, all the other elements in `S` and `L` groups are free to take any of the remaining available even and odd indices, respectively. And we end up with a \"wiggly-sorted\" array that is in the \"global relation\" state.\\n\\n---\\n**`II -- O(nlogn) time and O(n) space solution by sorting`**\\n\\nThe naive way to partition the array into `L` and `S` groups is by sorting. Here we can sort the elements in either ascending or descending order. For either case, we need to figure out the index mapping rules for the **placement** part. Let `i` be the index of an element before placement and `j` the index after, for ascending order, we have: \\n`j = 2 * (m - 1 - i)` if `i < m` \\n`j = 2 * (n - 1 - i) + 1` if `i >= m`\\nfor descending order, the mapping rule can be combined into one expression:\\n`j =  (2 * i + 1) % (n | 1)`.\\n\\nTo avoid confusion for the index mapping process, we will use an auxiliary array serving as the array before index mapping and the input array as the array after index mapping. Here is the java program for ascending order:\\n```\\npublic void wiggleSort(int[] nums) {\\n    int n = nums.length, m = (n + 1) >> 1;\\n    int[] copy = Arrays.copyOf(nums, n);\\n    Arrays.sort(copy);\\n    \\n    for (int i = m - 1, j = 0; i >= 0; i--, j += 2) nums[j] = copy[i];\\n    for (int i = n - 1, j = 1; i >= m; i--, j += 2) nums[j] = copy[i];\\n}\\n```\\n\\n---\\n**`III -- O(n) time and O(n) space solution by median partition`**\\n\\nSorting the whole array is overkill for the **partition** part, since all we need are the `S` and `L` groups. As for elements within each group, we don't really care whether they are sorted or not. Suppose `m_ele` is the `m-th` smallest element in the array. We partition the array such that all elements less than `m_ele` go to its left and those greater than it end up in its right (or the other way around). After partition, the first `m` elements will form the `S` group while the rest will be the `L` group. To get the `m-th` smallest element, we will use the randomized quick-sort subroutine (refer to problem [leetcode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/) for more details). All the three parts (obtaining the `m-th` smallest element, partition and placement) can be done in `O(n)` time, therefore the total time complexity will be `O(n)`. And again we will use an extra array to simplify the index mapping process. Here is the java code:\\n```\\npublic void wiggleSort(int[] nums) {\\n    int n = nums.length, m = (n + 1) >> 1;\\n    int[] copy = Arrays.copyOf(nums, n);\\n    int median = kthSmallestNumber(nums, m);\\n    \\n    for (int i = 0, j = 0, k = n - 1; j <= k;) {\\n        if (copy[j] < median) {\\n            swap(copy, i++, j++);\\n        } else if (copy[j] > median) {\\n            swap(copy, j, k--);\\n        } else {\\n            j++;\\n        }\\n    }\\n        \\n    for (int i = m - 1, j = 0; i >= 0; i--, j += 2) nums[j] = copy[i];\\n    for (int i = n - 1, j = 1; i >= m; i--, j += 2) nums[j] = copy[i];\\n}\\n\\nprivate int kthSmallestNumber(int[] nums, int k) {\\n    Random random = new Random();\\n    \\n    for (int i = nums.length - 1; i >= 0; i--) {\\n        swap(nums, i, random.nextInt(i + 1));\\n    }\\n    \\n    int l = 0, r = nums.length - 1;\\n    k--;\\n        \\n    while (l < r) {\\n        int m = getMiddle(nums, l, r);\\n        \\n        if (m < k) {\\n            l = m + 1;\\n        } else if (m > k) {\\n            r = m - 1;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n    return nums[k];\\n}\\n    \\nprivate int getMiddle(int[] nums, int l, int r) {\\n    int i = l;\\n    \\n    for (int j = l + 1; j <= r; j++) {\\n        if (nums[j] < nums[l]) swap(nums, ++i, j);\\n    }\\n    \\n    swap(nums, l, i);\\n    return i;\\n}\\n\\nprivate void swap(int[] nums, int i, int j) {\\n    int t = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = t;\\n}\\n```\\n\\n---\\n**`IV -- O(n) time and O(1) space solution by combining partition and placement`**\\n\\nTo have `O(1)` space, we have to drop the extra array. Then both the partition and placement will be done on the input array itself. If these two parts are carried out separately, i.e., placement is done after partition is completely finished, there will be no nice way to do the index mapping without keeping track of mapped and unmapped elements (as far as I know). It turns out the two parts can be combined into a single one. \\n\\nTo see how, let's examine the whole partition and placement process more carefully.  For partition, its core function is to subject each element in the array to the partition rule (i.e., compared with `median`) **exactly once** and distribute the element to the proper position based on the comparison result. Traditionally we will add it to either the left or right half of the array and deal with it later after the partition is over. This is of course unnecessary. The element should be ready for consumption (do whatever you like with it) once the distribution for it is over. We might as well map it to a new position according to the above placement rule (for example, `j =  (2 * i + 1) % (n | 1)` for descending order),  right before going to the next element. The traditional way of disposing the elements corresponds to the identity mapping (i.e., `j = i`).\\n\\nOne important issue here for the index mapping is the order for traversing the array in the partition process. The traditional way of linear scan from left to right works well with the identity mapping, but obviously will violate the constraint that each element will be partitioned **exactly once** if the mapping takes the partitioned element to the unscanned area. The correct traversing order typically depends on the mapping we want to do. Here I prove that the partition constraint will not be violated if the mapping is **bijective** and the traversing order follows that of the linear scan but with the same mapping applied at each position.\\n\\nEach mapping `f` will be characterized by three parts: domain, codomain and mapping rules. For our case, both the domain and codomain will be the set `S = [0, n)` (i.e., integers from `0` up to `n - 1`). If `f` is bijective, we have:\\n1. for any `i1, i2` that belong to `S`, `i1 != i2 <==> f(i1) != f(i2)`.\\n2. if `i` covers all the elements in `S` exactly once, `f(i)` will do the same.\\n\\nIf our traversing order follows that of the linear scan with `f` applied for each position `i` in the linear scan, the first property will guarantee each element will be visited at most once while the second will guarantee each element be visited at least once. Therefore, at the end each element will be visited **exactly once**.\\n\\nBy the way, this index mapping idea is called \"virtual index\" in [stefanpochmann's post](https://discuss.leetcode.com/topic/32929/o-n-o-1-after-median-virtual-indexing/5) and further explained in [shuoshankou's post](https://discuss.leetcode.com/topic/41464/step-by-step-explanation-of-index-mapping-in-java). I will follow the same notation for the index mapping function (which is called `A` here). We can do different mappings as needed. The following implementation is for descending order. And just for fun, a rotation mapping `j = (i + k) % n` will rotate the resulted array after partition, check it out! Anyway, here is the java code:\\n\\n```\\npublic void wiggleSort(int[] nums) {\\n    int n = nums.length, m = (n + 1) >> 1;\\n    int median = kthSmallestNumber(nums, m);\\n    \\n    for (int i = 0, j = 0, k = n - 1; j <= k;) {\\n        if (nums[A(j, n)] > median) {\\n            swap(nums, A(i++, n), A(j++, n));\\n        } else if (nums[A(j, n)] < median) {\\n            swap(nums, A(j, n), A(k--, n));\\n        } else {\\n            j++;\\n        }\\n    }\\n}\\n\\nprivate int A(int i, int n) {\\n    return (2 * i + 1) % (n | 1);\\n}\\n```\\n(Note: `kthSmallestNumber` are defined in part III)"
		},
		{
			"lc_ans_id":"77680",
			"view":"5165",
			"top":"6",
			"title":"Clear Java O(n) avg time & O(n) space solution using 3-way-partition",
			"vote":"16",
			"content":"The basic idea is to first select the kth smallest element, where k is the half the size (if size is even) or half the size+1 (if size is odd). So the array is partitioned into two halves, for even size, left half size==right half size, for odd size, left half size==right half size+1. Then iterate back from left and right half, put each value into original array.\\n\\nFor example, [1, 5, 1, 1, 6, 4], after select kth smallest element, it becomes [1,1,1,5,6,4] with median index of 2. For the left half is [1,1,1], right half is [5,6,4]. After merge, it becomes, 1,4,1,6,1,5.\\n\\nSame for [4,5,5,6], after select kth smallest , it becomes [4,5,5,6] with left half [4,5] and right half [5,6], merge it to be [5,6,4,5].\\n\\nThe tricky parts:\\n1) Do a three-way-partition, so that the duplicates are around median, so that they can be split\\n2) Iterate from the back of two halves, so that the duplicates in between can be split apart.\\n\\n    public class Solution {\\n        public void wiggleSort(int[] nums) {\\n            int median = selectKth(nums, 0, nums.length-1, nums.length%2==0 ? nums.length/2 : nums.length/2+1);\\n            List<Integer> leftArr = new ArrayList<Integer>();\\n            for(int i=0; i<=median; i++)\\n                leftArr.add(nums[i]);\\n            List<Integer> rightArr = new ArrayList<Integer>();\\n            for(int i=median+1; i<nums.length; i++)\\n                rightArr.add(nums[i]);\\n            for(int li=leftArr.size()-1,ri=rightArr.size()-1,i=0; ri>=0; li--,ri--,i+=2) { // right is same or shorter than left\\n                nums[i] = leftArr.get(li);\\n                nums[i+1] = rightArr.get(ri);\\n            }\\n            if(nums.length%2!=0)\\n                nums[nums.length-1] = leftArr.get(0);\\n        }\\n        \\n        private int selectKth(int[] nums, int start, int end, int k) {\\n            int[] res = partition(nums,start,end);\\n            int lb = res[0]; int hb = res[1];\\n            if(k-1<lb)\\n                return selectKth(nums,start,lb-1,k);\\n            else if (k-1>hb)\\n                return selectKth(nums,hb+1,end,k);\\n            else\\n                return k-1;\\n        }\\n        \\n        private int[] partition(int[] nums, int lb, int hb) {\\n            int pVal = nums[lb]; // use random genarater is better in performance\\n            int i = lb;\\n            while(i<=hb) {\\n                if(nums[i]==pVal)\\n                    i++;\\n                else if(nums[i]<pVal)\\n                    swap(nums,i++,lb++);\\n                else\\n                    swap(nums,i,hb--);\\n            }\\n            int[] res = new int[2];\\n            res[0] = lb; res[1] = hb;\\n            return res;\\n        }\\n        \\n        private void swap(int[] nums, int i, int j) {\\n            int tmp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = tmp;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"77688",
			"view":"1854",
			"top":"7",
			"title":"O(n)+O(1) after median --- without Virtual Indexing :-)",
			"vote":"13",
			"content":"The idea is the same as the [three-way partitioning](https://en.wikipedia.org/wiki/Dutch_national_flag_problem#Pseudocode), but don't use the [virtual indexing](https://discuss.leetcode.com/topic/32929/o-n-o-1-after-median-virtual-indexing) \\n\\nI don't think I can figure out the tricky [Index-rewiring] during interview, so come up my own way to do the three-way partitioning.\\n\\n```\\nclass Solution {\\npublic:\\n    void wiggleSort(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return;\\n    \\n        // Find a median.\\n        auto midptr = nums.begin() + n / 2;\\n        nth_element(nums.begin(), midptr, nums.end());\\n        int mid = *midptr;\\n        \\n        int i = (n - 1) / 2 * 2, j = i, k = 1;\\n        for (int c = 0; c < n; ++c) {\\n            if (nums[j] < mid) {\\n                swap(nums[i], nums[j]);\\n                i -= 2;\\n                j -= 2;\\n                if (j < 0) j = n / 2 * 2 - 1;\\n            } else if (nums[j] > mid) {\\n                swap(nums[j], nums[k]);\\n                k += 2;\\n            } else {\\n                j -= 2;\\n                if (j < 0) j = n / 2 * 2 - 1;\\n            }\\n        }\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"77716",
			"view":"9643",
			"top":"8",
			"title":"Java 18 ms true O(1) space / cheated O(n) time using binary search",
			"vote":"11",
			"content":"I spent a lot of time looking for an in-place linear algorithm for finding the median. Thanks to @StefanPochmann for posting [a link to Stack Overflow][1], I found [this one][2]. It's really esoteric, and what's worse, it's not really a complete algorithm because at some point it just says\\n\\n> then, using any other linear-time in-place selection algorithm, search\\n> the sample for two elements x,y, of ranks...\\n\\nSo in the end, it's not exactly an algorithm for linear in-place selection, but rather an algorithm for finding the best sample for other algorithms to optimize the total number of operations involved. The paper provides references to other algorithms, but I've been unable to find any of them in the open. But surely, one could buy some books or access to some scientific site, and in the end it is possible to solve this in linear time and constant space. The code would be a real mess, though, and I'm not even sure if it will fit within the code length limit.\\n\\nBut [there is a better way][3]. Once I saw that I was amazed how absurdly simple it is. Made me feel like Dr. Watson after another explanation by Holmes.\\n\\nIndeed, why bother with all those algorithms if we know that possible values of the median lie between `INT_MIN` and `INT_MAX`. We can use binary search on the entire range! And since checking whether some number is the median or not takes O(n), then the whole thing is just O(n log 2^32). But log 2^32 is a constant, so it's technically still O(n).\\n\\n    public void wiggleSort(int[] nums) {\\n        if (nums.length <= 1) {\\n            return;\\n        }\\n        int p = bsSelect(nums, (nums.length - 1) / 2 + 1);\\n        // Reverse Dutch National Flag with Wiggle Indexing (StefanPochmann's Virtual Indexing).\\n        // Thanks to apolloydy for reversing this thing.\\n        final int n = nums.length;\\n        int m = 0, r = nums.length - 1;\\n        int lw = 1, mw = 1, rw = (1 + 2 * (nums.length - 1)) % (n | 1);\\n        while (m <= r) {\\n            if (nums[mw] > p) {\\n                int tmp = nums[mw];\\n                nums[mw] = nums[lw];\\n                nums[lw] = tmp;\\n                mw = (mw + 2) % (n | 1);\\n                ++m;\\n                lw = (lw + 2) % (n | 1);\\n            } else if (nums[mw] < p) {\\n                int tmp = nums[mw];\\n                nums[mw] = nums[rw];\\n                nums[rw] = tmp;\\n                rw = (rw - 2 + (n | 1)) % (n | 1);\\n                --r;\\n            } else {\\n                mw = (mw + 2) % (n | 1);\\n                ++m;\\n            }\\n        }\\n    }\\n\\n    private int bsSelect(int[] nums, int k) {\\n        if (k < 1 || k > nums.length) {\\n            throw new IllegalArgumentException(\"length=\" + nums.length + \" k=\" + k);\\n        }\\n        int left = Integer.MIN_VALUE, right = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = (left < 0 && right > 0) ? (left + right) / 2 : left + (right - left) / 2;\\n            int cl = 0, cg = 0, d = 0;\\n            for (int n : nums) {\\n                if (n < mid) {\\n                    if (++cl > k - 1) {\\n                        d = +1; // mid larger than kth\\n                        break;\\n                    }\\n                } else if (n > mid) {\\n                    if (++cg > (nums.length - k)) {\\n                        d = -1; // mid smaller than kth\\n                        break;\\n                    }\\n                }\\n            }\\n            if (d == 0) {\\n                return mid;\\n            } else if (d < 0) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        throw new AssertionError();\\n    }\\n\\nIt almost feels like cheating. But according to that post on Quora, that's exactly what the interviewers expect. Thinking out of the box and such.\\n\\nThis thing runs on my PC for 500 million elements in 31 seconds if the array is sorted and in 38 seconds if it's wiggle-sorted to begin with. This is slower than the median of medians solution (22 and 12 seconds), but this time it's true O(1) space.\\n\\n**Note** that I moved the argument check to the beginning because the old variant was really bugged. And I fixed the binary search because I forgot to do the `mid + 1` / `mid - 1` part. That turned 15 ms into 18 ms for some reason, and if I put `while (true)` there then it raises the runtime to 20 ms. Figures. But at least it's not bugged now (I hope). Note that integer overflows aren't possible because if mid is either `INT_MIN` or `INT_MAX` then the respective condition for decreasing/increasing it would be false.\\n\\nAs noted in the comment below, `mid = (left + right) / 2` may overflow, so it was replaced by that ugly, but overflow-aware line.\\n\\n  [1]: http://stackoverflow.com/questions/34562256/why-is-the-median-of-medians-algorithm-described-as-using-o1-auxiliary-space/34600911?noredirect=1#comment56987453_34600911\\n  [2]: http://www.cai.sk/ojs/index.php/cai/article/viewArticle/345\\n  [3]: https://www.quora.com/Whats-an-algorithm-for-finding-the-median-element-in-an-unsorted-array-in-linear-time-constant-space"
		},
		{
			"lc_ans_id":"77687",
			"view":"2433",
			"top":"9",
			"title":"Simple modulo solution",
			"vote":"11",
			"content":"Once again I sort and then spread the numbers like in this example with nums=[0,1,...,9]:\\n\\n    Small half:    4 . 3 . 2 . 1 . 0 .\\n    Large half:    . 9 . 8 . 7 . 6 . 5\\n    ----------------------------------\\n    Together:      4 9 3 8 2 7 1 6 0 5\\n\\nJust write the numbers 9, 8, 7, etc at indexes 1, 3, 5, etc. Use modulo to wrap around for the second round (the even indexes).\\n\\n---\\n\\n**Python**\\n\\n     def wiggleSort(self, nums):\\n        for i, num in enumerate(sorted(nums)[::-1]):\\n            nums[(1+2*i) % (len(nums)|1)] = num\\n\\n---\\n\\n**C++**\\n\\n    void wiggleSort(vector<int>& nums) {\\n        vector<int> sorted(nums);\\n        sort(sorted.rbegin(), sorted.rend());\\n        int n = nums.size(), m = n | 1;\\n        for (int i=0; i<n; i++)\\n            nums[(1+2*i)%m] = sorted[i];\\n    }\\n\\nOr:\\n\\n    void wiggleSort(vector<int>& nums) {\\n        vector<int> sorted(nums);\\n        sort(sorted.rbegin(), sorted.rend());\\n        int n = nums.size(), m = n | 1, i = -1;\\n        for (int num : sorted)\\n            nums[(i+=2)%m] = num;\\n    }"
		}
	],
	"id":"324",
	"title":"Wiggle Sort II",
	"content":"<p>\r\n    Given an unsorted array <code>nums</code>, reorder it such that\r\n    <code>nums[0] < nums[1] > nums[2] < nums[3]...</code>.\r\n</p>\r\n\r\n<p>\r\n    <b>Example:</b><br/>\r\n    (1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>. <br/>\r\n    (2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.\r\n</p>\r\n\r\n<p>\r\n    <b>Note:</b><br/>\r\n    You may assume all input has valid answer.\r\n</p>\r\n\r\n<p>\r\n    <b>Follow Up:</b><br/>\r\n    Can you do it in O(n) time and/or in-place with O(1) extra space?\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/dietpepsi\">@dietpepsi</a> for adding this problem and creating all test cases.</p>",
	"frequency":"356",
	"ac_num":"35876"
}