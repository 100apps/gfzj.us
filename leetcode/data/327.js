{
	"difficulty":"3",
	"submit_num":"72707",
	"show_id":"327",
	"leetcode_id":"327",
	"answers":[
		{
			"lc_ans_id":"77990",
			"view":"40265",
			"top":"0",
			"title":"Share my solution",
			"vote":"226",
			"content":"First of all, let's look at the naive solution. Preprocess to calculate the prefix sums `S[i]` = `S(0, i)`, then `S(i, j)` = `S[j] - S[i]`. Note that here we define `S(i, j)` as the sum of range `[i, j)` where `j` exclusive and `j` > `i`. With these prefix sums, it is trivial to see that with `O(n^2)` time we can find all `S(i, j)` in the range `[lower, upper]`\\n\\n**Java - Naive Solution**\\n\\n    public int countRangeSum(int[] nums, int lower, int upper) {\\n        int n = nums.length;\\n        long[] sums = new long[n + 1];\\n        for (int i = 0; i < n; ++i)\\n            sums[i + 1] = sums[i] + nums[i];\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (int j = i + 1; j <= n; ++j)\\n                if (sums[j] - sums[i] >= lower && sums[j] - sums[i] <= upper)\\n                    ans++;\\n        return ans;\\n    }\\n\\n**However the naive solution is set to TLE intentionally**\\n\\n**Now let's do better than this.**\\n\\nRecall [count smaller number after self](http://algobox.org/count-of-smaller-numbers-after-self/) where we encountered the problem\\n\\n* `count[i]` = count of `nums[j]` - `nums[i]` < `0` with `j` > `i`\\n\\nHere, after we did the preprocess, we need to solve the problem\\n\\n* `count[i]` = count of `a` <= `S[j]` - `S[i]` <= `b` with `j` > `i`\\n* `ans` = sum(count[:])\\n\\n\\nTherefore the two problems are almost the same. We can use the same technique used in that problem to solve this problem. One solution is merge sort based; another one is Balanced BST based. The time complexity are both `O(n log n)`.\\n\\nThe merge sort based solution counts the answer while doing the merge. During the merge stage, we have already sorted the left half `[start, mid)` and right half `[mid, end)`. We then iterate through the left half with index `i`. For each `i`, we need to find two indices `k` and `j` in the right half where\\n\\n*  `j` is the first index satisfy `sums[j] - sums[i] > upper` and \\n* `k` is the first index satisfy `sums[k] - sums[i] >= lower`. \\n\\nThen the number of sums in `[lower, upper]` is `j-k`. We also use another index `t` to copy the elements satisfy `sums[t] < sums[i]` to a cache in order to complete the merge sort.\\n\\nDespite the nested loops, the time complexity of the \"merge & count\" stage is still linear. Because the indices `k`, `j`, `t` will only increase but not decrease, each of them will only traversal the right half once at most. The total time complexity of this divide and conquer solution is then `O(n log n)`.\\n\\nOne other concern is that the `sums` may overflow integer. So we use long instead.\\n\\n**Java - Merge Sort Solution**\\n\\n    public int countRangeSum(int[] nums, int lower, int upper) {\\n        int n = nums.length;\\n        long[] sums = new long[n + 1];\\n        for (int i = 0; i < n; ++i)\\n            sums[i + 1] = sums[i] + nums[i];\\n        return countWhileMergeSort(sums, 0, n + 1, lower, upper);\\n    }\\n\\n    private int countWhileMergeSort(long[] sums, int start, int end, int lower, int upper) {\\n        if (end - start <= 1) return 0;\\n        int mid = (start + end) / 2;\\n        int count = countWhileMergeSort(sums, start, mid, lower, upper) \\n                  + countWhileMergeSort(sums, mid, end, lower, upper);\\n        int j = mid, k = mid, t = mid;\\n        long[] cache = new long[end - start];\\n        for (int i = start, r = 0; i < mid; ++i, ++r) {\\n            while (k < end && sums[k] - sums[i] < lower) k++;\\n            while (j < end && sums[j] - sums[i] <= upper) j++;\\n            while (t < end && sums[t] < sums[i]) cache[r++] = sums[t++];\\n            cache[r] = sums[i];\\n            count += j - k;\\n        }\\n        System.arraycopy(cache, 0, sums, start, t - start);\\n        return count;\\n    }"
		},
		{
			"lc_ans_id":"78006",
			"view":"17885",
			"top":"1",
			"title":"Summary of the Divide and Conquer based and Binary Indexed Tree based solutions",
			"vote":"114",
			"content":"Thanks for those contributing excellent ideas to this problem. Here is a quick summary of solutions based on either divide and conquer or binary indexed tree. \\n\\nTo start, we already know there is a straightforward solution by computing each range sum and checking whether it lies in [lower, upper] or not. If the number of elements is n, we have n*(n+1)/2 such range sums so the naive solution will end up with O(n^2) time complexity. Now we are asked to do better than that. So what are the targeted time complexities in your mind? When I first looked at the problem, my instinct is that O(n) solution is too ambitious, so I will target at linearithmic-like (O(n*(logn)^b)) solutions. To get the logarithmic part, it's natural to think of breaking down the original array, and that's where the divide-and-conquer idea comes from.\\n\\nFor this problem, we need some array to apply our divide and conquer algorithm. Without much thinking, we can do that directly with the input array (nums) itself. Since our problem also involves range sums and I believe you have the experience of computing range sums from prefix array of the input array, we might as well apply divide and conquer ideas on the prefix array. So I will give both the input-array based and prefix-array based divide&conquer solutions.\\n\\nLet's first look at input-array based divide&conquer solution. Our original problem is like this: given an input array nums with length n and a range [lower, upper], find the total number of range sums that lie in the given range. Note the range [lower, upper] and the input array are both fixed. Therefore each range sum can be characterized by two indices i1 and i2 (i1 <= i2), such that range sum S(i1, i2) is the summation of input elements with indices going from i1 up to i2 (both inclusive). Then our problem can be redefined in terms of the value ranges of i1 and i2. For example our original problem can be restated as finding the total number of range sums lying in the given range with 0 <= i1 <= i2 <= n - 1, or in a symbolic way T(0, n-1).\\n\\nNow if we break our original input array into two subarrays, [0, m] and [m+1, n-1] with m = (n-1)/2, our original problem can be divided into three parts, depending on the values of i1 and i2. If i1 and i2 are both from the first subarray [0, m], we have a subproblem T(0, m); if i1 and i2 are both from the second subarray, we have a subproblem T(m+1, n-1); if i1 is from the first subarray and i2 from the second (note we assume i1 <= i2, therefore we don't have the other case with i2 from first subarray and i1 from second), then we have a new problem which I define as C. In summary we should have:\\n\\nT(0, n-1) = T(0, m) + T(m+1, n-1) + C\\n\\nNow from the master theorem, the time complexity of the new problem C should be better than O(n^2), otherwise we make no improvement by applying this divide&conquer idea. So again, I will aim at linearithmic-like solutions for the new problem C: find the total number of range sums lying in the given range with each range sum starting from the first subarray and ending at the second subarray.\\n\\nFirst let's try to compute all such range sums. The way I did it was first computing the prefix array of the second subarray and the suffix array (or \"backward\" prefix array if you like) of the first subarray. Then I can naively add each element in the suffix array to all elements in the prefix array to obtain all the possible range sums. Of course you end up with O(n^2) solution, as expected. So how can we approach it with better time complexity?\\n\\nHere are the facts I observed: for each element e in the suffix array, we need to add it to all elements in the prefix array. But the order in which we add it doesn't matter. This implies that we can sort our prefix array. This can be done in O(nlogn) time. Now we have a sorted prefix array, do we still need to add the element e to all elements in the prefix array? The answer is no. Because our final goal is to compare the resulted range sums with the given range bounds lower and upper. It is equivalent to modifying the range bounds so we have new bounds (lower - e) and (upper - e) and leave the prefix array unchanged. Now we can compare these new bounds with the sorted prefix array, and I'm sure you can write your own binary search algorithm to do that. So for each element e in the suffix array, we can compute the modified range bounds and get the number of range sums in this new range in logn time. Therefore the total time will be O(nlogn). So in summary, our new problem C can be solved in O(nlogn) time and according to the master theorem, our original problem can be solved in O(n(logn)^2) time. The following is the complete java program:\\n\\n    public int countRangeSum(int[] nums, int lower, int upper) {\\n        if (nums == null || nums.length == 0 || lower > upper) return 0;\\n        return countRangeSumSub(nums, 0, nums.length - 1, lower, upper);\\n    }\\n\\n    private int countRangeSumSub(int[] nums, int l, int r, int lower, int upper) {\\n        if (l == r) return nums[l] >= lower && nums[r] <= upper ? 1 : 0;  // base case\\n    \\t\\n        int m = l + (r - l) / 2;\\n        long[] arr = new long[r - m];  // prefix array for the second subarray\\n        long sum = 0;\\n        int count = 0;\\n    \\t\\n        for (int i = m + 1; i <= r; i++) {\\n    \\tsum += nums[i];\\n    \\tarr[i - (m + 1)] = sum;\\t// compute the prefix array\\n        }\\n    \\t\\n        Arrays.sort(arr);  // sort the prefix array\\n    \\t\\n        // Here we can compute the suffix array element by element.\\n        // For each element in the suffix array, we compute the corresponding\\n\\t    // \"insertion\" indices of the modified bounds in the sorted prefix array\\n        // then the number of valid ranges sums will be given by the indices difference.\\n        // I modified the bounds to be \"double\" to avoid duplicate elements.\\n        sum = 0;\\n        for (int i = m; i >= l; i--) {\\n    \\tsum += nums[i];  \\n    \\tcount += findIndex(arr, upper - sum + 0.5) - findIndex(arr, lower - sum - 0.5);\\n         }\\n    \\t\\n        return countRangeSumSub(nums, l, m, lower, upper) + countRangeSumSub(nums, m + 1, r, lower, upper) + count;\\n    }\\n\\n    // binary search function\\n    private int findIndex(long[] arr, double val) {\\n        int l = 0, r = arr.length - 1, m = 0;\\n    \\t\\n        while (l <= r) {\\n    \\tm = l + (r - l) / 2;\\n    \\t\\t\\n    \\tif (arr[m] <= val) {\\n    \\t    l = m + 1;\\n    \\t} else {\\n    \\t    r = m - 1;\\n            }\\n        }\\n    \\t\\n        return l;\\n    }\\n\\n**(Next two parts will come in answers due to the limitation of maximum length of characters )**"
		},
		{
			"lc_ans_id":"77991",
			"view":"19719",
			"top":"2",
			"title":"Short & simple O(n log n)",
			"vote":"64",
			"content":"    def countRangeSum(self, nums, lower, upper):\\n        first = [0]\\n        for num in nums:\\n            first.append(first[-1] + num)\\n        def sort(lo, hi):\\n            mid = (lo + hi) / 2\\n            if mid == lo:\\n                return 0\\n            count = sort(lo, mid) + sort(mid, hi)\\n            i = j = mid\\n            for left in first[lo:mid]:\\n                while i < hi and first[i] - left <  lower: i += 1\\n                while j < hi and first[j] - left <= upper: j += 1\\n                count += j - i\\n            first[lo:hi] = sorted(first[lo:hi])\\n            return count\\n        return sort(0, len(first))\\n\\nFirst compute the prefix sums: `first[m]` is the sum of the first `m` numbers.  \\nThen the sum of any subarray `nums[i:k]` is simply `first[k] - first[i]`.  \\nSo we just need to count those where `first[k] - first[i]` is in `[lower,upper]`.\\n\\nTo find those pairs, I use mergesort with embedded counting. The pairs in the left half and the pairs in the right half get counted in the recursive calls. We just need to also count the pairs that use both halves.\\n\\nFor each `left` in `first[lo:mid]` I find all `right` in `first[mid:hi]` so that `right - left` lies in `[lower, upper]`. Because the halves are sorted, these fitting `right` values are a subarray `first[i:j]`. With increasing `left` we must also increase `right`, meaning must we leave out `first[i]` if it's too small and and we must include `first[j]` if it's small enough.\\n\\nBesides the counting, I also need to actually merge the halves for the sorting. I let `sorted` do that, which uses [Timsort](https://en.wikipedia.org/wiki/Timsort) and takes linear time to recognize and merge the already sorted halves."
		},
		{
			"lc_ans_id":"77987",
			"view":"6411",
			"top":"3",
			"title":"Java SegmentTree Solution, 36ms",
			"vote":"19",
			"content":"Understand my segmentTree implementation is not optimized.\\nPlease feel free to give me suggestions.\\n\\n    public class Solution {\\n        class SegmentTreeNode {\\n            SegmentTreeNode left;\\n            SegmentTreeNode right;\\n            int count;\\n            long min;\\n            long max;\\n            public SegmentTreeNode(long min, long max) {\\n                this.min = min;\\n                this.max = max;\\n            }\\n        }\\n        private SegmentTreeNode buildSegmentTree(Long[] valArr, int low, int high) {\\n            if(low > high) return null;\\n            SegmentTreeNode stn = new SegmentTreeNode(valArr[low], valArr[high]);\\n            if(low == high) return stn;\\n            int mid = (low + high)/2;\\n            stn.left = buildSegmentTree(valArr, low, mid);\\n            stn.right = buildSegmentTree(valArr, mid+1, high);\\n            return stn;\\n        }\\n        private void updateSegmentTree(SegmentTreeNode stn, Long val) {\\n            if(stn == null) return;\\n            if(val >= stn.min && val <= stn.max) {\\n                stn.count++;\\n                updateSegmentTree(stn.left, val);\\n                updateSegmentTree(stn.right, val);\\n            }\\n        }\\n        private int getCount(SegmentTreeNode stn, long min, long max) {\\n            if(stn == null) return 0;\\n            if(min > stn.max || max < stn.min) return 0;\\n            if(min <= stn.min && max >= stn.max) return stn.count;\\n            return getCount(stn.left, min, max) + getCount(stn.right, min, max);\\n        }\\n    \\n        public int countRangeSum(int[] nums, int lower, int upper) {\\n    \\n            if(nums == null || nums.length == 0) return 0;\\n            int ans = 0;\\n            Set<Long> valSet = new HashSet<Long>();\\n            long sum = 0;\\n            for(int i = 0; i < nums.length; i++) {\\n                sum += (long) nums[i];\\n                valSet.add(sum);\\n            }\\n    \\n            Long[] valArr = valSet.toArray(new Long[0]);\\n    \\n            Arrays.sort(valArr);\\n            SegmentTreeNode root = buildSegmentTree(valArr, 0, valArr.length-1);\\n    \\n            for(int i = nums.length-1; i >=0; i--) {\\n                updateSegmentTree(root, sum);\\n                sum -= (long) nums[i];\\n                ans += getCount(root, (long)lower+sum, (long)upper+sum);\\n            }\\n            return ans;\\n        }\\n        \\n    }"
		},
		{
			"lc_ans_id":"77992",
			"view":"3808",
			"top":"4",
			"title":"C++ merge sort solution, very short",
			"vote":"16",
			"content":"    class Solution {\\n    public:\\n        int mergeSort(vector<long>& sum, int lower, int upper, int low, int high)\\n        {\\n            if(high-low <= 1) return 0;\\n            int mid = (low+high)/2, m = mid, n = mid, count =0;\\n            count =mergeSort(sum,lower,upper,low,mid) +mergeSort(sum,lower,upper,mid,high);\\n            for(int i =low; i< mid; i++)\\n            {\\n                while(m < high && sum[m] - sum[i] < lower) m++;\\n                while(n < high && sum[n] - sum[i] <= upper) n++;\\n                count += n - m;\\n            }\\n            inplace_merge(sum.begin()+low, sum.begin()+mid, sum.begin()+high);\\n            return count;\\n        }\\n    \\n        int countRangeSum(vector<int>& nums, int lower, int upper) {\\n            int len = nums.size();\\n            vector<long> sum(len + 1, 0);\\n            for(int i =0; i< len; i++) sum[i+1] = sum[i]+nums[i];\\n            return mergeSort(sum, lower, upper, 0, len+1);\\n        }\\n    };"
		},
		{
			"lc_ans_id":"78030",
			"view":"5245",
			"top":"5",
			"title":"8-line multiset  C++ solution (100ms), also binary search tree (180ms) + mergesort(52ms)",
			"vote":"15",
			"content":"The basic idea is to use a multiset to save sum, where sum at i = nums[0]+...+ nums[i]. At each i, only those sum[j] that satisfies  lower=< sum[i]-sum[j]<= upper can generate a valid range[j,i]. so we only need to calculate how many j (0=< j< i) satisfy  sum[i]-upper=< sum[j]<=-sum[i]-lower. The STL multiset can take care of sort and find upper_bound, lower_bound j. Since the multiset is usually implemented with Red-black tree, so those operations should have complexity of O(logN). So in total, the complexity is O(NlogN) (except the distance part). At least it looks neat\\n\\n    class Solution {\\n    public:\\n        int countRangeSum(vector<int>& nums, int lower, int upper) {\\n            multiset<long long> pSum;\\n            int res = 0,  i; \\n            long long left, right, sum=0;\\n            for(i=0,pSum.insert(0); i<nums.size(); ++i)\\n            {\\n                sum +=nums[i];\\n                res += std::distance(pSum.lower_bound(sum-upper), pSum.upper_bound(sum-lower));\\n                pSum.insert(sum);\\n            }\\n            return res;\\n        }\\n    };\\n\\nIn the comments made by StefanPochmann, there is concern that the STL distance function increases the total complexity to O(N^2), which is true. In the following version, I just show one possible way to fix that (O(1) distance function) if we implement the binary search tree by ourselves. Of course, the below version is not a balanced binary search tree, so the worst case is still O(N^2) even if the input is random, the average complexity is O(NlogN)\\n\\n    class Solution {\\n    private:\\n        class BSTNode{ // Binary search tree implementation\\n        public:    \\n            long long val;\\n            int cnt; // how many nodes with value of \"val'\\n            int lCnt; // how many nodes on its left subtree\\n            BSTNode *left;\\n            BSTNode *right;\\n            \\n            BSTNode(long long x)\\n            {\\n                val = x;\\n                cnt = 1;\\n                lCnt = 0;\\n                left = right = nullptr;\\n            }\\n        };\\n        \\n        int getBound(BSTNode *root, long long x, bool includeSelf)\\n        { // get the index of the last node that satisfy val<x (includeSelf=false) or val<=x (includeSelf = true)\\n            if(!root) return 0;\\n            if(root->val == x) return  root->lCnt + (includeSelf?root->cnt:0);\\n            else if(root->val > x) return getBound(root->left, x, includeSelf);\\n            else return root->cnt + root->lCnt + getBound(root->right, x, includeSelf);\\n        }\\n        void insert(BSTNode*& root, long long x)\\n        { // insert a node to the tree\\n            if(!root) root = new BSTNode(x);\\n            else if(root->val == x) (root->cnt)++;\\n            else if(root->val < x) \\n                insert(root->right,x);\\n            else{\\n                ++(root->lCnt);\\n                insert(root->left,x);\\n            }\\n        }\\n        void deleteTree(BSTNode*root)\\n        { //destroy the tree\\n            if(!root) return;\\n            deleteTree(root->left);\\n            deleteTree(root->right);\\n            delete root;\\n        }\\n        \\n        \\n    public:\\n        int countRangeSum(vector<int>& nums, int lower, int upper) { // same idea as the multiset  version\\n            BSTNode *root= new BSTNode(0);\\n            int res = 0,  i; \\n            long long left, right, sum=0;\\n            for(i=0; i<nums.size(); ++i)\\n            {\\n                sum +=nums[i];\\n                res += getBound(root, sum-lower, true) - getBound(root, sum-upper, false);\\n                insert(root, sum);\\n            }\\n            deleteTree(root);\\n            return res;\\n         }\\n    };\\n\\nAnother option is to multify mergesort to do counting. The code is as below and the complexity is O(NlogN) (52ms)\\n\\n    class Solution {\\n    private:    \\n        int mergeSort(vector<long long>&sum, int left, int right, int lower, int upper)\\n        {\\n            int mid, i, res, j, k;\\n            if(left>right) return 0;\\n            if(left==right) return ( (sum[left]>=lower) && (sum[left]<=upper) )?1:0;\\n            else\\n            {\\n                vector<long long> temp(right-left+1,0);\\n                mid = (left+right)/2;\\n                res = mergeSort(sum, left,mid, lower, upper) + mergeSort(sum, mid+1,right, lower, upper); // merge sort two halfs first, be careful about how to divide [left, mid] and [mid+1, right]\\n                for(i=left, j=k=mid+1; i<=mid; ++i)\\n                { // count the valid ranges [i,j], where i is in the first half and j is in the second half\\n                    while(j<=right && sum[j]-sum[i]<lower)  ++j;\\n                    while(k<=right && sum[k]-sum[i]<=upper) ++k;\\n                    res +=k-j;\\n                }\\n                for(i=k=left, j=mid+1; k<=right; ++k) //merge the sorted two halfs\\n                    temp[k-left] = (i<=mid) && (j>right || sum[i]<sum[j])?sum[i++]:sum[j++]; \\n                for(k=left; k<=right; ++k) // copy the sorted results back to sum\\n                    sum[k] = temp[k-left]; \\n                return res;\\n            }\\n        }\\n    public:\\n        int countRangeSum(vector<int>& nums, int lower, int upper) {\\n             int len = nums.size(), i;\\n             vector<long long> sum(len+1, 0);\\n             for(i=1; i<=len; ++i) sum[i] = sum[i-1]+nums[i-1];\\n             return mergeSort(sum, 1, len, lower, upper);\\n        }\\n    };"
		},
		{
			"lc_ans_id":"78003",
			"view":"3466",
			"top":"6",
			"title":"Java BST solution averagely O(nlogn)",
			"vote":"14",
			"content":"The performance would be bad if all the numbers are positive or negative, where the BST is completely unbalanced.\\n\\n    public class Solution {\\n        private class TreeNode {\\n            long val = 0;\\n            int count = 1;\\n            int leftSize = 0;\\n            int rightSize = 0;\\n            TreeNode left = null;\\n            TreeNode right = null;\\n            public TreeNode(long v) {\\n                this.val = v;\\n                this.count = 1;\\n                this.leftSize = 0;\\n                this.rightSize = 0;\\n            }\\n        }\\n        \\n        private TreeNode insert(TreeNode root, long val) {\\n            if(root == null) {\\n                return new TreeNode(val);\\n            } else if(root.val == val) {\\n                root.count++;\\n            } else if(val < root.val) {\\n                root.leftSize++;\\n                root.left = insert(root.left, val);\\n            } else if(val > root.val) {\\n                root.rightSize++;\\n                root.right = insert(root.right, val);\\n            }\\n            return root;\\n        }\\n        \\n        private int countSmaller(TreeNode root, long val) {\\n            if(root == null) {\\n                return 0;\\n            } else if(root.val == val) {\\n                return root.leftSize;\\n            } else if(root.val > val) {\\n                return countSmaller(root.left, val);\\n            } else {\\n                return root.leftSize + root.count + countSmaller(root.right, val);\\n            }\\n        }\\n        \\n        private int countLarger(TreeNode root, long val) {\\n            if(root == null) {\\n                return 0;\\n            } else if(root.val == val) {\\n                return root.rightSize;\\n            } else if(root.val < val) {\\n                return countLarger(root.right, val);\\n            } else {\\n                return countLarger(root.left, val) + root.count + root.rightSize;\\n            }\\n        }\\n        \\n        private int rangeSize(TreeNode root, long lower, long upper) {\\n            int total = root.count + root.leftSize + root.rightSize;\\n            int smaller = countSmaller(root, lower);    // Exclude everything smaller than lower\\n            int larger = countLarger(root, upper);      // Exclude everything larger than upper\\n            return total - smaller - larger;\\n        }\\n        \\n        public int countRangeSum(int[] nums, int lower, int upper) {\\n            if(nums.length == 0) {\\n                return 0;\\n            }\\n            long[] sums = new long[nums.length + 1];\\n            for(int i = 0; i < nums.length; i++) {\\n                sums[i + 1] = sums[i] + nums[i];\\n            }\\n            TreeNode root = new TreeNode(sums[0]);\\n            int output = 0;\\n            for(int i = 1; i < sums.length; i++) {\\n                output += rangeSize(root, sums[i] - upper, sums[i] - lower);\\n                insert(root, sums[i]);\\n            }\\n            return output;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"77989",
			"view":"3482",
			"top":"7",
			"title":"Summary Of BIT, Divide And Conquer and elses...",
			"vote":"10",
			"content":"[Leetcode, Count of Range Sum][1]\\n\\n  [1]: http://huntzhan.org/leetcode-count-of-range-sum/"
		},
		{
			"lc_ans_id":"78018",
			"view":"895",
			"top":"8",
			"title":"Share my Java solution using TreeMap",
			"vote":"9",
			"content":"```\\npublic class Solution {\\n    public int countRangeSum(int[] nums, int lower, int upper) {\\n        if(nums==null || nums.length==0) return 0;\\n        TreeMap<Long, Long> tr = new TreeMap<Long, Long>();\\n        tr.put((long)0, (long)1);\\n        long sum = 0;\\n        long count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            long from = sum - upper;\\n            long to = sum - lower;\\n            Map<Long, Long> sub = tr.subMap(from, true, to, true);\\n            for(Long value:sub.values()){\\n                count+=value;\\n            }\\n            if(tr.containsKey(sum)){\\n                tr.put(sum, tr.get(sum)+1);\\n            } else {\\n                tr.put(sum, (long)1);\\n            }\\n        }\\n        return (int)count;\\n    }\\n}\\n````"
		},
		{
			"lc_ans_id":"77986",
			"view":"1342",
			"top":"9",
			"title":"O(NlogN) Python solution, binary indexed tree, 268 ms",
			"vote":"7",
			"content":"`Sum[k]` is the sum of first k numbers. O(N^2) solution is \\n\\n    for j in range(n + 1):\\n        for i in range(j):\\n            if lower <= Sum[j] - Sum[i] <= upper: res += 1\\n\\nThis is equal to:\\n\\n    collection = empty\\n    for sum_j in Sum:\\n        sum_i_count = how many sum_i in this collection that sum_j - upper <= sum_i <= sum_j - lower\\n        res += sum_i_count\\n        put sum_j into this collection\\n\\nWith [Binary indexed tree][1], counting `sum_i` number is O(logN), putting  `sum_i` into tree is also O(logN). Here we store the index of `sortSum` in the tree. Since index of `BITree` starts from 1, we need `bisect.bisect_left(sortSum, sum_j) + 1` for `update()`.\\n\\n    def countRangeSum(self, nums, lower, upper):\\n        n = len(nums)\\n        Sum, BITree = [0] * (n + 1), [0] * (n + 2)\\n        \\n        def count(x):\\n            s = 0\\n            while x:\\n                s += BITree[x]\\n                x -= (x & -x)\\n            return s\\n        \\n        def update(x):\\n            while x <= n + 1:\\n                BITree[x] += 1\\n                x += (x & -x)\\n                \\n        for i in range(n):\\n            Sum[i + 1] = Sum[i] + nums[i]\\n        sortSum, res = sorted(Sum), 0\\n        for sum_j in Sum:\\n            sum_i_count = count(bisect.bisect_right(sortSum, sum_j - lower)) - count(bisect.bisect_left(sortSum, sum_j - upper))\\n            res += sum_i_count\\n            update(bisect.bisect_left(sortSum, sum_j) + 1)\\n        return res\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Fenwick_tree"
		}
	],
	"id":"327",
	"title":"Count of Range Sum",
	"content":"<p>\r\n    Given an integer array <code>nums</code>, return the number of range sums that lie in <code>[lower, upper]</code> inclusive.<br/>\r\n\r\n    Range sum <code>S(i, j)</code> is defined as the sum of the elements in <code>nums</code> between indices <code>i</code> and \r\n    <code>j</code> (<code>i</code> &le; <code>j</code>), inclusive.\r\n</p>\r\n\r\n<p>\r\n    <b>Note:</b><br/>\r\n    A naive algorithm of <i>O</i>(<i>n</i><sup>2</sup>) is trivial. You MUST do better than that.\r\n</p>\r\n<p>\r\n    <b>Example:</b><br/>\r\n    Given <i>nums</i> = <code>[-2, 5, -1]</code>, <i>lower</i> = <code>-2</code>, <i>upper</i> = <code>2</code>,<br/>\r\n    Return <code>3</code>.<br/>\r\n    The three ranges are : <code>[0, 0]</code>, <code>[2, 2]</code>, <code>[0, 2]</code> and their respective sums are: <code>-2, -1, 2</code>.\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/dietpepsi\">@dietpepsi</a> for adding this problem and creating all test cases.</p>",
	"frequency":"336",
	"ac_num":"22163"
}