{
	"difficulty":"3",
	"submit_num":"60637",
	"show_id":"335",
	"leetcode_id":"335",
	"answers":[
		{
			"lc_ans_id":"79131",
			"view":"20132",
			"top":"0",
			"title":"Java Oms with explanation",
			"vote":"126",
			"content":"    // Categorize the self-crossing scenarios, there are 3 of them: \\n    // 1. Fourth line crosses first line and works for fifth line crosses second line and so on...\\n    // 2. Fifth line meets first line and works for the lines after\\n    // 3. Sixth line crosses first line and works for the lines after\\n    public class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int l = x.length;\\n            if(l <= 3) return false;\\n            \\n            for(int i = 3; i < l; i++){\\n                if(x[i] >= x[i-2] && x[i-1] <= x[i-3]) return true;  //Fourth line crosses first line and onward\\n                if(i >=4)\\n                {\\n                    if(x[i-1] == x[i-3] && x[i] + x[i-4] >= x[i-2]) return true; // Fifth line meets first line and onward\\n                }\\n                if(i >=5)\\n                {\\n                    if(x[i-2] - x[i-4] >= 0 && x[i] >= x[i-2] - x[i-4] && x[i-1] >= x[i-3] - x[i-5] && x[i-1] <= x[i-3]) return true;  // Sixth line crosses first line and onward\\n                }\\n            }\\n            return false;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"79175",
			"view":"4821",
			"top":"1",
			"title":"The best submission in C searching for the crossing patterns is the key",
			"vote":"41",
			"content":"After drawing a few crossing cases ourselves, we can simply find out there are two basic patterns:\\n\\n - x[i-1]<=x[i-3] && x[i]>=x[i-2] the ending circle line cross the beginning circle line in one circle;\\n - i>=5 && x[i-1]<=x[i-3] && x[i]>=x[i-2]-x[i-4] the second line of the next circle cross the the beginning of the previous circle between two adjacent circles;\\n\\nBut still that is not over yet, how about some special cases? How about the first line of the next circle and the previous circle? Yeah, the beginning line of the next circle can overlap the the first line of the previous circle - another two adjacent circles case: \\n\\n - i>=4 && x[i-1]==x[i-3] && x[i]>=x[i-2]-x[i-4]\\n\\nQuite straightforward. Then we can test our patterns now, however soon we will find out that the second cases  is not strong enough to cover all possible situations - the second line of the next circle crossing the previous circle at the its first line\\n\\n - [3,3,3,2,1,1] is an example here, so x[i-2]>=x[i-4] then must be added to our conditions;\\n - [3,3,4,4,10,4,4,,3,3] is another typical example for x[i-3]<=x[i-1]+x[i-5] condition, which also should be added to make the constrained conditions stronger;\\n\\nAt last, we make it! Bang! End of story with a very terse, clean and efficient code as follows.\\n\\n**Updated: 2016-09-12** For better and easier reasoning, here is the thinking thread.\\nSuppose `i` is the current line, then:\\n\\n- i and i-3 can cross \\n- i and i-4 can cross\\n- i and i-5 can cross \\n\\nno more or no less just exactly the right combination.\\n\\nNow it's time for us to restrict the conditions to make them just happen.\\n\\ni and i-3\\n> i>=i-2 && i-1<=i-3\\n\\ni and i-4\\n>i+i-4>=i-2 && i-1==i-3\\n\\ni and i-5\\n> i+i-4>=i-2 && i-2>=i-4 && i-1+i-5>=i-3 && i-1<=i-3\\n\\n----------\\nIn C\\n\\n```\\nbool isSelfCrossing(int* x, int size)\\n{\\n    for(int i = 3; i < size; i++)\\n    {\\n        if(x[i]>=x[i-2] && x[i-1]<=x[i-3]) return true;\\n        if(i>=4 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2]) return true;\\n        if(i>=5 && x[i-2]-x[i-4]>=0 && x[i]>=x[i-2]-x[i-4] && x[i-1]>=x[i-3]-x[i-5] && x[i-1]<=x[i-3]) return true;\\n    }\\n    return false;\\n}\\n```\\n\\nIn C++\\n\\n```\\nclass Solution {\\npublic:\\n    bool isSelfCrossing(vector<int>& x) {\\n\\tfor(int i = 3; i < x.size(); i++) {\\n\\t\\tif(x[i-1]<=x[i-3] && x[i]>=x[i-2]) return true;\\n\\t\\tif(i>3 && x[i]+x[i-4]>=x[i-2] && x[i-1]==x[i-3]) return true;\\n\\t\\tif(i>4 && x[i-1]+x[i-5]>=x[i-3] && x[i-1]<=x[i-3] && x[i]+x[i-4]>=x[i-2] && x[i-4]<=x[i-2]) return true;\\n\\t}\\n\\treturn false;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"79168",
			"view":"4083",
			"top":"2",
			"title":"Simple Java Solution",
			"vote":"39",
			"content":"    public class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            if (x.length <= 3) {\\n                return false;\\n            }\\n            int i = 2;\\n            // keep spiraling outward\\n            while (i < x.length && x[i] > x[i - 2]) {\\n                i++;\\n            }\\n            if (i >= x.length) {\\n                return false;\\n            }\\n            // transition from spiraling outward to spiraling inward\\n            if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\\n                    (i == 3 && x[i] == x[i - 2])) {\\n                x[i - 1] -= x[i - 3];\\n            }\\n            i++;\\n            // keep spiraling inward\\n            while (i < x.length) {\\n                if (x[i] >= x[i - 2]) {\\n                    return true;\\n                }\\n                i++;\\n            }\\n            return false;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"79141",
			"view":"5604",
			"top":"3",
			"title":"Another python...",
			"vote":"38",
			"content":"Checking out every six pack.\\n\\n**Solution 1**\\n\\n    def isSelfCrossing(self, x):\\n        return any(d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b)\\n                   for a, b, c, d, e, f in ((x[i:i+6] + [0] * 6)[:6]\\n                                            for i in xrange(len(x))))\\n\\n**Solution 2**\\n\\n    def isSelfCrossing(self, x):\\n        b = c = d = e = 0\\n        for a in x:\\n            if d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b):\\n                return True\\n            b, c, d, e, f = a, b, c, d, e\\n        return False\\n\\n**Explanation**\\n\\n                b                              b\\n       +----------------+             +----------------+\\n       |                |             |                |\\n       |                |             |                | a\\n     c |                |           c |                |\\n       |                | a           |                |    f\\n       +----------->    |             |                | <----+\\n                d       |             |                |      | e\\n                        |             |                       |\\n                                      +-----------------------+\\n                                                   d\\n\\nDraw a line of length `a`. Then draw further lines of lengths `b`, `c`, etc. How does the `a`-line get crossed? From the left by the `d`-line or from the right by the `f`-line, see the above picture. I just encoded the criteria for actually crossing it.\\n\\nTwo details:\\n\\n- In both cases, `d` needs to be at least `b`. In the first case to cross the `a`-line directly, and in the second case to get behind it so that the `f`-line can cross it. So I factored out `d >= b`.\\n- The \"special case\" of the `e`-line stabbing the `a`-line from below is covered because in that case, the `f`-line \"crosses\" it (note that even if there is no actual `f`-line, my code uses `f = 0` and thus still finds that \"crossing\")."
		},
		{
			"lc_ans_id":"79133",
			"view":"1795",
			"top":"4",
			"title":"C++ simple solution",
			"vote":"19",
			"content":"    class Solution\\n    {\\n    public:\\n        bool isSelfCrossing(vector<int>& x)\\n        {\\n            x.insert(x.begin(), 4, 0);\\n    \\n            int len = x.size();\\n            int i = 4;\\n    \\n            // outer spiral\\n            for (; i < len && x[i] > x[i - 2]; i++);\\n    \\n            if (i == len) return false;\\n    \\n            // check border\\n            if (x[i] >= x[i - 2] - x[i - 4])\\n            {\\n                x[i - 1] -= x[i - 3];\\n            }\\n    \\n            // inner spiral\\n            for (i++; i < len && x[i] < x[i - 2]; i++);\\n    \\n            return i != len;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"79142",
			"view":"1757",
			"top":"5",
			"title":"Java Solution based on spiral direction status",
			"vote":"11",
			"content":"I solved this problem based on spiral direction status. Here is the accepted code: \\n\\n \\tpublic static boolean isSelfCrossing(int[] x) {\\n\\t\\tif (x.length < 4)\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tboolean inside = false;\\n\\t\\tfor (int i = 3; i < x.length; i++) {\\n\\t\\t\\tif(inside) {\\n\\t\\t\\t\\tif (x[i] >= x[i - 2])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tif(x[i-1] > x[i-3])\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tint x5 = i>=5 ? x[i-5] : 0;\\n\\t\\t\\tint x4 = i>=4 ? x[i-4] : 0;\\n\\t\\t\\tif(x[i-1] >= x[i-3] - x5) {\\n\\t\\t\\t\\tif(x[i] >= x[i-2] - x4)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tif(x[i] >= x[i-2])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tinside=true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\nFor this question, to keep the line not crossed, it can be in following conditions: \\n\\n1. Keep spiraling outside.\\n2. Keep spiraling inside.\\n3. Not crossing during transition from outside spiral into inside spiral. \\n\\nAnd one observation is once it starts to spiral inside, it will never spiral outside.  \\n\\nBased on this observation, we keep one flag: inside which is initialized to false,\\n\\nDuring spiraling outside, and inside, the check is very simple: just check x[i] < x[i-2] for inside spiral. In outside spiral phase, as long as x[i-1] > x[i-3], it's not possible to cross in this step. \\n\\nOnce x[i-1] > x[i-3] condition is broken, we will trigger the transition period: In this period, it has two conditions, \\n\\n1. If this turn back line is towards line x[i-5] (possible cross x[i-5])\\n2. If this turn back line is not towards line x[i-5]. in that case, it will go towards x[i-3] instead. \\n\\nWe need to calculate the max line for x[i] for the two cases.\\n\\nWhen i<4 and i<5 corner case, to avoid many if/else we just prepend two additional steps as if they are moving 0 length. So assign x4 and x5 to 0 respectively.\\n\\nThis solution compare to other solution based on 3 different crossing condition, it's slight better as it will only look back x[i-4] and x[i-4] during transition period (once only). In other two phases, it will only compare two edges."
		},
		{
			"lc_ans_id":"79140",
			"view":"2325",
			"top":"6",
			"title":"Re-post: 2 O(N) C++ 0ms solutions",
			"vote":"10",
			"content":"The first solution is well described in [KuangYuan's post][1] and the idea is to enumerate all the self-crossing cases. Basically, there are three cases\\nCase1:  self-crossing is formed by the last 4 lines (like a closed rectangle)\\nCase 2: self-crossing is formed by the last 5 lines (still like a closed rectangle with one edge having two moves)\\nCase 3: self-crossing is formed by the last 6 lines (like two overlapped rectangles)\\n\\n    class Solution {\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            int len = x.size(),i;\\n            for(i=3; i<len;++i)\\n            {\\n                if(x[i]>=x[i-2] && x[i-1] <= x[i-3]) return true; // case 1, the consecutive four lines form a cross\\n                if(i>3 && x[i-1]==x[i-3] && x[i]+x[i-4]>=x[i-2]) return true; // case 2, the consecutive five lines form a cross\\n                if(i>4 && x[i-2]>=x[i-4] && x[i-4]+x[i]>=x[i-2] && x[i-1]<=x[i-3] && x[i-5] + x[i-1]>=x[i-3]) return true;// case 3, the consecutive six lines form a cross\\n            }\\n            return false;\\n        }\\n    };\\n\\nThe second solution is to categorize all the non-self-crossing cases: basically we can only have two valid cases: one is \"grow spiral\" (which means the curve expands like spiral and there is no boundaries in x and y axis) and the other is \"shrink spiral\" (which means the spiral curve becomes smaller and smaller and the boundaries in x and y axis are the last move in that direction). The self-crossing cases can only happen in the \"shrink\" case and it happens only when x[i]>=x[i-2]. The \"grow\" case can become a \"shrink\" case and that only happens when x[i]<=x[i-2]. The  \"shrink\" case can not change to a \"grow\" case.\\nIn the solution, we use a bool grow_spiral to indicate whether the current one is a \"grow spiral\". if before x[i], it is a  \"shrink spiral\", we only need to check if a self-crossing happen (i.e. x[i]>=x[i-2]); if it is a \"grow spiral\", we check if x[i] changes from \"grow\" to \"shrink\" (i.e. x[i]<=x[i-2]), we need to update the boundary x[i-1] (in some cases, it can be x[i-1]-x[i-3]). \\n\\n\\n    class Solution {\\n    public:\\n        bool isSelfCrossing(vector<int>& x) {\\n            int len = x.size(), i;\\n            if(len<=3) return false;\\n            bool grow_spiral;\\n\\n            for(i=3, grow_spiral = x[2]>x[0]; i<len;++i)\\n            {\\n                if(!grow_spiral && x[i]>=x[i-2]) return true;//if it is a \"shrink\" case before x[i] and cross happens\\n                if(grow_spiral && x[i]<=x[i-2])\\n                { // if it is a grow case, and x[i] changes it to shrink\\n                        grow_spiral = false;\\n                        x[i-1] = x[i] + (i>=4?x[i-4]:0)<x[i-2]? x[i-1]:x[i-1]-x[i-3];// update boundary\\n                }\\n            }\\n            return false;\\n        }\\n    };\\n\\nMy special thank goes to  hohomi for pointing out one bug in Solution 2 and I believe I fixed it.\\n\\n\\n  [1]: https://leetcode.com/discuss/88054/java-oms-with-explanation"
		},
		{
			"lc_ans_id":"79192",
			"view":"1706",
			"top":"7",
			"title":"Java O(N) O(1) 0ms solution with explanation",
			"vote":"8",
			"content":"There are only 3 scenarios where it won't cross itself.\\n\\n1. The distances of the moves parallel to each other keeps going up (growing spiral).\\n2. The distances of the moves parallel to each other keeps going down (shrinking spiral).\\n3. The distances of the moves parallel to each other first keeps going up, then keeps going down (shrinking spiral inside of the growing spiral), and never goes up.\\n\\nOur code just needs to check if there're any things violating the above rules.\\n\\nI feel there should be smarter approaches. Please reply as answer or comments. :P\\n\\n    public class Solution {\\n        public boolean isSelfCrossing(int[] x) {\\n            int a1, a2, a3, a4, a5;\\n            \\n            // if it's increasing\\n            boolean up = false;\\n            \\n            if (x.length < 4) {\\n                return false;\\n            }\\n            \\n            a1 = 0;\\n            a2 = x[0];\\n            a3 = x[1];\\n            a4 = x[2];\\n            \\n            if (a2 < a4) {\\n                up = true;\\n            }\\n            else {\\n                up = false;\\n            }\\n            \\n            for (int i = 3; i < x.length; i++) {\\n                a5 = x[i];\\n                \\n                if (!up && a5 >= a3) {\\n                    return true;\\n                }\\n                else if (up && a5 <= a3) {\\n                    // succeeded in turning into decreasing\\n                    if (a5 + a1 < a3 || (i + 1 < x.length && x[i + 1] + a2 < a4)) {\\n                        up = false;\\n                    }\\n                    // not end yet\\n                    else if (i + 1 < x.length) {\\n                        return true;\\n                    }\\n                }\\n                \\n                a1 = a2;\\n                a2 = a3;\\n                a3 = a4;\\n                a4 = a5;\\n            }\\n            \\n            return false;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"79159",
			"view":"942",
			"top":"8",
			"title":"An ASCII Art Explanation of This Problem and My C Solution",
			"vote":"5",
			"content":"    //           =   a l l    c a s e s   =\\n    // \\n    //     case 1     case 2: expanding   case 3: collapsing\\n    //                     (global)           (local)\\n    //                  (not crossing)   (may not crossing)\\n    // \\n    //    <------+     +------------+      +---------+\\n    //           |     |            |      |         |\\n    //           |     |  +-----+   |      |  +---+  |\\n    //           |     |  |     |   |      |  |   |  :\\n    //           #     |  |     #   |      |  v   |  :\\n    //                 |  |         |      |      |  \\n    //                 |  +---------+      +------+  \\n    //                 |\\n    //                 +--------->\\n    // \\n    //     case 4: failed expanding                \\n    //      \\n    //      +----+\\n    //      |    |\\n    //      |  <----[2]----^     [2]: second failure\\n    //      |    #         |\\n    //      |             [1]    [1]: first  failure\\n    //      |              |\\n    //      +--------------+\\n    // \\n    //     case 5: failed expanding & then collapsing\\n    // \\n    //      +----+\\n    //      |    |\\n    //      |    |  +------+\\n    //      |    #  | [C]  |     [C]: may be perfectly collapsed\\n    //      |       +--->  |\\n    //      |              |\\n    //      +--------------+\\n    // \\n    //     case 6: failed expanding                \\n    // \\n    //         +---+\\n    //         |   |\\n    //         |   |\\n    //         |   #\\n    //         |\\n    //       <---[2]----+        [2]: second failure\\n    //         |        |\\n    //         |       [1]       [1]: first  failure\\n    //         |        |\\n    //         +--------+\\n    // \\n    //     case 7: failed expanding & then collapsing\\n    // \\n    //         +------+\\n    //         |      |\\n    //         |      #\\n    //         |\\n    //         |  +-----------+\\n    //         |  |  +-----+  |\\n    //         |  |  +-->  | [1] [1]: failure\\n    //         |  |        |  |\\n    //         |  +--------+  |\\n    //         +--------------+\\n    // \\n    //    *notice: case 3 = case 6 + case 7\\n    // \\n    //     case 8: docking!\\n    // \\n    //         +-------+\\n    //         |       |\\n    //         |       #\\n    //         |\\n    //         |       ^\\n    //         |       |\\n    //         +-------+\\n    // \\n    // #: starting point \\n    \\n    // case 3\\n    bool isPerfectCollapsing( int cur, int len, int *data )\\n    {\\n        while ( cur < len ) {\\n            if ( data[cur] < data[cur-2] ) {\\n                ++cur;\\n            } else { return false; }\\n        }\\n        return true;\\n    }\\n    \\n    bool isPerfect( int *data, int len )\\n    {\\n        // case 1\\n        if ( len <= 2 ) { return true; }\\n        // case 8\\n        if ( len >= 5 &&\\n             data[3]==data[1] &&\\n             data[2]<=data[0]+data[4] )\\n        {\\n            return false;\\n        }\\n    \\n        int cur = 2;\\n        while ( cur < len && data[cur] > data[cur-2] ) {\\n            ++cur;\\n        }\\n        if ( cur == len || cur == len-1 ) {\\n            // case 2: perfect expanding\\n            return true;\\n        }\\n    \\n        // collapsed!\\n        if ( cur == 2 || cur == 3 ) {\\n            // case 3\\n            return isPerfectCollapsing( ++cur, len, data );\\n        }\\n    \\n        if ( data[cur]+data[cur-4] >= data[cur-2] ) {                    // case 4/5\\n            if ( ++cur < len ) {\\n                if ( data[cur]+data[cur-4] >= data[cur-2] ) {            // case 4\\n                    return false;\\n                } else { return isPerfectCollapsing(++cur, len, data); } // case 5\\n            } else { return true; }\\n        } else { return isPerfectCollapsing(++cur, len, data); }         // case 6/7\\n    }\\n    \\n    bool isSelfCrossing( int *x, int xSize ) {\\n        return !isPerfect( x, xSize );\\n    }"
		},
		{
			"lc_ans_id":"79160",
			"view":"1161",
			"top":"9",
			"title":"5 lines cpp code with clear logic",
			"vote":"4",
			"content":"Basic observations:\\n1. No crossing is produced when the path keeps going either 'inward' or 'outward'.\\n2. A path without crossing is either one of the two above cases or a combination of both (an outward path transit into an inward path).\\n\\n    class Solution {\\n    public:\\n       bool isSelfCrossing(std::vector<int>& x) {\\n          // started 'outside', walk until 'inside' a rectangle\\n          int i; for(i=2; i<x.size()&&x[i]>x[i-2]; i++);\\n          // out->in transition step\\n          if( i>2 && x[i] >= x[i-2]-(i==3?0:x[i-4]) ) x[i-1] -= x[i-3];\\n          // we are inside a rectangle now, check for crossing\\n          for(i++; i<x.size()&&x[i]<x[i-2]; i++);\\n          // crossing detected if end is not reached\\n          return i<x.size();\\n       }\\n    };"
		}
	],
	"id":"335",
	"title":"Self Crossing",
	"content":"<p>\r\n    You are given an array <i>x</i> of <code>n</code> positive numbers. You start at point <code>(0,0)</code> and moves <code>x[0]</code> metres to the north, then <code>x[1]</code> metres to the west,\r\n    <code>x[2]</code> metres to the south,\r\n    <code>x[3]</code> metres to the east and so on. In other words, after each move your direction changes\r\n    counter-clockwise.\r\n</p>\r\n<p>\r\n    Write a one-pass algorithm with <code>O(1)</code> extra space to determine, if your path crosses itself, or not.\r\n</p>\r\n\r\n<p>\r\n<b>Example 1:</b><br/>\r\n<pre>\r\nGiven <i>x</i> = <code>[2, 1, 1, 2]</code>,\r\n?????\r\n?   ?\r\n???????>\r\n    ?\r\n\r\nReturn <b>true</b> (self crossing)\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Example 2:</b><br/>\r\n<pre>\r\nGiven <i>x</i> = <code>[1, 2, 3, 4]</code>,\r\n????????\r\n?      ?\r\n?\r\n?\r\n?????????????>\r\n\r\nReturn <b>false</b> (not self crossing)\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Example 3:</b><br/>\r\n<pre>\r\nGiven <i>x</i> = <code>[1, 1, 1, 1]</code>,\r\n?????\r\n?   ?\r\n?????>\r\n\r\nReturn <b>true</b> (self crossing)\r\n</pre>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/dietpepsi\">@dietpepsi</a> for adding this problem and creating all test cases.</p>",
	"frequency":"498",
	"ac_num":"15717"
}