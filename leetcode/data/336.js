{
	"difficulty":"3",
	"submit_num":"128473",
	"show_id":"336",
	"leetcode_id":"336",
	"answers":[
		{
			"lc_ans_id":"79199",
			"view":"31498",
			"top":"0",
			"title":"150 ms 45 lines JAVA solution",
			"vote":"148",
			"content":"    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> ret = new ArrayList<>(); \\n        if (words == null || words.length < 2) return ret;\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        for (int i=0; i<words.length; i++) map.put(words[i], i);\\n        for (int i=0; i<words.length; i++) {\\n            // System.out.println(words[i]);\\n            for (int j=0; j<=words[i].length(); j++) { // notice it should be \"j <= words[i].length()\"\\n                String str1 = words[i].substring(0, j);\\n                String str2 = words[i].substring(j);\\n                if (isPalindrome(str1)) {\\n                    String str2rvs = new StringBuilder(str2).reverse().toString();\\n                    if (map.containsKey(str2rvs) && map.get(str2rvs) != i) {\\n                        List<Integer> list = new ArrayList<Integer>();\\n                        list.add(map.get(str2rvs));\\n                        list.add(i);\\n                        ret.add(list);\\n                        // System.out.printf(\"isPal(str1): %s\\\\n\", list.toString());\\n                    }\\n                }\\n                if (isPalindrome(str2)) {\\n                    String str1rvs = new StringBuilder(str1).reverse().toString();\\n                    // check \"str.length() != 0\" to avoid duplicates\\n                    if (map.containsKey(str1rvs) && map.get(str1rvs) != i && str2.length()!=0) { \\n                        List<Integer> list = new ArrayList<Integer>();\\n                        list.add(i);\\n                        list.add(map.get(str1rvs));\\n                        ret.add(list);\\n                        // System.out.printf(\"isPal(str2): %s\\\\n\", list.toString());\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    private boolean isPalindrome(String str) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left <= right) {\\n            if (str.charAt(left++) !=  str.charAt(right--)) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n1. The `<=` in `for (int j=0; j<=words[i].length(); j++)` is aimed to handle empty string in the input. Consider the test case of [\"a\", \"\"];\\n\\n2.  Since we now use `<=` in `for (int j=0; j<=words[i].length(); j++)` instead of `<`. There may be duplicates in the output (consider test case [\"abcd\", \"dcba\"]). Therefore I put a `str2.length()!=0` to avoid duplicates.\\n\\n\\n\\nAnother way to avoid duplicates is to use `Set<List<Integer>> ret = new HashSet<>();` and return `new ArrayList<>(ret);`"
		},
		{
			"lc_ans_id":"79195",
			"view":"25591",
			"top":"1",
			"title":"O(n*k^2) java solution with Trie structure (n: total number of words; k: average length of each word)",
			"vote":"130",
			"content":"Apparently there is a `O(n^2*k)` naive solution for this problem, with n the total number of words in the \"words\" array and k the average length of each word: \\n\\n**For each word, we simply go through the `words` array and check whether the concatenated string is a palindrome or not.** \\n\\nOf course this will result in `TLE` as expected. To improve the algorithm, we need to reduce the number of words that is needed to check for each word, instead of iterating through the whole array. This prompted me to think if I can extract any useful information out of the process of checking whether the concatenated string is a palindrome, so that it can help eliminate as many words as possible for the rest of the `words` array. \\n\\nTo begin, here is the technique I employed to check for palindromes: maintain two pointers `i` and `j`, with `i` pointing to the start of the string and `j` to the end of the string. Characters pointed by `i` and `j` are compared. If at any time the characters pointed by them are not the same, we conclude the string is not a palindrome. Otherwise we move the two pointers towards each other until they meet in the middle and the string is a palindrome.\\n\\nBy examining the process above, I do find something that we may take advantage of to get rid of words that need to be checked otherwise. For example, let's say we want to append words to `w0`, which starts with character `'a'`. Then we only need to consider words ending with character `'a'`, i.e., this will single out all words ending with character `'a'`. If the second character of `w0` is `'b'` for instance, we can further reduce our candidate set to words ending with string `\"ba\"`, etc. Our naive solution throws away all this \"useful\" information and repeats the comparison, which leads to the undesired `O(n^2*k)` time complexity.\\n\\nIn order to exploit the information gathered so far, we obviously need to restructure all the words in the `words` array. If you are familiar with Trie structure (I believe you are, since LeetCode has problems for it. In case you are not, see [Trie](https://en.wikipedia.org/wiki/Trie)), it will come to mind as we need to deal with words with common suffixes. The next step is to design the structure for each Trie node. There are at least two fields that should be covered for each TrieNode: a TrieNode array denoting the next layer of nodes and a boolean (or integer) to signify the end of a word. So our tentative TrieNode will look like this:\\n\\n```\\nclass TrieNode {\\n    TrieNode[] next;\\n    boolean isWord;\\n}\\n```\\nOne point here is that we assume all the words contain lowercase letters only. This is not specified in the problem statement so you probably need to confirm with the interviewer (here I assume it is the case)\\n\\nNow we will rearrange each word into this Trie structure: for each word, simply starting from its last character and identify the node at the next layer by indexing into root's `next` array with index given by the difference between the ending character and character `'a'`. If the indexed node is null, create a new node.  Continue to the next layer and towards the beginning of the word in this manner until we are done with the word, at which point we will label the `isWord` field of the final node as true.\\n\\nAfter building up the Trie structure, we can proceed to search for pairs of palindromes for each word in the `words` array. I will use the following example to explain how it works and make possible modifications of the TrieNode we proposed above.\\n\\nLet's say we have these words: `[\"ba\", \"a\", \"aaa\"]`, the Trie structure will be as follows:\\n\\n            root (f)\\n               | 'a'\\n              n1 (t)\\n         ------------\\n     'b' |          | 'a'\\n        n2 (t)    n3 (f)\\n                    | 'a'\\n                  n4 (t)\\n The letter in parentheses indicates the value of `isWord` for each node: `f ==> false` and `t ==> true`. The letter beside each vertical line denotes the index into the `next` array of the corresponding node. For example, for the first vertical line, `'a'` means `root.next[0]` is not null. Similarly `'b'` means `n1.next[1]` is not null, and so on.\\n\\nHere is the searching process: \\n\\n 1. For word `\"ba\"`, starting from the first character `'b'`, index into the root.next array with index given by `'b' - 'a' = 1`. The corresponding node is null, then we know there are no words ending at this character, so the searching process is terminated;\\n 2. For word `\"a\"`, again indexing into array root.next at index given by `'a' - 'a' = 0` will yield node `n1`, which is not null. We then check the value of `n1.isWord`. If it is true, then it is possible to obtain a palindrome by appending this word to the one currently being examined (a.k.a word `\"a\"`). Also note that the two words should be distinct, but the `n1.isWord` field provides no information about the word itself, which makes it impossible to distinguish the two words. So it is necessary to modify the structure of the TrieNode so that we can identify the word it represents. One easy way is to have an integer field to remember the index of the word in the `words` array. For non-word nodes, this integer will take negative values (`-1` for example) while for those representing a word, it will be non-negative values. Suppose we have made this modification, then the two words will be identified to be the same, so we discard this pair combination. Since the word `\"a\"` has only one letter, it seems we are done with it. Or do we? Not really. What if there are words with suffix `\"a\"` (`\"aaa\"` in this case)? We need to continue to check the rest part of these words (such as `\"aa\"` for the word `\"aaa\"`) and see if the rest forms a palindrome. If it is, then appending this word (`\"aaa\"` in this case) to the original word (`\"a\"`) will also form a palindrome (`\"aaaa\"`). Here I take another strategy: add an integer list to each TrieNode; the list will record the indices of all words satisfying the following two conditions: each word has a suffix represented by the current Trie node; the rest of the word forms a palindrome.\\n\\nBefore I get to the third word `\"aaa\"`, let me spell out the new TrieNode and the corresponding Trie structure for the above array.\\n\\n`TrieNode:`\\n\\n```\\nclass TrieNode {\\n    TrieNode[] next;\\n    int index;\\n    List<Integer> list;\\n            \\n    TrieNode() {\\n        next = new TrieNode[26];\\n        index = -1;\\n        list = new ArrayList<>();\\n    }\\n}\\n```\\n\\n`Trie structure:`\\n\\n              root (-1,[1,2])\\n                | 'a'\\n              n1 (1,[0,1,2])\\n        ---------------------\\n    'b' |                 | 'a'\\n      n2 (0,[0])    n3 (-1,[2])\\n                          | 'a'\\n                     n4 (2,[2])\\n\\nThe first integer in the parentheses is the index of the word in the `words\"` array (defaulted to `-1`). The integers in the square bracket are the indices of words satisfying the two conditions mentioned above.\\n\\nLet's continue with the third word `\"aaa\"` with this new structure. Indexing into array `root.next` at index given by `'a' - 'a' = 0` will yield node `n1` and `n1.index = 1 >= 0`, which means we have a valid word now. The index of this word (which is `1`) is also different from the index of the word currently being visited, a.k.a `\"aaa\"` (which is `2`). So pair `(2,1)` is a possible concatenation to form a palindrome. But still we need to check the rest of `\"aaa\"` (excluding the substring represented by current node `n1` which is `\"a\"` from the beginning of `\"aaa\"`) to see if it is a palindrome. If so, `(2,1)` will be a valid combination. We continue in this fashion until we reach the end of `\"aaa\"`. Lastly we will check `n4.list` to see if there are any words satisfying the two conditions specified in `step 2` which are different from current word, and add the corresponding valid pairs.\\n\\nBoth building and searching the Trie structure take `O(n*k^2)`, which sets the total time complexity of the solution. Here is the complete Java program:\\n\\n```\\nprivate static class TrieNode {\\n    TrieNode[] next;\\n    int index;\\n    List<Integer> list;\\n    \\t\\n    TrieNode() {\\n    \\tnext = new TrieNode[26];\\n    \\tindex = -1;\\n    \\tlist = new ArrayList<>();\\n    }\\n}\\n    \\npublic List<List<Integer>> palindromePairs(String[] words) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    TrieNode root = new TrieNode();\\n    for (int i = 0; i < words.length; i++) addWord(root, words[i], i);\\n    for (int i = 0; i < words.length; i++) search(words, i, root, res);\\n    \\n    return res;\\n}\\n    \\nprivate void addWord(TrieNode root, String word, int index) {\\n    for (int i = word.length() - 1; i >= 0; i--) {\\n        int j = word.charAt(i) - 'a';\\n    \\tif (root.next[j] == null) root.next[j] = new TrieNode();\\n    \\tif (isPalindrome(word, 0, i)) root.list.add(index);\\n    \\troot = root.next[j];\\n    }\\n    \\t\\n    root.list.add(index);\\n    root.index = index;\\n}\\n    \\nprivate void search(String[] words, int i, TrieNode root, List<List<Integer>> res) {\\n    for (int j = 0; j < words[i].length(); j++) {\\t\\n    \\tif (root.index >= 0 && root.index != i && isPalindrome(words[i], j, words[i].length() - 1)) {\\n    \\t    res.add(Arrays.asList(i, root.index));\\n    \\t}\\n    \\t\\t\\n    \\troot = root.next[words[i].charAt(j) - 'a'];\\n      \\tif (root == null) return;\\n    }\\n    \\t\\n    for (int j : root.list) {\\n    \\tif (i == j) continue;\\n    \\tres.add(Arrays.asList(i, j));\\n    }\\n}\\n    \\nprivate boolean isPalindrome(String word, int i, int j) {\\n    while (i < j) {\\n    \\tif (word.charAt(i++) != word.charAt(j--)) return false;\\n    }\\n    \\t\\n    return true;\\n}\\n```\\n\\nWe have the TrieNode structure at the top. In the `palindromePairs` function, we build up the Trie by adding each word, then searching for valid pairs for each word and record the results in the `res` list. The last `isPalindrome` function checks if the substring `[i, j]` (both inclusive) of the given word is a palindrome."
		},
		{
			"lc_ans_id":"79215",
			"view":"11706",
			"top":"2",
			"title":"Easy to understand AC C++ solution O(n*k^2) using map",
			"vote":"47",
			"content":"**Assumption**: No duplicated string in the given dictionary\\n\\n**Steps:**\\n\\n1. Traverse the array, build map. Key is the reversed string, value is index in array (0 based)\\n\\n2. Edge case - check if empty string exists. It's interesting that for given words {\"a\", \"\"}, it's expected to return two results [0,1] and [1,0]. Since my main logic can cover [0, 1] concatenate(\"a\", \"\"), so as to cover the other situation concatenate(\"\", \"a\"), I need to traverse the words array again, find the palindrome word candidate **except** \"\" itself, and add pair(\"\", palindrome word) to the final answer.\\n\\n3. Main logic part. Partition the word into left and right, and see 1) if there exists a candidate in map equals the left side of current word, and right side of current word is palindrome, so concatenate(current word, candidate) forms a pair: **left** | right | **candidate**. 2) same for checking the right side of current word: **candidate** | left | **right**.\\n\\n\\n\\n        class Solution {\\n        public:\\n            vector<vector<int>> palindromePairs(vector<string>& words) {\\n                unordered_map<string, int> dict;\\n                vector<vector<int>> ans;\\n                // build dictionary\\n                for(int i = 0; i < words.size(); i++) {\\n                    string key = words[i];\\n                    reverse(key.begin(), key.end());\\n                    dict[key] = i;\\n                }\\n                // edge case: if empty string \"\" exists, find all palindromes to become pairs (\"\", self)\\n                if(dict.find(\"\")!=dict.end()){\\n                    for(int i = 0; i < words.size(); i++){\\n                        if(i == dict[\"\"]) continue;\\n                        if(isPalindrome(words[i])) ans.push_back({dict[\"\"], i}); // 1) if self is palindrome, here ans covers concatenate(\"\", self) \\n                    }\\n                }\\n\\n                for(int i = 0; i < words.size(); i++) {\\n                    for(int j = 0; j < words[i].size(); j++) {\\n                        string left = words[i].substr(0, j);\\n                        string right = words[i].substr(j, words[i].size() - j);\\n\\n                        if(dict.find(left) != dict.end() && isPalindrome(right) && dict[left] != i) {\\n                            ans.push_back({i, dict[left]});     // 2) when j = 0, left = \"\", right = self, so here covers concatenate(self, \"\")\\n                        }\\n\\n                        if(dict.find(right) != dict.end() && isPalindrome(left) && dict[right] != i) {\\n                            ans.push_back({dict[right], i});\\n                        }\\n                    }\\n                }\\n\\n                return ans;        \\n            }\\n\\n            bool isPalindrome(string str){\\n                int i = 0;\\n                int j = str.size() - 1; \\n\\n                while(i < j) {\\n                    if(str[i++] != str[j--]) return false;\\n                }\\n\\n                return true;\\n            }\\n\\n        };"
		},
		{
			"lc_ans_id":"79210",
			"view":"11293",
			"top":"3",
			"title":"The Easy-to-unserstand JAVA Solution",
			"vote":"46",
			"content":"There are several cases to be considered that isPalindrome(s1 + s2):\\n\\nCase1: If s1 is a blank string, then for any string that is palindrome s2, s1+s2 and s2+s1 are palindrome.\\n\\nCase 2: If s2 is the reversing string of s1, then s1+s2 and s2+s1 are palindrome.\\n\\nCase 3: If s1[0:cut] is palindrome and there exists s2 is the reversing string of s1[cut+1:] , then s2+s1 is palindrome.\\n\\nCase 4: Similiar to case3. If s1[cut+1: ] is palindrome and there exists s2 is the reversing string of s1[0:cut] , then s1+s2 is palindrome.\\n\\nTo make the search faster, build a HashMap to store the String-idx pairs.\\n\\nMy code:\\n\\n    public class Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(words == null || words.length == 0){\\n            return res;\\n        }\\n        //build the map save the key-val pairs: String - idx\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < words.length; i++){\\n            map.put(words[i], i);\\n        }\\n        \\n        //special cases: \"\" can be combine with any palindrome string\\n        if(map.containsKey(\"\")){\\n            int blankIdx = map.get(\"\");\\n            for(int i = 0; i < words.length; i++){\\n                if(isPalindrome(words[i])){\\n                    if(i == blankIdx) continue;\\n                    res.add(Arrays.asList(blankIdx, i));\\n                    res.add(Arrays.asList(i, blankIdx));\\n                }\\n            }\\n        }\\n        \\n        //find all string and reverse string pairs\\n        for(int i = 0; i < words.length; i++){\\n            String cur_r = reverseStr(words[i]);\\n            if(map.containsKey(cur_r)){\\n                int found = map.get(cur_r);\\n                if(found == i) continue;\\n                res.add(Arrays.asList(i, found));\\n            }\\n        }\\n        \\n        //find the pair s1, s2 that \\n        //case1 : s1[0:cut] is palindrome and s1[cut+1:] = reverse(s2) => (s2, s1)\\n        //case2 : s1[cut+1:] is palindrome and s1[0:cut] = reverse(s2) => (s1, s2)\\n        for(int i = 0; i < words.length; i++){\\n            String cur = words[i];\\n            for(int cut = 1; cut < cur.length(); cut++){\\n                if(isPalindrome(cur.substring(0, cut))){\\n                    String cut_r = reverseStr(cur.substring(cut));\\n                    if(map.containsKey(cut_r)){\\n                        int found = map.get(cut_r);\\n                        if(found == i) continue;\\n                        res.add(Arrays.asList(found, i));\\n                    }\\n                }\\n                if(isPalindrome(cur.substring(cut))){\\n                    String cut_r = reverseStr(cur.substring(0, cut));\\n                    if(map.containsKey(cut_r)){\\n                        int found = map.get(cut_r);\\n                        if(found == i) continue;\\n                        res.add(Arrays.asList(i, found));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public String reverseStr(String str){\\n        StringBuilder sb= new StringBuilder(str);\\n        return sb.reverse().toString();\\n    }\\n    \\n    public boolean isPalindrome(String s){\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while(i <= j){\\n            if(s.charAt(i) != s.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}"
		},
		{
			"lc_ans_id":"79217",
			"view":"8800",
			"top":"4",
			"title":"Accepted short Java solution using HashMap",
			"vote":"34",
			"content":"\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> pairs = new LinkedList<>();\\n        if (words == null) return pairs;\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < words.length; ++ i) map.put(words[i], i);\\n        for (int i = 0; i < words.length; ++ i) {\\n            int l = 0, r = 0;\\n            while (l <= r) {\\n                String s = words[i].substring(l, r);\\n                Integer j = map.get(new StringBuilder(s).reverse().toString());\\n                if (j != null && i != j && isPalindrome(words[i].substring(l == 0 ? r : 0, l == 0 ? words[i].length() : l)))\\n                    pairs.add(Arrays.asList(l == 0 ? new Integer[]{i, j} : new Integer[]{j, i}));\\n                if (r < words[i].length()) ++r;\\n                else ++l;\\n            }\\n        }\\n        return pairs;\\n    }\\n    \\n    private boolean isPalindrome(String s) {\\n        for (int i = 0; i < s.length()/2; ++ i)\\n            if (s.charAt(i) != s.charAt(s.length()-1-i))\\n                return false;\\n        return true;\\n    }"
		},
		{
			"lc_ans_id":"79209",
			"view":"1838",
			"top":"5",
			"title":"Accepted Python Solution With Explanation",
			"vote":"29",
			"content":"The basic idea is to check each word for prefixes (and suffixes) that are themselves palindromes.  If you find a prefix that is a valid palindrome, then the suffix reversed can be paired with the word in order to make a palindrome.  It's better explained with an example.\\n\\n    words = [\"bot\", \"t\", \"to\"]\\n\\nStarting with the string \"bot\".  We start checking all prefixes.  If `\"\", \"b\", \"bo\", \"bot\"` are themselves palindromes.  The empty string and \"b\" are palindromes.  We work with the corresponding suffixes (\"bot\", \"ot\") and check to see if their reverses (\"tob\", \"to\") are present in our initial word list.  If so (like the word to\"to\"), we have found a valid pairing where the reversed suffix can be **prepended** to the current word in order to form \"to\" + \"bot\" = \"tobot\".\\n\\nYou can do the same thing by checking all suffixes to see if they are palindromes.  If so, then finding all reversed prefixes will give you the words that can be **appended** to the current word to form a palindrome.\\n\\nThe process is then repeated for every word in the list.  Note that when considering suffixes, we explicitly leave out the empty string to avoid counting duplicates.  That is, if a palindrome can be created by appending an entire other word to the current word, then we will already consider such a palindrome when considering the empty string as prefix for the other word.  \\n\\n        def is_palindrome(check):\\n            return check == check[::-1]\\n    \\n        words = {word: i for i, word in enumerate(words)}\\n        valid_pals = []\\n        for word, k in words.iteritems():\\n            n = len(word)\\n            for j in range(n+1):\\n                pref = word[:j]\\n                suf = word[j:]\\n                if is_palindrome(pref):\\n                    back = suf[::-1]\\n                    if back != word and back in words:\\n                        valid_pals.append([words[back],  k])\\n                if j != n and is_palindrome(suf):\\n                    back = pref[::-1]\\n                    if back != word and back in words:\\n                        valid_pals.append([k, words[back]])\\n        return valid_pals"
		},
		{
			"lc_ans_id":"79219",
			"view":"5530",
			"top":"6",
			"title":"Python solution~",
			"vote":"23",
			"content":"        wordict = {}\\n        res = [] \\n        for i in range(len(words)):\\n            wordict[words[i]] = i\\n        for i in range(len(words)):\\n            for j in range(len(words[i])+1):\\n                tmp1 = words[i][:j]\\n                tmp2 = words[i][j:]\\n                if tmp1[::-1] in wordict and wordict[tmp1[::-1]]!=i and tmp2 == tmp2[::-1]:\\n                    res.append([i,wordict[tmp1[::-1]]])\\n                if j!=0 and tmp2[::-1] in wordict and wordict[tmp2[::-1]]!=i and tmp1 == tmp1[::-1]:\\n                    res.append([wordict[tmp2[::-1]],i])\\n                    \\n        return res"
		},
		{
			"lc_ans_id":"79292",
			"view":"1610",
			"top":"7",
			"title":"Problem statement needs improvement",
			"vote":"13",
			"content":"There is no requirement that states i and j should be different  in (i, j) pairs.\\nSo in example 2 (3, 3) should lead to 'ss' which is a palindrome.\\nProblem statement should be corrected as:\\n\\n Find all pairs of ***distinct*** indices (i, j) in the given list, so that"
		},
		{
			"lc_ans_id":"79202",
			"view":"1615",
			"top":"8",
			"title":"Clean C++ implementation",
			"vote":"10",
			"content":"```\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> result;\\n        unordered_map<string, int> dict;\\n        for(int i = 0; i < words.size(); i++) {\\n            dict[words[i]] = i;\\n        }\\n        for(int i = 0; i < words.size(); i++) {\\n            for(int j = 0; j <= words[i].length(); j++) {\\n                //check the suffix word\\n                if(is_palindrome(words[i], j, words[i].size() - 1)) {\\n                    /** the suffix word can be null to all the word **/\\n                    string suffix = words[i].substr(0, j);\\n                    reverse(suffix.begin(), suffix.end());\\n                    if(dict.find(suffix) != dict.end() && i != dict[suffix]) {\\n                        result.push_back({i, dict[suffix]});\\n                    }\\n                }\\n                //check the prefix word \\n                if(j > 0 && is_palindrome(words[i], 0, j - 1)) {\\n                    string prefix = words[i].substr(j);\\n                    reverse(prefix.begin(), prefix.end());\\n                    if(dict.find(prefix) != dict.end() && dict[prefix] != i) {\\n                        result.push_back({dict[prefix], i});\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    bool is_palindrome(string& s, int start, int end) {\\n        while(start < end) {\\n            if(s[start++] != s[end--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};"
		},
		{
			"lc_ans_id":"79254",
			"view":"1916",
			"top":"9",
			"title":"Java naive 154 ms O(nk^2 + r) and 126 ms O(nk + r) Manacher + suffixes/prefixes",
			"vote":"7",
			"content":"**Added: a (not so) naive solution**\\n\\nIf two concatenated words form a palindrome, then there are three cases to consider:\\n\\n    +---s1---+---s2--+     +---s1---+-s2-+    +-s1-+---s2---+\\n    |abcdefgh|hgfedcba|    |abcdxyyx|dcba|    |abcd|xyyxdcba|\\n\\nCase 1 is when one string is a mirror image of another. Case 2 is when the first string is longer than the other and consists of the mirror image of the other (prefix) and a palindrome (suffix). Case 3 is a mirror image of case 2. Case 1 can also be considered a special subcase of either case 2 or case 3 with an empty palindrome suffix/prefix.\\n\\nOf these three, case 1 is definitely the easiest because we just need to look up a word in a reverse string-to-index map (words are unique, so no multimaps needed). If we iterate over the list with `s1` as the current string, then case 2 is also much easier than case 3 because when we locate a prefix/palindrome split inside `s1` we just need to look up for the reversed prefix in the map.\\n\\nCase 3 is trickier, but we can get rid of case 3 altogether if we just make another run with the reversed words! This way case 3 turns into case 2. We only need to consider case 1 in one of these runs in order to avoid duplicate combinations. With that in mind, I present the following 154 ms solution:\\n\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        Map<String, Integer> index = new HashMap<>();\\n        Map<String, Integer> revIndex = new HashMap<>();\\n        String[] revWords = new String[words.length];\\n        for (int i = 0; i < words.length; ++i) {\\n            String s = words[i];\\n            String r = new StringBuilder(s).reverse().toString();\\n            index.put(s, i);\\n            revIndex.put(r, i);\\n            revWords[i] = r;\\n        }\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.addAll(findPairs(words, revWords, revIndex, false));\\n        result.addAll(findPairs(revWords, words, index, true));\\n        return result;\\n    }\\n    \\n    private static List<List<Integer>> findPairs(String[] words, String[] revWords, Map<String, Integer> revIndex, boolean reverse) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; ++i) {\\n            String s = words[i];\\n            for (int k = reverse ? 1 : 0; k <= s.length(); ++k) { // check suffixes, <= because we allow empty words\\n                Integer j = revIndex.get(s.substring(k));\\n                if (j != null && j != i) { // reversed suffix is present in the words list\\n                    // check whether the prefix is a palindrome\\n                    if (s.regionMatches(0, revWords[i], s.length() - k, k)) {\\n                        result.add(reverse ? Arrays.asList(i, j) : Arrays.asList(j, i));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\nNow this was actually the third solution I came up with. The first one was really ugly because it considered all three cases separately. The second one is below.\\n\\n**The ugly optimized solution**\\n\\nAs in other solutions posted here, I used Manacher's algorithm to quickly determine whether some part of a string is a palindrome or not. That gets rid of one O(nk^2) part, where `k` is the average word length and `n` is the number of words.\\n\\nAnother part is numerous calls to `substring`, so my idea is to avoid copying a substring unless there's a good chance that it's actually present in the list. I do this by creating a kind of ad-hoc hash tables for both reversed and non-reversed words.\\n\\nWe start by iterating over the list of the words and compute hashes for both reversed and non-reversed words. However, because I later calculate hashes of *suffixes* on the fly, which means that I calculate them right-to-left, so it is kind of mixed up which hash is reversed and which is not.\\n\\nThen we just compute every suffix's hash and look up the matching words. Updating the hash as we go, we avoid O(nk^2) complexity and get O(nk) which is the best we can get since we *have* to analyze all words. To consider all cases, we do it twice, for reversed and non-reversed words.\\n\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        int bCount = Integer.highestOneBit(words.length - 1) << 1; // round up to power of 2\\n        List<Integer>[] buckets = new List[bCount];\\n        List<Integer>[] revBuckets = new List[bCount];\\n        String[] revWords = new String[words.length];\\n        for (int i = 0; i < words.length; ++i) {\\n            String s = words[i];\\n            String r = new StringBuilder(s).reverse().toString();\\n            revWords[i] = r;\\n            int h = 0, hrev = 0;\\n            for (int j = 0; j < s.length(); ++j) {\\n                h = h * 17 + r.charAt(j); // will compute hash for suffixes in reversed order\\n                hrev = hrev * 17 + s.charAt(j); // so here s and r are swapped\\n            }\\n            h = (h & Integer.MAX_VALUE) % buckets.length;\\n            hrev = (hrev & Integer.MAX_VALUE) % revBuckets.length;\\n            if (buckets[h] == null) {\\n                buckets[h] = new ArrayList<>();\\n            }\\n            buckets[h].add(i);\\n            if (revBuckets[hrev] == null) {\\n                revBuckets[hrev] = new ArrayList();\\n            }\\n            revBuckets[hrev].add(i);\\n        }\\n        for (int i = 0; i < words.length; ++i) {\\n            String s = words[i];\\n            int[] m = manacher(s);\\n            for (int j : findPairs(s, m, 0, revBuckets, revWords)) {\\n                if (i != j) {\\n                    result.add(Arrays.asList(j, i));\\n                }\\n            }\\n            s = revWords[i];\\n            for (int j = 0, k = m.length - 1; j < k; ++j, --k) {\\n                int tmp = m[j];\\n                m[j] = m[k];\\n                m[k] = tmp;\\n            }\\n            for (int j : findPairs(s, m, 1, buckets, words)) {\\n                if (i != j) {\\n                    result.add(Arrays.asList(i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private static List<Integer> findPairs(String s, int[] manacher, int end,\\n            List<Integer>[] buckets, String[] words) {\\n        List<Integer> pairs = new ArrayList<>();\\n        for (int i = s.length(), h = 0;; ) {\\n            assert i + manacher[i] <= 2 * i;\\n            if (i + manacher[i] == 2 * i) {\\n                List<Integer> bucket = buckets[(h & Integer.MAX_VALUE) % buckets.length];\\n                if (bucket != null) {\\n                    for (int j : bucket) {\\n                        if (s.length() - i == words[j].length() && s.regionMatches(i, words[j], 0, words[j].length())) {\\n                            pairs.add(j);\\n                        }\\n                    }\\n                }\\n            }\\n            if (--i < end) {\\n                break;\\n            }\\n            h = h * 17 + s.charAt(i);\\n        }\\n        return pairs;\\n    }\\n    \\n    private static int[] manacher(String s) {\\n        final int n = s.length() * 2 + 1;\\n        int[] p = new int[n];\\n        for (int i = 0, c = 0; i < n; ++i) {\\n            int r = c + p[c], il, ir;\\n            if (i > r) {\\n                il = i - 1;\\n                ir = i + 1;\\n            } else {\\n                int i2 = c - (i - c);\\n                if (i + p[i2] >= r) {\\n                    ir = r + 1;\\n                    il = i - (ir - i);\\n                    p[i] = r - i;\\n                } else {\\n                    p[i] = p[i2];\\n                    il = ir = -1; // skip the check\\n                }\\n            }\\n            while (il >= 0 && ir < n && ((il & 1) == 0 || s.charAt(il / 2) == s.charAt(ir / 2))) {\\n                ++p[i];\\n                --il;\\n                ++ir;\\n            }\\n            if (i + p[i] > r) {\\n                c = i;\\n            }\\n        }\\n        return p;\\n    }"
		}
	],
	"id":"336",
	"title":"Palindrome Pairs",
	"content":"<p>\r\n    Given a list of <b>unique</b> words, find all pairs of <b><i>distinct</i></b> indices <code>(i, j)</code> in the given list, so that the concatenation of the two words, i.e. <code>words[i] + words[j]</code> is a palindrome.\r\n</p>\r\n\r\n<p>\r\n    <b>Example 1:</b><br/>\r\n    Given <code>words</code> = <code>[\"bat\", \"tab\", \"cat\"]</code><br/>\r\n    Return <code>[[0, 1], [1, 0]]</code><br/>\r\n    The palindromes are <code>[\"battab\", \"tabbat\"]</code><br/>\r\n</p>\r\n<p>\r\n    <b>Example 2:</b><br/>\r\n    Given <code>words</code> = <code>[\"abcd\", \"dcba\", \"lls\", \"s\", \"sssll\"]</code><br/>\r\n    Return <code>[[0, 1], [1, 0], [3, 2], [2, 4]]</code><br/>\r\n    The palindromes are <code>[\"dcbaabcd\", \"abcddcba\", \"slls\", \"llssssll\"]</code><br/>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/discuss/user/dietpepsi\">@dietpepsi</a> for adding this problem and creating all test cases.</p>",
	"frequency":"466",
	"ac_num":"34659"
}