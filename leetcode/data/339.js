{
	"difficulty":"1",
	"submit_num":"49226",
	"show_id":"339",
	"leetcode_id":"339",
	"answers":[
		{
			"lc_ans_id":"79957",
			"view":"10993",
			"top":"0",
			"title":"2ms easy to understand java solution",
			"vote":"38",
			"content":"    public int depthSum(List<NestedInteger> nestedList) {\\n        return helper(nestedList, 1);\\n    }\\n\\n    private int helper(List<NestedInteger> list, int depth)\\n    {\\n        int ret = 0;\\n        for (NestedInteger e: list)\\n        {\\n            ret += e.isInteger()? e.getInteger() * depth: helper(e.getList(), depth + 1);\\n        }\\n        return ret;\\n    }"
		},
		{
			"lc_ans_id":"79933",
			"view":"4622",
			"top":"1",
			"title":"Java Solution: similar to tree level order traversal",
			"vote":"35",
			"content":"    public int depthSum(List<NestedInteger> nestedList) {\\n        if(nestedList == null){\\n            return 0;\\n        }\\n        \\n        int sum = 0;\\n        int level = 1;\\n        \\n        Queue<NestedInteger> queue = new LinkedList<NestedInteger>(nestedList);\\n        while(queue.size() > 0){\\n            int size = queue.size();\\n            \\n            for(int i = 0; i < size; i++){\\n                NestedInteger ni = queue.poll();\\n                \\n                if(ni.isInteger()){\\n                    sum += ni.getInteger() * level;\\n                }else{\\n                    queue.addAll(ni.getList());\\n                }\\n            }\\n            \\n            level++;\\n        }\\n        \\n        return sum;\\n    }"
		},
		{
			"lc_ans_id":"80012",
			"view":"2521",
			"top":"2",
			"title":"Simple Java iterative solution 10 lines",
			"vote":"9",
			"content":"Using BFS.\\n\\n    public class Solution {\\n        public int depthSum(List<NestedInteger> nestedList) {\\n            int level = 1, total = 0;\\n            while(nestedList.size() != 0){\\n                List<NestedInteger> next = new LinkedList<>();\\n                for(NestedInteger nInt : nestedList){\\n                    if(nInt.isInteger())\\n                        total += nInt.getInteger() * level;\\n                    else\\n                        next.addAll(nInt.getList());\\n                }\\n                level++;\\n                nestedList = next;\\n            }\\n            return total;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"79966",
			"view":"1557",
			"top":"3",
			"title":"Short Python BFS",
			"vote":"8",
			"content":"```python\\nclass Solution(object):\\n    def depthSum(self, nestedList):\\n        \"\"\"\\n        :type nestedList: List[NestedInteger]\\n        :rtype: int\\n        \"\"\"\\n        depth, ret = 1, 0\\n        while nestedList:\\n            ret += depth * sum([x.getInteger() for x in nestedList if x.isInteger()])\\n            nestedList = sum([x.getList() for x in nestedList if not x.isInteger()], [])\\n            depth += 1\\n        return ret\\n```"
		},
		{
			"lc_ans_id":"79965",
			"view":"2265",
			"top":"4",
			"title":"Python Iterative",
			"vote":"6",
			"content":"    class Solution(object):\\n        def depthSum(self, nestedList):\\n            \"\"\"\\n            :type nestedList: List[NestedInteger]\\n            :rtype: int\\n            \"\"\"\\n            if len(nestedList) == 0: return 0\\n            stack = []\\n            sum = 0\\n            for n in nestedList:\\n                stack.append((n, 1))\\n            while stack:\\n                next, d = stack.pop(0)\\n                if next.isInteger():\\n                   sum += d * next.getInteger()\\n                else:\\n                    for i in next.getList():\\n                        stack.append((i,d+1))\\n            return sum"
		},
		{
			"lc_ans_id":"79980",
			"view":"466",
			"top":"5",
			"title":"[JAVA] Clean Code with Explanations and Running Time [5 Solutions]",
			"vote":"4",
			"content":"<h3>[JAVA] Clean Code with Explanations and Running Time [5 Solutions]</h3>\\n<a href=https://ratchapong.com/algorithm-practice/leetcode/nested-list-weight-sum>Full Solutions and Explanations</a>\\n<h3><b>Solution 1</b></h3>\\n```\\npublic class Solution {\\n    public int depthSum(List<NestedInteger> nestedList) {\\n        return depthSum(nestedList, 1);\\n    }\\n\\n    public int depthSum(List<NestedInteger> nestedList, int level) {\\n        int sum = 0;\\n        if (nestedList != null) {\\n            for (NestedInteger list : nestedList) {\\n                if (list.isInteger()) {\\n                    sum = sum + list.getInteger() * level;\\n                } else {\\n                    sum = sum + depthSum(list.getList(), level + 1);\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\\n\\n<div class=\"margin-bottom-20\"><h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4><p>Uniform cost model is used as Cost Model, `|V|` is the total number of nested elements in the input list and `h` is the maximum depth of the nested list.</p><p><b>Time Complexity:</b><ul><li>Best Case `O(|V|)` : There is no best case scenario as each element needed to be evaluated and add to running sum.</li><li>Average Case `O(|V|)` : For all possible input the algorithm evaluate each nested element at least once.</li><li>Worst Case `O(|V|)` : There is no worst case as each element needed to be evaluated and add to running sum.</li></ul></p><p><b>Auxiliary Space:</b><ul><li>Best Case `O(1)` : Occurs when no element is nested hence no recursive call is made.</li><li>Average Case `O(h)` : On average the space required will be the depth of recursive call as stack frames need to be allocated.</li><li>Worst Case `O(|V|)` : Occurs when each nested element has only one nested element. For example, <code>[[[[[2]]]]]</code>. This is the worst case for 6 nested elements as each nested element will be kept in stack frame until <code>2</code> is reached.</li></ul></p></div><div class=\"margin-bottom-20\"><h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4><p><b>Approach:</b> General Depth First Search Discovery (Recursive)</p><p>This is a general DFS discovery algorithm using recursion. Note that this does not categorized into pre or post order. Depth and unpacked nested list are being passed to the next recursive call. Anytime, an integer is encountered, a value is evaluated and incremented to the stack's sum. The sum is then returned to the caller once the for loop ends. Since this is a tree, there is no need to keep track of visited nodes like general graph traversal.</p></div>\\n<hr>\\n\\n<h3><b>Solution 2</b></h3>\\n```\\npublic class Solution {\\n    public int depthSum(List<NestedInteger> nestedList) {\\n        return depthSum(nestedList, 0, 0);\\n    }\\n\\n    public int depthSum(List<NestedInteger> nestedList, int level, int value) {\\n        int sum = 0;\\n        sum += value * level;\\n        if (nestedList != null) {\\n            for (NestedInteger list : nestedList) {\\n                if (list.isInteger()) {\\n                    sum = sum + depthSum(null, level + 1, list.getInteger());\\n                } else {\\n                    sum = sum + depthSum(list.getList(), level + 1, 0);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n<div class=\"margin-bottom-20\"><h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4><p>Uniform cost model is used as Cost Model, `|V|` is the total number of nested elements in the input list and `h` is the maximum depth of the nested list.</p><p><b>Time Complexity:</b><ul><li>Best Case `O(|V|)` : There is no best case scenario as each element needed to be evaluated and add to running sum.</li><li>Average Case `O(|V|)` : For all possible input the algorithm evaluate each nested element at least once.</li><li>Worst Case `O(|V|)` : There is no worst case as each element needed to be evaluated and add to running sum.</li></ul></p><p><b>Auxiliary Space:</b><ul><li>Best Case `O(1)` : Occurs when no element is nested hence no recursive call is made.</li><li>Average Case `O(h)` : On average the space required will be the depth of recursive call as stack frames need to be allocated.</li><li>Worst Case `O(|V|)` : Occurs when each nested element has only one nested element. For example, <code>[[[[[2]]]]]</code>. This is the worst case for 6 nested elements as each nested element will be kept in stack frame until <code>2</code> is reached.</li></ul></p></div><div class=\"margin-bottom-20\"><h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4><p><b>Approach:</b> Pre-order Tree Traversal (Recursive)</p><p>Pre-order tree traversal is achieved by explicitly visiting every node and processing it <em>before</em> traversal. Depth and unpacked nested list are being passed to the next recursive call. Anytime, an integer is encountered, a value is passed to the callee. The sum is then returned to the caller once the for loop ends. Since this is a tree, there is no need to keep track of visited nodes like general graph traversal. This example is used to explicitly show Pre-order tree traversal. There is no practical advantage for using this type of traversal.</p></div>\\n<hr>\\n\\n<h3><b>Solution 3</b></h3>\\n```\\npublic class Solution {\\n    public int depthSum(List<NestedInteger> nestedList) {\\n        return depthSum(nestedList, 0, 0);\\n    }\\n\\n    public int depthSum(List<NestedInteger> nestedList, int level, int value) {\\n        int sum = 0;\\n        if (nestedList != null) {\\n            for (NestedInteger list : nestedList) {\\n                if (list.isInteger()) {\\n                    sum = sum + depthSum(null, level + 1, list.getInteger());\\n                } else {\\n                    sum = sum + depthSum(list.getList(), level + 1, 0);\\n                }\\n            }\\n        }\\n        sum += value * level;\\n        return sum;\\n    }\\n}\\n```\\n\\n<div class=\"margin-bottom-20\"><h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4><p>Uniform cost model is used as Cost Model, `|V|` is the total number of nested elements in the input list and `h` is the maximum depth of the nested list.</p><p><b>Time Complexity:</b><ul><li>Best Case `O(|V|)` : There is no best case scenario as each element needed to be evaluated and add to running sum.</li><li>Average Case `O(|V|)` : For all possible input the algorithm evaluate each nested element at least once.</li><li>Worst Case `O(|V|)` : There is no worst case as each element needed to be evaluated and add to running sum.</li></ul></p><p><b>Auxiliary Space:</b><ul><li>Best Case `O(1)` : Occurs when no element is nested hence no recursive call is made.</li><li>Average Case `O(h)` : On average the space required will be the depth of recursive call as stack frames need to be allocated.</li><li>Worst Case `O(|V|)` : Occurs when each nested element has only one nested element. For example, <code>[[[[[2]]]]]</code>. This is the worst case for 6 nested elements as each nested element will be kept in stack frame until <code>2</code> is reached.</li></ul></p></div><div class=\"margin-bottom-20\"><h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4><p><b>Approach:</b> Post-order Tree Traversal (Recursive)</p><p>Post-order tree traversal is achieved by explicitly visiting every node and processing it <em>after</em> traversal. Depth and unpacked nested list are being passed to the next recursive call. Anytime, an integer is encountered, a value is passed to the callee. The sum is then returned to the caller once the for loop ends. Since this is a tree, there is no need to keep track of visited nodes like general graph traversal. This example is used to explicitly show Post-order tree traversal. There is no practical advantage for using this type of traversal.</p></div>\\n<hr>\\n\\n<h3><b>Solution 4</b></h3>\\n```\\npublic class Solution {\\n    public int depthSum(List<NestedInteger> nestedList) {\\n        Stack<NestedInteger> stack = new Stack<>();\\n        Stack<Integer> depth = new Stack<>();\\n        for (NestedInteger nestedInteger : nestedList) {\\n            stack.push(nestedInteger);\\n            depth.push(1);\\n        }\\n        int sum = 0;\\n        while (!stack.empty()) {\\n            NestedInteger currentNode = stack.pop();\\n            int currentDepth = depth.pop();\\n            if (currentNode.isInteger()) {\\n                sum += currentNode.getInteger() * currentDepth;\\n            } else {\\n                for (NestedInteger nestedInteger : currentNode.getList()) {\\n                    stack.push(nestedInteger);\\n                    depth.push(currentDepth + 1);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n<div class=\"margin-bottom-20\"><h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4><p>Uniform cost model is used as Cost Model, `|V|` is the total number of nested elements in the input list and `h` is the maximum depth of the nested list.</p><p><b>Time Complexity:</b><ul><li>Best Case `O(|V|)` : There is no best case scenario as each element needed to be evaluated and add to running sum.</li><li>Average Case `O(|V|)` : For all possible input the algorithm evaluate each nested element at least once.</li><li>Worst Case `O(|V|)` : There is no worst case as each element needed to be evaluated and add to running sum.</li></ul></p><p><b>Auxiliary Space:</b><ul><li>Best Case `O(1)` : Occurs when the initial list contains only integers so only one level of stack is used. For example, <code>[[[[[2]]]]]</code> has 6 nested elements. Given the nature of iterative pre-order traversal, the stack is popped frequently on each level so at every point in the only 1 stack frame is used.</li><li>Average Case `O(h)` : On average the space required will be the depth of the tree as stack is pushed with reference point to traverse back to. Note that this will occur when the nest is semi-balance.</li><li>Worst Case `O(|V|)` : Occurs when the initial list contains only integers. For example, <code>[1, 2, 3, 4, 5, 6]</code> has 6 nested elements. In this case, stack would have to store 6 elements.</li></ul></p></div><div class=\"margin-bottom-20\"><h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4><p><b>Approach:</b> Pre-order tree traversal (Iterative)</p><p>The iterative variation the first visit the last nested element instead of the first nested element. Instead of using activation stack, explicit stack can be used to perform pre-order tree travel iteratively. First stack is used to keep track of the node and second stack is used to keep track of the depth. Anytime, an integer is encountered, a value is evaluated and incremented to the running sum. Nested list is unpacked and added to the stack simultaneously with the incremented depth.</p></div>\\n<hr>\\n\\n<h3><b>Solution 5</b></h3>\\n```\\npublic class Solution {\\n    public int depthSum(List<NestedInteger> nestedList) {\\n        if (nestedList == null) return 0;\\n        List<NestedInteger> queue = new LinkedList<>(nestedList);\\n        int result = 0;\\n        int level = 1;\\n        while (queue.size() > 0) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                NestedInteger nestedInteger = queue.remove(0);\\n                if (nestedInteger.isInteger()) {\\n                    result = result + level * nestedInteger.getInteger();\\n                } else {\\n                    queue.addAll(nestedInteger.getList());\\n                }\\n            }\\n            level++;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n<div class=\"margin-bottom-20\"><h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4><p>Uniform cost model is used as Cost Model, `|V|` is the total number of nested elements in the input list and `h` is the maximum depth of the nested list.</p><p><b>Time Complexity:</b><ul><li>Best Case `O(|V|)` : There is no best case scenario as each element needed to be evaluated and add to running sum.</li><li>Average Case `O(|V|)` : For all possible input the algorithm evaluate each nested element at least once.</li><li>Worst Case `O(|V|)` : There is no worst case as each element needed to be evaluated and add to running sum.</li></ul></p><p><b>Auxiliary Space:</b><ul><li>Best Case `O(1)` : Occurs when the initial list contains only integers so only one level of stack is used. For example, <code>[[[[[2]]]]]</code> has 6 nested elements. Given the nature of iterative pre-order traversal, the stack is popped frequently on each level so at every point in the only 1 stack frame is used.</li><li>Average Case `O(h)` : On average the space required will be the depth of the tree as stack is pushed with reference point to traverse back to. Note that this will occur when the nest is semi-balance.</li><li>Worst Case `O(|V|)` : Occurs when the initial list contains only integers. For example, <code>[1, 2, 3, 4, 5, 6]</code> has 6 nested elements. In this case, stack would have to store 6 elements.</li></ul></p></div><div class=\"margin-bottom-20\"><h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4><p><b>Approach:</b> Breath First Search Discovery (Iterative)</p><p>This can also be categorized as Level-order tree traversal algorithm. The algorithm will travel level by level and increment the running sum when integer is encountered. Queue is used as data structure due to the nature of BFS where it needs to process data sequentially for each level.</p></div>\\n<hr>"
		},
		{
			"lc_ans_id":"80025",
			"view":"706",
			"top":"6",
			"title":"Java DFS and BFS simple code",
			"vote":"4",
			"content":"    public class Solution {\\n        public int depthSum(List<NestedInteger> nestedList) {\\n            if (nestedList == null || nestedList.size() == 0) {\\n                return 0;\\n            }\\n            int sum = 0;\\n            Queue<NestedInteger> queue = new LinkedList<>();\\n            for (NestedInteger nestedInt : nestedList) {\\n                queue.offer(nestedInt);\\n            }\\n            \\n            int depth = 0;\\n            while (!queue.isEmpty()) {\\n                int size = queue.size();\\n                depth++;\\n                for (int i = 0; i < size; i++) {\\n                    NestedInteger nestedInt = queue.poll();\\n                    if (nestedInt.isInteger()) {\\n                        sum += nestedInt.getInteger() * depth;\\n                    } else {\\n                        for (NestedInteger innerInt : nestedInt.getList()) {\\n                            queue.offer(innerInt);\\n                        }\\n                    }\\n                }\\n            }\\n            return sum;\\n        }\\n    }\\n    \\n    \\n    \\n    \\n    public class Solution {\\n        private int sum;\\n        public int depthSum(List<NestedInteger> nestedList) {\\n            if (nestedList == null) {\\n                return 0;\\n            }\\n            sum = 0;\\n            for (NestedInteger nestedInt : nestedList) {\\n                depthSumHelper(nestedInt, 1);\\n            }\\n            return sum;\\n        }\\n        \\n        private void depthSumHelper(NestedInteger nestedInt, int depth) {\\n            if (nestedInt.isInteger()) {\\n                sum += depth * nestedInt.getInteger();\\n                return;\\n            }\\n            for (NestedInteger innerInt : nestedInt.getList()) {\\n                depthSumHelper(innerInt, depth + 1);\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"79962",
			"view":"2078",
			"top":"7",
			"title":"Easy understanding DFS 0ms C++ and 48ms python  and 84ms javascript solutions",
			"vote":"4",
			"content":"c++:    \\n\\n    class Solution {\\n        private:\\n            int DFS(vector<NestedInteger>& nestedList, int depth){\\n                int n = (int)nestedList.size();\\n                int sum = 0;\\n                for(int i=0;i<n;i++){\\n                    if(nestedList[i].isInteger()){\\n                        sum += nestedList[i].getInteger()*depth;\\n                    }\\n                    else{\\n                        sum += DFS(nestedList[i].getList(),depth+1);\\n                    }\\n                }\\n                return sum;\\n            }\\n        public:\\n            int depthSum(vector<NestedInteger>& nestedList) {\\n                return DFS(nestedList, 1);\\n            }\\n    };\\n\\nPython:\\n\\n    class Solution(object):\\n        def depthSum(self, nestedList):\\n            \"\"\"\\n            :type nestedList: List[NestedInteger]\\n            :rtype: int\\n            \"\"\"\\n            def DFS(nestedList, depth):\\n                temp_sum = 0\\n                for member in nestedList:\\n                    if member.isInteger():\\n                        temp_sum += member.getInteger() * depth\\n                    else:\\n                        temp_sum += DFS(member.getList(),depth+1)\\n                return temp_sum\\n            return DFS(nestedList,1)\\nJavascript:\\n\\n    /**\\n     * @param {NestedInteger[]} nestedList\\n     * @return {number}\\n     */\\n    var dfs = function(nestedList,depth){\\n        var sum = 0;\\n        var n = nestedList.length;\\n        for(var i=0; i<n;i++){\\n            if(nestedList[i].isInteger()){\\n                sum += nestedList[i].getInteger() * depth;\\n            }\\n            else{\\n                sum += dfs(nestedList[i].getList(),depth+1);\\n            }\\n        }\\n        return sum;\\n    };\\n    var depthSum = function(nestedList) {\\n      return dfs(nestedList,1);  \\n    };"
		},
		{
			"lc_ans_id":"79973",
			"view":"861",
			"top":"8",
			"title":"3-line Python solution, easy to understand",
			"vote":"3",
			"content":"    def depthSum(self, nestedList):\\n        \"\"\"\\n        :type nestedList: List[NestedInteger]\\n        :rtype: int\\n        \"\"\"\\n        def scanList(curr_list, depth):\\n            return sum(depth * x.getInteger() if x.isInteger() else scanList(x.getList(), depth + 1) for x in curr_list)\\n        \\n        return scanList(nestedList, 1)"
		},
		{
			"lc_ans_id":"79968",
			"view":"168",
			"top":"9",
			"title":"My solution in c using DFS",
			"vote":"2",
			"content":"    int depthSum(struct NestedInteger** nestedList, int nestedListSize) {\\n    return sumOf(nestedList,nestedListSize,1);\\n    }\\n    \\n    int sumOf (struct NestedInteger** nestedList, int nestedListSize,int depth){\\n    int sum=0;\\n    if (nestedListSize !=0 && *nestedList!=NULL){\\n    for(int i=0;i<nestedListSize;i++){\\n        if(NestedIntegerIsInteger(nestedList[i])){\\n            sum=sum+NestedIntegerGetInteger(nestedList[i])*depth;\\n        }else{\\n            sum= sum+sumOf(NestedIntegerGetList(nestedList[i]),NestedIntegerGetListSize(nestedList[i]),depth+1);\\n        }\\n        \\n    }\\n    \\n    }\\n    return sum;\\n    }"
		}
	],
	"id":"339",
	"title":"Nested List Weight Sum",
	"content":"<p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>\r\n\r\n<p>Each element is either an integer, or a list -- whose elements may also be integers or other lists.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\nGiven the list <code>[[1,1],2,[1,1]]</code>, return <b>10</b>. (four 1's at depth 2, one 2 at depth 1)</p>\r\n\r\n<p><b>Example 2:</b><br />\r\nGiven the list <code>[1,[4,[6]]]</code>, return <b>27</b>. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27)\r\n</p>",
	"frequency":"338",
	"ac_num":"31279"
}