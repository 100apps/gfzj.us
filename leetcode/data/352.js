{
	"difficulty":"3",
	"submit_num":"39341",
	"show_id":"352",
	"leetcode_id":"352",
	"answers":[
		{
			"lc_ans_id":"82553",
			"view":"11917",
			"top":"0",
			"title":"Java solution using TreeMap, real O(logN) per adding.",
			"vote":"85",
			"content":"Use TreeMap to easily find the lower and higher keys, the key is the start of the interval. \\nMerge the lower and higher intervals when necessary. The time complexity for adding is O(logN) since lowerKey(), higherKey(), put() and remove() are all O(logN). It would be O(N) if you use an ArrayList and remove an interval from it. \\n\\n    public class SummaryRanges {\\n        TreeMap<Integer, Interval> tree;\\n    \\n        public SummaryRanges() {\\n            tree = new TreeMap<>();\\n        }\\n    \\n        public void addNum(int val) {\\n            if(tree.containsKey(val)) return;\\n            Integer l = tree.lowerKey(val);\\n            Integer h = tree.higherKey(val);\\n            if(l != null && h != null && tree.get(l).end + 1 == val && h == val + 1) {\\n                tree.get(l).end = tree.get(h).end;\\n                tree.remove(h);\\n            } else if(l != null && tree.get(l).end + 1 >= val) {\\n                tree.get(l).end = Math.max(tree.get(l).end, val);\\n            } else if(h != null && h == val + 1) {\\n                tree.put(val, new Interval(val, tree.get(h).end));\\n                tree.remove(h);\\n            } else {\\n                tree.put(val, new Interval(val, val));\\n            }\\n        }\\n    \\n        public List<Interval> getIntervals() {\\n            return new ArrayList<>(tree.values());\\n        }\\n    }"
		},
		{
			"lc_ans_id":"82557",
			"view":"5414",
			"top":"1",
			"title":"Very concise c++ solution.",
			"vote":"33",
			"content":"In general case, vector is OK, it will take O(n) time in each add, and O(1) in get result. But if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size, we'd better use another data structure \"set\", because the insert operation in vector will cost O(n) time, but it only cost O(log n) in binary search tree, but it will cost O(n) time in getInterval. So use which data structure will depends. \\n\\nfirst one is the solution use vector\\n\\n    class SummaryRanges {\\n    public:\\n        void addNum(int val) {\\n            auto Cmp = [](Interval a, Interval b) { return a.start < b.start; };\\n            auto it = lower_bound(vec.begin(), vec.end(), Interval(val, val), Cmp);\\n            int start = val, end = val;\\n            if(it != vec.begin() && (it-1)->end+1 >= val) it--;\\n            while(it != vec.end() && val+1 >= it->start && val-1 <= it->end)\\n            {\\n                start = min(start, it->start);\\n                end = max(end, it->end);\\n                it = vec.erase(it);\\n            }\\n            vec.insert(it,Interval(start, end));\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            return vec;\\n        }\\n    private:\\n        vector<Interval> vec;\\n    };\\n\\nand below is another solution use binary search tree.\\n\\n    class SummaryRanges {\\n    public:\\n        /** Initialize your data structure here. */\\n        void addNum(int val) {\\n            auto it = st.lower_bound(Interval(val, val));\\n            int start = val, end = val;\\n            if(it != st.begin() && (--it)->end+1 < val) it++;\\n            while(it != st.end() && val+1 >= it->start && val-1 <= it->end)\\n            {\\n                start = min(start, it->start);\\n                end = max(end, it->end);\\n                it = st.erase(it);\\n            }\\n            st.insert(it,Interval(start, end));\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            vector<Interval> result;\\n            for(auto val: st) result.push_back(val);\\n            return result;\\n        }\\n    private:\\n        struct Cmp{\\n            bool operator()(Interval a, Interval b){ return a.start < b.start; }\\n        };\\n        set<Interval, Cmp> st;\\n    };"
		},
		{
			"lc_ans_id":"82610",
			"view":"3862",
			"top":"2",
			"title":"Java fast log (N) solution (186ms) without using the TreeMap but a customized BST",
			"vote":"14",
			"content":"    public class SummaryRanges {\\n        class BSTNode {\\n            Interval interval;\\n            BSTNode left;\\n            BSTNode right;\\n            BSTNode(Interval in){\\n                interval = in;\\n            }\\n        }\\n        \\n        BSTNode findMin(BSTNode root) {\\n            if (root == null) return null;\\n            if (root.left == null ) return root;\\n            else return findMin(root.left);\\n        }\\n        \\n        BSTNode remove(Interval x, BSTNode root) {\\n            if (root == null) return null;\\n            else if ( x == null ) return root;\\n            else if (x.start > root.interval.end ) {\\n                root.right = remove(x, root.right);\\n            } else if (x.end < root.interval.start ) {\\n                root.left = remove(x, root.left);\\n            } else if ( root.left != null && root.right != null) {\\n                root.interval = findMin(root.right).interval;\\n                root.right = remove( root.interval, root.right);\\n            } else {\\n                root = ( root.left != null ) ? root.left : root.right;\\n            }\\n            return root;\\n        }\\n        \\n        BSTNode findKey(int val, BSTNode root) {\\n            if (root == null) return null;\\n            if (root.interval.start > val) {\\n                return findKey(val, root.left);\\n            } else if (root.interval.end < val) {\\n                return findKey(val, root.right);\\n            } else return root;\\n        }\\n        \\n        BSTNode addKey(int val, BSTNode root) {\\n            if (root == null) {\\n                root = new BSTNode( new Interval(val, val) ); \\n            } else if (root.interval.start > val) {\\n                root.left = addKey(val, root.left);\\n            } else if (root.interval.end < val) {\\n                root.right = addKey(val, root.right);\\n            }  \\n            return root;\\n        }\\n        void inOrder(BSTNode root) {\\n            if (root != null) {\\n                inOrder(root.left);\\n                list.add(root.interval);\\n                inOrder(root.right);\\n            }\\n        }\\n        \\n        /** Initialize your data structure here. */\\n        BSTNode root;\\n        List<Interval> list = new ArrayList();\\n        public SummaryRanges() {\\n            root = null;\\n        }\\n        \\n        public void addNum(int val) {\\n            if (root == null) {\\n                root = addKey(val, root);\\n            } else {\\n                if ( findKey(val, root) != null) return;\\n                BSTNode left = findKey(val-1, root);\\n                BSTNode right = findKey(val+1, root);\\n                if (left == null && right == null) {\\n                    root = addKey(val, root);\\n                } else if (left != null && right == null) {\\n                    left.interval.end++;\\n                } else if (left == null && right != null) {\\n                    right.interval.start--;\\n                } else {\\n                    Interval l = left.interval;\\n                    int e = right.interval.end;\\n                    root = remove(right.interval, root);\\n                    l.end = e;\\n                }\\n            }\\n        }\\n        \\n        public List<Interval> getIntervals() {\\n            list.clear();\\n            inOrder(root);\\n            return list;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"82548",
			"view":"2021",
			"top":"3",
			"title":"Share my python solution using heap",
			"vote":"13",
			"content":"Since there is no standard TreeMap library for python, I am implementing this structure with a min heap.\\nThe idea is straight froward: \\nAppend interval to heap when addNum called\\nMerge intervals when getIntervals called\\n\\n  \\n    class SummaryRanges(object):\\n\\n      def __init__(self):\\n        self.intervals = []\\n        \\n      def addNum(self, val):\\n        heapq.heappush(self.intervals, (val, Interval(val, val)))\\n        \\n      def getIntervals(self):\\n        stack = []\\n        while self.intervals:\\n            idx, cur = heapq.heappop(self.intervals)\\n            if not stack:\\n                stack.append((idx, cur))\\n            else:\\n                _, prev = stack[-1]\\n                if prev.end + 1 >= cur.start:\\n                    prev.end = max(prev.end, cur.end)\\n                else:\\n                    stack.append((idx, cur))\\n        self.intervals = stack\\n        return list(map(lambda x: x[1], stack))"
		},
		{
			"lc_ans_id":"82562",
			"view":"2551",
			"top":"4",
			"title":"C++ solution using vector and binary search with explanation",
			"vote":"9",
			"content":"For a new number n, find and return the index of interval [s, t] such that s is the largest 'start' that is smaller than n. If no such interval exists, return -1. This is done using binary search.\\n\\nFor example, \\n\\n - new number 5, intervals [[1,1], [4,6], [8,8]], binary search returns 1.\\n\\n - new number 0, intervals [[1,1], [4,6], [8,8]], binary search returns -1.\\n\\nAfter we find this 'index', there are three circumstances:\\n\\n1. intervals[index] already contains val. Do nothing.\\n\\n2. val can be merged into intervals[index+1]. Modify intervals[index+1].start to val.\\n\\n3. val can be merged into intervals[index]. Modify intervals[index].end to val.\\n\\n4. val can't be merged into either interval. Insert Interval( val, val).\\n\\nFinally, after inserting val, we need to check whether intervals[index] and intervals[index+1] can be merged.\\n\\n\\n\\n    class SummaryRanges {\\n    private:\\n        vector<Interval> intervals = vector<Interval>();\\n        \\n        int binarySearch(vector<Interval> intervals, int val) {\\n            return binarySearchHelper(intervals, 0, intervals.size(), val);\\n        }\\n        \\n        int binarySearchHelper(vector<Interval> intervals, int start, int end, int val) {\\n            if (start == end) return -1;\\n            if (start+1 == end && intervals[start].start < val) return start;\\n            \\n            int mid = (start + end)/2;\\n            if (intervals[mid].start == val) {\\n                return mid;\\n            } else if (intervals[mid].start < val) {\\n                return binarySearchHelper(intervals, mid, end, val);\\n            } else { //intervals[mid] > val\\n                return binarySearchHelper(intervals, start, mid, val);\\n            }\\n        }\\n        \\n    public:\\n        /** Initialize your data structure here. */\\n        SummaryRanges() {\\n            \\n        }\\n        \\n        /** For a new number n, find the last(biggest) interval\\n         *  [s,t], such that s < n. If no such interval exists, \\n         *  return -1.\\n         */\\n        void addNum(int val) {\\n            int index = binarySearch(intervals, val);\\n            \\n            // intervals[index] contains val\\n            if (index != -1 && intervals[index].end >= val) {\\n                return;\\n            }\\n            \\n            if (index != intervals.size()-1 && val + 1 == intervals[index+1].start) {\\n                intervals[index+1].start = val;\\n            } else if (index != -1 && val - 1 == intervals[index].end) {\\n                intervals[index].end = val;\\n            } else {\\n                intervals.insert(intervals.begin() + index + 1, Interval(val, val));\\n            }\\n            \\n            //merge intervals[index] with intervals[index+1]\\n            if (index != -1 && intervals[index].end + 1 == intervals[index+1].start) {\\n                intervals[index].end = intervals[index+1].end;\\n                intervals.erase(intervals.begin()+index+1);\\n            }\\n            \\n            return;\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            return this->intervals;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"82650",
			"view":"356",
			"top":"5",
			"title":"Can you add a C# definition?",
			"vote":"6",
			"content":"I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
		},
		{
			"lc_ans_id":"82656",
			"view":"628",
			"top":"6",
			"title":"I can not understand the question description, can any one explain it?",
			"vote":"6",
			"content":"I can not understand the question description, can any one explain it?"
		},
		{
			"lc_ans_id":"82546",
			"view":"444",
			"top":"7",
			"title":"simple python solution with binary search",
			"vote":"4",
			"content":"```\\nclass SummaryRanges(object):\\n    def __init__(self):\\n        self.intervals = []\\n\\n    def addNum(self, val):\\n        # find location\\n        low, high = 0, len(self.intervals) - 1\\n        while low <= high:\\n            mid = (low + high) // 2\\n            elem = self.intervals[mid]\\n            if elem.start <= val <= elem.end:\\n                return\\n            elif elem.start > val:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n\\n        # insert the interval\\n        pos = min(low, high) + 1\\n        self.intervals[pos:pos] = [Interval(val, val)]\\n\\n        # merge with next interval\\n        if pos + 1 < len(self.intervals) and val == self.intervals[pos + 1].start - 1:\\n            self.intervals[pos].end = self.intervals[pos + 1].end\\n            self.intervals[pos + 1:pos + 2] = []\\n\\n        # merge with prev interval\\n        if pos - 1 >= 0 and val == self.intervals[pos - 1].end + 1:\\n            self.intervals[pos - 1].end = self.intervals[pos].end\\n            self.intervals[pos:pos + 1] = []\\n\\n    def getIntervals(self):\\n        return self.intervals\\n\\n```"
		},
		{
			"lc_ans_id":"82660",
			"view":"789",
			"top":"8",
			"title":"Java fast simple code using TreeMap with detailed explanation",
			"vote":"4",
			"content":"The idea is map all map all val to its left bond of containing interval for fast lookup.\\nStore intervals in TreeMap as it seems to require output intervals in ascending order.(if ascending order is not required, I would use a hashmap for maximum performance)\\n\\n5 cases\\n0: isolated val\\n\\n1: val already in existing interval\\ne.g    [1,6]    3, do nothing\\n\\n2. val is connected to interval on its left\\ne.g [1,2] 3\\n\\n3. val is connected to interval on its right\\ne.g.  [4, 7] 3\\n\\n4. val is connected on both side\\ne.g  [1,2] [4, 7]  3.\\n\\nThe algorithm actually finds the possible left or right intervals to val, (or both). remove the old intervals,\\ninsert the new interval in the TreeMap. Update valueToBond hashmap to ensure the right bound val can find its correct left bound. Note that some val in the middle of the interval won't find correct left bound. But that is OK as we will not access to the middle values in the future! The left bound, right bound values must find their correct left bound.\\n\\n\\n  \\n\\n     public class SummaryRanges {\\n            private Map<Integer, Integer> valueToBond;//map val to containing interval left bound\\n            private Map<Integer, Interval> bondToInterval; // store intervals in TreeMap <left bound, interval>\\n            \\n            public SummaryRanges() {\\n                valueToBond = new HashMap<>();\\n                bondToInterval = new TreeMap<>();\\n            }\\n            \\n            public void addNum(int val) {\\n                //contained in an existing interval\\n                if (valueToBond.containsKey(val)) {\\n                    return;\\n                }\\n                //isolated number, no connection to its left or right\\n                if (!valueToBond.containsKey(val - 1) && !valueToBond.containsKey(val + 1)) {\\n                    valueToBond.put(val, val);\\n                    bondToInterval.put(val, new Interval(val, val));\\n                    return;\\n                }\\n                //may connect to left, right or both\\n                int left = valueToBond.containsKey(val - 1) ? valueToBond.get(val - 1) : val;\\n                int right = valueToBond.containsKey(val + 1) ? bondToInterval.get(valueToBond.get(val + 1)).end : val;\\n                valueToBond.put(val, left);\\n                valueToBond.put(right, left);\\n                bondToInterval.remove(val + 1);\\n                bondToInterval.put(left, new Interval(left, right));\\n            }\\n            \\n            public List<Interval> getIntervals() {\\n                return new ArrayList<>(bondToInterval.values());\\n            }\\n        }"
		},
		{
			"lc_ans_id":"82619",
			"view":"1089",
			"top":"9",
			"title":"JAVA AC Union Find Solution",
			"vote":"3",
			"content":"public class SummaryRanges {\\n\\n    HashMap<Integer,Integer> map;\\n    HashMap<Integer,Integer> Intervals;\\n\\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        map = new HashMap<>();\\n        Intervals = new HashMap<>();\\n    }\\n    \\n    public void addNum(int val) {\\n        if(map.containsKey(val))\\n            return;\\n        else{\\n            map.put(val,1);\\n            if(map.containsKey(val+1) && map.containsKey(val-1)){\\n                int l = map.get(val+1);\\n                int r = map.get(val-1);\\n                map.put(val+l,l+r+1);\\n                map.put(val-r,l+r+1);\\n                Intervals.remove(val+1);\\n                Intervals.put(val-r,l+r+1);\\n            }\\n            else if(map.containsKey(val+1)){\\n                int l = map.get(val+1);\\n                map.put(val+l,l+1);\\n                map.put(val,l+1);\\n                Intervals.remove(val+1);\\n                Intervals.put(val,l+1);\\n            }\\n            else if(map.containsKey(val-1)){\\n                int r = map.get(val-1);\\n                map.put(val-r,r+1);\\n                map.put(val,r+1);\\n                Intervals.put(val-r,r+1);\\n            }\\n            else\\n                Intervals.put(val,1);\\n        }\\n    }\\n    \\n    public List<Interval> getIntervals() {\\n        List<Interval> list = new ArrayList<>();\\n        for(Integer i: Intervals.keySet())\\n            list.add(new Interval(i,i+Intervals.get(i)-1));\\n        Collections.sort(list, new Comparator<Interval>(){\\n            @Override\\n            public int compare(Interval i1, Interval i2){\\n                return i1.start-i2.start;\\n            }\\n        });\\n        return list;\\n    }\\n}"
		}
	],
	"id":"352",
	"title":"Data Stream as Disjoint Intervals",
	"content":"<p>Given a data stream input of non-negative integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, ..., summarize the numbers seen so far as a list of disjoint intervals.</p>\r\n\r\n<p>For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:</p>\r\n<pre>\r\n[1, 1]\r\n[1, 1], [3, 3]\r\n[1, 1], [3, 3], [7, 7]\r\n[1, 3], [7, 7]\r\n[1, 3], [6, 7]\r\n</pre>\r\n\r\n<p><b>Follow up:</b><br />\r\nWhat if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://discuss.leetcode.com/user/yunhong\">@yunhong</a> for adding this problem and creating most of the test cases.</p>",
	"frequency":"221",
	"ac_num":"16053"
}