{
	"difficulty":"2",
	"submit_num":"38970",
	"show_id":"353",
	"leetcode_id":"353",
	"answers":[
		{
			"lc_ans_id":"82668",
			"view":"7111",
			"top":"0",
			"title":"Java Deque and HashSet design with detailed comments",
			"vote":"51",
			"content":"    public class SnakeGame {\\n    \\n        //2D position info is encoded to 1D and stored as two copies \\n        Set<Integer> set; // this copy is good for fast loop-up for eating body case\\n        Deque<Integer> body; // this copy is good for updating tail\\n        int score;\\n        int[][] food;\\n        int foodIndex;\\n        int width;\\n        int height;\\n        \\n        public SnakeGame(int width, int height, int[][] food) {\\n            this.width = width;\\n            this.height = height;\\n            this.food = food;\\n            set = new HashSet<>();\\n            set.add(0); //intially at [0][0]\\n            body = new LinkedList<>();\\n            body.offerLast(0);\\n        }\\n        \\n      \\n        public int move(String direction) {\\n            //case 0: game already over: do nothing\\n            if (score == -1) {\\n                return -1;\\n            }\\n            \\n            // compute new head\\n            int rowHead = body.peekFirst() / width;\\n            int colHead = body.peekFirst() % width;\\n            switch (direction) {\\n                case \"U\" : rowHead--;\\n                           break;\\n                case \"D\" : rowHead++;\\n                           break;\\n                case \"L\" : colHead--;\\n                           break;\\n                default :  colHead++;\\n            }\\n            int head = rowHead * width + colHead;\\n            \\n            //case 1: out of boundary or eating body\\n            set.remove(body.peekLast()); // new head is legal to be in old tail's position, remove from set temporarily \\n            if (rowHead < 0 || rowHead == height || colHead < 0 || colHead == width || set.contains(head)) {\\n                return score = -1;\\n            }\\n            \\n            // add head for case2 and case3\\n            set.add(head); \\n            body.offerFirst(head);\\n            \\n            //case2: eating food, keep tail, add head\\n            if (foodIndex < food.length && rowHead == food[foodIndex][0] && colHead == food[foodIndex][1]) {\\n                set.add(body.peekLast()); // old tail does not change, so add it back to set\\n                foodIndex++;\\n                return ++score;\\n            }\\n            \\n            //case3: normal move, remove tail, add head\\n            body.pollLast();\\n            return score;\\n            \\n        }\\n    }"
		},
		{
			"lc_ans_id":"82686",
			"view":"2781",
			"top":"1",
			"title":"Share my easy java solution",
			"vote":"16",
			"content":"public class SnakeGame {\\n\\t\\n\\t    class Position{\\n\\t        int x;\\n\\t        int y;\\n\\t        public Position(int x,int y){\\n\\t            this.x = x;\\n\\t            this.y = y;\\n\\t        }\\n\\t        public boolean isEqual(Position p){\\n\\t            return this.x==p.x && this.y == p.y ;\\n\\t        }\\n\\t    }\\n\\t    int len;\\n\\t    int rows ,cols;\\n\\t    \\n\\t    int[][] food;\\n\\t    LinkedList<Position> snake;\\n\\t   \\n\\t    /** Initialize your data structure here.\\n\\t        @param width - screen width\\n\\t        @param height - screen height \\n\\t        @param food - A list of food positions\\n\\t        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. */\\n\\t    public SnakeGame(int width, int height, int[][] food) {\\n\\t        this.rows = height;\\n\\t        this.cols = width;\\n\\t        this.food = food;\\n\\t   \\n\\t        snake = new LinkedList<Position>();\\n\\t        snake.add(new Position(0,0));\\n\\t        len = 0;\\n\\t    }\\n\\t    \\n\\t    /** Moves the snake.\\n\\t        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down \\n\\t        @return The game's score after the move. Return -1 if game over. \\n\\t        Game over when snake crosses the screen boundary or bites its body. */\\n\\t    public int move(String direction) {\\n\\t    \\t//if(len>=food.length) return len;\\n\\t    \\n\\t        Position cur = new Position(snake.get(0).x,snake.get(0).y);\\n\\t        \\n\\t        switch(direction){\\n\\t        case \"U\": \\n\\t            cur.x--;  break;\\n\\t        case \"L\": \\n\\t            cur.y--; break;\\n\\t        case \"R\": \\n\\t            cur.y++;   break;\\n\\t        case \"D\": \\n\\t            cur.x++;   break;\\n\\t        }\\n\\t        \\n\\t        if(cur.x<0 || cur.x>= rows || cur.y<0 || cur.y>=cols) return -1;\\n\\t        \\n\\t\\n\\t        for(int i=1;i<snake.size()-1;i++){\\n\\t            Position next = snake.get(i);\\n\\t            if(next.isEqual(cur)) return -1;\\t       \\n\\t        }\\n\\t        snake.addFirst(cur);     \\n\\t        if(len<food.length){\\n\\t            Position p = new Position(food[len][0],food[len][1]);\\t        \\n\\t            if(cur.isEqual(p)){\\t            \\n\\t                len++;\\n\\t            }\\n\\t        }\\n\\t        while(snake.size()>len+1) snake.removeLast();\\n\\t       \\n\\t        return len;\\n\\t    }\\n\\n\\n\\t/**\\n\\t * Your SnakeGame object will be instantiated and called as such:\\n\\t * SnakeGame obj = new SnakeGame(width, height, food);\\n\\t * int param_1 = obj.move(direction);\\n\\t */\\n\\n\\n}"
		},
		{
			"lc_ans_id":"82696",
			"view":"2592",
			"top":"2",
			"title":"C++ straightforward solution",
			"vote":"13",
			"content":"    class SnakeGame {\\n    public:\\n\\t/** Initialize your data structure here.\\n\\t@param width - screen width\\n\\t@param height - screen height\\n\\t@param food - A list of food positions\\n\\tE.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. */\\n\\n\\tint w, h, pos;\\n\\tvector<pair<int, int>> food;\\n\\tset<pair<int, int>> hist;\\n\\tdeque<pair<int, int>> q;\\n\\n\\tSnakeGame(int width, int height, vector<pair<int, int>> food) {\\n\\t\\tthis->food = food;\\n\\t\\tw = width, h = height, pos = 0;\\n\\t\\tq.push_back(make_pair(0, 0));\\n\\t}\\n\\n\\t/** Moves the snake.\\n\\t@param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down\\n\\t@return The game's score after the move. Return -1 if game over.\\n\\tGame over when snake crosses the screen boundary or bites its body. */\\n\\tint move(string direction) {\\n\\t\\tint row = q.back().first, col = q.back().second;\\n\\t\\tpair<int, int> d = q.front(); q.pop_front();\\n\\t\\thist.erase(d);\\n\\n\\t\\tif (direction == \"U\")\\n\\t\\t\\trow--;\\n\\t\\telse if (direction == \"D\")\\n\\t\\t\\trow++;\\n\\t\\telse if (direction == \"L\")\\n\\t\\t\\tcol--;\\n\\t\\telse if (direction == \"R\")\\n\\t\\t\\tcol++;\\n\\n\\t\\tif (row < 0 || col < 0 || col >= w || row >= h || hist.count(make_pair(row, col)))\\n\\t\\t\\treturn -1;\\n\\t\\n\\t\\thist.insert(make_pair(row, col));\\n\\t\\tq.push_back(make_pair(row, col));\\n\\n\\t\\tif (pos >= food.size())\\n\\t\\t\\treturn q.size() - 1;\\n\\n\\t\\tif (row == food[pos].first && col == food[pos].second) {\\n\\t\\t\\tpos++;\\n\\t\\t\\tq.push_front(d);\\n\\t\\t\\thist.insert(d);\\n\\t\\t}\\n\\n\\t\\treturn q.size() - 1;\\n\\t  }\\n    };"
		},
		{
			"lc_ans_id":"82681",
			"view":"1002",
			"top":"3",
			"title":"Straightforward Python solution using deque",
			"vote":"8",
			"content":"class SnakeGame(object):\\n\\n    def __init__(self, width,height,food):\\n        \"\"\"\\n        Initialize your data structure here.\\n        @param width - screen width\\n        @param height - screen height \\n        @param food - A list of food positions\\n        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0].\\n        :type width: int\\n        :type height: int\\n        :type food: List[List[int]]\\n        \"\"\"\\n        self.snake = collections.deque([[0,0]])    # snake head is at the front\\n        self.width = width\\n        self.height = height\\n        self.food = collections.deque(food)\\n        self.direct = {'U': [-1, 0], 'L': [0, -1], 'R': [0, 1], 'D': [1, 0]}\\n        \\n\\n    def move(self, direction):\\n        \"\"\"\\n        Moves the snake.\\n        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down \\n        @return The game's score after the move. Return -1 if game over. \\n        Game over when snake crosses the screen boundary or bites its body.\\n        :type direction: str\\n        :rtype: int\\n        \"\"\"\\n        newHead = [self.snake[0][0]+self.direct[direction][0], self.snake[0][1]+self.direct[direction][1]]\\n        \\n        # notice that the newHead can be equal to self.snake[-1]\\n        if (newHead[0] < 0 or newHead[0] >= self.height) or (newHead[1] < 0 or newHead[1] >= self.width)\\\\\\n        or (newHead in self.snake and newHead != self.snake[-1]): return -1\\n\\n        if self.food and self.food[0] == newHead:  # eat food\\n            self.snake.appendleft(newHead)   # just make the food be part of snake\\n            self.food.popleft()   # delete the food that's already eaten\\n        else:    # not eating food: append head and delete tail                 \\n            self.snake.appendleft(newHead)   \\n            self.snake.pop()   \\n            \\n        return len(self.snake)-1"
		},
		{
			"lc_ans_id":"82721",
			"view":"718",
			"top":"4",
			"title":"Easy Java solution using linkedlist",
			"vote":"5",
			"content":"I use a linkedlist to mimic the snake movement. Every time we move one step forward, we get a new x and y.\\nWe have three situations:\\n(1) The new position is out of the boundary, return -1\\n(2) The new position reach the end of the snake body, remember to delete the oldest point in the linkedlist first!\\n(3) the new position is the food, then we just need to add the deleted point back to the linkedlist. The list will be one point longer then before.\\nWe keep an foodIndex to reserve the score and the index for food array.\\n```\\npublic class SnakeGame {\\n    /** Initialize your data structure here.\\n        @param width - screen width\\n        @param height - screen height \\n        @param food - A list of food positions\\n        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. */\\n    int[][] food;\\n    int width;\\n    int height;\\n    int foodIndex;\\n    LinkedList<int[]> track;\\n    public SnakeGame(int width, int height, int[][] food) {\\n        this.width = width;\\n        this.height = height;\\n        this.foodIndex = 0;\\n        this.food = food;\\n        track = new LinkedList<int[]>();\\n        int[] n = {0,0};\\n        track.add(n);\\n    }\\n    \\n    /** Moves the snake.\\n        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down \\n        @return The game's score after the move. Return -1 if game over. \\n        Game over when snake crosses the screen boundary or bites its body. */\\n    public int move(String direction) {\\n        int x = track.get(0)[0];\\n        int y = track.get(0)[1];\\n        int[] newpoint = new int[2];\\n        if(direction.equals(\"U\")) {\\n            x = x-1;\\n            y = y;\\n        }\\n        else if(direction.equals(\"L\")) {\\n            x = x;\\n            y = y-1;\\n        }\\n        else if(direction.equals(\"R\")) {\\n            x = x;\\n            y = y+1;\\n        }\\n        else {\\n            x = x+1;\\n            y = y;\\n        }\\n        if(x< 0 || x>=height || y <0 || y >=width) return -1;\\n        newpoint[0] = x;\\n        newpoint[1] = y;\\n        int[] todelete = track.get(track.size()-1);\\n        track.remove(track.size()-1);\\n        if(isdead(x,y)) return -1;\\n        track.add(0,newpoint);\\n        if(food.length > foodIndex && x == food[foodIndex][0] && y == food[foodIndex][1]) {\\n            track.add(todelete);\\n            foodIndex++;\\n            return foodIndex;\\n        }\\n        return foodIndex;\\n    }\\n    \\n//to test whether it will reach the tails\\n    public boolean isdead(int x, int y) {\\n        for(int i = track.size() -1; i>=0; i--) {\\n            int[] t= track.get(i);\\n            if(t[0] == x && t[1] ==y) return true; \\n        }\\n        return false;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"82694",
			"view":"1774",
			"top":"5",
			"title":"Test case have the Snake \"turn around\", is it correct?",
			"vote":"3",
			"content":"Is this a valid test case?\\n\\n[\"SnakeGame\",\"move\",\"move\",\"move\"]\\n[[3,3,[[2,0],[0,0]]],[\"D\"],[\"D\"],[\"U\"]]  \\n\\n      public class SnakeGame {\\n            LinkedHashSet<Integer> snake = new LinkedHashSet<Integer>();\\n            Integer head = null;\\n            int width;\\n            int height;\\n            int[][] food;\\n            int foodCursor;\\n        \\n            /** Initialize your data structure here.\\n                @param width - screen width\\n                @param height - screen height \\n                @param food - A list of food positions\\n                E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. */\\n            public SnakeGame(int width, int height, int[][] food) {\\n                this.width = width;\\n                this.height = height;\\n                this.food = food;\\n                this.foodCursor = 0;\\n                head = 0;\\n                snake.add(0);\\n            }\\n            \\n            /** Moves the snake.\\n                @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down \\n                @return The game's score after the move. Return -1 if game over. \\n                Game over when snake crosses the screen boundary or bites its body. */\\n            public int move(String direction) {\\n                int next = -1;\\n                \\n                if(direction.equals(\"L\")){\\n                    if(head % width == 0){\\n                        return -1;\\n                    }else{\\n                        next = head - 1;\\n                    }\\n                }else if(direction.equals(\"R\")){\\n                    if(head % width == width - 1){\\n                        return -1;\\n                    }else{\\n                        next = head + 1;\\n                    }\\n                }else if(direction.equals(\"U\")){\\n                    if(head / width == 0){\\n                        return -1;\\n                    }else{\\n                        next = head - width;\\n                    }\\n                }else if(direction.equals(\"D\")){\\n                    if(head / width == height - 1){\\n                        return -1;\\n                    }else{\\n                        next = head + width;\\n                    }\\n                }\\n                \\n                if(foodCursor < food.length && food[foodCursor][0] * width + food[foodCursor][1] == next){\\n                    if(snake.contains(next)){\\n                        return -1;\\n                    }\\n                    \\n                    snake.add(next);\\n                    head = next;\\n                    foodCursor++;\\n                }else{\\n                    snake.remove(snake.iterator().next());\\n                    \\n                    if(snake.contains(next)){\\n                        return -1;\\n                    }\\n                    snake.add(next);\\n                    head = next;\\n                }\\n                \\n                return snake.size() - 1;\\n            }\\n        }"
		},
		{
			"lc_ans_id":"82676",
			"view":"115",
			"top":"6",
			"title":"Python O(1) for move with explanation",
			"vote":"2",
			"content":"Keep track of the snake positions using a deque and a set. Just have to make sure that they are in sync all the time (remove from both and add to both). Have annotated the code inline for easier understanding (:\\n\\n```\\nclass SnakeGame(object):\\n\\n    def __init__(self, width, height, food):\\n        \"\"\"\\n        Initialize your data structure here.\\n        @param width - screen width\\n        @param height - screen height\\n        @param food - A list of food positions\\n        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0].\\n        :type width: int\\n        :type height: int\\n        :type food: List[List[int]]\\n        \"\"\"\\n        # Space: O(n)\\n        from collections import deque\\n        initial_pos = (0, 0)\\n        self.snake = deque([initial_pos])\\n        self.snakePos = set([initial_pos])\\n        self.foods = deque(food)\\n        self.width, self.height = width, height\\n        self.directions = { 'U': (-1, 0), 'L': (0, -1), 'R': (0, 1), 'D': (1, 0) }\\n\\n\\n    def move(self, direction):\\n        \"\"\"\\n        Moves the snake.\\n        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down\\n        @return The game's score after the move. Return -1 if game over.\\n        Game over when snake crosses the screen boundary or bites its body.\\n        :type direction: str\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(1)\\n        # Space: O(1)\\n        head = self.snake[0]\\n        next_pos = (head[0] + self.directions[direction][0], head[1] + self.directions[direction][1])\\n\\n        # Remove the tail before checking because the new head \\n        # can be in the previous tail position.\\n        tail = self.snake.pop()\\n        self.snakePos.remove(tail)\\n        if next_pos in self.snakePos or not (0 <= next_pos[1] < self.width and 0 <= next_pos[0] < self.height):\\n            return -1\\n\\n        curr_food = (-1, -1)\\n        if len(self.foods):\\n            curr_food = tuple(self.foods[0])\\n        \\n        # Add next position of snake\\n        self.snake.appendleft(next_pos)\\n        self.snakePos.add(next_pos)\\n\\n        if curr_food == next_pos:\\n            self.foods.popleft()\\n            # Add back tail because eating the food is \\n            # equivalent to combining the food with the body.\\n            self.snake.append(tail)\\n            self.snakePos.add(tail)\\n\\n        # Score is proportional to snake length.\\n        return len(self.snake) - 1\\n\\n\\n# Your SnakeGame object will be instantiated and called as such:\\n# obj = SnakeGame(width, height, food)\\n# param_1 = obj.move(direction)\\n```"
		},
		{
			"lc_ans_id":"82749",
			"view":"670",
			"top":"7",
			"title":"Java Solution of SnakeGame 276ms",
			"vote":"2",
			"content":"\\n    public class SnakeGame {\\n    //Here we use int to keep the location of snake body, value = x*width + y\\n    //And LinkedList has the method boolean contains, to check if collide with snake body\\n    Deque<Integer> snakeBody = new LinkedList();\\n    int width = 0;\\n    int height = 0;\\n    int[][] food;\\n    int count = 0;\\n    boolean gameOver = false;\\n\\n    public SnakeGame(int width, int height, int[][] food) {\\n        this.width = width;\\n        this.height = height;\\n        this.food = food;\\n        snakeBody.addLast(0);\\n    }\\n    \\n    /** Moves the snake.\\n        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down \\n        @return The game's score after the move. Return -1 if game over. \\n        Game over when snake crosses the screen boundary or bites its body. */\\n    public int move(String direction) {\\n        if(gameOver) return -1;\\n        int curValue = snakeBody.getFirst();\\n        int lastValue = snakeBody.removeLast();\\n        int[] head = new int[2];\\n        head[0] = curValue/width;\\n        head[1] = curValue%width;\\n        switch(direction) {\\n            case \"U\": head[0]--;break;\\n            case \"L\": head[1]--;break;\\n            case \"R\": head[1]++;break;\\n            case \"D\": head[0]++;break;\\n        }\\n        if(head[0]<0||head[1]<0||head[0]>=height||head[1]>=width||snakeBody.contains(valueOf(head))) {\\n            gameOver = true;\\n            return -1;\\n        }\\n        snakeBody.addFirst(valueOf(head));\\n        if(count<food.length&&food[count][0]==head[0]&&food[count][1]==head[1]) {\\n            snakeBody.addLast(lastValue);\\n            count++;\\n        }\\n        return snakeBody.size()-1;\\n    }\\n    \\n    public int valueOf(int[] head) {\\n        return head[0]*width+head[1];\\n    }\\n    }"
		},
		{
			"lc_ans_id":"82710",
			"view":"280",
			"top":"8",
			"title":"C++ easy understand solution with comments",
			"vote":"1",
			"content":"\\n```\\nclass SnakeGame {\\npublic:\\n    /** Initialize your data structure here.\\n        @param width - screen width\\n        @param height - screen height \\n        @param food - A list of food positions\\n        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. */\\n    SnakeGame(int width, int height, vector<pair<int, int>> food) {\\n        body.push_back(make_pair(0,0));\\n        _food=food;\\n        _width=width;\\n        _height=height;\\n        \\n        // head coordinates\\n        head_x=0;\\n        head_y=0;\\n        \\n        // food index\\n        foodindx=0;\\n    }\\n    \\n    /** Moves the snake.\\n        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down \\n        @return The game's score after the move. Return -1 if game over. \\n        Game over when snake crosses the screen boundary or bites its body. */\\n    int move(string direction) {\\n        // food coordinates initilization\\n       int food_x=-1;\\n       int food_y=-1;\\n       // if food exist,record current food coordinates\\n       if(_food.size()!=0){\\n       food_x= _food[foodindx].first;\\n       food_y=_food[foodindx].second;\\n       }\\n       \\n       //update head coordinates \\n       if(direction==\"U\")\\n            head_x--;\\n      else if(direction==\"L\")\\n            head_y--;\\n       else if(direction==\"R\")\\n            head_y++;\\n       else if(direction==\"D\")\\n            head_x++;\\n            \\n        // check head if out boundary     \\n         if(outBoundary(head_x,head_y))\\n            return -1;\\n        // check if snake can eat food\\n            if(head_x==food_x&&head_y==food_y){\\n                body.insert(body.begin(),make_pair(head_x,head_y));\\n                foodindx++;\\n            }\\n        // no food, just update snake body\\n            else{\\n                body.pop_back();\\n                if(biteItself(head_x,head_y)){\\n                    return -1;\\n                }\\n                 body.insert(body.begin(),make_pair(head_x,head_y));\\n            }\\n        return body.size()-1;\\n   }\\n   // helper function: check head if is out boundary  \\n    bool outBoundary(int x,int y){\\n        if(x>=0&&x<_height&&y>=0&&y<_width)\\n        return false;\\n        return true;\\n    }\\n    //helper function: check snake if bite itself. \\n    bool biteItself(int x,int y){\\n        auto iter=find(body.begin(),body.end(),make_pair(x,y));\\n        if(iter!=body.end())\\n        return true;\\n        return false;\\n    }\\nprivate: \\n    vector<pair<int,int>>body;\\n    int _width;\\n    int _height;\\n    int head_x;\\n    int head_y;\\n    int foodindx;\\n    vector<pair<int,int>>_food;\\n};\\n```"
		},
		{
			"lc_ans_id":"82711",
			"view":"168",
			"top":"9",
			"title":"Java DoublyLinkedList + Set + Queue Solution",
			"vote":"1",
			"content":"```\\nclass SnakeNode {\\n    int row, col;\\n    SnakeNode pre;\\n    SnakeNode next;\\n    SnakeNode(int row, int col) {\\n        this.row = row;\\n        this.col = col;\\n        this.pre = null;\\n        this.next = null;\\n    }\\n}\\n\\npublic class SnakeGame {\\n    \\n    SnakeNode snakeHead;\\n    SnakeNode snakeTail;\\n    Set<Integer> snakeCell;\\n    Queue<int[]> foodList;\\n    Integer score, height, width;\\n\\n    public SnakeGame(int width, int height, int[][] food) {\\n        \\n        snakeHead = new SnakeNode(0, 0);\\n        snakeTail = snakeHead;\\n        \\n        snakeCell = new HashSet<>();\\n        snakeCell.add(0);\\n        \\n        foodList = new LinkedList<int[]>();\\n        for(int[] i : food) {\\n            foodList.offer(i);\\n        }\\n        \\n        this.score = 0;\\n        this.height = height;\\n        this.width = width;\\n    }\\n\\n\\n    public int move(String direction) {\\n        \\n        int[] moveDir = new int[2];\\n        switch (direction) {\\n            case \"U\" : \\n                moveDir[0] = -1;\\n                break;\\n            case \"L\" :\\n                moveDir[1] = -1;\\n                break;\\n            case \"R\" :\\n                moveDir[1] = 1;\\n                break;\\n            case \"D\" :\\n                moveDir[0] = 1;\\n                break;\\n            default:\\n                break;\\n        }\\n        int newRow = snakeHead.row + moveDir[0];\\n        int newCol = snakeHead.col + moveDir[1];\\n\\n        SnakeNode newHead = new SnakeNode(newRow, newCol);\\n        int headCode = newRow * width + newCol;\\n        int tailCode = snakeTail.row * width + snakeTail.col;\\n        \\n        if(newRow < 0 || newRow >= height || newCol < 0 || newCol >= width || snakeCell.contains(headCode) && headCode != tailCode) {\\n            return -1;\\n        }\\n            \\n        int[] nextFood = foodList.peek();\\n        \\n        newHead.next = snakeHead;\\n        snakeHead.pre = newHead;\\n        snakeHead = newHead;\\n        \\n        if(nextFood != null && newRow == nextFood[0] && newCol == nextFood[1]) {\\n            foodList.poll();\\n            snakeCell.add(headCode);\\n            score++;\\n        } else {\\n            snakeCell.remove(tailCode);\\n            snakeCell.add(headCode);\\n            snakeTail = snakeTail.pre;\\n            snakeTail.next = null;\\n        }\\n        \\n        return score;\\n    }\\n}\\n\\n```"
		}
	],
	"id":"353",
	"title":"Design Snake Game",
	"content":"<p>Design a <a href=\"https://en.wikipedia.org/wiki/Snake_(video_game)\" target=\"_blank\">Snake game</a> that is played on a device with screen size = <i>width</i> x <i>height</i>. <a href=\"http://patorjk.com/games/snake/\" target=\"_blank\">Play the game online</a> if you are not familiar with the game.</p>\r\n\r\n<p>The snake is initially positioned at the top left corner (0,0) with length = 1 unit.</p>\r\n\r\n<p>You are given a list of food's positions in row-column order. When a snake eats the food, its length and the game's score both increase by 1.</p>\r\n\r\n<p>Each food appears one by one on the screen. For example, the second food will not appear until the first food was eaten by the snake.</p>\r\n\r\n<p>When a food does appear on the screen, it is guaranteed that it will not appear on a block occupied by the snake.</p>\r\n\r\n<p>\r\n<b>Example:</b><br />\r\n<pre>\r\nGiven width = 3, height = 2, and food = [[1,2],[0,1]].\r\n\r\nSnake snake = new Snake(width, height, food);\r\n\r\nInitially the snake appears at position (0,0) and the food at (1,2).\r\n\r\n|S| | |\r\n| | |F|\r\n\r\nsnake.move(\"R\"); -> Returns 0\r\n\r\n| |S| |\r\n| | |F|\r\n\r\nsnake.move(\"D\"); -> Returns 0\r\n\r\n| | | |\r\n| |S|F|\r\n\r\nsnake.move(\"R\"); -> Returns 1 (Snake eats the first food and right after that, the second food appears at (0,1) )\r\n\r\n| |F| |\r\n| |S|S|\r\n\r\nsnake.move(\"U\"); -> Returns 1\r\n\r\n| |F|S|\r\n| | |S|\r\n\r\nsnake.move(\"L\"); -> Returns 2 (Snake eats the second food)\r\n\r\n| |S|S|\r\n| | |S|\r\n\r\nsnake.move(\"U\"); -> Returns -1 (Game over because snake collides with border)\r\n\r\n</pre>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://discuss.leetcode.com/user/elmirap\">@elmirap</a> for adding this problem and creating all test cases.</p>",
	"frequency":"52",
	"ac_num":"10553"
}