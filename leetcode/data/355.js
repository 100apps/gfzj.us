{
	"difficulty":"2",
	"submit_num":"89498",
	"show_id":"355",
	"leetcode_id":"355",
	"answers":[
		{
			"lc_ans_id":"82825",
			"view":"22618",
			"top":"0",
			"title":"Java OO Design with most efficient function getNewsFeed",
			"vote":"156",
			"content":"    public class Twitter {\\n        private static int timeStamp=0;\\n        \\n        // easy to find if user exist\\n        private Map<Integer, User> userMap;\\n        \\n        // Tweet link to next Tweet so that we can save a lot of time\\n        // when we execute getNewsFeed(userId)\\n        private class Tweet{\\n            public int id;\\n            public int time;\\n            public Tweet next;\\n            \\n            public Tweet(int id){\\n                this.id = id;\\n                time = timeStamp++;\\n                next=null;\\n            }\\n        }\\n        \\n        \\n        // OO design so User can follow, unfollow and post itself\\n        public class User{\\n            public int id;\\n            public Set<Integer> followed;\\n            public Tweet tweet_head;\\n            \\n            public User(int id){\\n                this.id=id;\\n                followed = new HashSet<>();\\n                follow(id); // first follow itself\\n                tweet_head = null;\\n            }\\n            \\n            public void follow(int id){\\n                followed.add(id);\\n            }\\n            \\n            public void unfollow(int id){\\n                followed.remove(id);\\n            }\\n            \\n            \\n            // everytime user post a new tweet, add it to the head of tweet list.\\n            public void post(int id){\\n                Tweet t = new Tweet(id);\\n                t.next=tweet_head;\\n                tweet_head=t;\\n            }\\n        }\\n        \\n        \\n        \\n    \\n        /** Initialize your data structure here. */\\n        public Twitter() {\\n            userMap = new HashMap<Integer, User>();\\n        }\\n        \\n        /** Compose a new tweet. */\\n        public void postTweet(int userId, int tweetId) {\\n            if(!userMap.containsKey(userId)){\\n                User u = new User(userId);\\n                userMap.put(userId, u);\\n            }\\n            userMap.get(userId).post(tweetId);\\n                \\n        }\\n        \\n \\n        \\n        // Best part of this.\\n        // first get all tweets lists from one user including itself and all people it followed.\\n        // Second add all heads into a max heap. Every time we poll a tweet with \\n        // largest time stamp from the heap, then we add its next tweet into the heap.\\n        // So after adding all heads we only need to add 9 tweets at most into this \\n        // heap before we get the 10 most recent tweet.\\n        public List<Integer> getNewsFeed(int userId) {\\n            List<Integer> res = new LinkedList<>();\\n    \\n            if(!userMap.containsKey(userId))   return res;\\n            \\n            Set<Integer> users = userMap.get(userId).followed;\\n            PriorityQueue<Tweet> q = new PriorityQueue<Tweet>(users.size(), (a,b)->(b.time-a.time));\\n            for(int user: users){\\n                Tweet t = userMap.get(user).tweet_head;\\n                // very imporant! If we add null to the head we are screwed.\\n                if(t!=null){\\n                    q.add(t);\\n                }\\n            }\\n            int n=0;\\n            while(!q.isEmpty() && n<10){\\n              Tweet t = q.poll();\\n              res.add(t.id);\\n              n++;\\n              if(t.next!=null)\\n                q.add(t.next);\\n            }\\n            \\n            return res;\\n            \\n        }\\n        \\n        /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n        public void follow(int followerId, int followeeId) {\\n            if(!userMap.containsKey(followerId)){\\n                User u = new User(followerId);\\n                userMap.put(followerId, u);\\n            }\\n            if(!userMap.containsKey(followeeId)){\\n                User u = new User(followeeId);\\n                userMap.put(followeeId, u);\\n            }\\n            userMap.get(followerId).follow(followeeId);\\n        }\\n        \\n        /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n        public void unfollow(int followerId, int followeeId) {\\n            if(!userMap.containsKey(followerId) || followerId==followeeId)\\n                return;\\n            userMap.get(followerId).unfollow(followeeId);\\n        }\\n    }\\n    \\n    /**\\n     * Your Twitter object will be instantiated and called as such:\\n     * Twitter obj = new Twitter();\\n     * obj.postTweet(userId,tweetId);\\n     * List<Integer> param_2 = obj.getNewsFeed(userId);\\n     * obj.follow(followerId,followeeId);\\n     * obj.unfollow(followerId,followeeId);\\n     */"
		},
		{
			"lc_ans_id":"82863",
			"view":"7320",
			"top":"1",
			"title":"Python solution",
			"vote":"44",
			"content":"    class Twitter(object):\\n    \\n        def __init__(self):\\n            self.timer = itertools.count(step=-1)\\n            self.tweets = collections.defaultdict(collections.deque)\\n            self.followees = collections.defaultdict(set)\\n    \\n        def postTweet(self, userId, tweetId):\\n            self.tweets[userId].appendleft((next(self.timer), tweetId))\\n    \\n        def getNewsFeed(self, userId):\\n            tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n            return [t for _, t in itertools.islice(tweets, 10)]\\n    \\n        def follow(self, followerId, followeeId):\\n            self.followees[followerId].add(followeeId)\\n    \\n        def unfollow(self, followerId, followeeId):\\n            self.followees[followerId].discard(followeeId)"
		},
		{
			"lc_ans_id":"82837",
			"view":"6367",
			"top":"2",
			"title":"Java Solutions with Two Maps and PriorityQueue",
			"vote":"22",
			"content":"I use a map to track the tweets for each user. When we need to generate a news feed, I merge the news feed for all the followees and take the most recent 10. This is unlikely to perform, but the code passes the OJ. I'm sure design interviews ask for performance trade-offs and just posting this code in a design interview will not help you get an offer.\\n\\n    public class Twitter {\\n        Map<Integer, Set<Integer>> fans = new HashMap<>();\\n        Map<Integer, LinkedList<Tweet>> tweets = new HashMap<>();\\n        int cnt = 0;\\n    \\n        public void postTweet(int userId, int tweetId) {\\n            if (!fans.containsKey(userId)) fans.put(userId, new HashSet<>());\\n            fans.get(userId).add(userId);\\n            if (!tweets.containsKey(userId)) tweets.put(userId, new LinkedList<>());\\n            tweets.get(userId).addFirst(new Tweet(cnt++, tweetId));\\n        }\\n    \\n        public List<Integer> getNewsFeed(int userId) {\\n            if (!fans.containsKey(userId)) return new LinkedList<>();\\n            PriorityQueue<Tweet> feed = new PriorityQueue<>((t1, t2) -> t2.time - t1.time);\\n            fans.get(userId).stream()\\n                .filter(f -> tweets.containsKey(f))\\n                .forEach(f -> tweets.get(f).forEach(feed::add));\\n            List<Integer> res = new LinkedList<>();\\n            while (feed.size() > 0 && res.size() < 10) res.add(feed.poll().id);\\n            return res;\\n        }\\n    \\n        public void follow(int followerId, int followeeId) {\\n            if (!fans.containsKey(followerId)) fans.put(followerId, new HashSet<>());\\n            fans.get(followerId).add(followeeId);\\n        }\\n    \\n        public void unfollow(int followerId, int followeeId) {\\n            if (fans.containsKey(followerId) && followeeId != followerId) fans.get(followerId).remove(followeeId);\\n        }\\n    \\n        class Tweet {\\n            int time;\\n            int id;\\n    \\n            Tweet(int time, int id) {\\n                this.time = time;\\n                this.id = id;\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"82871",
			"view":"6744",
			"top":"3",
			"title":"72ms C++ solution",
			"vote":"15",
			"content":"Complexity: O(1) post/follow/unfollow, O(n + k log n) newsfeed for getting k tweets from n followed users, with the O(n) part coming from constructing the heap of followed users (see below), as correctly noted by @poligun.\\n\\nUse `std::vector` to store tweets, `std::unordered_set` to store followed users, `std::unordered_map` to associate each user with their tweets and followed users.\\n\\nUse a heap to merge most recent k tweets from followed users. `std::make/push/pop_heap` provide finer control than `std::priority_queue`.\\n\\n\\n    class Twitter\\n    {\\n        struct Tweet\\n        {\\n            int time;\\n            int id;\\n            Tweet(int time, int id) : time(time), id(id) {}\\n        };\\n    \\n        std::unordered_map<int, std::vector<Tweet>> tweets; // [u] = array of tweets by u\\n        std::unordered_map<int, std::unordered_set<int>> following; // [u] = array of users followed by u\\n    \\n        int time;\\n    \\n    public:\\n        Twitter() : time(0) {}\\n    \\n        void postTweet(int userId, int tweetId)\\n        {\\n            tweets[userId].emplace_back(time++, tweetId);\\n        }\\n    \\n        std::vector<int> getNewsFeed(int userId)\\n        {\\n            std::vector<std::pair<Tweet*, Tweet*>> h; // pair of pointers (begin, current)\\n    \\n            for (auto& u: following[userId])\\n            {\\n                auto& t = tweets[u];\\n                if (t.size() > 0)\\n                    h.emplace_back(t.data(), t.data() + t.size() - 1);\\n            }\\n            auto& t = tweets[userId]; // self\\n            if (t.size() > 0)\\n                h.emplace_back(t.data(), t.data() + t.size() - 1);\\n    \\n            auto f = [](const std::pair<Tweet*, Tweet*>& x, const std::pair<Tweet*, Tweet*>& y) {\\n                return x.second->time < y.second->time;\\n            };\\n            std::make_heap(h.begin(), h.end(), f);\\n    \\n            const int n = 10;\\n            std::vector<int> o;\\n            o.reserve(n);\\n            for (int i = 0; (i < n) && !h.empty(); ++i)\\n            {\\n                std::pop_heap(h.begin(), h.end(), f);\\n    \\n                auto& hb = h.back();\\n                o.push_back(hb.second->id);\\n    \\n                if (hb.first == hb.second--)\\n                    h.pop_back();\\n                else\\n                    std::push_heap(h.begin(), h.end(), f);\\n            }\\n            return o;\\n        }\\n    \\n        void follow(int followerId, int followeeId)\\n        {\\n            if (followerId != followeeId)\\n                following[followerId].insert(followeeId);\\n        }\\n    \\n        void unfollow(int followerId, int followeeId)\\n        {\\n            following[followerId].erase(followeeId);\\n        }\\n    };"
		},
		{
			"lc_ans_id":"82831",
			"view":"3049",
			"top":"4",
			"title":"Simple and Clean Python code, O(logK) for getting news feed",
			"vote":"9",
			"content":"    import heapq\\n    \\n    class Twitter(object):\\n    \\n        def __init__(self):\\n            self.time = 0\\n            self.tweets = {}\\n            self.followee = {}\\n            \\n    \\n        def postTweet(self, user, tweet):\\n            self.time += 1\\n            self.tweets[user] = self.tweets.get(user, []) + [(-self.time,  tweet)]\\n            \\n            \\n    \\n        def getNewsFeed(self, user):\\n            h, tweets = [], self.tweets\\n            people = self.followee.get(user, set()) | set([user])\\n            for person in people:\\n                if person in tweets and tweets[person]:\\n                    time, tweet = tweets[person][-1]\\n                    h.append((time, tweet, person, len(tweets[person]) - 1))\\n            heapq.heapify(h)\\n            news = []\\n            for _ in range(10):\\n                if h:\\n                    time, tweet, person, idx = heapq.heappop(h)\\n                    news.append(tweet)\\n                    if idx:\\n                        new_time, new_tweet = tweets[person][idx-1]\\n                        heapq.heappush(h, (new_time, new_tweet, person, idx - 1))\\n            return news\\n            \\n            \\n    \\n        def follow(self, follower, other):\\n            self.followee[follower] = self.followee.get(follower, set()) | set([other])\\n            \\n            \\n    \\n        def unfollow(self, follower, other):\\n            if follower in self.followee:\\n                self.followee[follower].discard(other)\\n \\n\\n `K` is the number of followee of `user`. We have `O(log(K))` runtime for getting news feed because we do maximum 10 extractions in a heap that holds maximum `K` elements (similar to what is done in merge `K` linked lists). The other ops are obviously `O(1)`."
		},
		{
			"lc_ans_id":"82935",
			"view":"1061",
			"top":"5",
			"title":"Java OOD solution with detailed explanation",
			"vote":"7",
			"content":"OOD design:\\ndata structure need in the Tweet system:\\n\\n\\t1. A data structure that save the following relationship\\n\\t2. A data structure that save the tweets posted \\n\\nBased on the requirement of method 3: we should get our followees' tweets and select the most recent 10 tweet. So there should have a timestamp inside the tweet. So we create a new class to represent a tweet\\n\\n\\t3. A class Tweet containing timestamp\\n\\n\\nThere are some tips in the system:\\n\\n\\t1. One should get the tweets of itself, which means the followee must contain itself\\n\\t2. Since the followee must contains itself, it cannot unfollow itself(unfollow add this constraint)\\n\\t3. The followees must be identical\\nAccording to the analysis above, we have these data struture in this class:\\n\\n\\t1. A inner class Tweet(tweetId, timePosted)\\n\\t2. A HashMap(follower, Set(followees))\\n\\t3. A HashMap(UserId, List(Tweet))\\n\\t4. A Static int timeStamp\\n\\t5. A int Maximum number of feed(can adjust if needed, optional)\\n\\nFor method 3, just simply use min heap to get the most recent 10.\\n\\n    public class Twitter {\\n    \\n    private static class Tweet{\\n        int tweetId;\\n        int timePosted;\\n        public Tweet(int tId, int time){\\n            tweetId = tId;\\n            timePosted = time;\\n        }\\n    }\\n    \\n    static int timeStamp;\\n    int feedMaxNum;\\n    Map<Integer, Set<Integer>> followees;\\n    Map<Integer, List<Tweet>> tweets;\\n    \\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        timeStamp = 0;\\n        feedMaxNum = 10;\\n        followees = new HashMap<>();\\n        tweets = new HashMap<>();\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        if(!tweets.containsKey(userId)) {\\n            tweets.put(userId, new LinkedList<Tweet>());\\n            follow(userId, userId);  //follow itself\\n        }\\n        tweets.get(userId).add(0, new Tweet(tweetId, timeStamp++)); //add new tweet on the first place\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        //min heap that the earliest tweet is on the top\\n        PriorityQueue<Tweet> feedHeap = new PriorityQueue<>(new Comparator<Tweet>(){\\n            public int compare(Tweet t1, Tweet t2){\\n                return t1.timePosted - t2.timePosted;\\n            }\\n        });\\n\\n        //add tweets of the followees\\n        Set<Integer> myFollowees = followees.get(userId);\\n        if(myFollowees != null){\\n            for(int followeeId : myFollowees){\\n                List<Tweet> followeeTweets = tweets.get(followeeId);\\n                if(followeeTweets == null) continue;\\n                for(Tweet t : followeeTweets){\\n                    if(feedHeap.size() < feedMaxNum) feedHeap.add(t);\\n                    else{\\n                        if(t.timePosted <= feedHeap.peek().timePosted) break;\\n                        else{\\n                            feedHeap.add(t);\\n                            feedHeap.poll(); //remove the oldest tweet\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        List<Integer> myFeed = new LinkedList<>();\\n        while(!feedHeap.isEmpty()){\\n            myFeed.add(0, feedHeap.poll().tweetId);\\n        }\\n        return myFeed;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if(!followees.containsKey(followerId)) followees.put(followerId, new HashSet<Integer>());\\n        followees.get(followerId).add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if(!followees.containsKey(followerId) || followerId == followeeId) return; //cannot unfollow itself\\n        followees.get(followerId).remove(followeeId);\\n    }\\n}"
		},
		{
			"lc_ans_id":"82955",
			"view":"727",
			"top":"6",
			"title":"C++ simple code using stl",
			"vote":"6",
			"content":"    class Twitter {\\n    private:\\n        struct P {\\n            int id, ref;\\n            P(int i = 0, int j = 0) :id(i), ref(j) {}\\n            inline bool operator<(const P &a) const { return ref > a.ref; }\\n        };\\n    public:\\n        Twitter() { time = 1; }\\n        void postTweet(int userId, int tweetId) {\\n            userPost[userId].insert(P(tweetId, time++));\\n            userFollow[userId].insert(userId);\\n        }\\n        vector<int> getNewsFeed(int userId) {\\n            q.clear();\\n            vector<int> res;\\n            for(auto &r: userFollow[userId]) {\\n                int n = userPost[r].size();\\n                auto it = userPost[r].begin();\\n                n = min(n, 10);\\n                while(n--) {\\n                    if(q.size() < 10) {\\n                        q.insert(*it++);\\n                    } else {\\n                        auto c = q.end();\\n                        if(*it < *--c) {\\n                            q.erase(c);\\n                            q.insert(*it++);\\n                        }\\n                    }\\n                }\\n            }\\n            for(auto &r: q) res.push_back(r.id);\\n            return res;\\n        }\\n        void follow(int followerId, int followeeId) {\\n            userFollow[followerId].insert(followeeId);\\n        }\\n        void unfollow(int followerId, int followeeId) {\\n            if(followerId == followeeId) return;\\n            userFollow[followerId].erase(followeeId);\\n        }\\n    private:\\n        int time;\\n        set<P> q;\\n        unordered_map<int, set<int>> userFollow;\\n        unordered_map<int, set<P>> userPost;\\n    };"
		},
		{
			"lc_ans_id":"82920",
			"view":"2876",
			"top":"7",
			"title":"Java Solution using HashMap and PriorityQueue",
			"vote":"6",
			"content":"\\tprivate static class Tweet {\\n\\t\\tint timestamp;\\n\\t\\tint tweetId;\\n\\n\\t\\tpublic Tweet(int tweetId, int timestamp) {\\n\\t\\t\\tthis.tweetId = tweetId;\\n\\t\\t\\tthis.timestamp = timestamp;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate Map<Integer, Set<Integer>> followMap = new HashMap<Integer, Set<Integer>>();\\n\\tprivate Map<Integer, List<Tweet>> tweetMap = new HashMap<Integer, List<Tweet>>();\\n\\n\\tprivate AtomicInteger timestamp;\\n\\n\\t/** Initialize your data structure here. */\\n\\tpublic Twitter() {\\n\\t\\ttimestamp = new AtomicInteger(0);\\n\\t}\\n\\n\\t/** Compose a new tweet. */\\n\\tpublic void postTweet(int userId, int tweetId) {\\n\\t\\tTweet newTweet = new Tweet(tweetId, timestamp.getAndIncrement());\\n\\n\\t\\tif (!tweetMap.containsKey(userId)) {\\n\\t\\t\\ttweetMap.put(userId, new ArrayList<Tweet>());  //Assuming no deletion for now?\\n\\t\\t}\\n\\n\\t\\ttweetMap.get(userId).add(newTweet);\\n\\t}\\n\\n\\t/**\\n\\t * Retrieve the 10 most recent tweet ids in the user's news feed. Each item\\n\\t * in the news feed must be posted by users who the user followed or by the\\n\\t * user herself. Tweets must be ordered from most recent to least recent.\\n\\t */\\n\\tpublic List<Integer> getNewsFeed(int userId) {\\n\\t\\tList<Integer> result = new ArrayList<Integer>(10);\\n\\n\\t\\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\\n\\t\\t\\tpublic int compare(int[] it1, int[] it2) {\\n\\t\\t\\t\\treturn tweetMap.get(it2[0]).get(it2[1]).timestamp - tweetMap.get(it1[0]).get(it1[1]).timestamp;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tSet<Integer> followeeSet = new HashSet<Integer>();\\n\\t\\tfolloweeSet.add(userId);\\n\\t\\tif (followMap.containsKey(userId)) {\\n\\t\\t\\tfolloweeSet.addAll(followMap.get(userId));\\n\\t\\t}\\n\\n\\t\\tfor (Integer followee : followeeSet) {\\n\\t\\t\\tif (tweetMap.containsKey(followee)) {\\n\\t\\t\\t\\tList<Tweet> tweetList = tweetMap.get(followee);\\n\\t\\t\\t\\tif (tweetList.size() > 0) {\\n\\t\\t\\t\\t\\tpq.add(new int[] { followee, tweetList.size() - 1 });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\twhile (result.size() < 10 && pq.size() > 0) {\\n\\t\\t\\tint[] it = pq.poll();\\n\\n\\t\\t\\tresult.add(tweetMap.get(it[0]).get(it[1]).tweetId);\\n\\t\\t\\tit[1]--;\\n\\t\\t\\tif (it[1] >= 0) {\\n\\t\\t\\t\\tpq.add(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/**\\n\\t * Follower follows a followee. If the operation is invalid, it should be a\\n\\t * no-op.\\n\\t */\\n\\tpublic void follow(int followerId, int followeeId) {\\n\\t\\tSet<Integer> followSet = followMap.get(followerId);\\n\\t\\tif (followSet == null) {\\n\\t\\t\\tfollowSet = new HashSet<Integer>();\\n\\t\\t\\tfollowMap.put(followerId, followSet);\\n\\t\\t}\\n\\n\\t\\tfollowSet.add(followeeId);\\n\\t}\\n\\n\\t/**\\n\\t * Follower unfollows a followee. If the operation is invalid, it should be\\n\\t * a no-op.\\n\\t */\\n\\tpublic void unfollow(int followerId, int followeeId) {\\n\\t\\tSet<Integer> followSet = followMap.get(followerId);\\n\\t\\tif (followSet == null) {\\n\\t\\t\\tfollowSet = new HashSet<Integer>();\\n\\t\\t\\tfollowMap.put(followerId, followSet);\\n\\t\\t}\\n\\n\\t\\tfollowSet.remove(followeeId);\\n\\t}"
		},
		{
			"lc_ans_id":"82927",
			"view":"1279",
			"top":"8",
			"title":"C++ 80ms unordered_map list priority_queue solution",
			"vote":"5",
			"content":"Time Complexity: n is number of user\\n\\npostTweet: O(1)\\n\\ngetNewsFeed: O(n log n)\\n\\nfollow: O(1)\\n\\nunfollow: O(1)\\n\\n    class Twitter {\\n    private:\\n        struct tweet{\\n            int userId;\\n            int tweetId;\\n            int timestamp;\\n            tweet(int x, int y, int z):userId(x), tweetId(y), timestamp(z){};\\n        };\\n        struct mycompare{\\n            bool operator()(pair<list<tweet>::iterator, list<tweet>::iterator> p1, pair<list<tweet>::iterator, list<tweet>::iterator> p2){\\n                return p1.first->timestamp < p2.first->timestamp;\\n            }\\n        };\\n        int timelabel = 0;\\n        unordered_map<int, unordered_set<int>> follower_dict;\\n        unordered_map<int, list<tweet>> twitter_dict;\\n    public:\\n        /** Initialize your data structure here. */\\n        Twitter() {}\\n        \\n        /** Compose a new tweet. */\\n        void postTweet(int userId, int tweetId) {\\n            follower_dict[userId].insert(userId);\\n            twitter_dict[userId].push_front(tweet(userId, tweetId, timelabel));\\n            timelabel++;\\n        }\\n        \\n        /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n        vector<int> getNewsFeed(int userId) {\\n            vector<int> res;\\n            if(follower_dict.find(userId) == follower_dict.end()) return res;\\n            priority_queue< pair<list<tweet>::iterator, list<tweet>::iterator>, vector<pair<list<tweet>::iterator, list<tweet>::iterator>>, mycompare> pq;\\n            for(auto it = follower_dict[userId].begin(); it != follower_dict[userId].end(); it++){\\n                if(twitter_dict[*it].begin() != twitter_dict[*it].end()){\\n                    pq.push(make_pair(twitter_dict[*it].begin(), twitter_dict[*it].end()));\\n                }\\n            }\\n            int index = 0;\\n            while(!pq.empty() && index < 10){\\n                auto tmp = pq.top();\\n                pq.pop();\\n                res.push_back(tmp.first->tweetId);\\n                if(++tmp.first != tmp.second){\\n                    pq.push(tmp);\\n                }\\n                index++;\\n            }\\n            return res;\\n        }\\n        \\n        /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n        void follow(int followerId, int followeeId) {\\n            follower_dict[followerId].insert(followerId);\\n            follower_dict[followerId].insert(followeeId);\\n        }\\n        \\n        /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n        void unfollow(int followerId, int followeeId) {\\n            if(follower_dict.find(followerId) != follower_dict.end() && followerId != followeeId){\\n                follower_dict[followerId].erase(followeeId);\\n            }\\n        }\\n    };"
		},
		{
			"lc_ans_id":"82916",
			"view":"721",
			"top":"9",
			"title":"C++ solution with max heap",
			"vote":"4",
			"content":"Use two hash tables to keep track of the friends relationship and the tweets, respectively. For getting the news feed, first use a separate variable \"time\" to keep track of the time order when posting, then use a max heap to get the most recent ones, since the heap will do the sorting for us.\\n\\nAny suggestion is welcome!\\n\\n    class Twitter {\\n    private:    \\n       unordered_map<int, set<int>> fo;\\n       unordered_map<int, vector<pair<int, int>>> t;\\n       long long time; \\n\\n    public:\\n    /** Initialize your data structure here. */\\n    Twitter() {\\n        time = 0;\\n    }\\n    \\n    /** Compose a new tweet. */\\n    void postTweet(int userId, int tweetId) {\\n        t[userId].push_back({time++, tweetId});\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<pair<int, int>> maxHeap; \\n        for (auto it=t[userId].begin();it!=t[userId].end();++it)\\n            maxHeap.push(*it);\\n        for (auto it1=fo[userId].begin();it1!=fo[userId].end();++it1){\\n            int usr = *it1; // get target user\\n            for (auto it2=t[usr].begin();it2!=t[usr].end();++it2)\\n                maxHeap.push(*it2);\\n        }   \\n        vector<int> res;\\n        while(maxHeap.size()>0) {\\n            res.push_back(maxHeap.top().second);\\n            if (res.size()==10) break;\\n            maxHeap.pop();\\n        }\\n        return res;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    void follow(int followerId, int followeeId) {\\n        if (followerId != followeeId)\\n            fo[followerId].insert(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    void unfollow(int followerId, int followeeId) {\\n        fo[followerId].erase(followeeId);\\n    }\\n};"
		}
	],
	"id":"355",
	"title":"Design Twitter",
	"content":"<p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:</p>\r\n\r\n<p>\r\n<ol>\r\n<li><b>postTweet(userId, tweetId)</b>: Compose a new tweet.</li>\r\n<li><b>getNewsFeed(userId)</b>: Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</li>\r\n<li><b>follow(followerId, followeeId)</b>: Follower follows a followee.</li>\r\n<li><b>unfollow(followerId, followeeId)</b>: Follower unfollows a followee.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nTwitter twitter = new Twitter();\r\n\r\n// User 1 posts a new tweet (id = 5).\r\ntwitter.postTweet(1, 5);\r\n\r\n// User 1's news feed should return a list with 1 tweet id -> [5].\r\ntwitter.getNewsFeed(1);\r\n\r\n// User 1 follows user 2.\r\ntwitter.follow(1, 2);\r\n\r\n// User 2 posts a new tweet (id = 6).\r\ntwitter.postTweet(2, 6);\r\n\r\n// User 1's news feed should return a list with 2 tweet ids -> [6, 5].\r\n// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\r\ntwitter.getNewsFeed(1);\r\n\r\n// User 1 unfollows user 2.\r\ntwitter.unfollow(1, 2);\r\n\r\n// User 1's news feed should return a list with 1 tweet id -> [5],\r\n// since user 1 is no longer following user 2.\r\ntwitter.getNewsFeed(1);\r\n</pre>\r\n</p>",
	"frequency":"179",
	"ac_num":"23094"
}