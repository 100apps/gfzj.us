{
	"difficulty":"3",
	"submit_num":"41308",
	"show_id":"358",
	"leetcode_id":"358",
	"answers":[
		{
			"lc_ans_id":"83193",
			"view":"13144",
			"top":"0",
			"title":"Java 15ms Solution with Two auxiliary array. O(N) time.",
			"vote":"68",
			"content":"This is a greedy problem.  \\nEvery time we want to find the best candidate: which is the character with the largest remaining count. Thus we will be having two arrays.   \\nOne count array to store the remaining count of every character. Another array to keep track of the most left position that one character can appear.\\nWe will iterated through these two array to find the best candidate for every position. Since the array is fixed size, it will take constant time to do this.  \\nAfter we find the candidate, we update two arrays.\\n\\n    public class Solution {\\n        public String rearrangeString(String str, int k) {\\n            int length = str.length();\\n            int[] count = new int[26];\\n            int[] valid = new int[26];\\n            for(int i=0;i<length;i++){\\n                count[str.charAt(i)-'a']++;\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            for(int index = 0;index<length;index++){\\n                int candidatePos = findValidMax(count, valid, index);\\n                if( candidatePos == -1) return \"\";\\n                count[candidatePos]--;\\n                valid[candidatePos] = index+k;\\n                sb.append((char)('a'+candidatePos));\\n            }\\n            return sb.toString();\\n        }\\n        \\n       private int findValidMax(int[] count, int[] valid, int index){\\n           int max = Integer.MIN_VALUE;\\n           int candidatePos = -1;\\n           for(int i=0;i<count.length;i++){\\n               if(count[i]>0 && count[i]>max && index>=valid[i]){\\n                   max = count[i];\\n                   candidatePos = i;\\n               }\\n           }\\n           return candidatePos;\\n       }\\n    }\\n\\nAt first I was considering using PriorityQueue and referring to this post:  \\n[c++ unordered_map priority_queue solution using cache][1]  \\nI have doubts for this solution. If we have \"abba\", k=2; It seems we might end up with \"abba\" as the result. Since in the second while loop, I'm not sure 'a' or 'b' will be polled out first.  \\nIn Java, when two keys in PriorityQueue have same value, there is no guarantee on the order poll() will return.  But I'm not sure how heap is implemented in C++.\\n\\n\\n  [1]: https://leetcode.com/discuss/108174/c-unordered_map-priority_queue-solution-using-cache"
		},
		{
			"lc_ans_id":"83192",
			"view":"8156",
			"top":"1",
			"title":"Java 7 version of PriorityQueue O(nlogn) with comments and explanations",
			"vote":"51",
			"content":"The greedy algorithm is that in each step, select the char with highest remaining count if possible (if it is not in the waiting queue). PQ is used to achieve the greedy. A regular queue waitQueue is used to \"freeze\" previous appeared char in the period of k.\\n\\nIn each iteration, we need to add current char to the waitQueue and also release the char at front of the queue, put back to maxHeap. The \"impossible\" case happens when the maxHeap is empty but there is still some char in the waitQueue.\\n\\n\\n    public class Solution {\\n        public String rearrangeString(String str, int k) {\\n            \\n            StringBuilder rearranged = new StringBuilder();\\n            //count frequency of each char\\n            Map<Character, Integer> map = new HashMap<>();\\n            for (char c : str.toCharArray()) {\\n                if (!map.containsKey(c)) {\\n                    map.put(c, 0);\\n                }\\n                map.put(c, map.get(c) + 1);\\n            }\\n            \\n            //construct a max heap using self-defined comparator, which holds all Map entries, Java is quite verbose\\n            Queue<Map.Entry<Character, Integer>> maxHeap = new PriorityQueue<>(new Comparator<Map.Entry<Character, Integer>>() {\\n                public int compare(Map.Entry<Character, Integer> entry1, Map.Entry<Character, Integer> entry2) {\\n                    return entry2.getValue() - entry1.getValue();\\n                }\\n            });\\n            \\n            Queue<Map.Entry<Character, Integer>> waitQueue = new LinkedList<>();\\n            maxHeap.addAll(map.entrySet());\\n            \\n            while (!maxHeap.isEmpty()) {\\n                \\n                Map.Entry<Character, Integer> current = maxHeap.poll();\\n                rearranged.append(current.getKey());\\n                current.setValue(current.getValue() - 1);\\n                waitQueue.offer(current);\\n                \\n                if (waitQueue.size() < k) { // intial k-1 chars, waitQueue not full yet\\n                    continue;\\n                }\\n                // release from waitQueue if char is already k apart\\n                Map.Entry<Character, Integer> front = waitQueue.poll();\\n                //note that char with 0 count still needs to be placed in waitQueue as a place holder\\n                if (front.getValue() > 0) {\\n                    maxHeap.offer(front);\\n                }\\n            }\\n            \\n            return rearranged.length() == str.length() ? rearranged.toString() : \"\";\\n        }\\n        \\n    }"
		},
		{
			"lc_ans_id":"83207",
			"view":"5553",
			"top":"2",
			"title":"C++ unordered_map priority_queue solution using cache",
			"vote":"31",
			"content":"key point: using cache during processing heap data.\\n\\nnew version:\\n\\n    class Solution {\\n    public:\\n        string rearrangeString(string str, int k) {\\n            if(k == 0) return str;\\n            int length = (int)str.size(); \\n            \\n            string res;\\n            unordered_map<char, int> dict;\\n            priority_queue<pair<int, char>> pq;\\n            \\n            for(char ch : str) dict[ch]++;\\n            for(auto it = dict.begin(); it != dict.end(); it++){\\n                pq.push(make_pair(it->second, it->first));\\n            }\\n            \\n            while(!pq.empty()){\\n                vector<pair<int, char>> cache; //store used char during one while loop\\n                int count = min(k, length); //count: how many steps in a while loop\\n                for(int i = 0; i < count; i++){\\n                    if(pq.empty()) return \"\";\\n                    auto tmp = pq.top();\\n                    pq.pop();\\n                    res.push_back(tmp.second);\\n                    if(--tmp.first > 0) cache.push_back(tmp);\\n                    length--;\\n                }\\n                for(auto p : cache) pq.push(p);\\n            }\\n            return res;\\n        }\\n    };\\n\\nold version:\\n\\n    class Solution {\\n        struct mycompare{\\n            bool operator()(pair<int, char>& p1, pair<int, char>& p2){\\n                if(p1.first == p2.first) return p1.second > p2.second;\\n                return p1.first < p2.first;\\n            }\\n        };\\n    public:\\n        string rearrangeString(string str, int k) {\\n            if(k == 0) return str;\\n            unordered_map<char, int> dict;\\n            for(char ch : str) dict[ch]++;\\n            int left = (int)str.size();\\n            priority_queue<pair<int, char>, vector<pair<int, char>>, mycompare > pq;\\n            for(auto it = dict.begin(); it != dict.end(); it++){\\n                pq.push(make_pair(it->second, it->first));\\n            }\\n            string res;\\n            \\n            while(!pq.empty()){\\n                vector<pair<int, char>> cache;\\n                int count = min(k, left);\\n                for(int i = 0; i < count; i++){\\n                    if(pq.empty()) return \"\";\\n                    auto tmp = pq.top();\\n                    pq.pop();\\n                    res.push_back(tmp.second);\\n                    if(--tmp.first > 0) cache.push_back(tmp);\\n                    left--;\\n                }\\n                for(auto p : cache){\\n                    pq.push(p);\\n                }\\n            }\\n            return res;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"83199",
			"view":"3332",
			"top":"3",
			"title":"Greedy Solution Beats 95%",
			"vote":"12",
			"content":"The idea is:\\n\\nfor example: \"aaabbcc\", k = 3\\n\\n1) Count the statistics of letters, sort them in terms of frequency in a descending way.\\n\\nso it has the result: a - 3, b - 2, c - 2.\\n\\n2) Suppose the rewrite string length is len, divide the len into bins of size k, so in total\\nyou have \\n\\nbin number of nBin = (len - 1) / k + 1, \\n\\nwith last bin size:\\n\\nlastBinSize = len % k.\\n\\nin the example, nBin = 3, lastBinSize = 1;\\n\\n3) Fill the same letter in different bins:\\n\\nafter filling 'a' ---> result = a##a##a\\n\\nafter filling 'b' ---> result = ab#ab#a\\n\\nafter filling 'c' ---> result = abcabca\\n\\nBelow is the implementation code:\\n\\n\\n    public class Solution {\\n        private final static int sizeAZ = 26;\\n        public String rearrangeString(String str, int k) {\\n            if (k <= 1) return str;\\n            char[] c = str.toCharArray();\\n            int[][] cnt = new int[sizeAZ][2];\\n            int len = c.length;\\n            for (int i = 0; i < sizeAZ; cnt[i][0] = i++); // save letter id\\n            for (int i = 0; i < len; c[i++] = '*')\\n                cnt[c[i] - 'a'][1]++;\\n            \\n            // Sort according to occurance frequency, descending\\n            Arrays.sort(cnt, new Comparator<int[]>(){\\n                @Override\\n                public int compare(int[] a, int[] b) {\\n                    return b[1] - a[1];\\n                }\\n            });\\n            \\n            int nBin = (len - 1) / k + 1, sizeLastBin = len % k;\\n            int[] idx = new int[nBin];\\n            //System.out.println(nBin + \",,,\" + sizeLastBin);\\n            for (int u = 0, i = 0; u < sizeAZ; u++) if (cnt[u][1] > 0) {\\n                char ch = (char)(cnt[u][0] + 'a');\\n                int m = cnt[u][1];\\n                if (m > nBin) return \"\"; // Bins are not enough for ch, for sure\\n                for (int y = 0; y < m; y++) {\\n                    while (idx[i] >= binSize(i, k, len)) \\n                        i = (i + 1) % nBin;\\n    \\n                    int offset = i * k;\\n                    if (idx[i] > 0 && c[offset + idx[i] - 1] == ch) \\n                        return \"\"; //same letter falls in same bin\\n                    c[offset + idx[i]++] = ch;\\n                    i = (i + 1) % nBin;\\n                }\\n            }\\n            return new String(c);\\n        }\\n        \\n        private int binSize(int i, int k, int len) {\\n            return Math.min(len - i * k, k);\\n        }\\n    } //14ms"
		},
		{
			"lc_ans_id":"83198",
			"view":"1971",
			"top":"4",
			"title":"20-line linear-time Python solution",
			"vote":"8",
			"content":"Each heap operation takes constant time since it holds at most 26 elements. So this allows `theta(n)` time.\\n\\n```\\nclass Solution(object):\\n    def rearrangeString(self, str, k):\\n        heap = [(-freq, char) \\n                for char, freq in collections.Counter(str).items()]\\n        heapq.heapify(heap)\\n        res = []\\n        while len(res) < len(str):\\n            if not heap: return \"\"\\n            freq, char = heapq.heappop(heap)\\n            stack = []\\n            res.append(char)\\n            for j in range(k - 1):\\n                if len(res) == len(str): return \"\".join(res)\\n                if not heap: return \"\"\\n                fre, nex = heapq.heappop(heap)\\n                res.append(nex)\\n                if fre < -1: \\n                    stack.append((fre+1, nex))\\n            while stack:\\n                heapq.heappush(heap, stack.pop())\\n            heapq.heappush(heap, (freq+1, char))\\n        return \"\".join(res)\\n\\n# 56 / 56 test cases passed.\\n# Status: Accepted\\n# Runtime: 328 ms\\n```"
		},
		{
			"lc_ans_id":"83205",
			"view":"2712",
			"top":"5",
			"title":"Java_solution_in_12_ms, O(N) time and space",
			"vote":"7",
			"content":"```\\nimport java.util.SortedSet;\\nimport java.util.TreeSet;\\nimport java.util.SortedMap;\\nimport java.util.TreeMap;\\n\\npublic class Solution {\\n    public String rearrangeString(String str, int k) {\\n        if (k < 2) return str;\\n        int[][] times = new int[26][2];\\n        for(int i = 0; i < 26; i++) times[i][1] = 'a'+i;\\n        for (int i = 0; i < str.length(); i++) {\\n            times[str.charAt(i) - 'a'][0]++;\\n        }\\n        Arrays.sort(times, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                return a[0] == b[0] ? Integer.compare(a[1], b[1]) : Integer.compare(b[0], a[0]);\\n            }\\n        });\\n\\n        int len = str.length(), maxlen = (len + k - 1)/k, count = 0, i = 0;\\n        if(times[0][0] > maxlen) return \"\";\\n        \\n        char[] res = new char[len];\\n        if((count = (len % k)) != 0){\\n            for(i = 0; i < 26; i++){\\n                if(times[i][0] < maxlen) break;\\n                if(i >= count) return \"\";\\n                for(int j = i; j < len; j += k) res[j] = (char)times[i][1];\\n            }\\n        }\\n        \\n        count = i; maxlen = i;\\n        for(int j = 25; j >= maxlen; j--){\\n            for(int t = 0; t < times[j][0]; t++){\\n                res[count] = (char)times[j][1];\\n                count += k;\\n                if(count >= len) count = ++i;\\n            }\\n        }\\n\\n        return new String(res);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"83252",
			"view":"957",
			"top":"6",
			"title":"Java AC Solution using PriorityQueue and HashMap",
			"vote":"5",
			"content":"        public String rearrangeString(String str, int k) {\\n        if (str == null || str.length() == 0) {\\n            return \"\";\\n        }\\n        if (k == 0) {\\n            return str;\\n        }\\n\\n        char[] arr = str.toCharArray();\\n        int n = arr.length;\\n\\n        Map<Character, Integer> map = new HashMap<>();\\n        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = arr[i];\\n            int count = map.getOrDefault(c, 0) + 1;\\n            map.put(c, count);\\n        }\\n        pq.addAll(map.entrySet());\\n\\n        Deque<Map.Entry<Character, Integer>> queue = new ArrayDeque<>(k);\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < n; i++) {\\n            if (pq.size() == 0) {\\n                return \"\";\\n            }\\n            Map.Entry<Character, Integer> entry = pq.remove();\\n            sb.append(entry.getKey());\\n            int newVal = entry.getValue() - 1;\\n            entry.setValue(newVal);\\n\\n            queue.offer(entry);\\n            if (queue.size() == k) {\\n                Map.Entry<Character, Integer> poll = queue.poll();\\n                if (poll.getValue() > 0) {\\n                    pq.add(poll);\\n                }\\n            }\\n        }\\n\\n        return sb.toString();\\n    }"
		},
		{
			"lc_ans_id":"83239",
			"view":"1190",
			"top":"7",
			"title":"C++ 16ms 18-line O(n) Short and Simple Solution with Detailed Explanation",
			"vote":"4",
			"content":"The idea is pretty simple.\\nfor example, you have (aaaabbbbcccddeef, 4) how would you do it:\\n\\n    0. Count how many occurrences of each character: a:4, b:4, c:3, d:2, e:1 \\n    1. put the most 2 characters (ab) at least k apart first as reference point:\\n    abXXabXXabXXab (X is empty position)\\n    2. then fill the gap with all other numbers from most frequency to least frequency like filling out a rotated array:\\n       2.1 fill with c first:  abCXabCXabCXab\\n       2.2 fill with d then: abcDabcDabcXab\\n       2.3 fill with e:    abcdEabcdabcEab    // Here, first E is actually put last, second E is put first, because we are filling gaps in rotated manner. Note, it doesn't matter if it runs out of empty space, just insert E after abcd anyway, it won't break anything;\\n       2.4 fill with f:   abcdeabcdfabceab //A valid solution is generated.\\n\\n    3. Finally, how to determine if there is a solution:\\n        It's easy: At step 2, if you can't fill all the all empty positions with remaining characters after step 1, there is no solution.\\n\\nThis is the code (It seems to be best to use a linked-list, but I find it easier to implement it this way. The code may be a bit harder to understand, but the idea is stated above.)\\n\\n    struct Solution {\\n        string rearrangeString(string str, int k) {\\n            int char_map [26] = {0};\\n            for (int i = 0 ;  i < str.size(); ++i)\\n                char_map[str[i] - 'a'] ++;\\n            multimap<int, char, greater<int>> count_map;\\n            for (int i = 0; i < 26; ++i)\\n                count_map.emplace(char_map[i], i + 'a');\\n            int max_cnt = count_map.begin()->first, pos = 0;\\n            string str_arr[max_cnt];\\n            for (auto iter = count_map.begin(); iter != count_map.end(); ++iter)\\n                for (int i = 0; i < iter->first; ++i, pos = (pos + 1) % max(iter->first, max_cnt - 1))\\n                    str_arr[pos].push_back(iter->second);\\n            string result;\\n            for (int i = 0; i < max_cnt - 1; ++i)\\n                if (str_arr[i].size() < k) return \"\";\\n                else result += str_arr[i];\\n            result += str_arr[max_cnt - 1];\\n            return result;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"83225",
			"view":"456",
			"top":"8",
			"title":"Short python solution, beat 87% other solutions.",
			"vote":"2",
			"content":"```\\nclass Solution(object):\\n    def rearrangeString(self, str, k):\\n        if k == 0: return str\\n        counts = collections.Counter(str)\\n        heap = [[counts[key], key] for key in counts]\\n        res, j = ['']*len(str), 0\\n        while j < len(str):\\n            heap.sort(reverse=True)\\n            for i in range(k):\\n                if i >= len(heap) or heap[i][0] == 0:\\n                    return ''.join(res) if j == len(str) else ''\\n                res[j] = heap[i][1]\\n                heap[i][0] -= 1\\n                j += 1\\n        return ''.join(res)\\n``"
		},
		{
			"lc_ans_id":"83220",
			"view":"245",
			"top":"9",
			"title":"Don't understand a test case",
			"vote":"1",
			"content":"```\"bbabcaccaaabababbaaaaccbbcbacbacacccbbcaabcbcacaaccbabbbbbcacccaccbab\"```\\n```0```\\nCould someone explain how this answer can make sense ?\\nExpected: \\n```\"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc\"```"
		}
	],
	"id":"358",
	"title":"Rearrange String k Distance Apart",
	"content":"<p>\r\nGiven a non-empty string <b>s</b> and an integer <b>k</b>, rearrange the string such that the same characters are at least distance <b>k</b> from each other.\r\n</p>\r\n<p>\r\nAll input strings are given in lowercase letters. If it is not possible to rearrange the string, return an empty string <code>\"\"</code>.\r\n</p>\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\ns = \"aabbcc\", k = 3\r\n\r\nResult: \"abcabc\"\r\n\r\nThe same letters are at least distance 3 from each other.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\ns = \"aaabc\", k = 3 \r\n\r\nAnswer: \"\"\r\n\r\nIt is not possible to rearrange the string.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\ns = \"aaadbbcc\", k = 2\r\n\r\nAnswer: \"abacabcd\"\r\n\r\nAnother possible answer is: \"abcabcda\"\r\n\r\nThe same letters are at least distance 2 from each other.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://discuss.leetcode.com/user/elmirap\">@elmirap</a> for adding this problem and creating all test cases.</p>",
	"frequency":"95",
	"ac_num":"13111"
}