{
	"difficulty":"2",
	"submit_num":"53223",
	"show_id":"361",
	"leetcode_id":"361",
	"answers":[
		{
			"lc_ans_id":"83387",
			"view":"36445",
			"top":"0",
			"title":"Short O(mn) time O(n) space solution",
			"vote":"152",
			"content":"Walk through the matrix. At the start of each non-wall-streak (row-wise or column-wise), count the number of hits in that streak and remember it. O(mn) time, O(n) space.\\n\\n    int maxKilledEnemies(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0;\\n        int result = 0, rowhits, colhits[n];\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (!j || grid[i][j-1] == 'W') {\\n                    rowhits = 0;\\n                    for (int k=j; k<n && grid[i][k] != 'W'; k++)\\n                        rowhits += grid[i][k] == 'E';\\n                }\\n                if (!i || grid[i-1][j] == 'W') {\\n                    colhits[j] = 0;\\n                    for (int k=i; k<m && grid[k][j] != 'W'; k++)\\n                        colhits[j] += grid[k][j] == 'E';\\n                }\\n                if (grid[i][j] == '0')\\n                    result = max(result, rowhits + colhits[j]);\\n            }\\n        }\\n        return result;\\n    }"
		},
		{
			"lc_ans_id":"83383",
			"view":"16187",
			"top":"1",
			"title":"Simple DP solution in Java",
			"vote":"85",
			"content":" only need to store one killed enemies value for a row and an array of each column; \\nif current grid value is W, this means previous stored value becomes invalid, you need to recalculate. \\n\\n\\n     public int maxKilledEnemies(char[][] grid) {\\n        if(grid == null || grid.length == 0 ||  grid[0].length == 0) return 0;\\n        int max = 0;\\n        int row = 0;\\n        int[] col = new int[grid[0].length];\\n        for(int i = 0; i<grid.length; i++){\\n            for(int j = 0; j<grid[0].length;j++){\\n                if(grid[i][j] == 'W') continue;\\n                if(j == 0 || grid[i][j-1] == 'W'){\\n                     row = killedEnemiesRow(grid, i, j);\\n                }\\n                if(i == 0 || grid[i-1][j] == 'W'){\\n                     col[j] = killedEnemiesCol(grid,i,j);\\n                }\\n                if(grid[i][j] == '0'){\\n                    max = (row + col[j] > max) ? row + col[j] : max;\\n                }\\n            }\\n\\n        }\\n        \\n        return max;\\n    }\\n\\n    //calculate killed enemies for row i from column j\\n    private int killedEnemiesRow(char[][] grid, int i, int j){\\n        int num = 0;\\n        while(j <= grid[0].length-1 && grid[i][j] != 'W'){\\n            if(grid[i][j] == 'E') num++;\\n            j++;\\n        }\\n        return num;\\n    }\\n    //calculate killed enemies for  column j from row i\\n    private int killedEnemiesCol(char[][] grid, int i, int j){\\n        int num = 0;\\n        while(i <= grid.length -1 && grid[i][j] != 'W'){\\n            if(grid[i][j] == 'E') num++;\\n            i++;\\n        }\\n        return num;\\n    }"
		},
		{
			"lc_ans_id":"83391",
			"view":"5840",
			"top":"2",
			"title":"Java straightforward solution DP O(mn) time and space",
			"vote":"38",
			"content":"The code might be a little bit long and there should exist more elegant one.\\nHowever the idea of this very straightforward. We do simply two traversals. One from upper left to bottom right, for each spot we compute enemies to its left and up including itself. The other traversal is from bottom right to upper left, we compute enemies to its right and down and in the same time we add them up all to find the maxKill. Any suggestion to make it more concise?\\n\\n\\n    public class Solution {\\n        public int maxKilledEnemies(char[][] grid) {\\n            if (grid == null || grid.length == 0) {\\n                return 0;\\n            }\\n            int m = grid.length, n = grid[0].length;\\n            Spot[][] spots = new Spot[m][n];\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    spots[i][j] = new Spot();\\n                    if (grid[i][j] == 'W') {\\n                        continue;\\n                    }\\n                    spots[i][j].up = (i == 0 ? 0 : spots[i - 1][j].up) + (grid[i][j] == 'E' ? 1 : 0);\\n                    spots[i][j].left = (j == 0 ? 0 : spots[i][j - 1].left) + (grid[i][j] == 'E' ? 1 : 0);\\n                }\\n            }\\n            \\n            int maxKill = 0;\\n            for (int i = m - 1; i >= 0; i--) {\\n                for (int j = n - 1; j >= 0; j--) {\\n                    if (grid[i][j] == 'W') {\\n                        continue;\\n                    }\\n                    spots[i][j].bottom = (i == m - 1 ? 0 : spots[i + 1][j].bottom) + (grid[i][j] == 'E' ? 1 : 0);\\n                    spots[i][j].right = (j == n - 1 ? 0 : spots[i][j + 1].right) + (grid[i][j] == 'E' ? 1 : 0);\\n                    \\n                    if (grid[i][j] == '0') {\\n                        maxKill = Math.max(maxKill, spots[i][j].up + spots[i][j].left + spots[i][j].bottom + spots[i][j].right);\\n                    }\\n                }\\n            }\\n            return maxKill;\\n        }\\n    }\\n    \\n    class Spot {\\n        int up; // enemies to its up including itself\\n        int left; // enemies to its left including itself\\n        int bottom;\\n        int right;\\n    }"
		},
		{
			"lc_ans_id":"83385",
			"view":"4036",
			"top":"3",
			"title":"Easy-understanding concise C++ O(mn) solution",
			"vote":"11",
			"content":"Borrow the idea from [Product of Array Except Self][1]. \\n\\nCreate a 2D array `count`, where `count[i][j]` indicates how many enemies can be bombed if placing a bomb here. For each row/column, use `head` to keep track of how many enemies can be bombed from the beginning to current position, use `tail` to record how many enemies can be bombed from the end to current position. Then update `count[i][j]`.\\n\\nFor `head`, If **grid[i][j] == \\u2018W\\u2019**, set it to **0**; else if **grid[i][j] == \\u2018E\\u2019**, **add 1** to it. Same for `tail`.\\n\\nWe can combine the updating of `head` and `tail` into one loop so that each row/column will only be traversed once.\\n\\n\\n----------\\n\\n    class Solution {\\n    public:\\n        int maxKilledEnemies(vector<vector<char>>& grid) {\\n            int i, j, row = grid.size(), col, result, head, tail;\\n            if(row == 0 || (col = grid[0].size()) == 0)\\n                return 0;\\n            vector<vector<int> > count(row, vector<int>(col, 0));\\n            for(i = 0; i < row; i++) {\\n                for(head = tail = j = 0; j < col; j++) {\\n                    count[i][j] = grid[i][j] != '0' ? 0 : (count[i][j] + head);\\n                    count[i][col - 1 - j] = grid[i][col - 1 - j] != '0' ? 0 : (count[i][col - 1 - j] + tail);\\n                    head = grid[i][j] == 'W' ? 0 : (head + (grid[i][j] == 'E' ? 1 : 0));\\n                    tail = grid[i][col - 1 - j] == 'W' ? 0 : (tail + (grid[i][col - 1 - j] == 'E' ? 1 : 0));\\n                }\\n            }\\n            for(j = 0; j < col; j++) {\\n                for(head = tail = i = 0; i < row; i++) {\\n                    count[i][j] = grid[i][j] != '0' ? 0 : (count[i][j] + head);\\n                    count[row - 1 - i][j] = grid[row - 1 - i][j] != '0' ? 0 : (count[row - 1 - i][j] + tail);\\n                    head = grid[i][j] == 'W' ? 0 : (head + (grid[i][j] == 'E' ? 1 : 0));\\n                    tail = grid[row - 1 - i][j] == 'W' ? 0 : (tail + (grid[row - 1 - i][j] == 'E' ? 1 : 0));\\n                }\\n            }\\n            for(i = result = 0; i < row; i++) {\\n                for(j = 0; j < col; j++) {\\n                    result = max(result, count[i][j]);\\n                }\\n            }\\n            return result;\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/product-of-array-except-self/"
		},
		{
			"lc_ans_id":"83467",
			"view":"2973",
			"top":"4",
			"title":"Straightforward O(mn) Java Solution - 49ms",
			"vote":"8",
			"content":"    public int maxKilledEnemies(char[][] grid) {\\n        int rowNum = grid.length;\\n        if (rowNum == 0) return 0;\\n        int colNum = grid[0].length;\\n\\n        int[][] fromBottom = new int[rowNum][colNum];\\n        int[][] fromRight = new int[rowNum][colNum];\\n\\n        for (int i = rowNum - 1; i >= 0; i--) {\\n            for (int j = colNum - 1; j >= 0; j--) {\\n                int enemy = grid[i][j] == 'E' ? 1 : 0;\\n                if (grid[i][j] != 'W') {\\n                    fromBottom[i][j] = (i == rowNum - 1) ? enemy : fromBottom[i+1][j] + enemy;\\n                    fromRight[i][j] = (j == colNum - 1) ? enemy : fromRight[i][j+1] + enemy;\\n                }\\n                else {\\n                    fromBottom[i][j] = 0;\\n                    fromRight[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int[] fromTop = new int[colNum];\\n        int[] fromLeft = new int[rowNum];\\n        int max = 0;\\n\\n        for (int i = 0; i < rowNum; i++) {\\n            for (int j = 0; j < colNum; j++) {\\n                if (grid[i][j] != '0') {\\n                    fromTop[j] = grid[i][j] == 'W' ? 0 : fromTop[j] + 1;\\n                    fromLeft[i] = grid[i][j] == 'W' ? 0 : fromLeft[i] + 1;\\n                }\\n                else {\\n                    int num = fromTop[j] + fromLeft[i] + fromBottom[i][j] + fromRight[i][j];\\n                    max = Math.max(num, max);\\n                }\\n            }\\n        }\\n        return max;\\n    }"
		},
		{
			"lc_ans_id":"83466",
			"view":"2681",
			"top":"5",
			"title":"Short O(mn) Python",
			"vote":"7",
			"content":"Compute a matrix for row-wise hits and one for column-wise hits. Then find the maximum.\\n\\n    def maxKilledEnemies(self, grid):\\n        def hits(grid):\\n            return [[h\\n                     for block in ''.join(row).split('W')\\n                     for h in [block.count('E')] * len(block) + [0]]\\n                    for row in grid]\\n        rowhits = hits(grid)\\n        colhits = zip(*hits(zip(*grid)))\\n        return max([rh + ch\\n                    for row in zip(grid, rowhits, colhits)\\n                    for cell, rh, ch in zip(*row)\\n                    if cell == '0'] or [0])"
		},
		{
			"lc_ans_id":"83414",
			"view":"1034",
			"top":"6",
			"title":"Super stupid solution -:) Beat 92.93%",
			"vote":"6",
			"content":"```\\npublic class Solution {\\n    public int maxKilledEnemies(char[][] grid) {\\n        if (grid.length == 0 || grid[0].length == 0) return 0;\\n        int m = grid.length, n = grid[0].length;\\n        int[][] count = new int[m][n];\\n        int res = 0;\\n        for (int i = 0; i < m; i++) {\\n            int tmp = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 'E') tmp++;\\n                if (grid[i][j] == 'W') tmp = 0;\\n                if (grid[i][j] == '0') {\\n                    count[i][j] += tmp;\\n                    res = Math.max(count[i][j], res);\\n                }\\n            }\\n            tmp = 0;\\n            for (int j = n-1; j >= 0; j--) {\\n                if (grid[i][j] == 'E') tmp++;\\n                if (grid[i][j] == 'W') tmp = 0;\\n                if (grid[i][j] == '0') {\\n                    count[i][j] += tmp;\\n                    res = Math.max(count[i][j], res);\\n                }\\n            }\\n        }\\n        for (int j = 0; j < n; j++) {\\n            int tmp = 0;\\n            for (int i = 0; i < m; i++) {\\n                if (grid[i][j] == 'E') tmp++;\\n                if (grid[i][j] == 'W') tmp = 0;\\n                if (grid[i][j] == '0') {\\n                    count[i][j] += tmp;\\n                    res = Math.max(count[i][j], res);\\n                }\\n            }\\n            tmp = 0;\\n            for (int i = m-1; i >= 0; i--) {\\n                if (grid[i][j] == 'E') tmp++;\\n                if (grid[i][j] == 'W') tmp = 0;\\n                if (grid[i][j] == '0') {\\n                    count[i][j] += tmp;\\n                    res = Math.max(count[i][j], res);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nCompared with this [solution](https://discuss.leetcode.com/topic/48565/short-o-mn-solution), which is shorter. But it seems it yet slower, beats 50%... Below is the Java version of that solution.\\n```\\npublic class Solution {\\n    public int maxKilledEnemies(char[][] grid) {\\n        if (grid.length == 0 || grid[0].length == 0) return 0;\\n        int m = grid.length, n = grid[0].length;\\n        int rowCount = 0, res = 0;\\n        int[] colCount = new int[n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (j == 0 || grid[i][j-1] == 'W') {\\n                    rowCount = 0;\\n                    for (int k = j; k < n && grid[i][k] != 'W'; k++) {\\n                        rowCount += (grid[i][k] == 'E') ? 1 : 0;\\n                    }\\n                }\\n                if (i == 0 || grid[i-1][j] == 'W') {\\n                    colCount[j] = 0;\\n                    for (int k = i; k < m && grid[k][j] != 'W'; k++) {\\n                        colCount[j] += (grid[k][j] == 'E') ? 1 : 0; \\n                    }\\n                }\\n                if (grid[i][j] == '0') {\\n                    res = Math.max(res, colCount[j] + rowCount);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"83444",
			"view":"1410",
			"top":"7",
			"title":"Super straightforward Java solution",
			"vote":"5",
			"content":"Didn't use fancy algorithms or data structures like others did. Just used the plain idea:\\nSince a wall blocks one bomb in its direction, we can just count all possible enemies one can hit in all four directions and store the count for each empty call in a matrix called max, then return the max in this max matrix.\\nI know this algorithm definitely could be optimized, but just would like to let people know one option is out here.\\n\\n    public int maxKilledEnemies(char[][] grid) {\\n        int m = grid.length;\\n        if(grid == null || m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        int[][] max = new int[m][n];\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                \\n                if(grid[i][j] == '0'){\\n                    int count = 0;\\n                    \\n                    //count all possible hits in its upward direction\\n                    for(int k = j-1; k >= 0; k--){\\n                        if(grid[i][k] == 'E') {\\n                            count++;\\n                        } else if(grid[i][k] == 'W') {\\n                            break;\\n                        }\\n                    }\\n                    \\n                    //count all possible hits in its downward direction\\n                    for(int k = j+1; k < n; k++){\\n                        if(grid[i][k] == 'E') {\\n                            count++;\\n                        } else if(grid[i][k] == 'W') {\\n                            break;\\n                        }\\n                    }\\n                    \\n                    //count all possible hits in its right direction\\n                    for(int k = i+1; k < m; k++){\\n                        if(grid[k][j] == 'E') {\\n                            count++;\\n                        } else if(grid[k][j] == 'W') {\\n                            break;\\n                        }\\n                    }\\n                    \\n                    //count all possible hits in its left direction\\n                    for(int k = i-1; k >= 0; k--){\\n                        if(grid[k][j] == 'E') {\\n                            count++;\\n                        } else if(grid[k][j] == 'W') {\\n                            break;\\n                        }\\n                    }\\n                    \\n                    max[i][j] = count;\\n                    \\n                } \\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(max[i][j] > result) result = max[i][j];\\n            }\\n        }\\n        return result;\\n    }"
		},
		{
			"lc_ans_id":"83405",
			"view":"177",
			"top":"8",
			"title":"Python Brute Force O((mn)*(m+n)) to DP O(mn)",
			"vote":"4",
			"content":"The brute force solution is very intuitive.. just count 'E's in rows and cols for each 0 in the matrix and return the maximum. This takes O((mn)*(m+n)) as you have to traverse up, down, left, and right for every i,j.\\n\\nWe can optimize on this by doing 4 passes and adding the number of E's seen so far, and reset if we see a 'W'.\\nFrom left to right then right to left for E's seen in each row. And then from up to down and down to up for each E seen so far in column.\\n\\nTotal time -> O(4*mn) --> O(mn)\\n```\\nclass Solution(object):\\n    def maxKilledEnemies(self, grid):\\n        if len(grid) == 0:\\n            return 0\\n        max_hits = 0\\n        nums = [[0 for i in range(len(grid[0]))] for j in range(len(grid))]\\n        \\n        #From Left\\n        for i in range(len(grid)):\\n            row_hits = 0\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 'E':\\n                    row_hits += 1\\n                elif grid[i][j] == 'W':\\n                    row_hits = 0\\n                else:\\n                    nums[i][j] = row_hits\\n                \\n        #From Right\\n        for i in range(len(grid)):\\n            row_hits = 0\\n            for j in range(len(grid[0])-1, -1, -1):\\n                if grid[i][j] == 'W':\\n                    row_hits = 0\\n                elif grid[i][j] == 'E':\\n                    row_hits +=1\\n                else:\\n                    nums[i][j] += row_hits\\n\\n        for i in range(len(nums[0])):\\n            col_hits = 0\\n            for col in range(len(nums)):\\n                if grid[col][i] == 'E':\\n                    col_hits += 1\\n                elif grid[col][i] == 'W':\\n                    col_hits = 0\\n                else:\\n                    nums[col][i] += col_hits\\n\\n        for i in range(len(nums[0])):\\n            col_hits = 0\\n            for col in range(len(nums)-1, -1, -1):\\n                if grid[col][i] == 'E':\\n                    col_hits +=1\\n                elif grid[col][i] == 'W':\\n                    col_hits = 0\\n                else:\\n                    nums[col][i] += col_hits\\n                    max_hits = max(max_hits, nums[col][i])\\n\\n\\n        return max_hits\\n\\n```"
		},
		{
			"lc_ans_id":"83461",
			"view":"3502",
			"top":"9",
			"title":"Too strict time limit on Python?",
			"vote":"4",
			"content":"Same idea as @StefanPochmann posted but cannot get accepted. I think the last test case is too large for Python to pass it.\\n\\n    class Solution(object):\\n        def maxKilledEnemies(self, grid):\\n            \"\"\"\\n            :type grid: List[List[str]]\\n            :rtype: int\\n            \"\"\"\\n            if grid is None or len(grid) == 0 or len(grid[0]) == 0:\\n                return 0\\n    \\n            dp = [[[0, 0] for j in range(len(grid[0]))] for i in range(len(grid))]\\n            for i in xrange(0, len(grid)):\\n                for j in xrange(0, len(grid[0])):\\n                    if grid[i][j] == \"E\":\\n                        dp[i][j] = [dp[i - 1][j][0] + 1,  + dp[i][j - 1][1] + 1]\\n                    elif grid[i][j] == \"0\":\\n                        dp[i][j] = [dp[i - 1][j][0], dp[i][j - 1][1]]\\n    \\n            maxKilled = 0\\n            for i in reversed(xrange(0, len(grid))):\\n                for j in reversed(xrange(0, len(grid[0]))):\\n                    if j != len(grid[0]) - 1:\\n                        if grid[i][j + 1] != \"W\":\\n                            dp[i][j][1] = dp[i][j + 1][1]\\n                    if i != len(grid) - 1:\\n                        if grid[i + 1][j] != \"W\":\\n                            dp[i][j][0] = dp[i + 1][j][0]\\n                    if grid[i][j] == \"0\":\\n                        curKilled = dp[i][j][0] + dp[i][j][1]\\n                        if curKilled > maxKilled:\\n                            maxKilled = curKilled \\n    \\n            return maxKilled"
		}
	],
	"id":"361",
	"title":"Bomb Enemy",
	"content":"<p>Given a 2D grid, each cell is either a wall <code>'W'</code>, an enemy <code>'E'</code> or empty <code>'0'</code> (the number zero), return the maximum enemies you can kill using one bomb.<br/> The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.<br/>\r\n Note that you can only put the bomb at an empty cell. </p>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\nFor the given grid\r\n\r\n0 E 0 0\r\nE 0 W E\r\n0 E 0 0\r\n\r\nreturn 3. (Placing a bomb at (1,1) kills 3 enemies)\r\n</pre>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://discuss.leetcode.com/user/memoryless\">@memoryless</a> for adding this problem and creating all test cases.</p>",
	"frequency":"174",
	"ac_num":"21279"
}