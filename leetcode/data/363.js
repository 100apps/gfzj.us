{
	"difficulty":"3",
	"submit_num":"52827",
	"show_id":"363",
	"leetcode_id":"363",
	"answers":[
		{
			"lc_ans_id":"83599",
			"view":"27450",
			"top":"0",
			"title":"Accepted C++ codes with explanation and references",
			"vote":"140",
			"content":"The naive solution is brute-force, which is O((mn)^2). In order to be more efficient, I tried something similar to Kadane's algorithm. The only difference is that here we have upper bound restriction K. Here's the easily understanding video link for the problem \"find the max sum rectangle in 2D array\": [Maximum Sum Rectangular Submatrix in Matrix dynamic programming/2D kadane][1] (Trust me, it's really easy and straightforward). \\n\\nOnce you are clear how to solve the above problem, the next step is to find the max sum no more than K in an array. This can be done within O(nlogn), and you can refer to this article: [max subarray sum no more than k][2].\\n\\nFor the solution below, I assume that the number of rows is larger than the number of columns. Thus in general time complexity is O[min(m,n)^2 * max(m,n) * log(max(m,n))], space O(max(m, n)).\\n\\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        if (matrix.empty()) return 0;\\n        int row = matrix.size(), col = matrix[0].size(), res = INT_MIN;\\n        for (int l = 0; l < col; ++l) {\\n            vector<int> sums(row, 0);\\n            for (int r = l; r < col; ++r) {\\n                for (int i = 0; i < row; ++i) {\\n                    sums[i] += matrix[i][r];\\n                }\\n                \\n                // Find the max subarray no more than K \\n                set<int> accuSet;\\n                accuSet.insert(0);\\n                int curSum = 0, curMax = INT_MIN;\\n                for (int sum : sums) {\\n                    curSum += sum;\\n                    set<int>::iterator it = accuSet.lower_bound(curSum - k);\\n                    if (it != accuSet.end()) curMax = std::max(curMax, curSum - *it);\\n                    accuSet.insert(curSum);\\n                }\\n                res = std::max(res, curMax);\\n            }\\n        }\\n        return res;\\n    }\\n\\n  [1]: https://www.youtube.com/watch?v=yCQN096CwWM\\n  [2]: https://www.quora.com/Given-an-array-of-integers-A-and-an-integer-k-find-a-subarray-that-contains-the-largest-sum-subject-to-a-constraint-that-the-sum-is-less-than-k"
		},
		{
			"lc_ans_id":"83597",
			"view":"13595",
			"top":"1",
			"title":"Java Binary Search solution time complexity min(m,n)^2*max(m,n)*log(max(m,n))",
			"vote":"48",
			"content":"\\n    /* first  consider the situation matrix is 1D\\n        we can save every sum of 0~i(0<=i<len) and binary search previous sum to find \\n        possible result for every index, time complexity is O(NlogN).\\n        so in 2D matrix, we can sum up all values from row i to row j and create a 1D array \\n        to use 1D array solution.\\n        If col number is less than row number, we can sum up all values from col i to col j \\n        then use 1D array solution.\\n    */\\n    public int maxSumSubmatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        if(row==0)return 0;\\n        int col = matrix[0].length;\\n        int m = Math.min(row,col);\\n        int n = Math.max(row,col);\\n        //indicating sum up in every row or every column\\n        boolean colIsBig = col>row;\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 0;i<m;i++){\\n            int[] array = new int[n];\\n            // sum from row j to row i\\n            for(int j = i;j>=0;j--){\\n                int val = 0;\\n                TreeSet<Integer> set = new TreeSet<Integer>();\\n                set.add(0);\\n                //traverse every column/row and sum up\\n                for(int k = 0;k<n;k++){\\n                    array[k]=array[k]+(colIsBig?matrix[j][k]:matrix[k][j]);\\n                    val = val + array[k];\\n                    //use  TreeMap to binary search previous sum to get possible result \\n                    Integer subres = set.ceiling(val-target);\\n                    if(null!=subres){\\n                        res=Math.max(res,val-subres);\\n                    }\\n                    set.add(val);\\n                }\\n            }\\n        }\\n        return res;\\n    }"
		},
		{
			"lc_ans_id":"83618",
			"view":"8887",
			"top":"2",
			"title":"2 Accepted Java Solution",
			"vote":"24",
			"content":"Decide to post because I was actually asked this question during my interview!\\nThere is a simple version of O(n^4).\\nThe idea is to calculate every rectangle [[r1,c1], [r2,c2]], and simply pick the max area <= k.\\nAn improved version takes O(n^3logn). It borrows the idea to find max subarray with sum <= k in 1D array, and apply here: we find all rectangles bounded between r1 & r2, with columns from 0 to end. Pick a pair from tree.\\nI remember the interviewer said there could be an even better solution, but I haven't figured that out...\\n\\nSolution I, O(n^4):\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] areas = new int[rows][cols];\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                int area = matrix[r][c];\\n                if (r-1 >= 0)\\n                    area += areas[r-1][c];\\n                if (c-1 >= 0)\\n                    area += areas[r][c-1];\\n                if (r-1 >= 0 && c-1 >= 0)\\n                    area -= areas[r-1][c-1];\\n                areas[r][c] = area;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int r1 = 0; r1 < rows; r1++) {\\n            for (int c1 = 0; c1 < cols; c1++) {\\n                for (int r2 = r1; r2 < rows; r2++) {\\n                    for (int c2 = c1; c2 < cols; c2++) {\\n                        int area = areas[r2][c2];\\n                        if (r1-1 >= 0)\\n                            area -= areas[r1-1][c2];\\n                        if (c1-1 >= 0)\\n                            area -= areas[r2][c1-1];\\n                        if (r1-1 >= 0 && c1 -1 >= 0)\\n                            area += areas[r1-1][c1-1];\\n                        if (area <= k)\\n                            max = Math.max(max, area);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\nSolution II (O(n^3logn)\\n\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] areas = new int[rows][cols];\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                int area = matrix[r][c];\\n                if (r-1 >= 0)\\n                    area += areas[r-1][c];\\n                if (c-1 >= 0)\\n                    area += areas[r][c-1];\\n                if (r-1 >= 0 && c-1 >= 0)\\n                    area -= areas[r-1][c-1];\\n                areas[r][c] = area;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int r1 = 0; r1 < rows; r1++) {\\n            for (int r2 = r1; r2 < rows; r2++) {\\n                TreeSet<Integer> tree = new TreeSet<>();\\n                tree.add(0);    // padding\\n                for (int c = 0; c < cols; c++) {\\n                    int area = areas[r2][c];\\n                    if (r1-1 >= 0)\\n                        area -= areas[r1-1][c];\\n                    Integer ceiling = tree.ceiling(area - k);\\n                    if (ceiling != null)\\n                        max = Math.max(max, area - ceiling);\\n                    tree.add(area);\\n                }\\n            }\\n        }\\n        return max;\\n    }"
		},
		{
			"lc_ans_id":"83595",
			"view":"4324",
			"top":"3",
			"title":"JAVA 117ms, beat 99.81%, merge sort",
			"vote":"20",
			"content":"```\\n/*\\n * If # of columns is smaller, process one set of columns [i..j) at a time, for each different i<j.\\n * For one set of colums [i..j), do it like \"Count of Range Sum\".\\n * O(n) = n^2 * mlogm.\\n * Assume we have such result.\\n */\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length, n = matrix[0].length, ans = Integer.MIN_VALUE;\\n        long[] sum = new long[m+1]; // stores sum of rect[0..p][i..j]\\n        for (int i = 0; i < n; ++i) {\\n            long[] sumInRow = new long[m];\\n            for (int j = i; j < n; ++j) { // for each rect[*][i..j]\\n                for (int p = 0; p < m; ++p) {\\n                    sumInRow[p] += matrix[p][j];\\n                    sum[p+1] = sum[p] + sumInRow[p];\\n                }\\n                ans = Math.max(ans, mergeSort(sum, 0, m+1, k));\\n                if (ans == k) return k;\\n            }\\n        }\\n        return ans;\\n    }\\n    int mergeSort(long[] sum, int start, int end, int k) {\\n        if (end == start+1) return Integer.MIN_VALUE; // need at least 2 to proceed\\n        int mid = start + (end - start)/2, cnt = 0;\\n        int ans = mergeSort(sum, start, mid, k);\\n        if (ans == k) return k;\\n        ans = Math.max(ans, mergeSort(sum, mid, end, k));\\n        if (ans == k) return k;\\n        long[] cache = new long[end-start];\\n        for (int i = start, j = mid, p = mid; i < mid; ++i) {\\n            while (j < end && sum[j] - sum[i] <= k) ++j;\\n            if (j-1 >= mid) {\\n                ans = Math.max(ans, (int)(sum[j-1] - sum[i]));\\n                if (ans == k) return k;\\n            }\\n            while (p < end && sum[p] < sum[i]) cache[cnt++] = sum[p++];\\n            cache[cnt++] = sum[i];\\n        }\\n        System.arraycopy(cache, 0, sum, start, cnt);\\n        return ans;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"83596",
			"view":"4888",
			"top":"4",
			"title":"Any Accepted Python Solution?",
			"vote":"7",
			"content":"I got a TLE for the Python code below, because the time cost of bisect.insort is O(n) for a built-in list.\\n\\nThe code was rejudged as accepted just now, but very slow... 1800ms+\\n\\n    class Solution(object):\\n        def maxSumSubmatrix(self, matrix, k):\\n            \"\"\"\\n            :type matrix: List[List[int]]\\n            :type k: int\\n            :rtype: int\\n            \"\"\"\\n            m = len(matrix)\\n            n = len(matrix[0]) if m else 0\\n            \\n            M = max(m, n)\\n            N = min(m, n)\\n            ans = None\\n            for x in range(N):\\n                sums = [0] * M\\n                for y in range(x, N):\\n                    slist, num = [], 0\\n                    for z in range(M):\\n                        sums[z] += matrix[z][y] if m > n else matrix[y][z]\\n                        num += sums[z]\\n                        if num <= k: ans = max(ans, num)\\n                        i = bisect.bisect_left(slist, num - k)\\n                        if i != len(slist): ans = max(ans, num - slist[i])\\n                        bisect.insort(slist, num)\\n            return ans or 0\\n\\nCould anybody share a more efficient Python solution? Thank you :D"
		},
		{
			"lc_ans_id":"83601",
			"view":"911",
			"top":"5",
			"title":"C++ 46ms solution,beats 99.78%",
			"vote":"3",
			"content":"class Solution {\\npublic:\\n     \\n    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size();\\n        int res=INT_MIN;\\n        for(int i=0;i<n;i++) {  // the number of columns is smaller\\n            vector<int> sums(m,0);\\n            for(int j=i;j<n;j++) {\\n                for(int row=0;row<m;row++) {\\n                    sums[row]+=matrix[row][j];\\n                }\\n                int ms = maxSumArray(sums, k);\\n                if (ms == k) return ms;\\n                if (ms < k && ms > res) res = ms;\\n          \\n            }\\n        }\\n        return res;\\n    }\\n     \\n    int maxSumArray(vector<int> & arr, int k) {\\n        int sum = 0, maxS = INT_MIN;\\n        for (int i = 0; i < arr.size(); i++) {  //it's a trick. Maybe O(n) to solve this problem\\n            sum += arr[i];\\n            maxS = max(sum, maxS);\\n            if (sum == k ) return sum;\\n            if (sum < 0) sum = 0;\\n        }\\n        if (maxS <= k) return maxS;\\n        maxS= INT_MIN;\\n        set<int>sums;\\n        sum = 0;\\n        sums.insert(0);\\n        for (int i = 0; i < arr.size(); i++) {\\n            sum += arr[i];\\n            auto it = sums.lower_bound(sum - k);\\n            if (it != sums.end()) maxS = max(sum - *it, maxS);\\n            sums.insert(sum);\\n        }\\n        return maxS;\\n    }  \\n};"
		},
		{
			"lc_ans_id":"83621",
			"view":"1250",
			"top":"6",
			"title":"No real DP technique actually used C++, critically commented",
			"vote":"3",
			"content":"The last section of the solution can be tricky, but read it carefully and I believe you can get it done! \\n\\n**Good luck!**\\n\\n    class Solution {\\n    public:\\n        int maxSumSubmatrix(vector<vector<int>>& matrix, int k) \\n        {\\n            if(matrix.empty()) return 0;\\n            int rowSize = matrix.size(), colSize = matrix[0].size();\\n            int ret = INT_MIN;\\n            for(int l = 0; l < colSize; ++l) //starting leftmost column;\\n            {\\n                vector<int> sums(rowSize, 0); //store the row pre-sums;\\n                for(int c = l; c < colSize; ++c) //try different ending columns;\\n                {\\n                    for(int r = 0; r < rowSize; ++r) //sum them up in rows;\\n                        sums[r] += matrix[r][c];\\n                    set<int> sums_set; //store the sums from the starting top-left;\\n                    sums_set.insert(0); //as a sentinel;\\n                    int maxSum = INT_MIN, sum = 0;\\n                    for(int i = 0; i < rowSize; ++i)\\n                    {\\n                        sum += sums[i]; //the sum from the starting top-left to current position;\\n                        auto iter = sums_set.lower_bound(sum-k); //check the possible sum candidates;\\n                        if(iter != sums_set.end()) maxSum = max(maxSum, sum-*iter); //found one, check it;\\n                        sums_set.insert(sum);\\n                    }\\n                    ret = max(ret, maxSum);\\n                }\\n            }\\n            return ret;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"83614",
			"view":"542",
			"top":"7",
			"title":"Accepted Java Solution",
			"vote":"2",
			"content":"The idea of this solution is to convert the problem into \"find the maximum sum of sub-array no larger than K\". \\n\\nThe time complexity will be O(r^2clogc) where r is the number of rows and c is the number of columns. If r is much larger than c, the complexity can be O(c^2rlogr) by creating a row-sum array instead of column-sum array\\n\\n```\\n\\npublic class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < row; i ++) {\\n            int[] colSum = new int[col];\\n            for (int j = i; j < row; j ++) {\\n                for (int c = 0; c < col; c ++) {\\n                    colSum[c] += matrix[j][c];\\n                }\\n                max = Math.max(max, findMax(colSum, k));\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private int findMax(int[] nums, int k) {\\n        int max = Integer.MIN_VALUE;\\n        int sum = 0;\\n        TreeSet<Integer> s = new TreeSet();\\n        s.add(0);\\n    \\n        for(int i = 0;i < nums.length; i ++){\\n            int t = sum + nums[i];\\n            sum = t;\\n            Integer gap = s.ceiling(sum - k);\\n            if(gap != null) max = Math.max(max, sum - gap);\\n            s.add(t);\\n        }\\n    \\n        return max;\\n    }\\n}\\n\\n```"
		},
		{
			"lc_ans_id":"83631",
			"view":"419",
			"top":"8",
			"title":"using cumulative sum and TreeSet",
			"vote":"2",
			"content":"To find the max sum of an array, we can do as follows:\\n\\n* compute the cumulative sum of the array\\n* find a pair of i and j, constrained to i<j, and **cum[j]-cum[i]<=k**\\n* do some trick, the inequation above is actually **cum[j]-k<=cum[i]**, we need to find the minimum value of **cum[i]** in order to maximize **cum[j]-cum[i]**, that is, find **TreeSet.ceiling(cum[j]-k)**\\n* if founded in the treeset, the value is actually **cum[i]**, by subtract **cum[i]** from **cum[j]**, we update the result\\nThe Max sum of rectangle on larger than k can be transformed into the problem of finding the max sum of an array no larger than k by slicing  the matrix:\\n```\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int result = Integer.MIN_VALUE;\\n        for (int begin = 0; begin < n; begin++) {\\n            for (int end = begin + 1; end <= n; end++) {\\n                int[] arr = new int[m];\\n                for (int i = 0; i < m; i++) {\\n                    for (int j = begin; j < end; j++) {\\n                        arr[i] += matrix[i][j];\\n                    }\\n                }\\n                TreeSet<Integer> treeSet = new TreeSet<>();\\n                treeSet.add(0);\\n                int cumulative = 0;\\n                for (int i : arr) {\\n                    cumulative += i;\\n                    Integer ceiling = treeSet.ceiling(cumulative - k);\\n                    if (ceiling != null) {\\n                        result = Math.max(result, cumulative - ceiling);\\n                    }\\n                    treeSet.add(cumulative);\\n                }\\n            }\\n        }\\n        return result;\\n    }"
		},
		{
			"lc_ans_id":"83633",
			"view":"1203",
			"top":"9",
			"title":"Naive but accepted java solution.",
			"vote":"2",
			"content":"Well, I think that this is the most direct solution for this problem. We just add the numbers in every rectangle and find the sum closest but not larger than k. Since the array is 2-d, we have 4 points to decide the rectangle, the algorithm will be O(n^2).\\n\\n    public class Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        \\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n        \\n        int[][] sums = new int[matrix.length][matrix[0].length];\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (j == 0) {\\n                    sums[i][j] = matrix[i][j];\\n                } else {\\n                    sums[i][j] = sums[i][j - 1] + matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        /* O(n^4) loop */\\n        int max = 0;\\n        boolean firstMax = false;\\n        int tmpSum = 0;\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            for (int j = i; j < matrix[0].length; j++) {\\n                for (int m = 0; m < matrix.length; m++) {\\n                    tmpSum = 0;\\n                    for (int n = m; n < matrix.length; n++) {\\n                        if (i == 0) {\\n                            tmpSum += sums[n][j];\\n                        } else {\\n                            tmpSum += sums[n][j] - sums[n][i - 1];\\n                        }\\n                        if (tmpSum > k) {\\n                            continue;\\n                        } else {\\n                            if (firstMax == false) {\\n                                max = tmpSum;\\n                                firstMax = true;\\n                            } else if ((k - tmpSum) < (k - max)) {\\n                                max = tmpSum;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}"
		}
	],
	"id":"363",
	"title":"Max Sum of Rectangle No Larger Than K",
	"content":"<p>Given a non-empty 2D matrix <i>matrix</i> and an integer <i>k</i>, find the max sum of a rectangle in the <i>matrix</i> such that its sum is no larger than <i>k</i>.</p>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>Given matrix = [\r\n  [1,  0, 1],\r\n  [0, -2, 3]\r\n]\r\nk = 2\r\n</pre>\r\n</p>\r\n\r\n<p>The answer is <code>2</code>. Because the sum of rectangle <code>[[0, 1], [-2, 3]]</code> is 2 and 2 is the max number no larger than k (k = 2).</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ol>\r\n<li>The rectangle inside the matrix must have an area > 0.</li>\r\n<li>What if the number of rows is much larger than the number of columns?</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://discuss.leetcode.com/user/fujiaozhu\">@fujiaozhu</a> for adding this problem and creating all test cases.</p>",
	"frequency":"272",
	"ac_num":"17751"
}