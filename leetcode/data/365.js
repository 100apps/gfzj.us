{
	"difficulty":"2",
	"submit_num":"66433",
	"show_id":"365",
	"leetcode_id":"365",
	"answers":[
		{
			"lc_ans_id":"83715",
			"view":"21595",
			"top":"0",
			"title":"Math solution - Java solution",
			"vote":"100",
			"content":"This is a pure Math problem. We need the knowledge of number theory to cover the proof and solution. No idea why microsoft uses this problem in real interview. \\n\\nThe basic idea is to use the property of B\\xe9zout's identity  and check if z is a multiple of GCD(x, y)\\n\\nQuote from wiki:\\n\\n> B\\xe9zout's identity (also called B\\xe9zout's lemma) is a theorem in the elementary theory of numbers:\\n>\\n> let a and b be nonzero integers and let d be their greatest common divisor. Then there exist integers x\\n> and y such that ax+by=d\\n> \\n> In addition, the greatest common divisor d is the smallest positive integer that can be written as ax + by\\n>\\n> every integer of the form ax + by is a multiple of the greatest common divisor d.\\n\\nIf  a or  b is negative this means we are emptying a jug of  x or  y gallons respectively.\\n\\nSimilarly if  a or  b is positive this means we are filling a jug of  x or  y gallons respectively.\\n\\nx = 4, y = 6, z = 8.\\n\\nGCD(4, 6) = 2\\n\\n8 is multiple of 2\\n\\nso this input is valid and we have: \\n\\n-1 * 4 + 6 * 2 = 8\\n\\nIn this case, there is a solution obtained by filling the 6 gallon jug twice and emptying the 4 gallon jug once. (Solution. Fill the 6 gallon jug and empty 4 gallons to the 4 gallon jug. Empty the 4 gallon jug. Now empty the remaining two gallons from the 6 gallon jug to the 4 gallon jug. Next refill the 6 gallon jug. This gives 8 gallons in the end)\\n\\nSee wiki:\\n\\n[B\\xe9zout's identity][1]\\n\\nand comments in the code\\n\\n\\n    public boolean canMeasureWater(int x, int y, int z) {\\n        //limit brought by the statement that water is finallly in one or both buckets\\n        if(x + y < z) return false;\\n        //case x or y is zero\\n        if( x == z || y == z || x + y == z ) return true;\\n        \\n        //get GCD, then we can use the property of B\\xe9zout's identity\\n        return z%GCD(x, y) == 0;\\n    }\\n    \\n    public int GCD(int a, int b){\\n        while(b != 0 ){\\n            int temp = b;\\n            b = a%b;\\n            a = temp;\\n        }\\n        return a;\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity"
		},
		{
			"lc_ans_id":"83714",
			"view":"7798",
			"top":"1",
			"title":"A little explanation on GCD method. C++/Java/Python",
			"vote":"66",
			"content":"only thing we should proof is this:\\n\\n    if x and y are coprime,  then we can and only can reach every integer z in [0, x + y]. (1)\\n\\nthen for a GCD `g`, from `gx` and `gy`, \\nwe can and only can reach every `z` in `{i * g | i in [0, x + y] }`\\n\\n\\nnow, let's see how to proof (1).\\nlet x be the less one, and y the greater one.\\nthen fill the two jug to full, we have `x` and `y` water each and `x + y` water in total.\\nthen we pour out x water each time until we can't.\\n\\nnow we have these different z:\\n   \\n\\n     y + x,  y,  y - x,  y - 2x, ... , y % x \\n\\n   \\nfinally we have `y % x` water left, we pour it into the x jug, \\nthen fill the y jug to full.\\nnow the two jugs have `y % x` and  `y` water separately, \\nand `y + y % x` water in total.\\nthen we pour from y jug into x jug until the x jug is full, \\nafterwards do the same thing like before,\\nto pour out x water each time until we can't.\\n\\nfinally we get `(y + y % x) % x = (y % x + y % x) % x = (2y) % x`  water left.\\n\\nnow we have these different z:\\n   \\n     y + y % x,   y + y % x - x,  y + y % x - 2x, ... ,  (2y) % x \\n\\ndo this x times, we get z:\\n\\n     y + (2y) % x,  y + (2y) % x - x, y + (2y) % x - 2x, ..., (3y) % x\\n     :\\n     :\\n     :    \\n     y + ((x-1)y) % x,  y + ((x-1)y) % x - x,  y + ((x-1)y) % x - 2x, ... ,  (xy) % x\\n\\n\\n\\nthen you see `(xy) % x = 0`, and \\n   \\n\\n   set `{ y % x, (2y) % x, (3y) % x, ... , ((x-1)y) % x }` just equals to `{ 1, 2, 3, 4, 5, ... , x - 1 }` . (2)\\n\\nproof for (2):\\n    modulo x could get x - 1 different results at most exclusive 0, that's 1,2,3,...,x-1. \\n    we have x - 1 expressions, suppose there is two same, \\n    let a != b in [1, x-1] and `(ay) % x = (by) % x`,\\n    then we get `((a - b)y) % x = 0`, \\n    then `((a - b) % x) * (y % x) = 0`, `(a - b) % x = 0`. \\n    for `1 <= a, b <= x - 1`, so we get `a = b`. it's impossible.\\n\\n   \\nso we can get any z in [0, x + y]  water for coprime x and y.\\n\\n\\n  C++ code:\\n\\n    bool canMeasureWater(int x, int y, int z) {\\n        return z == 0 || z <= (long long)x + y && z % __gcd(x, y) == 0;\\n    }\\n\\nJava code:\\n\\n    public boolean canMeasureWater(int x, int y, int z) {\\n        return z == 0 || (long)x + y >= z && z % gcd(x, y) == 0;\\n    }\\n    public int gcd(int x, int y) {\\n        return y == 0 ? x : gcd(y, x % y);\\n    }\\n\\nPython code:\\n\\n\\n    def canMeasureWater(self, x, y, z):\\n        from fractions import gcd\\n        return z == 0 or x + y >= z and z % gcd(x, y) == 0\\n\\np.s. the testcases are too weak.\\nyou may get overflow without long long, say 2147483647, 234524287, 1.\\nsome code get AC, while runs wrong on this 4,6,8."
		},
		{
			"lc_ans_id":"83717",
			"view":"5721",
			"top":"2",
			"title":"This problem should be classified as HARD",
			"vote":"61",
			"content":"This problem should be classified as HARD."
		},
		{
			"lc_ans_id":"83720",
			"view":"4993",
			"top":"3",
			"title":"Clear Explanation of Why Using GCD",
			"vote":"23",
			"content":"Forget about two jugs pouring between each other, which may make you confused. \\n\\nLet's make it simple: assuming we have one big enough bucket and two cups with volume `x` and `y`, respectively. Now we want to perform a series of operation -- pouring water in and out only by those two cups with exactly amount `x` or `y`. Somehow, there will be only `z` water left in this big bucket eventually. Then the equation will be:\\n\\n    z = m * x + n * y\\n\\n `m` means using cup-x `m` times. If m is positive, it means pouring in. Otherwise, it's pouring out.\\n`n` is similar.\\n\\nFor example, `4 = (-2) * 3 + 2 * 5`, which means you pour in water twice with cup-5 and pour out water twice with cup-3. Talk back to the question, it's like we first fill jug-5, pour water to jug-3 from jug-5, empty jug-3, pour the remaining `2` water into jug-3 from jug-5, fill jug-5 again, pour water into jug-3 from jug-5, empty jug-3, then we have only `4` water left in jug-5. It's exactly fill jug-5 twice and empty jug-3 twice.  \\n\\nNow the question is, can we find those two `m` and `n` exist? \\n\\nThe answer is YES. Here we need a little math -- [Bezout's identity][1], which is:\\n\\n **We can always find `a` and `b` to satisfy `ax + bx = d` where `d = gcd(x, y)`** \\n\\nSo, everything is clear, if `z % d == 0`, then we have `(a*z/d)*x + (b*z/d)*y = z`, which means `m` and `n` exist.\\n\\nBelow is the code:\\n\\n    class Solution {\\n    public:\\n    bool canMeasureWater(int x, int y, int z) {\\n        return z == 0 || (z - x <= y && z % gcd(x, y) == 0);\\n    }\\n    private:\\n    int gcd(int x, int y)\\n    {\\n        return y == 0 ? x : gcd(y, x % y);\\n    }\\n    };\\n\\n  [1]: https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity"
		},
		{
			"lc_ans_id":"83709",
			"view":"2906",
			"top":"4",
			"title":"Breadth-First Search with explanation.",
			"vote":"16",
			"content":"It took me a while to understand the GCD method. My first attempt to this problem was using BFS, which is very intuitive and easy to understand.\\nThe complexity is definitely much longer than GCD-based method.\\n\\n```\\nclass Solution(object):\\n    def canMeasureWater(self, x, y, z):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :type z: int\\n        :rtype: bool\\n        \"\"\"\\n        if x > y:\\n            temp = x;\\n            x = y;\\n            y = temp;\\n            \\n        if z > x + y:\\n            return False;\\n        \\n        # set the initial state will empty jars;\\n        queue = [(0, 0)];\\n        visited = set((0, 0));\\n        while len(queue) > 0:\\n            a, b = queue.pop(0);\\n            if a + b == z:\\n                return True;\\n            \\n            states = set()\\n            \\n            states.add((x, b)) # fill jar x;\\n            states.add((a, y)) # fill jar y;\\n            states.add((0, b)) # empty jar x;\\n            states.add((a, 0)) # empty jar y;\\n            states.add((min(x, b + a), 0 if b < x - a else b - (x - a))) # pour jar y to x;\\n            states.add((0 if a + b < y else a - (y - b), min(b + a, y))) # pour jar x to y;\\n\\n            for state in states:\\n                if state in visited:\\n                    continue;\\n                queue.append(state)\\n                visited.add(state);\\n                \\n        return False;\\n```"
		},
		{
			"lc_ans_id":"83727",
			"view":"2078",
			"top":"5",
			"title":"[c++ solution] follow the procedure",
			"vote":"10",
			"content":"First let x be smaller than y.\\nloop:\\nif total water is less than x liters, only thing you can do is fill y liters.\\nelse total water is more or equal than x liters, \\nonly thing you can do is pour x liters(don't fill x, that will return to the previous state...) \\ntest:\\nif total water equals to z, return true.\\nif total water equals to 0, that means loop back to the first state, return false.\\nnow loop\\n```\\nclass Solution {\\npublic:\\n    bool canMeasureWater(int x, int y, int z) {\\n        if (x+y == z)\\n            return true;\\n        if (x+y < z)\\n            return false;\\n        if (x > y) {\\n            int temp = x;\\n            x = y;\\n            y = temp;\\n        }\\n        int volume = 0;\\n        while (1) {\\n            if (volume < x)\\n                volume += y;\\n            else\\n                volume -= x;\\n            if (volume == z)\\n                return true;\\n            if (volume == 0)\\n                return false;\\n        }\\n    }\\n````\\n`};"
		},
		{
			"lc_ans_id":"83711",
			"view":"1144",
			"top":"6",
			"title":"Python solution gcd",
			"vote":"7",
			"content":"    class Solution(object):\\n        def canMeasureWater(self, x, y, z):\\n            \"\"\"\\n            :type x: int\\n            :type y: int\\n            :type z: int\\n            :rtype: bool\\n            \"\"\"\\n            a,b=x,y\\n            while y:\\n                r=x%y\\n                x=y\\n                y=r\\n            return bool(not z or (x and z<=a+b and not z%x))"
		},
		{
			"lc_ans_id":"83743",
			"view":"2238",
			"top":"7",
			"title":"Share my 0ms C++ solution with proof and explanation",
			"vote":"7",
			"content":"You are given two jugs with capacities ***x*** and ***y*** litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs.\\n\\nIf ***z*** liters of water is measurable, you must have z liters of water contained within **one or both buckets** by the end.\\n\\nOperations allowed:\\n\\n - Fill any of the jugs completely with water.\\n - Empty any of the jugs.\\n - Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.\\n\\nHere I choose a math solution based on **linear congruential formula**:\\n\\n - ***ax \\u2261 b (mod n)***\\n\\n----------\\n## Just take a try! (Example 1)\\n\\nWe can write down all the possible ***x*** and ***y*** (start from ***x = 0, y = 0***, end at ***x = 3, y = 5*** ):\\n\\n - (0,0)\\n - (0,5)\\n - (3,2)\\n - (0,2)\\n - (2,0)\\n - (2,5)\\n - (3,4)\\n - (0,4)\\n - (3,1)\\n - (0,1)\\n - (1,0)\\n - (1,5)\\n - (3,3)\\n - (0,3)\\n - (3,0)\\n - (3,3)\\n - (3,5)\\n\\nIf we put these points to a **2D oblique coordinate system (*\\u03b8* = 60\\xb0)**, and draw the paths from the start to the end. We can get\\n\\n![path graph for example 1][1]\\n\\nIf you imagine that\\n\\n - The border lines (***x = 0, y = 0, x = 3, y = 5***) are **mirrors**\\n - The start point ***(0,0)*** is a **light source**\\n\\nAs the angle of incidence equals the angle of reflection, have you find that the route is **light path diagram**? \\n\\nIn the diagram, **EACH REFLECTION POINT** is **A SOLUTION** FOR ***(x,y)***\\n\\nSince what we need is the sum of ***x*** and ***y***,  note that:\\n\\n - **RED** route: ***x*** is same.\\n - **BLUE** route: The value ***x + y*** of the start point is as same as the end point.\\n       - (2,5) to (3,4)\\n       - (1,5) to (3,3)\\n       - (0,5) to (3,2)\\n       - (0,4) to (3,1)\\n       - (0,3) to (3,0)\\n       - (0,2) to (2,0)\\n       - (0,1) to (1,0)\\n - **GREEN** route: ***y*** is same.\\n\\nAt first, I write a program to follow the **light path diagram**, but when ***x*** and ***y*** is too high, the program is slow.\\n\\n----------\\n## Let's make it more general!\\n\\nFor normal ***y = p, x = q*** (***p > q > 0***), if we draw the paths (between 2 **RED** routes) in a 2D oblique coordinate system, we get\\n\\n![general path graph][2]\\n\\nAs the sum ***x + y*** keep the same on the **BLUE** route, we **ONLY** focus on the points on the **y-axis**.\\n\\n - From **A0**, we get ***(0, p - q), (0, p - 2q)***, ... The last point is ***(0, r0)***, and ***r0 \\u2261 p (mod q)***.\\n\\n - ***x + y = p - q, p - 2q, ..., r0***. We can write ***p = kq + r0***.\\n\\n**Result 1**: If function returns **TRUE**, ***z*** is in ***{p - q, p - 2q, ..., r0}***.\\n\\n - ***z \\u2261 r0 (mod q)***\\n\\n----------\\n\\nThen the **RED** route goes to **B1**, then **BLUE** route to **C1**.\\n\\nIf we extend **B1C1** to the back, we get **A1** on the y-axis, and the ***x + y*** in A1/B1/C1 is **SAME**.\\n\\n - From **A1**, we get ***(0, p - q + r0), (0, p - 2q + r0)***, ... The last point is ***(0, r1)***\\n\\n - ***x + y = p - q + r0, p - 2q + r0, ..., r1***\\n\\n - Here,  ***r1 \\u2261 (p + r0) (mod q) \\u2261 (p mod q) +  (r0 mod q) \\u2261 2r0 (mod q)***\\n\\n**Result 2**: If function returns **TRUE**, ***z*** is in ***{p - q + r0, p - 2q + r0, ..., r1}***.\\n\\n - ***z \\u2261 r1 (mod q) \\u2261 (2r0 mod q)***\\n\\n..........\\n\\n**Result k**: If function returns **TRUE**.\\n\\n - ***z \\u2261 r(k-1) (mod q) \\u2261 kr0 (mod q)***\\n\\n----------\\n## Conclution\\n\\nIf function returns **TRUE**. There **MUST EXIST** a ***k***, that ***kr0 \\u2261 z (mod q)***.\\n\\nThe problem becomes that **whether the formula *kr0 \\u2261 z (mod q)* has a root k**.\\n\\n - If ***r0 = 0***, then ***z mod q* MUST equals to 0**.\\n - If ***r0 \\u2260 0***, then:\\n     - On wikipedia ([\\u7ebf\\u6027\\u540c\\u4f59\\u65b9\\u7a0b][3]), I get that I only need to judge whether ***gcd(r0,q) | z***.\\n     - About the gcd algorithm, I use the [Euclidean_algorithm][4].\\n\\n----------\\n## Some special cases\\n\\n 1. ***z = 0*** is always **TRUE**, because we **ALWAYS** start from ***(0, 0)***.\\n\\n 2. ***z = x + y*** is always **TRUE**, because we **ALWAYS** end at ***(x, y)***.\\n\\n 3. When ***x = 0*** (or ***y = 0***), we only need to judge ***z = y*** (or ***z = x***).\\n\\n 4. When ***x = y***,  since the **light path diagram** can **ONLY** go from ***(0, 0)*** to ***(0, y)***,and then to ***(x, 0)*** and ***(x, y)***, ***z* MUST** be ***0, x, 2x***.\\n\\n----------\\n## Code\\n\\n    class Solution {\\n    public:\\n        int gcd(int a, int b)\\n        {\\n            if(a % b == 0)\\n            {\\n                return b;\\n            }else{\\n                return gcd(b, a % b);\\n            }\\n        }\\n        bool canMeasureWater(int x, int y, int z) {\\n            if(z == 0 || z == x + y) return true;\\n            if(z > x + y) return false;\\n            if(x == 0) return z == y;\\n            if(y == 0) return z == x;\\n            if(x == y) return z == x;\\n            int y_in = (y > x)? y : x;\\n            int x_in = (y > x)? x : y;\\n            int r = y_in % x_in;\\n            if (r == 0)\\n            {\\n                return z % x_in == 0;\\n            }else{\\n                return z % gcd(r, x_in) == 0;\\n            }\\n        }\\n    };\\n\\n----------\\n\\n\\n  [1]: https://s32.postimg.org/62xx3y8r9/pic1.png\\n  [2]: https://s32.postimg.org/s1j6mjdw5/pic2.png\\n  [3]: https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B\\n  [4]: https://en.wikipedia.org/wiki/Euclidean_algorithm"
		},
		{
			"lc_ans_id":"83716",
			"view":"203",
			"top":"8",
			"title":"Java Programmatic Solution BFS without GCD",
			"vote":"5",
			"content":"    public boolean canMeasureWater(int x, int y, int z) {\\n        if (z < 0 || z > x + y) {\\n            return false;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        while (!q.isEmpty()) {\\n            int n = q.poll();\\n            if (n + x <= x + y && set.add(n + x)) {\\n                q.offer(n + x);\\n            } \\n            if (n + y <= x + y && set.add(n + y)) {\\n                q.offer(n + y);\\n            } \\n            if (n - x >= 0 && set.add(n - x)) {\\n                q.offer(n - x);\\n            } \\n            if (n - y >= 0 && set.add(n - y)) {\\n                q.offer(n - y);\\n            }\\n            if (set.contains(z)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }"
		},
		{
			"lc_ans_id":"83736",
			"view":"2122",
			"top":"9",
			"title":"I don't understand the test case",
			"vote":"5",
			"content":"Why the test case 1 2 5 return false? Because I think 5 = 1 + 2 + 2."
		}
	],
	"id":"365",
	"title":"Water and Jug Problem",
	"content":"<p>You are given two jugs with capacities <i>x</i> and <i>y</i> litres. There is an infinite amount of water supply available.\r\nYou need to determine whether it is possible to measure exactly <i>z</i> litres using these two jugs.</p>\r\n\r\n<p>If <i>z</i> liters of water is measurable, you must have <i>z</i> liters of water contained within <b>one or both buckets</b> by the end.</p>\r\n\r\n<p>\r\nOperations allowed:\r\n<ul>\r\n<li>Fill any of the jugs completely with water.</li>\r\n<li>Empty any of the jugs.</li>\r\n<li>Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.</li>\r\n</ul>\r\n</p>\r\n\r\n<p><b>Example 1:</b> (From the famous <a href=\"https://www.youtube.com/watch?v=BVtQNK_ZUJg\" target=\"_blank\"><i>\"Die Hard\"</i> example</a>)\r\n<pre>\r\nInput: x = 3, y = 5, z = 4\r\nOutput: True\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\nInput: x = 2, y = 6, z = 5\r\nOutput: False\r\n</pre>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://discuss.leetcode.com/user/vinod23\">@vinod23</a> for adding this problem and creating all test cases.</p>",
	"frequency":"148",
	"ac_num":"18564"
}