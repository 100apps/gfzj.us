{
	"difficulty":"2",
	"submit_num":"93391",
	"show_id":"368",
	"leetcode_id":"368",
	"answers":[
		{
			"lc_ans_id":"83998",
			"view":"16972",
			"top":"0",
			"title":"C++ Solution with Explanations",
			"vote":"78",
			"content":"The key concept here is:\\n  Given a set of integers that satisfies the property that each pair of integers inside the set are mutually divisible, for a new integer S, S can be placed into the set as long as it can divide the smallest number of the set or is divisible by the largest number of the set.\\n\\t\\nFor example, let's say we have a set P = { 4, 8, 16 }, P satisfies the divisible condition. Now consider a new number 2, it can divide the smallest number 4, so it can be placed into the set; similarly, 32 can be divided by 16, the biggest number in P, it can also placed into P.\\n\\nNext, let's define:\\n\\n**EDIT: For clarification, the following definitions try to enlarge candidate solutions by appending a larger element at the end of each potential set, while my implementation below is prefixing a smaller element at the front of a set. Conceptually they are equivalent but by adding smaller elements at the front saves the trouble for keeping the correct increasing order for the final answer. Please refer to comments in code for more details.**\\n\\nFor an increasingly sorted array of integers a[1 .. n]\\n\\nT[n] = the length of the largest divisible subset whose largest number is a[n]\\n\\nT[n+1] = max{ 1 + T[i] if a[n+1] mod a[i] == 0 else 1 }\\n\\nNow, deducting T[n] becomes straight forward with a DP trick. For the final result we will need to maintain a backtrace array for the answer.\\n\\nImplementation in C++:\\n\\n    class Solution {\\n    public:\\n        vector<int> largestDivisibleSubset(vector<int>& nums) {\\n            sort(nums.begin(), nums.end());\\n            \\n            vector<int> T(nums.size(), 0);\\n            vector<int> parent(nums.size(), 0);\\n            \\n            int m = 0;\\n            int mi = 0;\\n            \\n            // for(int i = 0; i < nums.size(); ++i) // if extending by larger elements\\n            for(int i = nums.size() - 1; i >= 0; --i) // iterate from end to start since it's easier to track the answer index\\n            {\\n                // for(int j = i; j >=0; --j) // if extending by larger elements\\n                for(int j = i; j < nums.size(); ++j)\\n                {\\n                    // if(nums[i] % nums[j] == 0 && T[i] < 1 + T[j]) // if extending by larger elements\\n                    // check every a[j] that is larger than a[i]\\n                    if(nums[j] % nums[i] == 0 && T[i] < 1 + T[j])\\n                    {\\n                        // if a[j] mod a[i] == 0, it means T[j] can form a larger subset by putting a[i] into T[j]\\n                        T[i] = 1 + T[j];\\n                        parent[i] = j;\\n                        \\n                        if(T[i] > m)\\n                        {\\n                            m = T[i];\\n                            mi = i;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            vector<int> ret;\\n            \\n            for(int i = 0; i < m; ++i)\\n            {\\n                ret.push_back(nums[mi]);\\n                mi = parent[mi];\\n            }\\n\\n            // sort(ret.begin(), ret.end()); // if we go by extending larger ends, the largest \"answer\" element will come first since the candidate element we observe will become larger and larger as i increases in the outermost \"for\" loop above.\\n           // alternatively, we can sort nums in decreasing order obviously. \\n            \\n            return ret;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"84006",
			"view":"12270",
			"top":"1",
			"title":"Classic DP solution similar to LIS, O(n^2)",
			"vote":"71",
			"content":"Use DP to track max Set and pre index.\\n\\n    public class Solution {\\n        public List<Integer> largestDivisibleSubset(int[] nums) {\\n            int n = nums.length;\\n            int[] count = new int[n];\\n            int[] pre = new int[n];\\n            Arrays.sort(nums);\\n            int max = 0, index = -1;\\n            for (int i = 0; i < n; i++) {\\n                count[i] = 1;\\n                pre[i] = -1;\\n                for (int j = i - 1; j >= 0; j--) {\\n                    if (nums[i] % nums[j] == 0) {\\n                        if (1 + count[j] > count[i]) {\\n                            count[i] = count[j] + 1;\\n                            pre[i] = j;\\n                        }\\n                    }\\n                }\\n                if (count[i] > max) {\\n                    max = count[i];\\n                    index = i;\\n                }\\n            }\\n            List<Integer> res = new ArrayList<>();\\n            while (index != -1) {\\n                res.add(nums[index]);\\n                index = pre[index];\\n            }\\n            return res;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"84002",
			"view":"14435",
			"top":"2",
			"title":"4 lines in Python",
			"vote":"71",
			"content":"    def largestDivisibleSubset(self, nums):\\n        S = {-1: set()}\\n        for x in sorted(nums):\\n            S[x] = max((S[d] for d in S if x % d == 0), key=len) | {x}\\n        return list(max(S.values(), key=len))\\n\\nMy `S[x]` is the largest subset with `x` as the largest element, i.e., the subset of all divisors of `x` in the input. With `S[-1] = emptyset` as useful base case. Since divisibility is transitive, a multiple `x` of some divisor `d` is also a multiple of all elements in `S[d]`, so it's not necessary to explicitly test divisibility of `x` by all elements in `S[d]`. Testing `x % d` suffices.\\n\\nWhile storing entire subsets isn't super efficient, it's also not that bad. To extend a subset, the new element must be divisible by all elements in it, meaning it must be at least twice as large as the largest element in it. So with the 31-bit integers we have here, the largest possible set has size 31 (containing all powers of 2)."
		},
		{
			"lc_ans_id":"83999",
			"view":"10287",
			"top":"3",
			"title":"Easy understood Java DP solution in 28ms with O(n^2) time",
			"vote":"33",
			"content":"The basic idea is like:\\n\\n    1. Sort\\n    2. Find the length of longest subset\\n    3. Record the largest element of it.\\n    4. Do a loop from the largest element to nums[0], add every element belongs to the longest subset.\\n\\n\\nThe old version cant pass the test case [1,2,4,8,9,72] and [4,8,10,240], thanks for that @Yanning and @svc \\nHere comes the revised version: \\n\\n    public static List<Integer> largestDivisibleSubset(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (nums == null || nums.length == 0) return res;\\n        Arrays.sort(nums);\\n        int[] dp = new int[nums.length];\\n        dp[0] = 1;\\n\\n        //for each element in nums, find the length of largest subset it has.\\n        for (int i = 1; i < nums.length; i++){\\n            for (int j = i-1; j >= 0; j--){\\n                if (nums[i] % nums[j] == 0){\\n                    dp[i] = Math.max(dp[i],dp[j] + 1);\\n                }\\n            }\\n        }\\n\\n        //pick the index of the largest element in dp.\\n        int maxIndex = 0;\\n        for (int i = 1; i < nums.length; i++){\\n            maxIndex = dp[i] > dp[maxIndex] ?  i :  maxIndex;\\n        }\\n\\n        //from nums[maxIndex] to 0, add every element belongs to the largest subset.\\n        int temp = nums[maxIndex];\\n        int curDp = dp[maxIndex];\\n        for (int i = maxIndex; i >= 0; i--){\\n            if (temp % nums[i] == 0 && dp[i] == curDp){\\n                res.add(nums[i]);\\n                temp = nums[i];\\n                curDp--;\\n            }\\n        }\\n        return res;\\n    }"
		},
		{
			"lc_ans_id":"84031",
			"view":"6251",
			"top":"4",
			"title":"Java Solution in 32ms O(N^2) time, O(N) space",
			"vote":"15",
			"content":"    public class Solution {\\n        public int[] largestDivisibleSubset(int[] nums) {\\n            if(nums.length < 2)\\n                return nums;\\n            else{\\n                Arrays.sort(nums);\\n                int[] parent = new int[nums.length];\\n                int[] count = new int[nums.length];\\n                int max = 0, maxind = -1;\\n                for(int i = nums.length - 1; i >= 0; i--){\\n                    for(int j = i; j < nums.length; j++){\\n                        if(nums[j] % nums[i] == 0 && count[i] < 1 + count[j] ){\\n                            count[i] = 1 + count[j];\\n                            parent[i] = j;\\n                            if(count[i] > max){\\n                                max = count[i];\\n                                maxind = i;\\n                            }\\n                        }\\n                    }\\n                }\\n                int[] res = new int[max];\\n                for(int i = 0; i < max; i++){\\n                    res[i] = nums[maxind];\\n                    maxind = parent[maxind];\\n                }\\n                return res;\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"84098",
			"view":"1458",
			"top":"5",
			"title":"Is this question broken?  aka ill-posed",
			"vote":"7",
			"content":"**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
		},
		{
			"lc_ans_id":"84093",
			"view":"987",
			"top":"6",
			"title":"Python dp n^2 solution",
			"vote":"6",
			"content":"We first do some math work.  For two numbers, A and B, if A < B, A % B  must > 0 (A != 0).  The only chance A % B == 0 must be A >= B.\\n\\nWith this idea, we sort the list.  Then, the question turns similar to no.300 longest increasing subsequence.  For ith number, its largest divisible subset is the max of subset of any j from 0 - i-1 in which nums[i] % nums[j] == 0.\\n\\n    class Solution(object):\\n        def largestDivisibleSubset(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: List[int]\\n            \"\"\"\\n            from copy import copy\\n            nums.sort()\\n            n = len(nums)\\n            if n == 0: return []\\n            dp = [0] * n\\n            dp[0] = [nums[0]]\\n            #print(dp)\\n            for i in xrange(1, n):\\n                curNum = nums[i]\\n                maxSet = []\\n                for j in xrange(i):\\n                    if curNum % nums[j] == 0:\\n                        localSet = copy(dp[j])\\n                        if len(localSet) > len(maxSet):\\n                            maxSet = localSet\\n                \\n                maxSet.append(nums[i])\\n                dp[i] = maxSet\\n                #print(dp)\\n            \\n            #print(dp)\\n            res = []\\n            for localSet in dp:\\n                if len(localSet) > len(res):\\n                    res = localSet\\n            return res"
		},
		{
			"lc_ans_id":"84033",
			"view":"1352",
			"top":"7",
			"title":"6ms C++ beats 100% w/ explanations",
			"vote":"4",
			"content":"**Solution #1 (TLE)**\\nThis solution builds upon the naive approach of building up a solution by either adding an element to the solution (if it passes the divisibility check) or by skipping the value as all nums are iterated over. Nums is first sorted so that it is easier to test if a new (larger) num satisfies the divisibility check of the current solution by only checking the last element of the solution (others, like @StefanPochmann, have talked about this). Speed is O(2^n), and Space is O(n).\\n```\\nclass Solution {\\n    int bSz=0, sPos=0, nSz;\\n    vector<int> nums, sol, best=vector<int>(0);\\n    \\n    int passes(int v, int i) {\\n        return ( (sPos==0) || ((v%sol[sPos-1])==0) );\\n    }\\n    void rec(int i) {\\n        for ( ; i<nSz; ++i ) {\\n            if ( passes(nums[i],i) ) {\\n                sol[sPos++]=nums[i];\\n                rec(i+1);   // w/ num[i] in solution\\n                --sPos;\\n            }               // else, w/o num[i] in solution\\n        }\\n        if ( bSz < sPos ) {\\n            bSz = sPos;     // store best\\n            best = vector<int>(sol.begin(), sol.begin()+sPos);\\n        }\\n    }\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& numsOrig) {\\n        if ( (nSz=numsOrig.size())<=1 ) return numsOrig; \\n        nums = numsOrig;\\n        sol = vector<int>(nSz);\\n        //\\n        sort (nums.begin(), nums.end());\\n        //\\n        rec(0);\\n        return best;\\n    }\\n};\\n```\\n**Solution #2 (Accepted 149ms)**\\nLike Dijkstra's shortest path algorithm, it can be observed that a num should only be considered if it contributes to a better solution (in this case a longer subset). Therefore the distance of a num contributing to any partial solution can be recorded in a 'furthest' vector (where it is found in the solution), of size n, and only be considered again if it has a further solution position. \\n```// don't consider the num 32 in a solution of [1,32,...] when a better solution [1,2,4,32,...] has already been found```\\nSomeone can correct me if I am wrong, but I believe the Speed is O(n^2) and the Space is still O(n). The reason it is no longer O(2^n) is because the the outer loop runs in O(n) while the inner recursive loop now only expands ~once per new divisible num, also O(n). In other words, the recursive portion is like a DFS that walks the remaining nodes once; then, later attempts to visit the same node are rejected for not having a further solution position.\\n```\\nclass Solution {\\n    int bSz=0, sPos=0, nSz;\\n    vector<int> nums, sol, furthest, best=vector<int>(0);\\n    \\n    int passes(int v, int i) {\\n        if ( sPos==0 ) return 1;\\n        if ( (sPos>furthest[i]) && ((v%sol[sPos-1])==0) ) {\\n            furthest[i]=sPos;\\n            return 1;       // mark the position\\n        }\\n        return 0;\\n    }\\n    void rec(int i) {\\n        for ( ; i<nSz; ++i ) {\\n            if ( passes(nums[i],i) ) {\\n                sol[sPos++]=nums[i];\\n                rec(i+1);   // w/ num[i] in solution\\n                --sPos;\\n            }               // else, w/o num[i] in solution\\n        }\\n        if ( bSz < sPos ) {\\n            bSz = sPos;     // store best\\n            best = vector<int>(sol.begin(), sol.begin()+sPos);\\n        }\\n    }\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& numsOrig) {\\n        if ( (nSz=numsOrig.size())<=1 ) return numsOrig; \\n        nums = numsOrig;\\n        sol = vector<int>(nSz);\\n        furthest = vector<int>(nSz,0);\\n        //\\n        sort (nums.begin(), nums.end());\\n        //\\n        rec(0);\\n        return best;\\n    }\\n};\\n```\\n**Solution #3 (Accepted 6ms)**\\nAdditional pruning can be added for early rejection of numbers that will not contribute to a better solution than what has already been found, with the below check:\\n```// given input [1...1000] and a current best solution of [1,2,4,8...512], don't proceed with a solution like [1,3,99] or [1,400] because the optimal way to expand these solutions would be to multiply the last number by 2 repeatedly, but a larger best-subset would require a final number > 1000. ```\\nSo a check is added to our iterative loop to see if there remains a large enough num to satisfy this constraint with: largest > num * 2^(difference in solution size to the best known solution size). This check requires O(1) additional complexity leaving the Speed at O(n^2) and the Space O(n).\\n```\\nclass Solution {\\n    int bSz=0, sPos=0, nSz, largest;\\n    vector<int> nums, sol, furthest, best=vector<int>(0);\\n    \\n    int passes(int v, int i) {\\n        if ( sPos==0 ) return 1;\\n        if ( (sPos>furthest[i]) && ((v%sol[sPos-1])==0) ) {\\n            furthest[i]=sPos;\\n            return 1;       // mark the position\\n        }\\n        return 0;\\n    }\\n    void rec(int i) {\\n        for ( ; i<nSz; ++i ) {\\n            if ( bSz>sPos && ((((long)1)<<(bSz-sPos))*nums[i])>largest ) break;\\n            if ( passes(nums[i],i) ) {\\n                sol[sPos++]=nums[i];\\n                rec(i+1);   // w/ num[i] in solution\\n                --sPos;\\n            }               // else, w/o num[i] in solution\\n        }\\n        if ( bSz < sPos ) {\\n            bSz = sPos;     // store best\\n            best = vector<int>(sol.begin(), sol.begin()+sPos);\\n        }\\n    }\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& numsOrig) {\\n        if ( (nSz=numsOrig.size())<=1 ) return numsOrig; \\n        nums = numsOrig;\\n        sol = vector<int>(nSz);\\n        furthest = vector<int>(nSz,0);\\n        //\\n        sort (nums.begin(), nums.end());\\n        largest = nums.back();\\n        //\\n        rec(0);\\n        return best;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"84083",
			"view":"731",
			"top":"8",
			"title":"Java DFS solution 62ms by considering the problem as finding the longest path in a DAG",
			"vote":"4",
			"content":"By considering each number as a node and its multiples as connected nodes. We can obtain a DAG. For example, [1,3,4,6] can form a DAG with edges of 1->3, 1->4, 1->6, 3->6. So, the answer is the longest path of 1->3->6. \\n\\nThis is very similar to the [Topological sorting][1] question which should be solved in O(|E|+|V|), linear running time. However, the bottleneck is that the edges are not given and we need to find those edges using O(|V|^2). Therefore, we need to find a better way to find the edges from a current node to all its connected nodes.\\n\\nThe idea is that we store all numbers in a TreeSet so they can be searched by order instead of going  from small to large one by one. The advantage is that we can jump through the numbers that are not a multiple of the current node. i.e. use above example, when stop at 3, we can jump to 6 directly without visiting 4 by knowing the next  multiple of 3 is 3X2=6. And, the next multiple is 3X3 and so on. \\n\\nHowever, this is not enough when we have the case of the big gap, ie, [2, 10000, 10000001]. If we adding factor by one each time, it will take long long time. Therefore, here is the TreeSet coming handy. We find the ceiling of 4 to obtain 10000. In addition, we increase the factor to 10000/2 +1 for next round.\\n\\nOn the side node, this implementation use O(logN) to search the next multiple. A better implementation is to search only the TreeSet which only has numbers greater than the current number by cutting down the TreeSet. Or, using a sorted array and call Arrays.binarySearch(start, end, value).\\n\\n\\n[1]: https://en.wikipedia.org/wiki/Topological_sorting\\n\\n\\n\\n    public class Solution {\\n        TreeSet<Long> mem = new TreeSet<Long>();\\n        long max = 0;\\n        List<Integer> ret = new ArrayList();\\n        Map<Long, List<Integer> > visited = new HashMap<>();\\n       \\n        public List<Integer> helper(long cur) {\\n            if (cur > max || ! mem.contains(cur) ) return null;\\n            if (visited.containsKey(cur)) return visited.get(cur);\\n            List<Integer> list = new ArrayList<>();\\n            long i=2; // the factor for the next multiple of current value\\n            while ( mem.ceiling(cur*i) != null ) { // no more multiple\\n                // use O(log N) to find next multiple\\n                long next = mem.ceiling(cur*i);\\n                if ( next % cur == 0 ) {\\n                    List<Integer> temp = helper(next);\\n                    if (temp != null  && temp.size() > list.size() )\\n                        list = new ArrayList(temp);\\n                }\\n                i=(next/cur)+1; // increase the factor based on the gap. \\n            }\\n            list.add((int)cur);\\n            visited.put(cur, list);\\n            return list;\\n        }\\n        \\n        public List<Integer> largestDivisibleSubset(int[] nums) {\\n            if (nums==null || nums.length ==0) return ret;\\n            int len = nums.length;\\n            if (len == 1) { \\n                ret.add(nums[0]);\\n                return ret;\\n            }\\n            for (int num : nums) {\\n                mem.add((long)num);\\n            }\\n            max = mem.last();\\n            for (int num : nums) { \\n                List<Integer> temp = helper((long)num);\\n                if (temp != null  && temp.size() > ret.size() )\\n                    ret = new ArrayList(temp);\\n            }\\n            return ret;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"84103",
			"view":"1127",
			"top":"9",
			"title":"Easy DP with path record, C++ code, O(n^2) time on worst case, O(n) space",
			"vote":"4",
			"content":"the idea is using a bucket to record which nums can be the current longest sequence,\\nand meantime using pair record the pre-num's id in its bucket, so we can get the result using it.\\n\\nsee this case [1,2,3,4,5,6,7,24]\\n\\nat last it runs like this:\\n\\n     1 | 2 | 4 | 24\\n       | 3 | 6 |\\n       | 5 |    \\n       | 7 |    \\ncode:\\n\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        vector<int> ret;\\n        int n = nums.size();\\n        if (!n) return ret;\\n        sort(nums.begin(), nums.end());\\n        vector<pair<int, int>> dp[n];\\n        int maxi = 0;\\n        dp[maxi].push_back(make_pair(nums[0], -1));\\n        for (int i = 1; i < n; ++i) {\\n            int j = maxi;\\n            while (j >= 0) {\\n                for (int id = 0; id < dp[j].size(); ++id) {\\n                    if (nums[i] % dp[j][id].first == 0) {\\n                        dp[j + 1].emplace_back(nums[i], id);\\n                        maxi = max(maxi, j + 1);\\n                        goto out_of_while;\\n                    }\\n                }\\n                --j;\\n            }\\n            dp[j + 1].emplace_back(nums[i], -1);\\n            out_of_while:;\\n        }\\n        int i = maxi, id = 0;\\n        while (i >= 0) {\\n            ret.push_back(dp[i][id].first);\\n            id = dp[i][id].second;\\n            --i;\\n        }\\n        return ret;\\n    }"
		}
	],
	"id":"368",
	"title":"Largest Divisible Subset",
	"content":"<p>\r\nGiven a set of <b>distinct</b> positive integers, find the largest subset such that every pair (S<sub>i</sub>, S<sub>j</sub>) of elements in this subset satisfies: S<sub>i</sub> % S<sub>j</sub> = 0 or S<sub>j</sub> % S<sub>i</sub> = 0.\r\n</p>\r\n\r\n<p>If there are multiple solutions, return any subset is fine.\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\nnums: [1,2,3]\r\n\r\nResult: [1,2] (of course, [1,3] will also be ok)\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\nnums: [1,2,4,8]\r\n\r\nResult: [1,2,4,8]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/stomach_ache\">@Stomach_ache</a> for adding this problem and creating all test cases.</p>",
	"frequency":"272",
	"ac_num":"31580"
}