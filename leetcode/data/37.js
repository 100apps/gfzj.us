{
	"difficulty":"3",
	"submit_num":"275066",
	"show_id":"37",
	"leetcode_id":"37",
	"answers":[
		{
			"lc_ans_id":"15752",
			"view":"35751",
			"top":"0",
			"title":"Straight Forward Java Solution Using Backtracking",
			"vote":"176",
			"content":"Try 1 through 9 for each cell. The time complexity should be 9 ^ m (m represents the number of blanks to be filled in), since each blank can have 9 choices. Details see comments inside code.\\n\\n```\\npublic class Solution {\\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length == 0)\\n            return;\\n        solve(board);\\n    }\\n    \\n    public boolean solve(char[][] board){\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == '.'){\\n                    for(char c = '1'; c <= '9'; c++){//trial. Try 1 through 9\\n                        if(isValid(board, i, j, c)){\\n                            board[i][j] = c; //Put c for this cell\\n                            \\n                            if(solve(board))\\n                                return true; //If it's the solution return true\\n                            else\\n                                board[i][j] = '.'; //Otherwise go back\\n                        }\\n                    }\\n                    \\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isValid(char[][] board, int row, int col, char c){\\n        for(int i = 0; i < 9; i++) {\\n            if(board[i][col] != '.' && board[i][col] == c) return false; //check row\\n            if(board[row][i] != '.' && board[row][i] == c) return false; //check column\\n            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != '.' && \\nboard[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; //check 3*3 block\\n        }\\n        return true;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"15748",
			"view":"16148",
			"top":"1",
			"title":"Sharing my 2ms C++ solution with comments and explanations.",
			"vote":"59",
			"content":"Update: there's a [follow-up 0ms solution which is even more optimized][1]\\n\\nThis is one of the fastest Sudoku solvers I've ever written. It is compact enough - just 150 lines of C++ code with comments. I thought it'd be interesting to share it, since it combines several techniques like reactive network update propagation and backtracking with very aggressive pruning.\\n\\nThe algorithm is online - it starts with an empty board and as you add numbers to it, it starts solving the Sudoku.\\n\\nUnlike in other solutions where you have bitmasks of allowed/disallowed values per row/column/square, this solution track bitmask for every(!) cell, forming a set of constraints for the allowed values for each particular cell. Once a value is written into a cell, new constraints are immediately propagated to row, column and 3x3 square of the cell. If during this process a value of other cell can be unambiguously deduced - then the value is set, new constraints are propagated, so on.... You can think about this as an implicit reactive network of cells.\\n\\nIf we're lucky (and we'll be lucky for 19 of 20 of Sudokus published in magazines) then Sudoku is solved at the end (or even before!) processing of the input.\\n\\nOtherwise, there will be empty cells which have to be resolved. Algorithm uses backtracking for this purpose. To optimize it, algorithm starts with the cell with the smallest ambiguity. This could be improved even further by using priority queue (but it's not implemented here). Backtracking is more or less standard, however, at each step we guess the number, the reactive update propagation comes back into play and it either quickly proves that the guess is unfeasible or significantly prunes the remaining search space.\\n\\nIt's interesting to note, that in this case taking and restoring snapshots of the compact representation of the state is faster than doing backtracking rollback by \"undoing the moves\".\\n\\n    class Solution {\\n    \\tstruct cell // encapsulates a single cell on a Sudoku board\\n    \\t{\\n    \\t\\tuint8_t value; // cell value 1..9 or 0 if unset\\n    \\t\\t// number of possible (unconstrained) values for the cell\\n    \\t\\tuint8_t numPossibilities;\\n    \\t\\t// if bitset[v] is 1 then value can't be v\\n    \\t\\tbitset<10> constraints;\\n    \\t\\tcell() : value(0), numPossibilities(9),constraints() {};\\n    \\t};\\n    \\tarray<array<cell,9>,9> cells;\\n    \\n    \\t// sets the value of the cell to [v]\\n    \\t// the function also propagates constraints to other cells and deduce new values where possible\\n    \\tbool set(int i, int j, int v)\\n    \\t{ \\n    \\t\\t// updating state of the cell\\n    \\t\\tcell& c = cells[i][j];\\n    \\t\\tif (c.value == v)\\n    \\t\\t\\treturn true;\\n    \\t\\tif (c.constraints[v])\\n    \\t\\t\\treturn false;\\n    \\t\\tc.constraints = bitset<10>(0x3FE); // all 1s\\n    \\t\\tc.constraints.reset(v);\\n    \\t\\tc.numPossibilities = 1;\\n    \\t\\tc.value = v;\\n    \\n    \\t\\t// propagating constraints\\n    \\t\\tfor (int k = 0; k<9; k++) {\\n    \\t\\t\\t// to the row: \\n    \\t\\t\\tif (i != k && !updateConstraints(k, j, v))\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t// to the column:\\n    \\t\\t\\tif (j != k && !updateConstraints(i, k, v))\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t// to the 3x3 square:\\n    \\t\\t\\tint ix = (i / 3) * 3 + k / 3;\\n    \\t\\t\\tint jx = (j / 3) * 3 + k % 3;\\n    \\t\\t\\tif (ix != i && jx != j && !updateConstraints(ix, jx, v))\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\treturn true;\\n    \\t}\\n    \\t// update constraints of the cell i,j by excluding possibility of 'excludedValue'\\n    \\t// once there's one possibility left the function recurses back into set()\\n    \\tbool updateConstraints(int i, int j, int excludedValue)\\n    \\t{\\n    \\t\\tcell& c = cells[i][j];\\n    \\t\\tif (c.constraints[excludedValue]) {\\n    \\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\tif (c.value == excludedValue) {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\tc.constraints.set(excludedValue);\\n    \\t\\tif (--c.numPossibilities > 1)\\n    \\t\\t\\treturn true;\\n    \\t\\tfor (int v = 1; v <= 9; v++) {\\n    \\t\\t\\tif (!c.constraints[v]) {\\n    \\t\\t\\t\\treturn set(i, j, v);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tassert(false);\\n    \\t}\\n    \\n    \\t// backtracking state - list of empty cells\\n    \\tvector<pair<int, int>> bt;\\n    \\n    \\t// find values for empty cells\\n    \\tbool findValuesForEmptyCells()\\n    \\t{\\n    \\t\\t// collecting all empty cells\\n    \\t\\tbt.clear();\\n    \\t\\tfor (int i = 0; i < 9; i++) {\\n    \\t\\t\\tfor (int j = 0; j < 9; j++) {\\n    \\t\\t\\t\\tif (!cells[i][j].value)\\n    \\t\\t\\t\\t\\tbt.push_back(make_pair(i, j));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// making backtracking efficient by pre-sorting empty cells by numPossibilities\\n    \\t\\tsort(bt.begin(), bt.end(), [this](const pair<int, int>&a, const pair<int, int>&b) {\\n    \\t\\t\\treturn cells[a.first][a.second].numPossibilities < cells[b.first][b.second].numPossibilities; });\\n    \\t\\treturn backtrack(0);\\n    \\t}\\n    \\n    \\t// Finds value for all empty cells with index >=k\\n    \\tbool backtrack(int k)\\n    \\t{\\n    \\t\\tif (k >= bt.size())\\n    \\t\\t\\treturn true;\\n    \\t\\tint i = bt[k].first;\\n    \\t\\tint j = bt[k].second;\\n    \\t\\t// fast path - only 1 possibility\\n    \\t\\tif (cells[i][j].value)\\n    \\t\\t\\treturn backtrack(k + 1);\\n    \\t\\tauto constraints = cells[i][j].constraints;\\n    \\t\\t// slow path >1 possibility.\\n    \\t\\t// making snapshot of the state\\n    \\t\\tarray<array<cell,9>,9> snapshot(cells);\\n    \\t\\tfor (int v = 1; v <= 9; v++) {\\n    \\t\\t\\tif (!constraints[v]) {\\n    \\t\\t\\t\\tif (set(i, j, v)) {\\n    \\t\\t\\t\\t\\tif (backtrack(k + 1))\\n    \\t\\t\\t\\t\\t\\treturn true;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\t// restoring from snapshot,\\n    \\t\\t\\t\\t// note: computationally this is cheaper\\n    \\t\\t\\t\\t// than alternative implementation with undoing the changes\\n    \\t\\t\\t\\tcells = snapshot;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    public:\\n    \\tvoid solveSudoku(vector<vector<char>> &board) {\\n    \\t\\tcells = array<array<cell,9>,9>(); // clear array\\n    \\t\\t// Decoding input board into the internal cell matrix.\\n    \\t\\t// As we do it - constraints are propagated and even additional values are set as we go\\n    \\t\\t// (in the case if it is possible to unambiguously deduce them).\\n    \\t\\tfor (int i = 0; i < 9; i++)\\n    \\t\\t{\\n    \\t\\t\\tfor (int j = 0; j < 9; j++) {\\n    \\t\\t\\t\\tif (board[i][j] != '.' && !set(i, j, board[i][j] - '0'))\\n    \\t\\t\\t\\t\\treturn; // sudoku is either incorrect or unsolvable\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// if we're lucky we've already got a solution,\\n    \\t\\t// however, if we have empty cells we need to use backtracking to fill them\\n    \\t\\tif (!findValuesForEmptyCells())\\n    \\t\\t\\treturn; // sudoku is unsolvable\\n    \\n    \\t\\t// copying the solution back to the board\\n    \\t\\tfor (int i = 0; i < 9; i++)\\n    \\t\\t{\\n    \\t\\t\\tfor (int j = 0; j < 9; j++) {\\n    \\t\\t\\t\\tif (cells[i][j].value)\\n    \\t\\t\\t\\t\\tboard[i][j] = cells[i][j].value + '0';\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/59649/yet-another-0ms-c-solution"
		},
		{
			"lc_ans_id":"15796",
			"view":"12219",
			"top":"2",
			"title":"Singapore prime minister Lee Hsien Loong's Sudoku Solver code runs in 1ms",
			"vote":"38",
			"content":"Singapore's prime minister [Lee Hsien Loong][1] showcased his Sudoku Solver C code. You can read his original Facebook post [here][2] and another news reporting it [here][3].\\n\\nI have made some slight modification to adapt it so it can be [tested on LeetCode OJ][4]. It passed all 6/6 test cases with a runtime of **1 ms**. Pretty impressive for a prime minister, huh?\\n\\n    // Original author: Hsien Loong Lee (http://bit.ly/1zfIGMc)\\n    // Slight modification by @1337c0d3r to adapt to run on LeetCode OJ.\\n    // https://leetcode.com/problems/sudoku-solver/\\n    int InBlock[81], InRow[81], InCol[81];\\n    \\n    const int BLANK = 0;\\n    const int ONES = 0x3fe; \\t// Binary 1111111110\\n    \\n    int Entry[81];\\t// Records entries 1-9 in the grid, as the corresponding bit set to 1\\n    int Block[9], Row[9], Col[9];\\t// Each int is a 9-bit array\\n    \\n    int SeqPtr = 0;\\n    int Sequence[81];\\n    \\n    \\n    \\n    void SwapSeqEntries(int S1, int S2)\\n    {\\n         int temp = Sequence[S2];\\n         Sequence[S2] = Sequence[S1];\\n         Sequence[S1] = temp;\\n    }\\n    \\n    \\n    void InitEntry(int i, int j, int val)\\n    {\\n    \\t int Square = 9 * i + j;\\n    \\t int valbit = 1 << val;\\n         int SeqPtr2;\\n    \\n         // add suitable checks for data consistency\\n         \\n    \\t Entry[Square] = valbit;\\n    \\t Block[InBlock[Square]] &= ~valbit;\\n    \\t Col[InCol[Square]] &= ~valbit; // Simpler Col[j] &= ~valbit;\\n    \\t Row[InRow[Square]] &= ~valbit; // Simpler Row[i] &= ~valbit;\\n    \\n         SeqPtr2 = SeqPtr;\\n         while (SeqPtr2 < 81 && Sequence[SeqPtr2] != Square)\\n               SeqPtr2++ ;\\n    \\n         SwapSeqEntries(SeqPtr, SeqPtr2);\\n         SeqPtr++;\\n    }\\n    \\n    \\n    void PrintArray(char **board)\\n    {\\n         int i, j, valbit, val, Square;\\n         char ch;\\n         \\n         Square = 0;\\n    \\n         for (i = 0; i < 9; i++) {\\n             for (j = 0; j < 9; j++) {\\n                 valbit = Entry[Square++];\\n                 if (valbit == 0) ch = '-';\\n                 else {\\n                     for (val = 1; val <= 9; val++) \\n                         if (valbit == (1 << val)) {\\n                            ch = '0' + val;\\n                            break;\\n                         }\\n                 }    \\n                 board[i][j] = ch;\\n             }\\n         }\\n    }\\n    \\n    \\n    int NextSeq(int S)\\n    {\\n        int S2, Square, Possibles, BitCount;\\n        int T, MinBitCount = 100;\\n    \\n        for (T = S; T < 81; T++) {\\n            Square = Sequence[T];\\n            Possibles = Block[InBlock[Square]] & Row[InRow[Square]] & Col[InCol[Square]];\\n            BitCount = 0;\\n            while (Possibles) {\\n               Possibles &= ~(Possibles & -Possibles);\\n               BitCount++;\\n            }\\n    \\n            if (BitCount < MinBitCount) {\\n               MinBitCount = BitCount;\\n               S2 = T;\\n            }\\n        }\\n    \\n        return S2;\\n    }\\n    \\n    \\n    void Place(int S, char** board)\\n    {\\n        if (S >= 81) {\\n            PrintArray(board);\\n            return;\\n        }\\n    \\n        int S2 = NextSeq(S);\\n        SwapSeqEntries(S, S2);\\n    \\n        int Square = Sequence[S];\\n    \\n        int \\tBlockIndex = InBlock[Square],\\n    \\t\\t\\tRowIndex = InRow[Square],\\n    \\t\\t\\tColIndex = InCol[Square];\\n    \\n        int \\tPossibles = Block[BlockIndex] & Row[RowIndex] & Col[ColIndex];\\n        while (Possibles) {\\n              int valbit = Possibles & (-Possibles); // Lowest 1 bit in Possibles\\n              Possibles &= ~valbit;\\n              Entry[Square] = valbit;\\n              Block[BlockIndex] &= ~valbit;\\n              Row[RowIndex] &= ~valbit;\\n              Col[ColIndex] &= ~valbit;\\n    \\t\\t\\t\\t\\n              Place(S + 1, board);\\n    \\n              Entry[Square] = BLANK; // Could be moved out of the loop\\n              Block[BlockIndex] |= valbit;\\n              Row[RowIndex] |= valbit;\\n              Col[ColIndex] |= valbit;\\n    \\t}\\n    \\n        SwapSeqEntries(S, S2);\\n    }\\n    \\n    void solveSudoku(char **board, int m, int n) {\\n        SeqPtr = 0;\\n        int i, j, Square;\\n    \\n    \\tfor (i = 0; i < 9; i++)\\n    \\t\\tfor (j = 0; j < 9; j++) {\\n    \\t\\t\\tSquare = 9 * i + j;\\n    \\t\\t\\tInRow[Square] = i;\\n    \\t\\t\\tInCol[Square] = j;\\n    \\t\\t\\tInBlock[Square] = (i / 3) * 3 + ( j / 3);\\n    \\t\\t}\\n    \\n    \\n    \\tfor (Square = 0; Square < 81; Square++) {\\n            Sequence[Square] = Square;\\n    \\t\\tEntry[Square] = BLANK;\\n        }\\n        \\n    \\tfor (i = 0; i < 9; i++) \\n    \\t\\tBlock[i] = Row[i] = Col[i] = ONES;\\n        \\n        for (int i = 0; i < 9; ++i)\\n           for (int j = 0; j < 9; ++j) {\\n               if ('.' != board[i][j])\\n                    InitEntry(i, j, board[i][j] - '0');\\n           }\\n           \\n        Place(SeqPtr, board);\\n    }\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Lee_Hsien_Loong\\n  [2]: https://www.facebook.com/leehsienloong/photos/a.344710778924968.83425.125845680811480/905828379479869/?type=3&permPage=1\\n  [3]: http://arstechnica.com/information-technology/2015/05/04/prime-minister-of-singapore-shares-his-c-code-for-sudoku-solver/\\n  [4]: https://leetcode.com/problems/sudoku-solver/"
		},
		{
			"lc_ans_id":"15853",
			"view":"6235",
			"top":"3",
			"title":"Simple and Clean Solution / C++",
			"vote":"27",
			"content":"\\n    bool check(vector<vector<char>> &board, int i, int j, char val)\\n    {\\n        int row = i - i%3, column = j - j%3;\\n        for(int x=0; x<9; x++) if(board[x][j] == val) return false;\\n        for(int y=0; y<9; y++) if(board[i][y] == val) return false;\\n        for(int x=0; x<3; x++)\\n        for(int y=0; y<3; y++)\\n            if(board[row+x][column+y] == val) return false;\\n        return true;\\n    }\\n    bool solveSudoku(vector<vector<char>> &board, int i, int j)\\n    {\\n        if(i==9) return true;\\n        if(j==9) return solveSudoku(board, i+1, 0);\\n        if(board[i][j] != '.') return solveSudoku(board, i, j+1);\\n\\n        for(char c='1'; c<='9'; c++)\\n        {\\n            if(check(board, i, j, c))\\n            {\\n                board[i][j] = c;\\n                if(solveSudoku(board, i, j+1)) return true;\\n                board[i][j] = '.';\\n            }\\n        }\\n            \\n        return false;\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solveSudoku(board, 0, 0);\\n    }"
		},
		{
			"lc_ans_id":"15892",
			"view":"10216",
			"top":"4",
			"title":"A simple DFS solution",
			"vote":"22",
			"content":"\\n\\n    class Solution {\\n    public:\\n    \\tbool isValidSudoku(vector<vector<char> > &board) {\\n    \\t\\treturn true;\\n    \\t}\\n    \\tvoid solveSudoku(vector<vector<char> > &board) {\\n    \\t\\tutil(board, 0);\\n    \\t}\\n    \\tbool util(vector<vector<char>>& board, int pos)\\n    \\t{\\n    \\t\\tif (pos >= 81)\\n    \\t\\t\\treturn true;\\n    \\t\\tint i = pos / 9;\\n    \\t\\tint j = pos % 9;\\n    \\t\\tif (board[i][j] != '.')\\n    \\t\\t\\treturn util(board, pos + 1);\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\tfor (char c = '1'; c <= '9'; c++)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tif (!isInRow(board, i,c) && !isInCol(board, j, c) && !isInRec(board, i, j, c))\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tboard[i][j] = c;\\n    \\t\\t\\t\\t\\tif (util(board, pos + 1))\\n    \\t\\t\\t\\t\\t\\treturn true;\\n    \\t\\t\\t\\t\\telse\\n    \\t\\t\\t\\t\\t\\tboard[i][j] = '.';\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\tbool isInRow(vector<vector<char>>& board, int i, char c)\\n    \\t{\\n    \\t\\tvector<char>& row = board[i];\\n    \\t\\tfor (int k = 0; k < 9; k++)\\n    \\t\\t{\\n    \\t\\t\\tif (row[k] == c)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    \\tbool isInCol(vector<vector<char>>& board,int j, char c)\\n    \\t{\\n    \\t\\tfor (int k = 0; k < 9; k++)\\n    \\t\\t{\\n    \\t\\t\\tif (board[k][j] == c)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    \\tbool isInRec(vector<vector<char>>& board, int i, int j, char c)\\n    \\t{\\n    \\t\\tint bigrow = i / 3, bigcol = j / 3;\\n    \\t\\tfor (int m = 3 * bigrow; m < 3 * (bigrow + 1); m++)\\n    \\t\\t{\\n    \\t\\t\\tfor (int n = 3 * bigcol; n < 3 * (bigcol + 1); n++)\\n    \\t\\t\\t\\tif (board[m][n] == c)\\n    \\t\\t\\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    };"
		},
		{
			"lc_ans_id":"15904",
			"view":"1719",
			"top":"5",
			"title":"C++ clear solution using dfs, beating 90% c++ coder.",
			"vote":"16",
			"content":"    class Solution {\\n    public:\\n        bool col[10][10],row[10][10],f[10][10];\\n        bool flag = false;\\n        void solveSudoku(vector<vector<char>>& board) {\\n             memset(col,false,sizeof(col));\\n             memset(row,false,sizeof(row));\\n             memset(f,false,sizeof(f));\\n             for(int i = 0; i < 9;i++){\\n                 for(int j = 0; j < 9;j++){\\n                     if(board[i][j] == '.')   continue;\\n                     int temp = 3*(i/3)+j/3;\\n                     int num = board[i][j]-'0';\\n                     col[j][num] = row[i][num] = f[temp][num] = true;\\n                 }\\n             }\\n             dfs(board,0,0);\\n        }\\n        void dfs(vector<vector<char>>& board,int i,int j){\\n            if(flag == true)  return ;\\n            if(i >= 9){\\n                flag = true;\\n                return ;\\n            }\\n            if(board[i][j] != '.'){\\n                 if(j < 8)  dfs(board,i,j+1);\\n                 else dfs(board,i+1,0);\\n                 if(flag)  return;\\n            }\\n            \\n            else{\\n                int temp = 3*(i/3)+j/3;\\n                for(int n = 1; n <= 9; n++){\\n                    if(!col[j][n] && !row[i][n] && !f[temp][n]){\\n                        board[i][j] = n + '0';\\n                        col[j][n] = row[i][n] = f[temp][n] = true;\\n                        if(j < 8)  dfs(board,i,j+1);\\n                        else dfs(board,i+1,0);\\n                        col[j][n] = row[i][n] = f[temp][n] = false;\\n                        if(flag)  return;\\n                    }\\n                }\\n                board[i][j] = '.';\\n            }\\n        }\\n    };"
		},
		{
			"lc_ans_id":"15759",
			"view":"2393",
			"top":"6",
			"title":"48ms straitforward python DFS solution with explanations",
			"vote":"16",
			"content":"It's similar to how human solve Sudoku. <br>\\n1. create a hash table (dictionary) `val` to store possible values in every location.<br>\\n2. Each time, start from the location with fewest possible values, choose one value from it and then update the board and possible values at other locations. If this update is valid, keep solving (DFS). If this update is invalid (leaving zero possible values at some locations) or this value doesn't lead to the solution, undo the updates and then choose the next value. <br>\\n\\nSince we calculated `val` at the beginning and start filling the board from the location with fewest possible values, the amount of calculation and thus the runtime can be significantly reduced: <br><br>\\nThe run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest python solutions here.<br><br>\\nThe `PossibleVals` function may be further simplified/optimized, but it works just fine for now. (it would look less lengthy if we are allowed to use numpy array for the board lol). <br>\\n\\n<br>\\n\\n    def solveSudoku(self, board):\\n        self.board = board\\n        self.val = self.PossibleVals()\\n        self.Solver()\\n\\n    def PossibleVals(self):\\n        a = \"123456789\"\\n        d, val = {}, {}\\n        for i in xrange(9):\\n            for j in xrange(9):\\n                ele = self.board[i][j]\\n                if ele != \".\":\\n                    d[(\"r\", i)] = d.get((\"r\", i), []) + [ele]\\n                    d[(\"c\", j)] = d.get((\"c\", j), []) + [ele]\\n                    d[(i//3, j//3)] = d.get((i//3, j//3), []) + [ele]\\n                else:\\n                    val[(i,j)] = []\\n        for (i,j) in val.keys():\\n            inval = d.get((\"r\",i),[])+d.get((\"c\",j),[])+d.get((i/3,j/3),[])\\n            val[(i,j)] = [n for n in a if n not in inval ]\\n        return val\\n\\n    def Solver(self):\\n        if len(self.val)==0:\\n            return True\\n        kee = min(self.val.keys(), key=lambda x: len(self.val[x]))\\n        nums = self.val[kee]\\n        for n in nums:\\n            update = {kee:self.val[kee]}\\n            if self.ValidOne(n, kee, update): # valid choice\\n                if self.Solver(): # keep solving\\n                    return True\\n            self.undo(kee, update) # invalid choice or didn't solve it => undo\\n        return False\\n        \\n    def ValidOne(self, n, kee, update):\\n        self.board[kee[0]][kee[1]] = n\\n        del self.val[kee]\\n        i, j = kee\\n        for ind in self.val.keys():\\n            if n in self.val[ind]:\\n                if ind[0]==i or ind[1]==j or (ind[0]/3,ind[1]/3)==(i/3,j/3):\\n                    update[ind] = n\\n                    self.val[ind].remove(n)\\n                    if len(self.val[ind])==0:\\n                        return False\\n        return True\\n\\n    def undo(self, kee, update):\\n        self.board[kee[0]][kee[1]]=\".\"\\n        for k in update:            \\n            if k not in self.val:\\n                self.val[k]= update[k]\\n            else:\\n                self.val[k].append(update[k])\\n        return None"
		},
		{
			"lc_ans_id":"15806",
			"view":"4200",
			"top":"7",
			"title":"Yet another 0ms C++ solution",
			"vote":"13",
			"content":"This is an extension of my [previous 2ms solution posted earlier][1].\\n\\nIt is much faster than pure DFS/Backtracking, since it primarily relies on reactive constraint propagation and uses backtracking only as a fallback. This aspect of the algorithm remains unchanged. See the link above for more detailed description.\\n\\nThe new version posted here, uses the same algorithm, but optimized with the help of moderately-crazy bithacks and modulo-n arithmetic tricks to speedup some things.\\n\\n    class Solution {\\n        // Table which allows compute the value of the cell\\n        // from the unambiguous bit mask as maskToValue[(mask%11)-1] \\n        // uses the fact that (1<<i)%11 is unique for i = [0..8] and never produces 0\\n        const char maskToValue[10] = {'1','2','9','3','5','6','8','4','7','6'};\\n        struct SudokuSolver {\\n            // Using mask for each cell which constraints values which can be in the cell\\n            // Yeap, it is more storage, comparing to rows/cols/sqrs approach\\n            // but it allows to do super-fast reactive constraint propagation\\n            array<array<uint16_t,9>,9> board;\\n            SudokuSolver()\\n            {\\n                // Initializing the board with mask, which permits all numbers\\n                for (int i=0; i<9; i++)\\n                    for (int j=0; j<9; j++)\\n                        board[i][j] = 0x1ff;\\n            }\\n            \\n            // adds value v [1..9] to the board, return false if it violates constraints\\n            bool add(int i, int j, int v)\\n            {\\n                return set(i, j, 1<<(v-1));\\n            }\\n    \\n            // set a value mask to the cell (i,j) and reactively updates constraints\\n            bool set(int i, int j, uint16_t mask)\\n            {\\n                int16_t prev = board[i][j];\\n                if (prev == mask) return true;\\n                if (!(prev&mask)) return false;\\n                board[i][j] = mask;\\n                return propagate(i,j,mask);\\n            }\\n            \\n            // propagates constraints as a result of setting i,j to mask\\n            bool propagate(int i, int j, uint16_t mask)\\n            {\\n                for (int k=0; k<9; k++) {\\n                    if (k!=j && !addConstraint(i, k, mask)) return false;\\n                    if (k!=i && !addConstraint(k, j, mask)) return false;\\n                    int ii = (i/3)*3 + (k/3);\\n                    int jj = (j/3)*3 + (k%3);\\n                    if ((i != ii || j != jj) && !addConstraint(ii, jj, mask)) return false;\\n                }\\n                return true;\\n            }\\n            \\n            // prohibits putting value in mask to the cell (i,j)\\n            bool addConstraint(int i, int j, uint16_t mask)\\n            {\\n                int16_t newMask = board[i][j] &~ mask;\\n                if (newMask != board[i][j]) {\\n                    if (newMask == 0) return false;\\n                    board[i][j] = newMask;\\n                    if (((newMask-1)&newMask)==0) {\\n                        // good news - we have only one possibility for the cell (i,j)\\n                        return propagate(i, j, newMask);\\n                    }\\n                }\\n                return true;\\n            }\\n            \\n            // list of cell coordinates with >1 possibilities for values\\n            vector<pair<int,int>> v;\\n            void solve()\\n            {\\n                // finding all ambiguous cells\\n                for (int i=0; i<9; i++) {\\n                    for (int j=0; j<9; j++) {\\n                        uint16_t mask = board[i][j];\\n                        if (mask&(mask-1)) v.push_back(make_pair(i,j));\\n                    }\\n                }\\n                // note: it is also a good idea to sort v by the hamming weight, but\\n                // without sorting it is still super-fast\\n                // running backtracking as is\\n                backtrack(0);\\n            }\\n    \\n            // backtracking        \\n            bool backtrack(int k) {\\n                if (k == v.size()) return true;\\n                int i = v[k].first;\\n                int j = v[k].second;\\n                uint16_t mask = board[i][j];\\n                if (mask&(mask-1)) {\\n                    // the board state is so compact and backtracking depth is so shallow, so\\n                    // it is cheaper to make a snapshot of the state vs. doing classical\\n                    // undo at each move\\n                    auto snapshot = board;\\n                    for (uint16_t cand = 1; cand<=0x1ff; cand = cand <<1) {\\n                        if (set(i, j, cand) && backtrack(k+1)) return true;\\n                        board = snapshot;\\n                    }\\n                    return false;\\n                }\\n                else {\\n                    return backtrack(k + 1);\\n                }\\n            }\\n            \\n        };\\n        \\n    public:\\n        void solveSudoku(vector<vector<char>>& board) {\\n            SudokuSolver solver;\\n            for (int i=0; i<9; i++) {\\n                for (int j=0; j<9; j++) {\\n                    char c = board[i][j];\\n                    if (c != '.' && !solver.add(i,j,c-'0')) return;\\n                }\\n            }\\n            // At this point 9 of 10 sudokus published in magazines will be solved by constraint propagation\\n            // only 'hard' sudokus will require some (limited) backtracking \\n            solver.solve();\\n            for (int i=0; i<9; i++)\\n                for (int j=0; j<9; j++)\\n                    board[i][j] = maskToValue[(solver.board[i][j]%11)-1];\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/21452/sharing-my-2ms-c-solution-with-comments-and-explanations?show=21452#q21452"
		},
		{
			"lc_ans_id":"15903",
			"view":"2135",
			"top":"8",
			"title":"Two very Simple and Neat Java DFS/Backtracking solutions",
			"vote":"12",
			"content":"1.The first one uses three `2D-array` to check valid. Running time is about 256-320ms.\\n\\n    private char[][] b;\\n    private boolean[][] row = new boolean[9][9];\\n    private boolean[][] col = new boolean[9][9];\\n    private boolean[][] block = new boolean[9][9];\\n    public void solveSudoku(char[][] board) {\\n        b = board;\\n        int num, k;\\n        for (int i=0; i<9; i++) {\\n            for (int j=0; j<9; j++) {\\n                if(board[i][j]!='.') {\\n                    num = board[i][j]-'1'; \\n                    k = i/3*3 + j/3;\\n                    row[i][num] = col[j][num] = block[k][num] = true;\\n                }\\n            }\\n        }\\n        Helper(0);\\n    }\\n    public boolean Helper(int ind){\\n        if(ind==81) return true; \\n        int i=ind/9, j=ind%9, num, k;\\n        if(b[i][j]!='.') return Helper(ind+1);\\n        else{\\n            for(char f='1'; f<='9'; f++){\\n                num = f-'1'; \\n                k= i/3*3 + j/3;\\n                if(!row[i][num] && !col[j][num] && !block[k][num]){\\n                    b[i][j]= f;\\n                    row[i][num] = col[j][num] = block[k][num] = true;\\n                    if(Helper(ind+1)) return true;                \\n                    b[i][j]='.';\\n                    row[i][num] = col[j][num] = block[k][num] = false;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n2.The second one check with `board itself`. The code is neat and simple. Running time is about 252-332ms. The time difference between these two version is small. But it's huge in [C++ answer][1].\\n\\n    private char[][] b;\\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length < 9) return;\\n        b = board;\\n        solve(0);\\n    }\\n    public boolean solve(int ind){\\n        if(ind==81) return true; \\n        int i=ind/9, j=ind%9;\\n        if(b[i][j]!='.') return solve(ind+1);\\n        else{\\n            for(char f = '1'; f <= '9'; f++){\\n                if(isValidFill(i, j, f)){\\n                    b[i][j]= f;\\n                    if(solve(ind+1)) return true;                \\n                    b[i][j]='.';\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n    public boolean isValidFill(int i, int j, char fill){\\n        for(int k=0; k<9; k++){\\n            int r= i/3*3+j/3;   //select the block\\n            if(b[i][k]==fill || b[k][j]==fill || b[r/3*3+k/3][r%3*3+k%3]==fill) \\n                return false; //check row, column, block\\n        }            \\n        return true;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/51303/two-very-simple-and-neat-c-dfs-backtracking-solutions"
		},
		{
			"lc_ans_id":"15930",
			"view":"2369",
			"top":"9",
			"title":"There is a Dancing Links X Algorithm",
			"vote":"12",
			"content":"Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
		}
	],
	"id":"37",
	"title":"Sudoku Solver",
	"content":"<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>\r\n\r\n<p>Empty cells are indicated by the character <code>'.'</code>.</p>\r\n\r\n<p>You may assume that there will be only one unique solution.</code>\r\n\r\n<p>\r\n<img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" /><br />\r\n<p style=\"font-size: 11px\">A sudoku puzzle...</p>\r\n</p>\r\n\r\n<p>\r\n<img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png\" /><br />\r\n<p style=\"font-size: 11px\">...and its solution numbers marked in red.\r\n</p>",
	"frequency":"430",
	"ac_num":"86834"
}