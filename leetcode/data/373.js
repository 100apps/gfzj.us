{
	"difficulty":"2",
	"submit_num":"117717",
	"show_id":"373",
	"leetcode_id":"373",
	"answers":[
		{
			"lc_ans_id":"84551",
			"view":"18442",
			"top":"0",
			"title":"simple Java O(KlogK) solution with explanation",
			"vote":"119",
			"content":"Basic idea: Use min_heap to keep track on next minimum pair sum, and we only need to maintain K possible candidates in the data structure.\\n\\nSome observations: For every numbers in nums1, its best partner(yields min sum) always strats from nums2[0] since arrays are all sorted; And for a specific number in nums1, its next candidate sould be **[this specific number]** + **nums2[current_associated_index + 1]**, unless out of boundary;)\\n\\nHere is a simple example demonstrate how this algorithm works.\\n\\n![image](https://cloud.githubusercontent.com/assets/8743900/17332795/0bb46cfe-589e-11e6-90b5-5d3c9696c4f0.png)\\n\\n\\nThe run time complexity is O(kLogk) since que.size <= k and we do at most k loop.\\n\\n```\\npublic class Solution {\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<int[]> que = new PriorityQueue<>((a,b)->a[0]+a[1]-b[0]-b[1]);\\n        List<int[]> res = new ArrayList<>();\\n        if(nums1.length==0 || nums2.length==0 || k==0) return res;\\n        for(int i=0; i<nums1.length && i<k; i++) que.offer(new int[]{nums1[i], nums2[0], 0});\\n        while(k-- > 0 && !que.isEmpty()){\\n            int[] cur = que.poll();\\n            res.add(new int[]{cur[0], cur[1]});\\n            if(cur[2] == nums2.length-1) continue;\\n            que.offer(new int[]{cur[0],nums2[cur[2]+1], cur[2]+1});\\n        }\\n        return res;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"84550",
			"view":"21725",
			"top":"1",
			"title":"Slow 1-liner to Fast solutions",
			"vote":"102",
			"content":"Several solutions from naive to more elaborate. I found it helpful to visualize the input as an **m\\xd7n matrix** of sums, for example for nums1=[1,7,11], and nums2=[2,4,6]:\\n\\n          2   4   6\\n       +------------\\n     1 |  3   5   7\\n     7 |  9  11  13\\n    11 | 13  15  17\\n\\nOf course the smallest pair overall is in the top left corner, the one with sum 3. We don't even need to look anywhere else. After including that pair in the output, the next-smaller pair must be the next on the right (sum=5) or the next below (sum=9). We can keep a \"horizon\" of possible candidates, implemented as a heap / priority-queue, and roughly speaking we'll grow from the top left corner towards the right/bottom. That's what my solution 5 does. Solution 4 is similar, not quite as efficient but a lot shorter and my favorite.\\n<br>\\n\\n## **Solution 1: Brute Force** <sup>(accepted in 560 ms)</sup>\\n\\nJust produce all pairs, sort them by sum, and return the first k.\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        return sorted(itertools.product(nums1, nums2), key=sum)[:k]\\n\\n## **Solution 2: Clean Brute Force** <sup>(accepted in 532 ms)</sup>\\n\\nThe above produces tuples and while the judge doesn't care, it's cleaner to make them lists as requested:\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        return map(list, sorted(itertools.product(nums1, nums2), key=sum)[:k])\\n\\n## **Solution 3: Less Brute Force** <sup>(accepted in 296 ms)</sup>\\n\\nStill going through all pairs, but only with a generator and `heapq.nsmallest`, which uses a heap of size k. So this only takes O(k) extra memory and O(mn log k) time.\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        return map(list, heapq.nsmallest(k, itertools.product(nums1, nums2), key=sum))\\n\\nOr (accepted in 368 ms):\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        return heapq.nsmallest(k, ([u, v] for u in nums1 for v in nums2), key=sum)\\n\\n## **Solution 4: Efficient**  <sup>(accepted in 112 ms)</sup>\\n\\nThe brute force solutions computed the whole matrix (see visualization above). This solution doesn't. It turns each row into a generator of triples [u+v, u, v], only computing the next when asked for one. And then merges these generators with a heap. Takes O(m + k\\\\*log(m)) time and O(m) extra space.\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        streams = map(lambda u: ([u+v, u, v] for v in nums2), nums1)\\n        stream = heapq.merge(*streams)\\n        return [suv[1:] for suv in itertools.islice(stream, k)]\\n\\n## **Solution 5: More efficient**  <sup>(accepted in 104 ms)</sup>\\n\\nThe previous solution right away considered (the first pair of) all matrix rows (see visualization above). This one doesn't. It starts off only with the very first pair at the top-left corner of the matrix, and expands from there as needed. Whenever a pair is chosen into the output result, the next pair in the row gets added to the priority queue of current options. Also, if the chosen pair is the first one in its row, then the first pair in the next row is added to the queue.\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        queue = []\\n        def push(i, j):\\n            if i < len(nums1) and j < len(nums2):\\n                heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\\n        push(0, 0)\\n        pairs = []\\n        while queue and len(pairs) < k:\\n            _, i, j = heapq.heappop(queue)\\n            pairs.append([nums1[i], nums2[j]])\\n            push(i, j + 1)\\n            if j == 0:\\n                push(i + 1, 0)\\n        return pairs"
		},
		{
			"lc_ans_id":"84569",
			"view":"12134",
			"top":"2",
			"title":"Java 9ms heap queue solution, k log(k)",
			"vote":"53",
			"content":"Frist, we take the first k elements of nums1 and paired with nums2[0] as the starting pairs so that we have (0,0), (1,0), (2,0),.....(k-1,0) in the heap.\\nEach time after we pick the pair with min sum, we put the new pair with the second index +1. ie, pick (0,0), we put back (0,1). Therefore, the heap alway maintains at most min(k, len(nums1)) elements.    \\n\\n```\\npublic class Solution {\\n    class Pair{\\n        int[] pair;\\n        int idx; // current index to nums2\\n        long sum;\\n        Pair(int idx, int n1, int n2){\\n            this.idx = idx;\\n            pair = new int[]{n1, n2};\\n            sum = (long) n1 + (long) n2;\\n        }\\n    }\\n    class CompPair implements Comparator<Pair> {\\n        public int compare(Pair p1, Pair p2){\\n            return Long.compare(p1.sum, p2.sum);\\n        }\\n    }\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> ret = new ArrayList<>();\\n        if (nums1==null || nums2==null || nums1.length ==0 || nums2.length ==0) return ret;\\n        int len1 = nums1.length, len2=nums2.length;  \\n\\n        PriorityQueue<Pair> q = new PriorityQueue(k, new CompPair()); \\n        for (int i=0; i<nums1.length && i<k ; i++) { // only need first k number in nums1 to start  \\n            q.offer( new Pair(0, nums1[i],nums2[0]) );\\n        }\\n        for (int i=1; i<=k && !q.isEmpty(); i++) { // get the first k sums\\n            Pair p = q.poll(); \\n            ret.add( p.pair );\\n            if (p.idx < len2 -1 ) { // get to next value in nums2\\n                int next = p.idx+1;\\n                q.offer( new Pair(next, p.pair[0], nums2[next]) );\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"84607",
			"view":"10760",
			"top":"3",
			"title":"Clean 16ms C++ O(N) Space O(KlogN) Time Solution using Priority queue",
			"vote":"50",
			"content":"Here, N = min(k, n).\\n          K = min(k, mn) \\n        where m, n is the size of two arrays and k is the k in the problem.\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>> result;\\n        if (nums1.empty() || nums2.empty() || k <= 0)\\n            return result;\\n        auto comp = [&nums1, &nums2](pair<int, int> a, pair<int, int> b) {\\n            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];};\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> min_heap(comp);\\n        min_heap.emplace(0, 0);\\n        while(k-- > 0 && min_heap.size())\\n        {\\n            auto idx_pair = min_heap.top(); min_heap.pop();\\n            result.emplace_back(nums1[idx_pair.first], nums2[idx_pair.second]);\\n            if (idx_pair.first + 1 < nums1.size())\\n                min_heap.emplace(idx_pair.first + 1, idx_pair.second);\\n            if (idx_pair.first == 0 && idx_pair.second + 1 < nums2.size())\\n                min_heap.emplace(idx_pair.first, idx_pair.second + 1);\\n        }\\n        return result;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"84566",
			"view":"9758",
			"top":"4",
			"title":"Share My Solution which beat 96.42%",
			"vote":"49",
			"content":"This problem is exactly the same as Leetcode378 Kth Smallest Element in a Sorted Matrix, the only difference is this problem give two array while 378 gives a matrix, but they are the same. You can check my previous post for 378 to see how it works.\\nhttps://discuss.leetcode.com/topic/52948/share-my-thoughts-and-solution\\n\\n```\\npublic class Solution {\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<Tuple> pq = new PriorityQueue<Tuple>();\\n        int m = nums1.length, n = nums2.length;\\n        List<int[]> res = new ArrayList<int[]>();\\n        if(nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0 || k <= 0) return res;\\n        for(int j = 0; j <= n-1; j++) pq.offer(new Tuple(0, j, nums1[0]+nums2[j]));\\n        for(int i = 0; i < Math.min(k, m *n); i++) {\\n            Tuple t = pq.poll();\\n            res.add(new int[]{nums1[t.x], nums2[t.y]});\\n            if(t.x == m - 1) continue;\\n            pq.offer(new Tuple (t.x + 1, t.y, nums1[t.x + 1] + nums2[t.y]));\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Tuple implements Comparable<Tuple> {\\n    int x, y, val;\\n    public Tuple (int x, int y, int val) {\\n        this.x = x;\\n        this.y = y;\\n        this.val = val;\\n    }\\n    \\n    @Override\\n    public int compareTo (Tuple that) {\\n        return this.val - that.val;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"84611",
			"view":"5256",
			"top":"5",
			"title":"Java 10ms solution no priority queue",
			"vote":"20",
			"content":"Because both array are sorted, so we can keep track of the paired index. Therefore, we do not need to go through all combinations when k < nums1.length + num2.length. Time complexity is O(k*m) where m is the length of the shorter array.\\n\\n\\n```\\npublic List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> ret = new ArrayList<int[]>();\\n        if (nums1.length == 0 || nums2.length == 0 || k == 0) {\\n            return ret;\\n        }\\n        \\n        int[] index = new int[nums1.length];\\n        while (k-- > 0) {\\n            int min_val = Integer.MAX_VALUE;\\n            int in = -1;\\n            for (int i = 0; i < nums1.length; i++) {\\n                if (index[i] >= nums2.length) {\\n                    continue;\\n                }\\n                if (nums1[i] + nums2[index[i]] < min_val) {\\n                    min_val = nums1[i] + nums2[index[i]];\\n                    in = i;\\n                }\\n            }\\n            if (in == -1) {\\n                break;\\n            }\\n            int[] temp = {nums1[in], nums2[index[in]]};\\n            ret.add(temp);\\n            index[in]++;\\n        }\\n        return ret;\\n    }\\n```"
		},
		{
			"lc_ans_id":"84568",
			"view":"3357",
			"top":"6",
			"title":"c++ priority_queue solution",
			"vote":"18",
			"content":"nums1: m     nums2: n \\ntime complexity: O(m * n logk)\\nspace complexity O(k)\\n\\n72ms solution:\\n```\\nclass Solution {\\nprivate:\\n    struct mycompare{\\n        bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n            return p1.first + p1.second < p2.first + p2.second;\\n        }\\n    };\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> res;\\n        priority_queue<pair<int,int>, vector<pair<int, int> >, mycompare> pq;\\n        for(int i = 0; i < min((int)nums1.size(), k); i++){\\n            for(int j = 0; j < min((int)nums2.size(), k); j++){\\n                if(pq.size() < k)\\n                    pq.push(make_pair(nums1[i], nums2[j]));\\n                else if(nums1[i] + nums2[j] < pq.top().first + pq.top().second){\\n                    pq.push(make_pair(nums1[i], nums2[j]));\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        while(!pq.empty()){\\n            res.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n1132ms solution:\\n```\\nclass Solution {\\nprivate:\\n    struct mycompare{\\n        bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n            return p1.first + p1.second < p2.first + p2.second;\\n        }\\n    };\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> res;\\n        priority_queue<pair<int,int>, vector<pair<int, int> >, mycompare> pq;\\n        for(int num1 : nums1){\\n            for(int num2 : nums2){\\n                pq.push(make_pair(num1, num2));\\n                if(pq.size() > k) pq.pop();\\n            }\\n        }\\n        while(!pq.empty()){\\n            res.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n40ms solution:\\n```\\nclass Solution {\\npublic:\\nvector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> res;\\n        int m = (int)nums1.size();\\n        int n = (int)nums2.size();\\n        k = min(k, m * n);\\n        vector<int> indice(m, 0);\\n        while(k-- > 0){\\n            int tmp_index = 0;\\n            long tmp_sum = LONG_MAX;\\n            for(int i = 0; i < m; i++){\\n                if(indice[i] < n && tmp_sum >= nums1[i] + nums2[indice[i]]){\\n                    tmp_index = i;\\n                    tmp_sum = nums1[i] + nums2[indice[i]];\\n                }\\n            }\\n            res.push_back(make_pair(nums1[tmp_index], nums2[indice[tmp_index]]));\\n            indice[tmp_index]++;\\n        }\\n        return res;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"84577",
			"view":"3210",
			"top":"7",
			"title":"O(k) solution",
			"vote":"11",
			"content":"Now that I can find the [kth smallest element in a sorted n\\xd7n matrix in time O(min(n, k))](https://discuss.leetcode.com/topic/53126/o-n-from-paper-yes-o-rows), I can finally solve this problem in O(k).\\n\\n**The idea:**\\n1. If `nums1` or `nums2` are larger than `k`, shrink them to size `k`.\\n2. Build a virtual matrix of the pair sums, i.e., `matrix[i][j] = nums1[i] + nums2[j]`. Make it a square matrix by padding with \"infinity\" if necessary. With \"virtual\" I mean its entries will be computed on the fly, and only those that are needed. This is necessary to stay within O(k) time.\\n3. Find the kth smallest sum `kthSum` by using that other algorithm.\\n4. Use a saddleback search variation to discount the pairs with sum **smaller** than `kthSum`. After this, `k` tells how many pairs we need whose sum **equals** `kthSum`.\\n5. Collect all pairs with sum smaller than `kthSum` as well as `k` pairs whose sum equals `kthSum`.\\n\\nEach of those steps only takes O(k) time.\\n\\nThe code (minus the code for kthSmallest, which you can copy verbatim from my solution to the other problem):\\n\\n```\\nclass Solution(object):\\n    def kSmallestPairs(self, nums1_, nums2_, k):\\n\\n        # Use at most the first k of each, then get the sizes.\\n        nums1 = nums1_[:k]\\n        nums2 = nums2_[:k]\\n        m, n = len(nums1), len(nums2)\\n\\n        # Gotta Catch 'Em All?\\n        if k >= m * n:\\n            return [[a, b] for a in nums1 for b in nums2]\\n        \\n        # Build a virtual matrix.\\n        N, inf = max(m, n), float('inf')\\n        class Row:\\n            def __init__(self, i):\\n                self.i = i\\n            def __getitem__(self, j):\\n                return nums1[self.i] + nums2[j] if self.i < m and j < n else inf\\n        matrix = map(Row, range(N))\\n\\n        # Get the k-th sum.\\n        kthSum = self.kthSmallest(matrix, k)\\n\\n        # Discount the pairs with sum smaller than the k-th.\\n        j = min(k, n)\\n        for a in nums1:\\n            while j and a + nums2[j-1] >= kthSum:\\n                j -= 1\\n            k -= j\\n\\n        # Collect and return the pairs.\\n        pairs = []\\n        for a in nums1:\\n            for b in nums2:\\n                if a + b >= kthSum + (k > 0):\\n                    break\\n                pairs.append([a, b])\\n                k -= a + b == kthSum\\n        return pairs\\n\\n    def kthSmallest(self, matrix, k):\\n        \\n        # copy & paste from https://discuss.leetcode.com/topic/53126/o-n-from-paper-yes-o-rows\\n```\\nThanks to @zhiqing_xiao for pointing out that my previous way of capping the input lists might not be O(k). It was this:\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        del nums1[k:]\\n        del nums2[k:]"
		},
		{
			"lc_ans_id":"84583",
			"view":"1891",
			"top":"8",
			"title":"Three different solutions in C++, well-explained",
			"vote":"7",
			"content":"### Solutions\\n\\n#### Priority_queue\\nIntuitively we can use priority_queue to sort the pair and collect the top k in the min heap. Time complexity will be O(nlogn) and space O(n) where n is the multiple of size1 and size2.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        vector<pair<int, int>> v;\\n        if(nums1.empty() || nums2.empty()) return v;\\n        auto cmp = [](const pair<int, int>& a, const pair<int, int>& b) {\\n            return a.first+a.second > b.first+b.second; };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> minHeap(cmp);\\n        for(auto n: nums1)\\n            for(auto m: nums2)\\n                minHeap.emplace(n, m);\\n        while(minHeap.size() && k--)\\n        {\\n            v.emplace_back(minHeap.top());\\n            minHeap.pop();\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n#### Index array\\nActually we can index the array via comparison referring to [Super Ugly Number](https://leetcode.com/problems/super-ugly-number/) and easily we collect the pairs from the sum of the smallest to the biggest.\\n\\nTime complexity will be O(km) and space cost O(n) where n and m are the sizes of the arrays respectively.\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        vector<pair<int, int>> v;\\n        if(nums1.empty() || nums2.empty()) return v;\\n        int indexes[nums1.size()]{0};\\n        int size = min(k, int(nums1.size()*nums2.size()));\\n        while(size)\\n        {\\n            int t = INT_MAX;\\n            for(int i = 0; i < nums1.size(); ++i)\\n            {\\n                if(indexes[i] == nums2.size()) continue;\\n                t = min(t, nums1[i]+nums2[indexes[i]]);\\n            }\\n            for(int i = 0; i < nums1.size(); ++i)\\n            {\\n                if(indexes[i]<nums2.size() && nums1[i]+nums2[indexes[i]]==t)\\n                    v.emplace_back(nums1[i], nums2[indexes[i]++]), size--;\\n                if(!size) return v;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n#### Combination\\nInspired by the index-array solution, we can further optimize the priority_queue solution where we only insert the next potential smallest one each time avoid inserting all the pairs at the first time. Time complexity now would be O(klogm) where k is from the problem while m is the size of the second array.\\n\\n> **Analysis for validity** If the current smallest pair is (i, j), then next potential smallest pair should be (i+1, j) or (i, j+1). But to ensure each pair will be covered, we can insert the next column index into the minimal heap only when the row index is 0. Minimal heap is where all the potential smallest pairs are stored. P.S. To ease the problem, you can put each index pair as each cell of a matrix composed of the index of the two arrays.\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        vector<pair<int,int>> v;\\n        if(nums1.empty() || nums2.empty()) return v;\\n        auto cmp = [&nums1, &nums2](const pair<int, int>& a, const pair<int, int>&b) {\\n            return nums1[a.first]+nums2[a.second] > nums1[b.first]+nums2[b.second]; };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> minHeap(cmp);\\n        minHeap.emplace(0, 0);\\n        while(minHeap.size() && k--)\\n        {\\n            auto t = minHeap.top(); minHeap.pop();\\n            v.emplace_back(nums1[t.first], nums2[t.second]);\\n            if(t.first<nums1.size()-1) minHeap.emplace(t.first+1, t.second);\\n            if(t.first==0 && t.second<nums2.size()-1) minHeap.emplace(t.first, t.second+1);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!"
		},
		{
			"lc_ans_id":"84633",
			"view":"2070",
			"top":"9",
			"title":"Java easy understandable bfs with PriorityQueue",
			"vote":"7",
			"content":"use a matrix to represent all combination of pairs from nums1 and nums2. Do a bfs from [0][0]. However, use a PriorityQueue instead of regular queue.\\n```\\npublic class Solution {\\n    final int[][] neighbors = {{0, 1}, {1, 0}};\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> list = new ArrayList<>();\\n        if (nums1 == null || nums2 == null || nums1.length == 0 || nums2.length == 0 || k == 0) {\\n            return list;\\n        }\\n        int m = nums1.length, n = nums2.length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<Pair> minHeap = new PriorityQueue<>();\\n        minHeap.offer(new Pair(0, 0, nums1[0] + nums2[0]));\\n        visited[0][0] = true;\\n        while (k > 0 && !minHeap.isEmpty()) {\\n            Pair min = minHeap.poll();\\n            list.add(new int[] {nums1[min.row], nums2[min.col]});\\n            k--;\\n            for (int[] neighbor : neighbors) {\\n                int row1 = min.row + neighbor[0];\\n                int col1 = min.col + neighbor[1];\\n                if (row1 < 0 || row1 == m || col1 < 0 || col1 == n || visited[row1][col1]) {\\n                    continue;\\n                }\\n                visited[row1][col1] = true;\\n                minHeap.offer(new Pair(row1, col1, nums1[row1] + nums2[col1]));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair> {\\n    int row;\\n    int col;\\n    int value;\\n    \\n    Pair(int row, int col, int value) {\\n        this.row = row;\\n        this.col = col;\\n        this.value = value;\\n    }\\n    \\n    public int compareTo(Pair other) {\\n        return value - other.value;\\n    } \\n}\\n```"
		}
	],
	"id":"373",
	"title":"Find K Pairs with Smallest Sums",
	"content":"<p>\r\nYou are given two integer arrays <b>nums1</b> and <b>nums2</b> sorted in ascending order and an integer <b>k</b>. \r\n</p>\r\n\r\n<p>Define a pair <b>(u,v)</b> which consists of one element from the first array and one element from the second array.</p>\r\n\r\n<p>Find the k pairs <b>(u<sub>1</sub>,v<sub>1</sub>),(u<sub>2</sub>,v<sub>2</sub>) ...(u<sub>k</sub>,v<sub>k</sub>)</b> with the smallest sums.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\nGiven nums1 = [1,7,11], nums2 = [2,4,6],  k = 3\r\n\r\nReturn: [1,2],[1,4],[1,6]\r\n\r\nThe first 3 pairs are returned from the sequence:\r\n[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\nGiven nums1 = [1,1,2], nums2 = [1,2,3],  k = 2\r\n\r\nReturn: [1,1],[1,1]\r\n\r\nThe first 2 pairs are returned from the sequence:\r\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\nGiven nums1 = [1,2], nums2 = [3],  k = 3 \r\n\r\nReturn: [1,3],[2,3]\r\n\r\nAll possible pairs are returned from the sequence:\r\n[1,3],[2,3]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/elmirap/\">@elmirap</a> and <a href=\"https://leetcode.com/stefanpochmann/\">@StefanPochmann</a> for adding this problem and creating all test cases.</p>",
	"frequency":"178",
	"ac_num":"36695"
}