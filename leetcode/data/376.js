{
	"difficulty":"2",
	"submit_num":"84254",
	"show_id":"376",
	"leetcode_id":"376",
	"answers":[
		{
			"lc_ans_id":"84849",
			"view":"16875",
			"top":"0",
			"title":"Very Simple Java Solution with detail explanation",
			"vote":"59",
			"content":"In Wiggle Subsequence, think that the solution we need should be in a way that we get alternative higher, lower,higher number.\\nEg: 2, 5, 3, 8, 6, 9 \\nIn above example, the sequence of numbers is small,big,small,big,small,big numbers (In shape of hill).\\n\\nNow for explanation, we take example series:\\n2,1,4,5,6,3,3,4,8,4\\n\\nFirst we check  if the series is starting as (big, small) or (small, big). So as 2,1 is big, small. So we will start the loop as we need small number first that is 1 as 2 is already there.\\n```\\nStep 1: First we check our requirement is to get small number. As 1<2 so the series will be\\n 2,1\\n```\\n```\\nStep 2: Now we need big number that is  greater than 1. As 4>1 so series  will be\\n2,1,4\\n```\\n```\\nStep 3: Now we need small number. But 5>4 so 4 will be replaced by 5. So the series will become\\n2,1,5\\n```\\n```\\nStep 4:  We need small number. But 6>5. Series will be\\n2,1,6\\n```\\n```\\nStep 5: Require small number. 3<6. Series will be\\n2,1,6,3\\n```\\n```\\nStep 6: Require big number. 3=3. No change in series\\n2,1,6,3\\n```\\n```\\nStep 7: Require big number. 4>3. Series will become\\n2,1,6,3,4\\n```\\n```\\nStep 8:  Require small number. 8>4. 8 will  replace 4 and series will become\\n2,1,6,3,8\\n```\\n```\\nStep 9: Require small number. 4<8. So final series will  be\\n2,1,6,3,8,4\\n```\\nAnswer is 6.\\n\\nIn the code, for constant space O(1) we will  modify the same 'num' array to store the (small, big, small) hill shape values. So the code will not only calculate the length of the sequence but if the interviewers asks for the Wiggle series also then we can return the series too. The leetcode Online Judge skipped a test case if the series starts with same set of numbers. Thanks to @ztq63830398, modified the  code to consider that test case also.    \\n\\nCode:\\n```\\n    public class Solution {\\n\\tpublic int wiggleMaxLength(int[] nums) {\\n\\t\\tif (nums.length == 0 || nums.length == 1) {\\n\\t\\t\\treturn nums.length;\\n\\t\\t}\\n\\t\\tint k = 0;\\n\\t\\twhile (k < nums.length - 1 && nums[k] == nums[k + 1]) {  //Skips all the same numbers from series beginning eg 5, 5, 5, 1\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\t\\tif (k == nums.length - 1) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint result = 2;     // This will track the result of result array\\n\\t\\tboolean smallReq = nums[k] < nums[k + 1];       //To check series starting pattern\\n\\t\\tfor (int i = k + 1; i < nums.length - 1; i++) {\\n\\t\\t\\tif (smallReq && nums[i + 1] < nums[i]) {\\n\\t\\t\\t\\tnums[result] = nums[i + 1];\\n\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\tsmallReq = !smallReq;    //Toggle the requirement from small to big number\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (!smallReq && nums[i + 1] > nums[i]) {\\n\\t\\t\\t\\t\\tnums[result] = nums[i + 1];\\n\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tsmallReq = !smallReq;    //Toggle the requirement from big to small number\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```"
		},
		{
			"lc_ans_id":"84843",
			"view":"6081",
			"top":"1",
			"title":"Easy understanding DP solution with O(n), Java version",
			"vote":"49",
			"content":"For every position in the array, there are only three possible statuses for it. \\n- up position, it means nums[i] > nums[i-1]\\n- down position, it means nums[i] < nums[i-1]\\n- equals to position, nums[i] == nums[i-1]\\n\\nSo we can use two arrays up[] and down[] to record *the max wiggle sequence length so far* at index ***i***. \\nIf nums[i] > nums[i-1], that means it  wiggles up. the element before it must be a down position. so up[i] = down[i-1] + 1;  down[i] keeps the same with before. \\nIf nums[i] < nums[i-1], that means it  wiggles down. the element before it must be a up position. so down[i] = up[i-1] + 1;  up[i] keeps the same with before. \\n If nums[i] == nums[i-1], that means it will not change anything becasue it didn't wiggle at all. so both down[i] and up[i] keep the same.\\n\\nIn fact, we can reduce the space complexity to O(1), but current way is more easy to understanding.\\n\\n```\\npublic class Solution {\\n    public int wiggleMaxLength(int[] nums) {\\n        \\n        if( nums.length == 0 ) return 0;\\n        \\n        int[] up = new int[nums.length];\\n        int[] down = new int[nums.length];\\n        \\n        up[0] = 1;\\n        down[0] = 1;\\n        \\n        for(int i = 1 ; i < nums.length; i++){\\n            if( nums[i] > nums[i-1] ){\\n                up[i] = down[i-1]+1;\\n                down[i] = down[i-1];\\n            }else if( nums[i] < nums[i-1]){\\n                down[i] = up[i-1]+1;\\n                up[i] = up[i-1];\\n            }else{\\n                down[i] = down[i-1];\\n                up[i] = up[i-1];\\n            }\\n        }\\n        \\n        return Math.max(down[nums.length-1],up[nums.length-1]);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"84883",
			"view":"7981",
			"top":"2",
			"title":"Two solutions. One is DP, the other is greedy (8 lines).",
			"vote":"34",
			"content":"DP:\\n```\\nclass Solution {\\npublic:\\n    int wiggleMaxLength(vector<int>& nums) {\\n        int size=nums.size();\\n        if(size==0) return 0;\\n        vector<int> f(size, 1);\\n        vector<int> d(size, 1);\\n        for(int i=1; i<size; ++i){\\n            for(int j=0; j<i; ++j){\\n                if(nums[j]<nums[i]){\\n                    f[i]=max(f[i], d[j]+1);\\n                }\\n                else if(nums[j]>nums[i]){\\n                    d[i]=max(d[i], f[j]+1);\\n                }\\n            }\\n        }\\n        return max(d.back(), f.back());\\n    }\\n};\\n```\\nGreedy:\\n```\\nclass Solution {\\npublic:\\n    int wiggleMaxLength(vector<int>& nums) {\\n        int size=nums.size(), f=1, d=1;\\n        for(int i=1; i<size; ++i){\\n                 if(nums[i]>nums[i-1]) f=d+1;\\n            else if(nums[i]<nums[i-1]) d=f+1;\\n        }\\n        return min(size, max(f, d));\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"84887",
			"view":"3689",
			"top":"3",
			"title":"C++ 0ms O(N) dynamic programming solution",
			"vote":"30",
			"content":"````\\nclass Solution {\\npublic:\\n    int wiggleMaxLength(vector<int>& nums) {\\n        int size = nums.size();\\n        \\n        if (size == 0) {\\n            return 0;\\n        }\\n        \\n        /** up[i] is the length of a longest wiggle subsequence of {nums[0],...,nums[i]}, with a\\n            positive difference between its last two numbers. This subsequence may or may not\\n            include nums[i] and there may be several such subsequences (of the same length).\\n            We call this a subsequence of type U.\\n         */\\n        vector<int> up(size, 0);\\n        /** down[i] is the length of a longest wiggle subsequence of {nums[0],...,nums[i]}, with a\\n            negative difference between its last two numbers. This subsequence may or may not\\n            include nums[i] and there may be several such subsequences (of the same length).\\n            We call this a subsequence of type D.\\n         */\\n        vector<int> down(size, 0);\\n        \\n        // At i=0, there is only one number and we can use it as a subsequence, i.e up[0]=down[0]=1\\n        up[0] = 1;\\n        down[0] = 1;\\n        for(int i=1; i<size; ++i){\\n            \\n            if (nums[i] > nums[i-1]) {\\n                /** If nums[i] > nums[i-1], then we can use nums[i] to make a longer subsequence of type U\\n                    Proof: We consider a subsequence of type D in {0,...,i-1} (its length is down[i-1]).\\n                    Let N be the last number of this subsequence.\\n                    - If nums[i] > N, then we can add nums[i] to the subsequence and it gives us a longer\\n                    valid subsequence of type U.\\n                    - If nums[i] <= N, then:\\n                    (1) N cannot be nums[i-1], because nums[i-1] < nums[i] <= N i.e. nums[i-1] < N\\n                    (2) We can replace N with nums[i-1] (we still have a valid\\n                    subsequence of type D since N >= nums[i] > nums[i-1] i.e. N > nums[i-1]),\\n                    and then add nums[i] to the subsequence, and we have a longer subsequence of type U.\\n                    Therefore up[i] = down[i-1] + 1\\n                    \\n                    There is no gain in using nums[i] to make a longer subsequence of type D.\\n                    Proof: Let N be the last number of a subsequence of type U\\n                    in {0,...,i-1}.\\n                    Assume we can use nums[i] to make a longer subsequence of type D. Then:\\n                    (1) N cannot be nums[i-1], otherwise we would not be able to use nums[i]\\n                    to make a longer subsequence of type D as nums[i] > nums[i-1]\\n                    (2) Necessarily nums[i] < N, and therefore nums[i-1] < N since nums[i-1] < nums[i].\\n                    But this means that we could have used nums[i-1] already to make a longer\\n                    subsequence of type D.\\n                    So even if we can use nums[i], there is no gain in using it, so we keep the old value of\\n                    down (down[i] = down[i-1])\\n                */\\n                up[i] = down[i-1] + 1;\\n                down[i] = down[i-1];\\n            }\\n            else if (nums[i] < nums[i-1]) {\\n                /** The reasoning is similar if nums[i] < nums[i-1] */\\n                down[i] = up[i-1] + 1;\\n                up[i] = up[i-1];\\n            }\\n            else {\\n                /** if nums[i] == nums[i-1], we cannot do anything more than what we did with\\n                     nums[i-1] so we just keep the old values of up and down\\n                */\\n                up[i] = up[i-1];\\n                down[i] = down[i-1];\\n            }\\n        }\\n        return max(up[size-1], down[size-1]);\\n    }\\n};\\n````"
		},
		{
			"lc_ans_id":"84921",
			"view":"2838",
			"top":"4",
			"title":"3 lines O(n) Python with explanation/proof",
			"vote":"20",
			"content":"    def wiggleMaxLength(self, nums):\\n        nan = float('nan')\\n        diffs = [a-b for a, b in zip([nan] + nums, nums + [nan]) if a-b]\\n        return sum(not d*e >= 0 for d, e in zip(diffs, diffs[1:]))\\n\\n**Explanation / Proof:**\\n\\nImagine the given array contains [..., **10, 10, 10, 10**, ...]. Obviously we can't use more than one of those tens, as that wouldn't be wiggly. So right away we can ignore all consecutive duplicates.\\n\\nImagine the given array contains [..., 10, **7, 11, 13, 17, 19, 23**, 20, ...]. So  increasing from 7 to 23. What can we do with that? Well we can't use more than two of those increasing numbers, as that wouldn't be wiggly. And if we do use two, we'd better use the 7 and the 23, as that offers the best extensibility (for example, the 19 wouldn't allow to next pick the 20 for the wiggly subsequence). And if we do use only one, it still should be either the 7 or the 23, as the 7 is the best wiggle-low and the 23 is the best wiggle-high of them. So whether we actually use the 7 and the 23 or not, we definitely can and should remove the 11, 13, 17, and 19. So then we have [..., 10, **7, 23**, 20, ...]. Now, notice that the 7 is a local minimum (both the 10 and the 23 are larger) and the 23 is a local maximum. And if we do this  with **all** increasing or decreasing streaks, i.e., keep only their first and last number, then all the numbers we have left are local extrema, either smaller than both neighbors or larger than both neighbors. Which means that at that point, we're already fully wiggly. And we only removed as many numbers as we have to. So it's a longest possible wiggly subsequence.\\n\\nMy solution first computes differences of neighbors and throws out zeros (which does get rid of those useless consecutive duplicates). And then it just counts the local extrema (by checking two consecutive differences).\\n\\nI use `nan` for some convenience, I'll let you figure that part out :-)\\n<br>\\n**Alternative implementations** not using the `nan` trick: First remove repetitions, then count the local extrema except the ends, and add the number of ends (because the ends are always local extrema)\\n\\n    def wiggleMaxLength(self, nums):\\n        norep = [num for num, _ in itertools.groupby(nums)]\\n        triples = zip(norep, norep[1:], norep[2:])\\n        return sum((b>a) == (b>c) for a, b, c in triples) + len(norep[:2])\\n\\n    def wiggleMaxLength(self, nums):\\n        norep = [num for num, _ in itertools.groupby(nums)]\\n        if len(norep) < 2: return len(norep)\\n        triples = zip(norep, norep[1:], norep[2:])\\n        return 2 + sum(a<b>c or a>b<c for a, b, c in triples)"
		},
		{
			"lc_ans_id":"84838",
			"view":"886",
			"top":"5",
			"title":"Java Greedy solution O(n) time complexity, O(1) space complexity",
			"vote":"14",
			"content":"```\\npublic int wiggleMaxLength(int[] nums) {\\n        if (nums == null) return 0;\\n        if (nums.length <= 1) return nums.length;\\n        int f = 1, b = 1; //the first number can be a smaller number or larger number depends on what the next number it is. \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i-1]) f = b + 1;\\n            else if (nums[i] < nums[i-1]) b = f + 1;\\n        }\\n        return Math.max(f, b);\\n    }\\n```"
		},
		{
			"lc_ans_id":"84978",
			"view":"2047",
			"top":"6",
			"title":"Java O(n) greedy solution",
			"vote":"7",
			"content":"```\\npublic class Solution {\\n    public int wiggleMaxLength(int[] nums) {\\n        if(nums.length <= 1) return nums.length;\\n        int count = 1;\\n        Boolean prevInc = null;\\n        for(int i = 1; i < nums.length; i++) {\\n            if(nums[i] > nums[i - 1] && (prevInc == null || !prevInc)) {\\n                prevInc = true;\\n                count++;\\n            } else if(nums[i] < nums[i - 1] && (prevInc == null || prevInc)) {\\n                prevInc = false;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}"
		},
		{
			"lc_ans_id":"85001",
			"view":"509",
			"top":"7",
			"title":"JAVA O(n) solution, quite simple idea with explanation, everyone can get it",
			"vote":"5",
			"content":"The idea is quite simple, to get the answer, we just need to remove redundant elements from the array of differences. here comes a simple example:\\nfor test case: \\n[1,17,5,10,13,15,10,5,16,8]\\nFirst, we get array of differences, which are 17-1, 5-17, 10-5....\\n[16, -12, 5, 3, 2, -5, -5, 11, -8]\\nto become a wiggle sequence, we need these differences to be like [+,-,+,-...] or [-,+,-,+...]\\nSo, what we need to do is removing all the redundant difference.\\n[16, -12, 5, ~~**3, 2**~~, -5, ~~**-5**~~, 11, -8], That's it!\\n\\nSo we assume the length of wiggle sequence is equal to the length of input array, and once we meet a redundant difference, (wiggle sequence)--.\\n\\nTo distinguish redundant difference, we need to bring in one boolean variable : positive, which tell us the last number in differences is positive or negative.\\n\\nOne last thing, we deal with the \"0\" situation, we treat \"0\" as redundant, and do the same thing.\\n\\nHere comes the code: (Please let me know if you have better idea or any suggestion, Thx!)\\n\\n\\n    public int wiggleMaxLength(int[] nums) {\\n        if (nums.length <= 1) return nums.length;\\n        \\n        int count = nums.length;\\n        Boolean positive = null;\\n        \\n        for (int i = 0; i < nums.length-1; i++){\\n            int temp = nums[i+1] - nums[i];\\n            if (temp == 0) count--;\\n            else if (positive == null) positive = temp > 0;\\n            else if ((temp > 0 && positive) || (temp < 0 && !positive))\\n                count--;\\n            else\\n                positive = !positive;\\n        }\\n        return count;\\n    }\\n* >! list item"
		},
		{
			"lc_ans_id":"84982",
			"view":"407",
			"top":"8",
			"title":"Python solution - 48ms",
			"vote":"4",
			"content":"```\\nclass Solution(object):\\n    def wiggleMaxLength(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # trivial case\\n        if (len(nums) < 2):\\n            return len(nums)\\n        # create array of diffs\\n        diffs = []\\n        for i in range(1, len(nums)):\\n            x = nums[i] - nums[i - 1]\\n            # ignore diffs of 0 as they don't count as turning points\\n            if (x != 0):\\n                diffs.append(x)\\n        # if there were diffs of only 0, then seq length is 1\\n        if (not diffs):\\n            return 1\\n            \\n        cnt = 1 # min seq length at this stage\\n        # now count the number of times the sign of diff between consecutive numbers changes\\n        # that will be equal to the max wiggle subseq length\\n        for i in range(1, len(diffs)):\\n            prod = diffs[i] * diffs[i - 1]\\n            if (prod < 0):\\n                cnt += 1\\n                \\n        return cnt + 1\\n```"
		},
		{
			"lc_ans_id":"84955",
			"view":"979",
			"top":"9",
			"title":"O(n) solution (no code)",
			"vote":"4",
			"content":"Your array can be abstracted like this:\\n[solution LC376](http://i.imgur.com/FDCjFBq.png)\\n\\nConsider the number of turning points: they are DIRECTLY related to the length of wiggle subsequence..\\nSo you only need to scan once, that's O(n) :)"
		}
	],
	"id":"376",
	"title":"Wiggle Subsequence",
	"content":"<p>A sequence of numbers is called a <strong>wiggle sequence</strong> if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. </p>\r\n\r\n<p>For example, <code>[1,7,4,9,2,5]</code> is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, <code>[1,4,7,2,5]</code> and <code>[1,7,4,5,5]</code> are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</p>\r\n\r\n<p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p>\r\n\r\n<p><b>Examples:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,7,4,9,2,5]\r\n<b>Output:</b> 6\r\nThe entire sequence is a wiggle sequence.\r\n\r\n<b>Input:</b> [1,17,5,10,13,15,10,5,16,8]\r\n<b>Output:</b> 7\r\nThere are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].\r\n\r\n<b>Input:</b> [1,2,3,4,5,6,7,8,9]\r\n<b>Output:</b> 2\r\n</pre>\r\n</p>\r\n\r\n<p><b>Follow up:</b><br />\r\nCan you do it in O(<i>n</i>) time?\r\n</p>\r\n\r\n<p><b>Credits:</b><br />Special thanks to <a href=\"https://leetcode.com/agave/\">@agave</a> and <a href=\"https://leetcode.com/stefanpochmann/\">@StefanPochmann</a> for adding this problem and creating all test cases.</p>",
	"frequency":"237",
	"ac_num":"30417"
}