{
	"difficulty":"3",
	"submit_num":"75028",
	"show_id":"381",
	"leetcode_id":"381",
	"answers":[
		{
			"lc_ans_id":"85541",
			"view":"6293",
			"top":"0",
			"title":"C++ 128m Solution, Real O(1) Solution",
			"vote":"29",
			"content":"There are two data member in the solution\\n1. a vector **nums**\\n2. an unordered_map **m**\\n\\nThe **key** of **m** is the **val**, the **value** of **m** is a vector contains indices where the **val** appears in **nums**.\\nEach element of **nums** is a pair, the first element of the pair is **val** itself, the second element of the pair is an index into **m[val]**.\\nThere is a relationship between **nums** and **m**:\\n\\n**m[nums[i].first][nums[i].second] == i;**\\n\\n```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        auto result = m.find(val) == m.end();\\n        \\n        m[val].push_back(nums.size());\\n        nums.push_back(pair<int, int>(val, m[val].size() - 1));\\n        \\n        return result;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        auto result = m.find(val) != m.end();\\n        if(result)\\n        {\\n            auto last = nums.back();\\n            m[last.first][last.second] = m[val].back();\\n            nums[m[val].back()] = last;\\n            m[val].pop_back();\\n            if(m[val].empty()) m.erase(val);\\n            nums.pop_back();\\n        }\\n        return result;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()].first;\\n    }\\nprivate:\\n    vector<pair<int, int>> nums;\\n    unordered_map<int, vector<int>> m;\\n};\\n```"
		},
		{
			"lc_ans_id":"85540",
			"view":"18775",
			"top":"1",
			"title":"Java HaspMap, LinkedHashSet, ArrayList (155 ms)",
			"vote":"27",
			"content":"See my previous post [here](https://discuss.leetcode.com/topic/53216/java-solution-using-a-hashmap-and-an-arraylist-along-with-a-follow-up-131-ms/4).\\nI modified the code by replacing HashSet with LinkedHashSet because the set.iterator() might be costly when a number has too many duplicates. Using LinkedHashSet can be considered as O(1) if we only get the first element to remove. \\n```\\npublic class RandomizedCollection {\\n    ArrayList<Integer> nums;\\n\\tHashMap<Integer, Set<Integer>> locs;\\n\\tjava.util.Random rand = new java.util.Random();\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        nums = new ArrayList<Integer>();\\n\\t    locs = new HashMap<Integer, Set<Integer>>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean contain = locs.containsKey(val);\\n\\t    if ( ! contain ) locs.put( val, new LinkedHashSet<Integer>() ); \\n\\t    locs.get(val).add(nums.size());        \\n\\t    nums.add(val);\\n\\t    return ! contain ;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        boolean contain = locs.containsKey(val);\\n\\t    if ( ! contain ) return false;\\n\\t    int loc = locs.get(val).iterator().next();\\n\\t    locs.get(val).remove(loc);\\n\\t    if (loc < nums.size() - 1 ) {\\n\\t       int lastone = nums.get( nums.size()-1 );\\n\\t       nums.set( loc , lastone );\\n\\t       locs.get(lastone).remove( nums.size()-1);\\n\\t       locs.get(lastone).add(loc);\\n\\t    }\\n\\t    nums.remove(nums.size() - 1);\\n\\t   \\n\\t    if (locs.get(val).isEmpty()) locs.remove(val);\\n\\t    return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return nums.get( rand.nextInt(nums.size()) );\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"85556",
			"view":"4213",
			"top":"2",
			"title":"Frugal Python code",
			"vote":"18",
			"content":"```\\nimport random\\n\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        self.vals, self.idxs = [], collections.defaultdict(set)\\n        \\n\\n    def insert(self, val):\\n        self.vals.append(val)\\n        self.idxs[val].add(len(self.vals) - 1)\\n        return len(self.idxs[val]) == 1\\n        \\n\\n    def remove(self, val):\\n        if self.idxs[val]:\\n            out, ins = self.idxs[val].pop(), self.vals[-1]\\n            self.vals[out] = ins\\n            if self.idxs[ins]:\\n                self.idxs[ins].add(out)\\n                self.idxs[ins].discard(len(self.vals) - 1)\\n            self.vals.pop()\\n            return True\\n        return False \\n\\n    def getRandom(self):\\n        return random.choice(self.vals)"
		},
		{
			"lc_ans_id":"85555",
			"view":"6527",
			"top":"3",
			"title":"Clean O(1) Java Solution with HashMap and Set",
			"vote":"13",
			"content":"The problem is a simple extension of the previous problem that did not have duplicates. Instead of storing a single index like in the previous problem, we simply store a collection of indices for all the times that a number appears in the array.\\n\\nInsert() and random() are quite straightforward. For remove(), we take advantage of the fact that adding/removing from a HashSet is O(1) average time. The logic is otherwise similar - swap the index of any one instance of the item to be removed with the item in the very last place of the array. Update the sets after doing so, and then remove the last item.\\n\\nThanks to @yubad2000 for the wonderful idea of using a LinkedHashSet for O(1) iteration over large items. An iterator over a normal HashSet is actually O(h/n), where h is table capacity. So it is not a solution to our problem requiring O(1) time. Nor does an ArrayList instead of a HashSet work (I wasted some time on that for a while...).\\n\\n```\\npublic class RandomizedCollection {\\n\\n    ArrayList<Integer> result;\\n    HashMap<Integer, LinkedHashSet<Integer>> map;\\n    \\n    public RandomizedCollection() {\\n        result = new ArrayList<Integer>();\\n        map = new HashMap<Integer, LinkedHashSet<Integer>>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        // Add item to map if it doesn't already exist.\\n        boolean alreadyExists = map.containsKey(val);\\n        if(!alreadyExists) {\\n            map.put(val, new LinkedHashSet<Integer>());\\n        }\\n        map.get(val).add(result.size());\\n        result.add(val);\\n        return !alreadyExists;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) {\\n            return false;\\n        }\\n        // Get arbitary index of the ArrayList that contains val\\n        LinkedHashSet<Integer> valSet = map.get(val);\\n        int indexToReplace = valSet.iterator().next();\\n        \\n        // Obtain the set of the number in the last place of the ArrayList\\n        int numAtLastPlace = result.get(result.size() - 1);\\n        LinkedHashSet<Integer> replaceWith = map.get(numAtLastPlace);\\n        \\n        // Replace val at arbitary index with very last number\\n        result.set(indexToReplace, numAtLastPlace);\\n        \\n        // Remove appropriate index\\n        valSet.remove(indexToReplace);\\n        \\n        // Don't change set if we were replacing the removed item with the same number\\n        if(indexToReplace != result.size() - 1) {\\n            replaceWith.remove(result.size() - 1);\\n            replaceWith.add(indexToReplace);\\n        }\\n        result.remove(result.size() - 1);\\n        \\n        // Remove map entry if set is now empty, then return\\n        if(valSet.isEmpty()) {\\n            map.remove(val);\\n        }\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        // Get linearly random item\\n        return result.get((int)(Math.random() * result.size()));\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"85591",
			"view":"1850",
			"top":"4",
			"title":"Easy Understanding Java Solution using HashSet",
			"vote":"4",
			"content":"```\\npublic class RandomizedCollection {\\n\\n    List<Integer> nums;\\n    Map<Integer, Set<Integer>> map;\\n    java.util.Random random;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        nums = new ArrayList<>();\\n        map = new HashMap<>();\\n        random = new java.util.Random();\\n    }\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean doesContain = map.containsKey(val);\\n        if(!doesContain) map.put(val, new HashSet<>());\\n        map.get(val).add(nums.size());\\n        nums.add(val);\\n        return !doesContain;\\n    }\\n\\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) return false;\\n        if(!map.get(val).contains(nums.size()-1)) {\\n            int currPos = map.get(val).iterator().next();\\n            int lastVal = nums.get(nums.size() - 1);\\n            map.get(lastVal).remove(nums.size() - 1);\\n            map.get(lastVal).add(currPos);\\n            map.get(val).remove(currPos);\\n            map.get(val).add(nums.size() - 1);\\n            nums.set(currPos, lastVal);\\n        }\\n        map.get(val).remove(nums.size()-1);\\n        if(map.get(val).isEmpty()) map.remove(val);\\n        nums.remove(nums.size()-1);\\n        return true;\\n    }\\n\\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return nums.get(random.nextInt(nums.size()));\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"85622",
			"view":"389",
			"top":"5",
			"title":"C++ updated solution with unordered map and set",
			"vote":"3",
			"content":"```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        m[val].insert(v.size());\\n        v.push_back(val);\\n        return m[val].size() == 1;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (!m.count(val)) {\\n            return false;\\n        }\\n        int last = v.back();\\n        int pos = *(m[val].rbegin());\\n        m[last].erase(*(m[last].rbegin()));\\n        m[last].insert(pos);\\n        v[pos] = last;\\n        v.pop_back();\\n        if (m[val].size() > 1) {\\n            m[val].erase(*(m[val].rbegin()));\\n        } else {\\n            m.erase(val);\\n        }\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return v[rand() % v.size()];\\n    }\\n    \\nprivate:\\n    vector<int> v;\\n    unordered_map<int, set<int>> m;\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.insert(val);\\n * bool param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```"
		},
		{
			"lc_ans_id":"85599",
			"view":"775",
			"top":"6",
			"title":"C++ solution with unordered_multimap",
			"vote":"3",
			"content":"```\\n\\nclass RandomizedCollection {\\n    unordered_multimap<int, int> Map;\\n    typedef unordered_multimap<int,int>::iterator Itr;\\n    vector<Itr> Vec;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        std::srand(std::time(0));\\n        std::srand(std::time(0));\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ret = Map.count(val) == 0;\\n        auto it = Map.insert({val,-1});\\n        it->second = Vec.size();  //change the -1 to the index in the vector\\n        Vec.push_back(it);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(Vec.empty()) return false;\\n        auto it = Map.find(val); if(it == Map.end() ) return false;\\n        int index = it->second;\\n        (Vec.back())->second = index;  //change the object inside the Map\\n        swap(Vec[Vec.size()-1], Vec[index]);  //move the object to be removed to the back of vector\\n        Vec.pop_back();\\n        Map.erase(it);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int random = std::rand();\\n        random %= Vec.size();\\n        return Vec[random]->first; //First is the value! Don't be careless!\\n    }\\n};\\n\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.insert(val);\\n * bool param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */"
		},
		{
			"lc_ans_id":"85542",
			"view":"3605",
			"top":"7",
			"title":"C++ solution using map and vector with detailed explanation",
			"vote":"3",
			"content":"It is obvious that we should use hash map to achieve O(1) insert and remove.\\nBut how to achieve O(1) getRandom() remains a problem.\\nHere is what I think:\\nwe use vector *arr* to store all the elements in this collection, so that \\n```\\narr[rand()%arr.size()]\\n```\\nwill help to realize getRandom() in O(1).\\nEvery time we want to remove an element, we swap this element with the last element in *arr* and then pop back the last element.\\n\\nAnd in hash map, the element value is the key, and its index in the *arr* is the value.\\nEvery time we remove an element A, we should remove A both from map and *arr*. \\n```\\nclass RandomizedCollection {\\nprivate:\\n    map<int, vector<int>> dic;\\n    vector<int> arr;\\n    \\npublic:\\n    RandomizedCollection() {\\n    }\\n\\n    bool insert(int val) {\\n        arr.push_back(val);//add val in arr\\n        dic[val].push_back(arr.size() - 1);//add its index in dic[val]\\n        return dic[val].size() == 1;\\n    }\\n    \\n    bool remove(int val) {\\n        if(dic[val].size() == 0)\\n        {\\n            return false;\\n        }\\n        int idx = dic[val].back();//arr[idx] = val\\n        dic[val].pop_back();\\n       //swap arr[idx] and arr[arr.size()-1] if idx != arr.size()-1\\n       //modify the dic at the same time.\\n        if(arr.size() - 1 != idx);\\n        {\\n            int tmp = arr.back();\\n            arr[idx] = tmp;\\n     //the new index of tmp is now idx, so modify the dic accordingly.\\n            dic[tmp].pop_back();\\n            dic[tmp].push_back(idx);\\n        }\\n       //remove the last element in arr\\n        arr.pop_back();\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return arr[rand()%arr.size()];\\n    }\\n};\\n```\\nComments are welcomed!"
		},
		{
			"lc_ans_id":"85636",
			"view":"327",
			"top":"8",
			"title":"C++ Solution using a map of vectors to handle duplicates.",
			"vote":"2",
			"content":"```\\nclass RandomizedCollection {\\n    vector<pair<int, int>> buffer; // pair.first: the actual value stored; pair.second: the index of the pointer in the idx_map[pair.first]; so idx_map[pair.first][pair.second] is the index of the value in the buffer.\\n    unordered_map<int, vector<int>> idx_map; // duplicates are stacked into vector<int>\\n    default_random_engine rng;\\npublic:\\n    bool insert(int val) {\\n        auto is_exist = idx_map.find(val) == idx_map.end() ;\\n        idx_map[val].push_back(buffer.size()); \\n        buffer.emplace_back(val, idx_map[val].size() - 1);\\n        return is_exist;\\n    }\\n    bool remove(int val) {\\n        if (idx_map.find(val) == idx_map.end())\\n            return false;\\n        int idx = idx_map[val].back();\\n        buffer[idx] = buffer.back();\\n        idx_map[buffer.back().first][buffer.back().second] = idx;\\n        idx_map[val].pop_back();\\n        if (idx_map[val].empty())\\n            idx_map.erase(val);\\n        buffer.pop_back();\\n        return true;\\n    }\\n    int getRandom() {\\n        uniform_int_distribution<int> distribution(0, buffer.size() - 1);\\n        int idx = distribution(rng);\\n        return buffer[idx].first;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"85593",
			"view":"759",
			"top":"9",
			"title":"C++ AC Solution with unordered_map and vector (104ms)",
			"vote":"2",
			"content":"The main idea is use unordered_map<int, vector<int>> to record multiple location of numbers, and use vector<int> to store all numbers. The main different with problem [Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/) is :\\n1. [insert] We should always push number, no matter the number is existing or not.\\n2. [delete] We can erase the number from hashmap only when all the number are removed. (we can get this info by checking the length hashmap[val])\\n\\nBesides, the if statement in delete() can reduce redundant access to unordered_map and vector, which can slightly improve its performance.\\n\\nIf you have any suggestion, please leave the comment. Thanks. :)\\n```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {}\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        nums.push_back(val);\\n        m[val].push_back(nums.size() - 1);\\n        return m[val].size() == 1;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if(m.find(val) == m.end())  return false;\\n        int last = nums.back();\\n        if(val != last) {   // Reduce redundant access.\\n            nums[m[val].back()] = last;\\n            m[last].back() = m[val].back();\\n        }\\n        m[val].pop_back();\\n        nums.pop_back();\\n        if(m[val].size() == 0)\\n            m.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n\\nprivate:\\n    unordered_map<int, vector<int>> m;\\n    vector<int> nums;\\n};\\n```"
		}
	],
	"id":"381",
	"title":"Insert Delete GetRandom O(1) - Duplicates allowed",
	"content":"<p>Design a data structure that supports all following operations in <i>average</i> <b>O(1)</b> time.</p>\r\n<b>Note: Duplicate elements are allowed.</b>\r\n<p>\r\n<ol>\r\n<li><code>insert(val)</code>: Inserts an item val to the collection.</li>\r\n<li><code>remove(val)</code>: Removes an item val from the collection if present.</li>\r\n<li><code>getRandom</code>: Returns a random element from current collection of elements. The probability of each element being returned is <b>linearly related</b> to the number of same value the collection contains.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n// Init an empty collection.\r\nRandomizedCollection collection = new RandomizedCollection();\r\n\r\n// Inserts 1 to the collection. Returns true as the collection did not contain 1.\r\ncollection.insert(1);\r\n\r\n// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].\r\ncollection.insert(1);\r\n\r\n// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].\r\ncollection.insert(2);\r\n\r\n// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.\r\ncollection.getRandom();\r\n\r\n// Removes 1 from the collection, returns true. Collection now contains [1,2].\r\ncollection.remove(1);\r\n\r\n// getRandom should return 1 and 2 both equally likely.\r\ncollection.getRandom();\r\n</pre>\r\n</p>",
	"frequency":"159",
	"ac_num":"22089"
}