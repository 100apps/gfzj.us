{
	"difficulty":"2",
	"submit_num":"65874",
	"show_id":"385",
	"leetcode_id":"385",
	"answers":[
		{
			"lc_ans_id":"86066",
			"view":"12292",
			"top":"0",
			"title":"An Java Iterative Solution",
			"vote":"48",
			"content":"This approach will just iterate through every char in the string (no recursion).\\n* If encounters '[', push current NestedInteger to stack and start a new one.\\n* If encounters ']', end current NestedInteger and pop a NestedInteger from stack to continue.\\n* If encounters ',', append a new number to curr NestedInteger, if this comma is not right after a brackets.\\n* Update index l and r, where l shall point to the start of a integer substring, while r shall points to the end+1 of substring.\\n\\n\\nJava Code:\\n\\n    public NestedInteger deserialize(String s) {\\n        if (s.isEmpty())\\n            return null;\\n        if (s.charAt(0) != '[') // ERROR: special case\\n            return new NestedInteger(Integer.valueOf(s));\\n            \\n        Stack<NestedInteger> stack = new Stack<>();\\n        NestedInteger curr = null;\\n        int l = 0; // l shall point to the start of a number substring; \\n                   // r shall point to the end+1 of a number substring\\n        for (int r = 0; r < s.length(); r++) {\\n            char ch = s.charAt(r);\\n            if (ch == '[') {\\n                if (curr != null) {\\n                    stack.push(curr);\\n                }\\n                curr = new NestedInteger();\\n                l = r+1;\\n            } else if (ch == ']') {\\n                String num = s.substring(l, r);\\n                if (!num.isEmpty())\\n                    curr.add(new NestedInteger(Integer.valueOf(num)));\\n                if (!stack.isEmpty()) {\\n                    NestedInteger pop = stack.pop();\\n                    pop.add(curr);\\n                    curr = pop;\\n                }\\n                l = r+1;\\n            } else if (ch == ',') {\\n                if (s.charAt(r-1) != ']') {\\n                    String num = s.substring(l, r);\\n                    curr.add(new NestedInteger(Integer.valueOf(num)));\\n                }\\n                l = r+1;\\n            }\\n        }\\n        \\n        return curr;\\n    }"
		},
		{
			"lc_ans_id":"86060",
			"view":"7067",
			"top":"1",
			"title":"Python & C++ solutions",
			"vote":"25",
			"content":"## Python using `eval`:\\n\\n    def deserialize(self, s):\\n        def nestedInteger(x):\\n            if isinstance(x, int):\\n                return NestedInteger(x)\\n            lst = NestedInteger()\\n            for y in x:\\n                lst.add(nestedInteger(y))\\n            return lst\\n        return nestedInteger(eval(s))\\n\\n## Python one-liner\\n\\n    def deserialize(self, s):\\n        return NestedInteger(s) if isinstance(s, int) else reduce(lambda a, x: a.add(self.deserialize(x)) or a, s, NestedInteger()) if isinstance(s, list) else self.deserialize(eval(s))\\n\\n## Python Golf (136 bytes or 31 bytes)\\n```\\nclass Solution:deserialize=d=lambda S,s,N=NestedInteger:s<[]and N(s)or s<''and reduce(lambda a,x:a.add(S.d(x))or a,s,N())or S.d(eval(s))\\n```\\nOr abusing how the judge judges (yes, this gets accepted):\\n```\\nclass Solution:deserialize=eval\\n```\\n\\n## Python parsing char by char\\n\\nHere I turned the input string into a list with sentinel for convenience.\\n\\n    def deserialize(self, s):\\n        def nestedInteger():\\n            num = ''\\n            while s[-1] in '1234567890-':\\n                num += s.pop()\\n            if num:\\n                return NestedInteger(int(num))\\n            s.pop()\\n            lst = NestedInteger()\\n            while s[-1] != ']':\\n                lst.add(nestedInteger())\\n                if s[-1] == ',':\\n                    s.pop()\\n            s.pop()\\n            return lst\\n        s = list(' ' + s[::-1])\\n        return nestedInteger()\\n\\n## C++ using `istringstream`\\n```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        istringstream in(s);\\n        return deserialize(in);\\n    }\\nprivate:\\n    NestedInteger deserialize(istringstream &in) {\\n        int number;\\n        if (in >> number)\\n            return NestedInteger(number);\\n        in.clear();\\n        in.get();\\n        NestedInteger list;\\n        while (in.peek() != ']') {\\n            list.add(deserialize(in));\\n            if (in.peek() == ',')\\n                in.get();\\n        }\\n        in.get();\\n        return list;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"86061",
			"view":"860",
			"top":"2",
			"title":"Clarification",
			"vote":"19",
			"content":"No offense but this problem seriously needs some more explanation and grammar check. I want to add a few clarification as follows so it saves you some time:\\n\\n1. the add() method adds a NestedInteger object to the caller. e.g.:\\nouter = NestedInteger() # []\\nnested = NestedInteger(5) \\nouter2 = nested\\nouter.add(nested) # outer is now [5]\\nouter2.add(outer) # outer2 is now [5, [5]]\\n\\n\"Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\" cannot be more vague.\\n\\n2. '-' means negative. It's not a delimiter.\\n\\n3. For test cases like \"324\" you need to return something like NestedInteger(324) not \"[324]\". \\n\\n4. A list cannot have multiple consecutive integers. e.g. \"321, 231\" is invalid. I guess it's for difficulty purposes."
		},
		{
			"lc_ans_id":"86074",
			"view":"2738",
			"top":"3",
			"title":"C++ Non-Recursive One-Pass Solution (using Stack) || A Possible Implementation of NestedInteger",
			"vote":"17",
			"content":"**Solution in a Glance:**\\nThis solution uses a stack to record the NestedInteger's.\\nAt the very beginning, an empty NestedInteger is placed in the stack. This NestedInteger will be regarded as a list that holds one but only one NestedInteger, which will be returned in the end.\\n*Logic:* When encountering '[', the stack has one more element. When encountering ']', the stack has one less element.\\n\\n**Complexities:**\\n* Time: *O*(n)     \\n* Space: worse-case *O*(n) (worse case: [1,[2,[3,[....[n-1,[n]]]....])\\n\\n**C++ Accepted Code:** \\n(A possible implementation of **NestedInteger** is also provided in the first reply.)\\n\\n    class Solution {\\n    public:\\n        NestedInteger deserialize(string s) {\\n            function<bool(char)> isnumber = [](char c){ return (c == '-') || isdigit(c); };\\n            \\n            stack<NestedInteger> stk;\\n            stk.push(NestedInteger());\\n            \\n            for (auto it = s.begin(); it != s.end();) {\\n                const char & c = (*it);\\n                if (isnumber(c)) {\\n                    auto it2 = find_if_not(it, s.end(), isnumber);\\n                    int val = stoi(string(it, it2));\\n                    stk.top().add(NestedInteger(val));\\n                    it = it2;\\n                }\\n                else {\\n                    if (c == '[') {\\n                        stk.push(NestedInteger());\\n                    }\\n                    else if (c == ']') {\\n                        NestedInteger ni = stk.top();\\n                        stk.pop();\\n                        stk.top().add(ni);\\n                    }\\n                    ++it;\\n                }\\n            }\\n            \\n            NestedInteger result = stk.top().getList().front();\\n            return result;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"86157",
			"view":"3725",
			"top":"4",
			"title":"Straightforward Java solution with explanation and a simple implementation of NestedInteger for your ease of testing",
			"vote":"15",
			"content":"Also viewable [here](https://github.com/fishercoder1534/Leetcode/blob/master/src/main/java/com/fishercoder/solutions/MiniParser.java).\\n\\nThe idea is very straightforward:\\n\\n1. if it's '[', we just construct a new nested integer and push it onto the stack\\n\\n2. if it's a number, we parse the whole number and add to the previous nested integer object\\n\\n3. if it's ',', we'll just continue;\\n\\n4. if it's ']', we'll just pop one nested integer from the working stack and assign it to the result\\n\\nAlso, we'll pay attention to this corner case or understand the input: the input could be \"324\", \"[324]\", they are different: the former should return a nested integer with one single integer, the latter should return a nested integer with a list\\n```\\npublic NestedInteger deserialize(String s) {\\n        if(s == null || s.isEmpty() || s.length() == 0) return new NestedInteger();\\n        Stack<NestedInteger> workStack = new Stack<NestedInteger>();\\n        NestedInteger result = null;\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        //if it's just a single number, then we'll just return a nested integer with one integer\\n        if(s.charAt(i) != '['){\\n            sb.setLength(0);\\n            while(i < s.length() && ((Character.getNumericValue(s.charAt(i)) < 10 && Character.getNumericValue(s.charAt(i)) >= 0) || s.charAt(i) == '-')){\\n                sb.append(s.charAt(i));\\n                i++;\\n            }\\n            int num = Integer.parseInt(sb.toString());\\n            return new NestedInteger(num);\\n        }//all other cases, we'll return a nested integer with a list\\n        else{\\n            while (i < s.length()) {\\n                if (s.charAt(i) == '[') {\\n                    NestedInteger ni = new NestedInteger();\\n                    // we'll put this one into its last one if there's one on the workStack\\n                    if (!workStack.isEmpty()) {\\n                        NestedInteger lastNi = workStack.pop();\\n                        lastNi.add(ni);\\n                        workStack.push(lastNi);// then push it back\\n                    }\\n                    workStack.push(ni);\\n                    i++;\\n                } else if (s.charAt(i) == ',') {\\n                    i++;\\n                } else if (s.charAt(i) == ']') {\\n                    NestedInteger completedNi = workStack.pop();\\n                    result = completedNi;\\n                    i++;\\n                } else {\\n                    // then it must be a number\\n                    sb.setLength(0);\\n                    while (i < s.length()\\n                            && ((Character.getNumericValue(s.charAt(i)) < 10 && Character\\n                                    .getNumericValue(s.charAt(i)) >= 0) || s.charAt(i) == '-')) {\\n                        sb.append(s.charAt(i));\\n                        i++;\\n                    }\\n                    int num = Integer.parseInt(sb.toString());\\n                    NestedInteger ni = null;\\n                    if (!workStack.isEmpty())\\n                        ni = workStack.pop();\\n                    else\\n                        ni = new NestedInteger();\\n                    // case 1: if this one contains one integer\\n                    if (ni.isInteger()) {\\n                        // we'll add it to this ni\\n                        ni.add(new NestedInteger(num));\\n                    }\\n                    // case 2: if this one contains a nested integer\\n                    else if (ni.getList() != null && ni.getList().size() != 0) {\\n                        // we'll get the last nested integer and add this one to it\\n                        ni.add(new NestedInteger(num));\\n                    } else {\\n                        // case 3: if this is an empty nested integer\\n                        if(i > 0) ni.add(new NestedInteger(num));\\n                        else ni.setInteger(num);\\n                    }\\n                    workStack.push(ni);\\n                    if (i == s.length())\\n                        return ni;// this is for test cases like this: \"324\", there's no '[' or ']'\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\nAlso, I've written a simple implementation for NestedInteger class, I find it helpful, posted it here as well:\\n```\\nclass NestedInteger {\\n    private List<NestedInteger> list;\\n    private Integer integer;\\n    \\n    public NestedInteger(List<NestedInteger> list){\\n        this.list = list;\\n    }\\n    \\n    public void add(NestedInteger nestedInteger) {\\n        if(this.list != null){\\n            this.list.add(nestedInteger);\\n        } else {\\n            this.list = new ArrayList();\\n            this.list.add(nestedInteger);\\n        }\\n    }\\n\\n    public void setInteger(int num) {\\n        this.integer = num;\\n    }\\n\\n    public NestedInteger(Integer integer){\\n        this.integer = integer;\\n    }\\n\\n    public NestedInteger() {\\n        this.list = new ArrayList();\\n    }\\n\\n    public boolean isInteger() {\\n        return integer != null;\\n    }\\n\\n    public Integer getInteger() {\\n        return integer;\\n    }\\n\\n    public List<NestedInteger> getList() {\\n        return list;\\n    }\\n    \\n    public String printNi(NestedInteger thisNi, StringBuilder sb){\\n        if(thisNi.isInteger()) {\\n            sb.append(thisNi.integer);\\n            sb.append(\",\");\\n        }\\n        sb.append(\"[\");\\n        for(NestedInteger ni : thisNi.list){\\n            if(ni.isInteger()) {\\n                sb.append(ni.integer);\\n                sb.append(\",\");\\n            }\\n            else {\\n                printNi(ni, sb);\\n            }\\n        }\\n        sb.append(\"]\");\\n        return sb.toString();\\n    }\\n}\\n\\n```"
		},
		{
			"lc_ans_id":"86120",
			"view":"2326",
			"top":"5",
			"title":"A top down parser using c++",
			"vote":"14",
			"content":"```c++\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        int index = 0;\\n        char c = s[index];\\n        if (c == '[') {\\n            return parseList(s, index);\\n        } else {\\n            // starts with 0-9, '-'\\n            return parseNumber(s, index);\\n        }\\n    }\\n    \\n    NestedInteger parseList(string &s, int &index) {\\n        index++; // eat '['\\n        NestedInteger root;\\n        while (index < s.size()) {\\n            char c = s[index];\\n            if (c == '[') {\\n                root.add(parseList(s, index));\\n            } else if (isNumber(c) || c == '-') {\\n                root.add(parseNumber(s, index));\\n            } else if (c == ',') {\\n                // skip\\n                index++;\\n            } else if (c == ']') {\\n                break;\\n            }\\n        }\\n        index++; // eat ']'\\n        return root;\\n    }\\n    \\n    NestedInteger parseNumber(string &s, int &index) {\\n        int n = 0;\\n        int positive = 1;  // flag for positive number\\n        if (s[index] == '-') {\\n            positive = -1;\\n            index++;\\n        }\\n        while (index < s.size()) {\\n            char c = s[index];\\n            if (isNumber(c)) {\\n                n = 10 * n + c - '0';\\n                index++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return NestedInteger(n * positive);\\n    }\\n    \\n    bool isNumber(char c) {\\n        return '0' <= c && c <= '9';\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"86083",
			"view":"1758",
			"top":"6",
			"title":"Short Java recursive solution",
			"vote":"11",
			"content":"\\n```\\npublic class Solution {\\n    public NestedInteger deserialize(String s) {\\n        NestedInteger ret = new NestedInteger();\\n        if (s == null || s.length() == 0) return ret;\\n        if (s.charAt(0) != '[') {\\n            ret.setInteger(Integer.parseInt(s));\\n        }\\n        else if (s.length() > 2) {\\n            int start = 1, count = 0;\\n            for (int i = 1; i < s.length(); i++) {\\n                char c = s.charAt(i);\\n                if (count == 0 && (c == ',' || i == s.length() - 1)) {\\n                    ret.add(deserialize(s.substring(start, i)));\\n                    start = i + 1;\\n                }\\n                else if (c == '[') count++;\\n                else if (c == ']') count--;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"86182",
			"view":"953",
			"top":"7",
			"title":"C++ Clean and Elegant Code with Clear logic",
			"vote":"6",
			"content":"```cs\\nclass Solution {\\n    NestedInteger parse(const string &s, int & pos)\\n    {\\n        if (s[pos] == '[')\\n            return parseList(s, pos);\\n        return parseNum(s, pos);\\n    }\\n    NestedInteger parseNum(const string &s, int & pos)\\n    {\\n        int num = 0;\\n        int sign = s[pos] == '-' ? -1 : 1;\\n        if (s[pos] == '-' || s[pos] == '+')\\n            pos ++;\\n        for (;pos < s.size() && isdigit(s[pos]); pos ++)\\n            num = num * 10 + s[pos] - '0';\\n        return NestedInteger(sign * num);\\n    }\\n    NestedInteger parseList(const string &s, int &pos)\\n    {\\n        NestedInteger ni;\\n        while (s[pos] != ']')\\n        {\\n            pos ++;                   //skip [ or ,\\n            if (s[pos] == ']') break; //handle [] or [1,2,]\\n            ni.add(parse(s, pos));\\n        }\\n        pos ++;                       // skip ]\\n        return ni;\\n    }\\npublic:\\n    NestedInteger deserialize(const string &s) {\\n        int pos = 0;//pos ALWAYS points to 1 position past the last parsed string;\\n                    //This is an invariance maintained across the entire program.\\n        return parse(s, pos);\\n    }\\n};"
		},
		{
			"lc_ans_id":"86082",
			"view":"536",
			"top":"8",
			"title":"Python iterative solution with stack and dummy NestedInteger",
			"vote":"4",
			"content":"    from collections import deque\\n\\n    class Solution(object):\\n        def deserialize(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: NestedInteger\\n            \"\"\"\\n            initial = NestedInteger()\\n            q = deque()\\n            q.append(initial)\\n            i = 0\\n\\n            while(i < len(s)):\\n                if s[i] == '[':\\n                    n = NestedInteger()\\n                    q[-1].add(n)\\n                    q.append(n)\\n                    i += 1\\n                elif s[i] == ']':\\n                    q.pop()\\n                    i += 1\\n                elif s[i] == ',':\\n                    i += 1\\n                else:\\n                    j = i\\n                    while j < len(s) and ('0' <= s[j] <= '9' or s[j] == '-'):\\n                        j += 1\\n                    q[-1].add(int(s[i:j]))\\n                    i = j\\n\\n            return q[0].getList()[0]"
		},
		{
			"lc_ans_id":"86161",
			"view":"537",
			"top":"9",
			"title":"Short and Clean Java Recursive Solution with Explanation",
			"vote":"3",
			"content":"Using the \"lvl\" variable to track if we are inside an inner integer.\\nUsing lIndex to track the leftmost start position.\\nEvery time the program hit the \"[\" increase lvl, and decrease lvl when hit \"]\"\\nWhen the program meets \",\"\\n      If lvl != 0, ignore the \",\" since we are inside a nested integer\\n      else do recursive call  ,add the result to the current list and move lIndex.\\n\\n[ [abc, [xy]] , def, [qqq] ]\\nni.add(myDeserialize(\"[abc, [xy]]\"));\\nni.add(myDeserialize(\"def\");\\nni.add(myDeserialize(\"[qqq]\");\\n\\n\\n\\n    public NestedInteger deserialize(String s) {\\n        if (s.length() == 0)    return new NestedInteger();\\n        return myDeserialize(s, 0, s.length()-1);\\n    }\\n    \\n    private NestedInteger myDeserialize(String s, int start, int end) {\\n        if (s.charAt(start) != '[') \\n            return new NestedInteger(Integer.valueOf(s.substring(start, end+1)));\\n\\n        NestedInteger ni = new NestedInteger();\\n        int lvl = 0, lIndex = start+1;\\n \\n        for (int i=start+1 ; i<=end-1 ; ++i) {\\n            char ch = s.charAt(i);\\n            if (ch == '[')  ++lvl;\\n            else if (ch == ']') --lvl; \\n            else if (ch == ',' && lvl == 0) {\\n                ni.add(myDeserialize(s, lIndex, i-1));\\n                lIndex = i + 1;\\n            }\\n        }\\n        if (lIndex <= end-1) {\\n            ni.add(myDeserialize(s, lIndex, end-1));\\n        }\\n        return ni;        \\n    }"
		}
	],
	"id":"385",
	"title":"Mini Parser",
	"content":"<p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p>\r\n\r\n<p>Each element is either an integer, or a list -- whose elements may also be integers or other lists.</p>\r\n\r\n<p><b>Note:</b>\r\nYou may assume that the string is well-formed:\r\n<ul>\r\n<li>String is non-empty.</li>\r\n<li>String does not contain white spaces.</li>\r\n<li>String contains only digits <code>0-9</code>, <code>[</code>, <code>-</code> <code>,</code>, <code>]</code>.</li>\r\n</ul>\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\nGiven s = \"324\",\r\n\r\nYou should return a NestedInteger object which contains a single integer 324.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\nGiven s = \"[123,[456,[789]]]\",\r\n\r\nReturn a NestedInteger object containing a nested list with 2 elements:\r\n\r\n1. An integer containing value 123.\r\n2. A nested list containing two elements:\r\n    i.  An integer containing value 456.\r\n    ii. A nested list with one element:\r\n         a. An integer containing value 789.\r\n</pre>\r\n</p>",
	"frequency":"214",
	"ac_num":"20339"
}