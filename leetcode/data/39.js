{
	"difficulty":"2",
	"submit_num":"491855",
	"show_id":"39",
	"leetcode_id":"39",
	"answers":[
		{
			"lc_ans_id":"16502",
			"view":"48006",
			"top":"0",
			"title":"A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning)",
			"vote":"276",
			"content":"This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n \\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/"
		},
		{
			"lc_ans_id":"16496",
			"view":"34239",
			"top":"1",
			"title":"Accepted 16ms c++ solution use backtracking, easy understand.",
			"vote":"128",
			"content":"Accepted 16ms c++ solution use backtracking for [Combination Sum][1]:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n            std::sort(candidates.begin(), candidates.end());\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum(candidates, target, res, combination, 0);\\n            return res;\\n        }\\n    private:\\n        void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n            if (!target) {\\n                res.push_back(combination);\\n                return;\\n            }\\n            for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\\n                combination.push_back(candidates[i]);\\n                combinationSum(candidates, target - candidates[i], res, combination, i);\\n                combination.pop_back();\\n            }\\n        }\\n    };\\n\\nAccepted 12ms c++ solution use backtracking for [Combination Sum II][2]:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum2(std::vector<int> &candidates, int target) {\\n            std::sort(candidates.begin(), candidates.end());\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum2(candidates, target, res, combination, 0);\\n            return res;\\n        }\\n    private:\\n        void combinationSum2(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n            if (!target) {\\n                res.push_back(combination);\\n                return;\\n            }\\n            for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i)\\n                if (i == begin || candidates[i] != candidates[i - 1]) {\\n                    combination.push_back(candidates[i]);\\n                    combinationSum2(candidates, target - candidates[i], res, combination, i + 1);\\n                    combination.pop_back();\\n                }\\n        }\\n    };\\n\\nAccepted 0ms c++ solution use backtracking for [Combination Sum III][3]:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum3(int k, int n) {\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum3(n, res, combination, 1, k);\\n            return res;\\n        }\\n    private:\\n        void combinationSum3(int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin, int need) {\\n            if (!target) {\\n                res.push_back(combination);\\n                return;\\n            }\\n            else if (!need)\\n                return;\\n            for (int i = begin; i != 10 && target >= i * need + need * (need - 1) / 2; ++i) {\\n                combination.push_back(i);\\n                combinationSum3(target - i, res, combination, i + 1, need - 1);\\n                combination.pop_back();\\n            }\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/combination-sum/\\n  [2]: https://leetcode.com/problems/combination-sum-ii/\\n  [3]: https://leetcode.com/problems/combination-sum-iii/"
		},
		{
			"lc_ans_id":"16521",
			"view":"23951",
			"top":"2",
			"title":"Java solution using recursive",
			"vote":"64",
			"content":"    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        \\tArrays.sort(candidates);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            getResult(result, new ArrayList<Integer>(), candidates, target, 0);\\n            \\n            return result;\\n        }\\n        \\n        private void getResult(List<List<Integer>> result, List<Integer> cur, int candidates[], int target, int start){\\n        \\tif(target > 0){\\n        \\t\\tfor(int i = start; i < candidates.length && target >= candidates[i]; i++){\\n        \\t\\t\\tcur.add(candidates[i]);\\n        \\t\\t\\tgetResult(result, cur, candidates, target - candidates[i], i);\\n        \\t\\t\\tcur.remove(cur.size() - 1);\\n        \\t\\t}//for\\n        \\t}//if\\n        \\telse if(target == 0 ){\\n        \\t\\tresult.add(new ArrayList<Integer>(cur));\\n        \\t}//else if\\n        }\\n    }"
		},
		{
			"lc_ans_id":"16510",
			"view":"12367",
			"top":"3",
			"title":"Python dfs solution.",
			"vote":"59",
			"content":"        \\n    def combinationSum(self, candidates, target):\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, 0, [], res)\\n        return res\\n        \\n    def dfs(self, nums, target, index, path, res):\\n        if target < 0:\\n            return  # backtracking\\n        if target == 0:\\n            res.append(path)\\n            return \\n        for i in xrange(index, len(nums)):\\n            self.dfs(nums, target-nums[i], i, path+[nums[i]], res)"
		},
		{
			"lc_ans_id":"16509",
			"view":"17194",
			"top":"4",
			"title":"Iterative Java DP solution",
			"vote":"51",
			"content":"Hi guys!\\n\\nThe main idea reminds an approach for solving coins/knapsack problem - to store the result for all i < target and create the solution from them. For that for each t from 1 to our target we try every candidate which is less or equal to t in ascending order. For each candidate \"c\" we run through all combinations for target t-c starting with the value greater or equal than c to avoid duplicates and store only ordered combinations. \\n\\n    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] cands, int t) {\\n            Arrays.sort(cands); // sort candidates to try them in asc order\\n            List<List<List<Integer>>> dp = new ArrayList<>();\\n            for (int i = 1; i <= t; i++) { // run through all targets from 1 to t\\n                List<List<Integer>> newList = new ArrayList(); // combs for curr i\\n                // run through all candidates <= i\\n                for (int j = 0; j < cands.length && cands[j] <= i; j++) {\\n                    // special case when curr target is equal to curr candidate\\n                    if (i == cands[j]) newList.add(Arrays.asList(cands[j]));\\n                    // if current candidate is less than the target use prev results\\n                    else for (List<Integer> l : dp.get(i-cands[j]-1)) {\\n                        if (cands[j] <= l.get(0)) {\\n                            List cl = new ArrayList<>();\\n                            cl.add(cands[j]); cl.addAll(l);\\n                            newList.add(cl);\\n                        }\\n                    }\\n                }\\n                dp.add(newList);\\n            }\\n            return dp.get(t-1);\\n        }\\n    }\\n\\nHope it helps!"
		},
		{
			"lc_ans_id":"16713",
			"view":"8600",
			"top":"5",
			"title":"A solution avoid using set",
			"vote":"30",
			"content":"Sort the candidates and we choose from small to large recursively, every time we add a candidate to our possible sub result, we subtract the target to a new smaller one.\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ret = new LinkedList<List<Integer>>();\\n        Arrays.sort(candidates); // sort the candidates\\n        // collect possible candidates from small to large to eliminate duplicates,\\n        recurse(new ArrayList<Integer>(), target, candidates, 0, ret);\\n        return ret;\\n    }\\n    \\n    // the index here means we are allowed to choose candidates from that index\\n    private void recurse(List<Integer> list, int target, int[] candidates, int index, List<List<Integer>> ret) {\\n        if (target == 0) {\\n            ret.add(list);\\n            return;\\n        }\\n        for (int i = index; i < candidates.length; i++) {\\n            int newTarget = target - candidates[i];\\n            if (newTarget >= 0) {\\n                List<Integer> copy = new ArrayList<Integer>(list);\\n                copy.add(candidates[i]);\\n                recurse(copy, newTarget, candidates, i, ret);\\n            } else {\\n                break;\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"16530",
			"view":"5223",
			"top":"6",
			"title":"Concise Backtracking Solution",
			"vote":"20",
			"content":"We backtrack from successful searches as well because they are saved at the leafs of recursion tree\\n\\n    class Solution {\\n    public:\\n    \\n        void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n        {\\n            if(target == 0)\\n            {\\n                result.push_back(pSol);\\n                return;\\n            }\\n            \\n            if(next == num.size() || target - num[next] < 0)\\n                return;\\n                \\n            pSol.push_back(num[next]);\\n            search(num, next, pSol, target - num[next], result);\\n            pSol.pop_back();\\n            \\n            search(num, next + 1, pSol, target, result);\\n        }\\n    \\n        \\n        vector<vector<int> > combinationSum(vector<int> &num, int target) \\n        {\\n            vector<vector<int> > result;\\n            sort(num.begin(), num.end());\\n            vector<int> pSol;\\n            search(num, 0, pSol, target, result);\\n            return result;    \\n        }\\n    };"
		},
		{
			"lc_ans_id":"16506",
			"view":"1913",
			"top":"7",
			"title":"8-line Python solution, dynamic programming, beats 86.77%",
			"vote":"13",
			"content":"    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        dp = [[[]]] + [[] for i in xrange(target)]\\n        for i in xrange(1, target + 1):\\n            for number in candidates:\\n                if number > i: break\\n                for L in dp[i - number]:\\n                    if not L or number >= L[-1]: dp[i] += L + [number],\\n        return dp[target]"
		},
		{
			"lc_ans_id":"16656",
			"view":"7483",
			"top":"8",
			"title":"Dynamic Programming Solution",
			"vote":"12",
			"content":"It adapts the DP solution of coin change problem\\n\\n    class Solution {\\n    public:\\n    \\tvector<vector<int> > combinationSum(vector<int> &candidates, int target) {\\n    \\t\\tvector< vector< vector<int> > > combinations(target + 1, vector<vector<int>>());\\n    \\t\\tcombinations[0].push_back(vector<int>());\\n    \\t\\tfor (auto& score : candidates)\\n    \\t\\t\\tfor (int j = score; j <= target; j++)\\n    \\t\\t\\t\\tif (combinations[j - score].size() > 0)\\t{\\n    \\t\\t\\t\\t\\tauto tmp = combinations[j - score];\\n    \\t\\t\\t\\t\\tfor (auto& s : tmp)\\n    \\t\\t\\t\\t\\t\\ts.push_back(score);\\n    \\t\\t\\t\\t\\tcombinations[j].insert(combinations[j].end(), tmp.begin(), tmp.end());\\n    \\t\\t\\t\\t}\\n    \\t\\tauto ret = combinations[target];\\n    \\t\\tfor (int i = 0; i < ret.size(); i++)\\n    \\t\\t\\tsort(ret[i].begin(), ret[i].end());\\n    \\t\\treturn ret;\\n    \\t}\\n    };"
		},
		{
			"lc_ans_id":"16554",
			"view":"2092",
			"top":"9",
			"title":"Share My Python Solution beating 98.17%",
			"vote":"11",
			"content":"    class Solution(object):\\n    def combinationSum(self, candidates, target):\\n        result = []\\n        candidates = sorted(candidates)\\n        def dfs(remain, stack):\\n            if remain == 0:\\n                result.append(stack)\\n                return \\n\\n            for item in candidates:\\n                if item > remain: break\\n                if stack and item < stack[-1]: continue\\n                else:\\n                    dfs(remain - item, stack + [item])\\n        \\n        dfs(target, [])\\n        return result"
		}
	],
	"id":"39",
	"title":"Combination Sum",
	"content":"<p>\r\nGiven a <b>set</b> of candidate numbers (<b><i>C</i></b>) <b>(without duplicates)</b> and a target number (<b><i>T</i></b>), find all unique combinations in <b><i>C</i></b> where the candidate numbers sums to <b><i>T</i></b>. \r\n</p>\r\n\r\n<p>The <b>same</b> repeated number may be chosen from <b><i>C</i></b> unlimited number of times.\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ul>\r\n<li>All numbers (including target) will be positive integers.</li>\r\n<li>The solution set must not contain duplicate combinations.</li>\r\n</ul>\r\n</p>\r\n\r\n<p>\r\nFor example, given candidate set <code>[2, 3, 6, 7]</code> and target <code>7</code>, <br />\r\nA solution set is: <br />\r\n<pre>\r\n[\r\n  [7],\r\n  [2, 2, 3]\r\n]\r\n</pre>\r\n</p>",
	"frequency":"445",
	"ac_num":"199675"
}