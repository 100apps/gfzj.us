{
	"difficulty":"2",
	"submit_num":"58711",
	"show_id":"399",
	"leetcode_id":"399",
	"answers":[
		{
			"lc_ans_id":"88169",
			"view":"18530",
			"top":"0",
			"title":"Java AC Solution using graph",
			"vote":"68",
			"content":"Image a/b = k as a link between node a and b, the weight from a to b is k, the reverse link  is 1/k. Query is to find a path between two nodes.\\n```\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        HashMap<String, ArrayList<String>> pairs = new HashMap<String, ArrayList<String>>();\\n        HashMap<String, ArrayList<Double>> valuesPair = new HashMap<String, ArrayList<Double>>();\\n        for (int i = 0; i < equations.length; i++) {\\n            String[] equation = equations[i];\\n            if (!pairs.containsKey(equation[0])) {\\n                pairs.put(equation[0], new ArrayList<String>());\\n                valuesPair.put(equation[0], new ArrayList<Double>());\\n            }\\n            if (!pairs.containsKey(equation[1])) {\\n                pairs.put(equation[1], new ArrayList<String>());\\n                valuesPair.put(equation[1], new ArrayList<Double>());\\n            }\\n            pairs.get(equation[0]).add(equation[1]);\\n            pairs.get(equation[1]).add(equation[0]);\\n            valuesPair.get(equation[0]).add(values[i]);\\n            valuesPair.get(equation[1]).add(1/values[i]);\\n        }\\n        \\n        double[] result = new double[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            String[] query = queries[i];\\n            result[i] = dfs(query[0], query[1], pairs, valuesPair, new HashSet<String>(), 1.0);\\n            if (result[i] == 0.0) result[i] = -1.0;\\n        }\\n        return result;\\n    }\\n    \\n    private double dfs(String start, String end, HashMap<String, ArrayList<String>> pairs, HashMap<String, ArrayList<Double>> values, HashSet<String> set, double value) {\\n        if (set.contains(start)) return 0.0;\\n        if (!pairs.containsKey(start)) return 0.0;\\n        if (start.equals(end)) return value;\\n        set.add(start);\\n        \\n        ArrayList<String> strList = pairs.get(start);\\n        ArrayList<Double> valueList = values.get(start);\\n        double tmp = 0.0;\\n        for (int i = 0; i < strList.size(); i++) {\\n            tmp = dfs(strList.get(i), end, pairs, values, set, value*valueList.get(i));\\n            if (tmp != 0.0) {\\n                break;\\n            }\\n        }\\n        set.remove(start);\\n        return tmp;\\n    }"
		},
		{
			"lc_ans_id":"88175",
			"view":"11251",
			"top":"1",
			"title":"9 lines \"Floyd\\u2013Warshall\" in Python",
			"vote":"60",
			"content":"A variation of [**Floyd\\u2013Warshall**](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm), computing quotients instead of shortest paths. An equation `A/B=k` is like a graph edge `A->B`, and `(A/B)*(B/C)*(C/D)` is like the path `A->B->C->D`. Submitted once, accepted in 35 ms.\\n\\n    def calcEquation(self, equations, values, queries):\\n        quot = collections.defaultdict(dict)\\n        for (num, den), val in zip(equations, values):\\n            quot[num][num] = quot[den][den] = 1.0\\n            quot[num][den] = val\\n            quot[den][num] = 1 / val\\n        for k, i, j in itertools.permutations(quot, 3):\\n            if k in quot[i] and j in quot[k]:\\n                quot[i][j] = quot[i][k] * quot[k][j]\\n        return [quot[num].get(den, -1.0) for num, den in queries]\\n\\n<br>\\n\\nVariation without the `if` (submitted twice, accepted in 68 and 39 ms):\\n\\n    def calcEquation(self, equations, values, queries):\\n        quot = collections.defaultdict(dict)\\n        for (num, den), val in zip(equations, values):\\n            quot[num][num] = quot[den][den] = 1.0\\n            quot[num][den] = val\\n            quot[den][num] = 1 / val\\n        for k in quot:\\n            for i in quot[k]:\\n                for j in quot[k]:\\n                    quot[i][j] = quot[i][k] * quot[k][j]\\n        return [quot[num].get(den, -1.0) for num, den in queries]\\n\\nCould save a line with `for i, j in itertools.permutations(quot[k], 2)` but it's longer and I don't like it as much here."
		},
		{
			"lc_ans_id":"88170",
			"view":"9002",
			"top":"2",
			"title":"0ms C++ Union-Find Solution [EASY to UNDERSTAND]",
			"vote":"21",
			"content":"```c++\\nclass Solution {\\n    // date: 2016-09-12     location: Santa Clara City Library\\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries) {\\n        unordered_map<string, Node*> map;\\n        vector<double> res;\\n        for (int i = 0; i < equations.size(); i ++) {\\n            string s1 = equations[i].first, s2 = equations[i].second;\\n            if (map.count(s1) == 0 && map.count(s2) == 0) {\\n                map[s1] = new Node();\\n                map[s2] = new Node();\\n                map[s1] -> value = values[i];\\n                map[s2] -> value = 1;\\n                map[s1] -> parent = map[s2];\\n            } else if (map.count(s1) == 0) {\\n                map[s1] = new Node();\\n                map[s1] -> value = map[s2] -> value * values[i];\\n                map[s1] -> parent = map[s2];\\n            } else if (map.count(s2) == 0) {\\n                map[s2] = new Node();\\n                map[s2] -> value = map[s1] -> value / values[i];\\n                map[s2] -> parent = map[s1];\\n            } else {\\n                unionNodes(map[s1], map[s2], values[i], map);\\n            }\\n        }\\n\\n        for (auto query : queries) {\\n            if (map.count(query.first) == 0 || map.count(query.second) == 0 || findParent(map[query.first]) != findParent(map[query.second]))\\n                res.push_back(-1);\\n            else\\n                res.push_back(map[query.first] -> value / map[query.second] -> value);\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    struct Node {\\n        Node* parent;\\n        double value = 0.0;\\n        Node()  {parent = this;}\\n    };\\n    \\n    void unionNodes(Node* node1, Node* node2, double num, unordered_map<string, Node*>& map) {\\n        Node* parent1 = findParent(node1), *parent2 = findParent(node2);\\n        double ratio = node2 -> value * num / node1 -> value;\\n        for (auto it = map.begin(); it != map.end(); it ++)\\n            if (findParent(it -> second) == parent1)\\n                it -> second -> value *= ratio;\\n        parent1 -> parent = parent2;\\n    }\\n    \\n    Node* findParent(Node* node) {\\n        if (node -> parent == node)\\n            return node;\\n        node -> parent = findParent(node -> parent);\\n        return node -> parent;\\n    }\\n};\\n```\\n   \\n   \\n**Update:**\\n- Please also check Java solutions below.  \\n- Special thanks to @iambright and @Scarlett_comeup."
		},
		{
			"lc_ans_id":"88228",
			"view":"6298",
			"top":"3",
			"title":"Java AC solution with explanation",
			"vote":"17",
			"content":"The logic I have used is to construct a Map of maps, that contains all possible a/b and b/a from the given input and their values.\\n\\nFor the given input\\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ]. values = [2.0, 3.0]\\n\\nThe map that gets constructed is :\\n\\n[a:  [b:2.0]\\nb:  [a:0.5], [c:3.0]\\nc:  [b:0.333]]\\n\\nFor each key in the outer map, the value represents a map, that denotes all possible denominators for the key and the corresponding key/value.\\n\\nWith this map constructed, the logic for evaluating a query is simple in a dfs style:\\n\\nTo find any m/n, if the map of m contains x1, x2, x3\\nthen \\nm/n = m/x1 * x1/n if this gives a valid result or m/x2 * x2/n or m/x3 * x3/n \\n\\n\\n```\\npublic static double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n        Map<String, Map<String, Double>> numMap = new HashMap<>();\\n        int i = 0;\\n        for(String[] str : equations) {\\n            insertPairs(numMap, str[0], str[1], values[i]);\\n            insertPairs(numMap, str[1], str[0], 1.0/values[i]);\\n            i++;\\n        }\\n\\n        double[] res = new double[query.length];\\n        i = 0;\\n        for(String[] q: query) {\\n            Double resObj = handleQuery(q[0], q[1], numMap, new HashSet<>());\\n            res[i++] = (resObj != null) ? resObj : -1.0;\\n        }\\n        return res;\\n    }\\n\\n    public static void insertPairs(Map<String, Map<String, Double>> numMap, String num, String denom, Double value) {\\n        Map<String, Double> denomMap = numMap.get(num);\\n        if(denomMap == null) {\\n            denomMap = new HashMap<>();\\n            numMap.put(num, denomMap);\\n        }\\n        denomMap.put(denom, value);\\n    }\\n\\n    public static Double handleQuery(String num, String denom, Map<String, Map<String, Double>> numMap, Set<String> visitedSet) {\\n        String dupeKey = num+\":\"+denom;\\n        if(visitedSet.contains(dupeKey)) return null;\\n        if(!numMap.containsKey(num) || !numMap.containsKey(denom)) return null;\\n        if(num.equals(denom)) return 1.0;\\n\\n        Map<String, Double> denomMap = numMap.get(num);\\n        visitedSet.add(dupeKey);\\n        for(String key : denomMap.keySet()) {\\n            Double res = handleQuery(key, denom, numMap, visitedSet);\\n            if(res != null) {\\n                return denomMap.get(key) * res;\\n            }\\n        }\\n        visitedSet.remove(dupeKey);\\n        return null;\\n    }\\n```"
		},
		{
			"lc_ans_id":"88168",
			"view":"3715",
			"top":"4",
			"title":"c++ 0ms Hash+DFS solution",
			"vote":"16",
			"content":"```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, \\n        vector<double>& values, vector<pair<string, string>> query) \\n    {\\n        unordered_map<string,unordered_map<string, double>> m;\\n        vector<double> res;\\n        for (int i = 0; i < values.size(); ++i)\\n        {\\n            m[equations[i].first].insert(make_pair(equations[i].second,values[i]));\\n            if(values[i]!=0)\\n                m[equations[i].second].insert(make_pair(equations[i].first,1/values[i]));\\n        }\\n\\n        for (auto i : query)\\n        {\\n            unordered_set<string> s;\\n            double tmp = check(i.first,i.second,m,s);\\n            if(tmp) res.push_back(tmp);\\n            else res.push_back(-1);\\n        }\\n        return res;\\n    }\\n\\n    double check(string up, string down, \\n            unordered_map<string,unordered_map<string, double>> &m,\\n            unordered_set<string> &s)\\n    {\\n        if(m[up].find(down) != m[up].end()) return m[up][down];\\n        for (auto i : m[up])\\n        {\\n            if(s.find(i.first) == s.end())\\n            {\\n                s.insert(i.first);\\n                double tmp = check(i.first,down,m,s);\\n                if(tmp) return i.second*tmp;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"88287",
			"view":"4112",
			"top":"5",
			"title":"Esay understand Java solution, 3ms",
			"vote":"14",
			"content":"``` java\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n        double[] result = new double[query.length];\\n        // filter unexpected words\\n        // \\u8fc7\\u6ee4\\u6389\\u6ca1\\u6709\\u9047\\u89c1\\u8fc7\\u7684\\u5b57\\u7b26\\n        Set<String> words = new HashSet<>();\\n        for (String[] strs : equations) {\\n            words.add(strs[0]);\\n            words.add(strs[1]);\\n        }\\n        for (int i = 0; i < query.length; ++i) {\\n            String[] keys = query[i];\\n            if (!words.contains(keys[0]) || !words.contains(keys[1])) result[i] = -1.0d;\\n            else {\\n                Stack<Integer> stack = new Stack<>();\\n                result[i] = helper(equations, values, keys, stack);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public double helper(String[][] equations, double[] values, String[] keys, Stack<Integer> stack) {\\n        // \\u76f4\\u63a5\\u67e5\\u627e\\uff0ckey\\u7684\\u987a\\u5e8f\\u6709\\u6b63\\u53cd\\n        // look up equations directly\\n        for (int i = 0; i < equations.length; ++i) {\\n            if (equations[i][0].equals(keys[0]) && equations[i][1].equals(keys[1])) return values[i];\\n            if (equations[i][0].equals(keys[1]) && equations[i][1].equals(keys[0])) return 1 / values[i];\\n        }\\n        // lookup equations by other equations\\n        // \\u95f4\\u63a5\\u67e5\\u627e\\uff0ckey\\u7684\\u987a\\u5e8f\\u4e5f\\u6709\\u6b63\\u53cd\\n        for (int i = 0; i < equations.length; ++i) {\\n            if (!stack.contains(i) && keys[0].equals(equations[i][0])) {\\n                stack.push(i);\\n                double temp = values[i] * helper(equations, values, new String[]{equations[i][1], keys[1]}, stack);\\n                if (temp > 0) return temp;\\n                else stack.pop();\\n            }\\n            if (!stack.contains(i) && keys[0].equals(equations[i][1])) {\\n                stack.push(i);\\n                double temp = helper(equations, values, new String[]{equations[i][0], keys[1]}, stack) / values[i];\\n                if (temp > 0) return temp;\\n                else stack.pop();\\n            }\\n        }\\n        // \\u67e5\\u4e0d\\u5230\\uff0c\\u8fd4\\u56de-1\\n        return -1.0d;\\n    }\\n```\\n\\nupdate:\\n\\nThanks for @jason88628  remind me. change from stack to set will be better.\\n\\nupdate:\\n\\nAnother way for this problem, but it need more memory and more time to build a whole map of equations.\\n\\nIt's efficient when there is a large set of queries.\\n\\n``` java\\npublic double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n        // use table save string to integer\\n        Map<String, Integer> table = new HashMap<>();\\n        int len = 0;\\n        for (String[] strings : equations)\\n            for (String string : strings)\\n                if (!table.containsKey(string)) table.put(string, len++);\\n\\n        // init map by direct equation\\n        double[][] map = new double[len][len];\\n        for (int i = 0; i < len; ++i)\\n            for (int j = 0; j < len; ++j)\\n                map[i][j] = (i == j ? 1.0d : -1.0d);\\n        for (int i = 0; i < equations.length; ++i) {\\n            String[] keys = equations[i];\\n            int row = table.get(keys[0]);\\n            int col = table.get(keys[1]);\\n            map[row][col] = values[i];\\n            map[col][row] = 1 / values[i];\\n        }\\n\\n        // floyd-warshall like algorithm\\n        for (int i = 0; i < len; ++i) {\\n            for (int j = 0; j < len; ++j) {\\n                for (int k = 0; k < len; ++k) {\\n                    if (map[j][i] >= 0d && map[i][k] >= 0d) map[j][k] = map[j][i] * map[i][k];\\n                }\\n            }\\n        }\\n\\n        // query now\\n        double[] result = new double[query.length];\\n        for (int i = 0; i < query.length; ++i) {\\n            String[] keys = query[i];\\n            Integer row = table.get(keys[0]);\\n            Integer col = table.get(keys[1]);\\n            if (row == null || col == null) result[i] = -1.0d;\\n            else result[i] = map[row][col];\\n        }\\n        return result;\\n    }\\n```\\n\\nupdate:\\nA better way with union-find alogrithm. It takes less memory and time than the above one. But it's hard to understand.\\n\\nYou can replace class `Node` with two arrays. In that way, it will be more efficient.\\n\\n``` java\\npublic double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n\\n        // map string to integer\\n        Map<String, Integer> mIdTable = new HashMap<>();\\n        int len = 0;\\n        for (String[] words : equations)\\n            for (String word : words)\\n                if (!mIdTable.containsKey(word)) mIdTable.put(word, len++);\\n\\n        // init parent index and value\\n        Node[] nodes = new Node[len];\\n        for (int i = 0; i < len; ++i) nodes[i] = new Node(i);\\n\\n        // union, you can take an example as follows\\n        // (a/b=3)->(c/d=6)->(b/d=12)\\n        for (int i = 0; i < equations.length; ++i) {\\n            String[] keys = equations[i];\\n            int k1 = mIdTable.get(keys[0]);\\n            int k2 = mIdTable.get(keys[1]);\\n            int groupHead1 = find(nodes, k1);\\n            int groupHead2 = find(nodes, k2);\\n            nodes[groupHead2].parent = groupHead1;\\n            nodes[groupHead2].value = nodes[k1].value * values[i] / nodes[k2].value;\\n        }\\n\\n        // query now\\n        double[] result = new double[query.length];\\n        for (int i = 0; i < query.length; ++i) {\\n            Integer k1 = mIdTable.get(query[i][0]);\\n            Integer k2 = mIdTable.get(query[i][1]);\\n            if (k1 == null || k2 == null) result[i] = -1d;\\n            else {\\n                int groupHead1 = find(nodes, k1);\\n                int groupHead2 = find(nodes, k2);\\n                if (groupHead1 != groupHead2) result[i] = -1d;\\n                else result[i] = nodes[k2].value / nodes[k1].value;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public int find(Node[] nodes, int k) {\\n        int p = k;\\n        while (nodes[p].parent != p) {\\n            p = nodes[p].parent;\\n            // compress\\n            nodes[k].value *= nodes[p].value;\\n        }\\n        // compress\\n        nodes[k].parent = p;\\n        return p;\\n    }\\n\\n    private static class Node {\\n        int    parent;\\n        double value;\\n\\n        public Node(int index) {\\n            this.parent = index;\\n            this.value = 1d;\\n        }\\n    }\\n```"
		},
		{
			"lc_ans_id":"88196",
			"view":"1035",
			"top":"6",
			"title":"Simple'n'Clean DFS solution in Python",
			"vote":"12",
			"content":"A series of equations `A / B = k` can be seen as a graph in which nodes are the dividend and divisor A and B and weights are the result of the division. So we simply create the graph and traverse it with DFS/BFS to get our result.\\n\\nComplexity is `K * O(N + M)` where N and M are the number of nodes and edges, and `K` is the number of queries. How many nodes can we have? It's `2 * E`, where `E` is the number of equations (2 different nodes per each equation). We can have at most `E` edges in the graph. \\n\\nSo total complexity is `O(K * E)`, with `O(E)` additional space for the graph.\\n\\n```\\nclass Solution(object):\\n    def calcEquation(self, equations, values, queries):\\n        \\n        def dfs(start, end, path, paths):\\n            if start == end and start in G:\\n                paths[0] = path\\n                return\\n            if start in vis: \\n                return\\n            vis.add(start)\\n            for node in G[start]:\\n                dfs(node, end, path * W[start, node], paths)\\n        \\n        \\n        G, W = collections.defaultdict(set), collections.defaultdict(float)\\n        for (A, B), V in zip(equations, values):\\n            G[A], G[B] = G[A] | {B}, G[B] | {A}\\n            W[A, B], W[B, A] = V, 1.0 / V\\n            \\n        res = []\\n        for X, Y in queries:\\n            paths, vis = [-1.0], set()\\n            dfs(X, Y, 1.0, paths)\\n            res += paths[0],\\n        return res\\n```"
		},
		{
			"lc_ans_id":"88207",
			"view":"1887",
			"top":"7",
			"title":"java solution using Floyd\\u2013Warshall algorithm",
			"vote":"10",
			"content":"Using a variant of [Floyd\\u2013Warshall algorithm](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm), to find the distance between each reachable pair:\\n```\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        HashMap<String, HashMap<String, Double>> graph = new HashMap<>();\\n        Function<String, HashMap<String, Double>> function = s -> new HashMap<>();\\n        for (int i = 0; i < equations.length; i++) {\\n            graph.computeIfAbsent(equations[i][0], function).put(equations[i][0], 1.0);\\n            graph.computeIfAbsent(equations[i][1], function).put(equations[i][1], 1.0);\\n            graph.get(equations[i][0]).put(equations[i][1], values[i]);\\n            graph.get(equations[i][1]).put(equations[i][0], 1 / values[i]);\\n        }\\n        for (String mid : graph.keySet()) {\\n            for (String src : graph.get(mid).keySet()) {\\n                for (String dst : graph.get(mid).keySet()) {\\n                    double val = graph.get(src).get(mid) * graph.get(mid).get(dst);\\n                    graph.get(src).put(dst, val);\\n                }\\n            }\\n        }\\n        double[] result = new double[queries.length];\\n        for (int i = 0; i < result.length; i++) {\\n            if (!graph.containsKey(queries[i][0])) {\\n                result[i] = -1;\\n            } else {\\n                result[i] = graph.get(queries[i][0]).getOrDefault(queries[i][1], -1.0);\\n            }\\n        }\\n        return result;\\n    }\\n```\\nIt is very slow, some optimization applied:\\n```\\n    public double[] calcEquation2(String[][] equations, double[] values, String[][] queries) {\\n        HashMap<String, HashMap<String, Double>> graph = new HashMap<>();\\n        for (int i = 0; i < equations.length; i++) {\\n            String src = equations[i][0], dst = equations[i][1];\\n            if (!graph.containsKey(src)) {\\n                graph.put(src, new HashMap<>());\\n            }\\n            if (!graph.containsKey(dst)) {\\n                graph.put(dst, new HashMap<>());\\n            }\\n            graph.get(src).put(src, 1.0);\\n            graph.get(dst).put(dst, 1.0);\\n            graph.get(src).put(dst, values[i]);\\n            graph.get(dst).put(src, 1 / values[i]);\\n        }\\n        for (String mid : graph.keySet()) {\\n            for (String src : graph.get(mid).keySet()) {\\n                for (String dst : graph.get(mid).keySet()) {\\n                    double val = graph.get(src).get(mid) * graph.get(mid).get(dst);\\n                    graph.get(src).put(dst, val);\\n                }\\n            }\\n        }\\n        double[] result = new double[queries.length];\\n        for (int i = 0; i < result.length; i++) {\\n            if (!graph.containsKey(queries[i][0])) {\\n                result[i] = -1;\\n            } else {\\n                result[i] = graph.get(queries[i][0]).getOrDefault(queries[i][1], -1.0);\\n            }\\n        }\\n        return result;\\n    }\\n```\\nIn practice, we can use guava's `HashBasedTable`, do not have to use `HashMap<String,HashMap<String,Double>>`,:\\n```\\nimport com.google.common.collect.HashBasedTable;\\nimport com.google.common.collect.Table;\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        Table<String, String, Double> table = HashBasedTable.create();\\n        for (int i = 0; i < equations.length; i++) {\\n            String src = equations[i][0], dst = equations[i][1];\\n            table.put(src, src, 1.0);\\n            table.put(dst, dst, 1.0);\\n            table.put(src, dst, values[i]);\\n            table.put(dst, src, 1.0 / values[i]);\\n        }\\n        for (String mid : table.rowKeySet()) {\\n            for (String src : table.row(mid).keySet()) {\\n                for (String dst : table.row(mid).keySet()) {\\n                    double val = table.get(src, mid) * table.get(mid, dst);\\n                    table.put(src, dst, val);\\n                }\\n            }\\n        }\\n        double[] result = new double[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            result[i] = table.contains(queries[i][0], queries[i][1]) ? table.get(queries[i][0], queries[i][1]) : -1.0;\\n        }\\n        return result;\\n    }\\n```"
		},
		{
			"lc_ans_id":"88343",
			"view":"970",
			"top":"8",
			"title":"Union-find algorithm: c++ 0ms solution (almost linear complexity)",
			"vote":"10",
			"content":"The time complexity of this algorithm is amortized O((n+m) * a(n)), where n is the number of equations (or, number of variables),  m is the number of queries, a(n) is the inverse Ackermann function and is less than 5 for all practical values of n. So, it is an almost O(n+m) algorithm.\\n```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> query) {\\n        unordered_map<string, int> varID; // map var name to its ID \\n        vector<int> par;                  // par[v2]==v1 ;  v1 is v2's parent\\n        vector<double> parEq;             // parEq[v2]==t ; v1 is t times of v2 \\n\\n        for (int i=0; i<equations.size(); i++) // process equations\\n        {\\n            string& v1Name = equations[i].first;\\n            string& v2Name = equations[i].second;\\n            double x = values[i]; // v1 is x times of v2\\n            int v1, v2;\\n            if (varID.count(v1Name)==0){ //new variable\\n                v1 = par.size();\\n                par.push_back(v1); //par[v1]==v1, v1 is itself's parent\\n                parEq.push_back(1); \\n                varID[v1Name] = v1;\\n            }\\n            else  v1 = varID[v1Name];\\n            if (varID.count(v2Name)==0) {\\n                v2 = par.size();\\n                par.push_back(v2);  \\n                parEq.push_back(1);\\n                varID[v2Name] = v2; \\n            }\\n            else  v2 = varID[v2Name];\\n            \\n            int r1, r2;\\n            double t1, t2;\\n            r1 = findRoot(par, parEq, v1, t1); //r1 is t1 times of v1\\n            r2 = findRoot(par, parEq, v2, t2); //r2 is t2 times of v2\\n            par[r2] = r1;\\n            parEq[r2] = t1 * x / t2;           //do simple math here\\n        }\\n\\n        vector<double> res;\\n        for (auto& q : query) // process queries\\n        {\\n            int v1, v2;\\n            if (varID.count(q.first)==1 && varID.count(q.second)==1 ) {\\n                v1 = varID[q.first];\\n                v2 = varID[q.second];\\n            }\\n            else {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            int r1, r2;\\n            double t1, t2;\\n            r1 = findRoot(par, parEq, v1, t1); //r1 is t1 times of v1\\n            r2 = findRoot(par, parEq, v2, t2); //r2 is t2 times of v2\\n            if (r1 != r2) res.push_back(-1);\\n            else res.push_back(t2/t1);\\n        }\\n        return res;\\n    }\\n    \\n    int findRoot(vector<int>& par, vector<double>& parEq, int v, double& t) {\\n        t = 1;\\n        while (v != par[v]) {\\n            // path compression\\n            parEq[v] = parEq[v] * parEq[par[v]];\\n            par[v] = par[par[v]];\\n            // climb up\\n            t *= parEq[v];\\n            v = par[v];\\n        }\\n        return v;\\n    }\\n};\\n\\n```"
		},
		{
			"lc_ans_id":"88310",
			"view":"719",
			"top":"9",
			"title":"C++ 0ms 23 lines DFS solution with comments",
			"vote":"7",
			"content":"```\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<pair<string, double>>> children;                               // adjacency list\\n    \\n    pair<bool, double> search(string& a, string& b, unordered_set<string>& visited, double val) {\\n        if (visited.count(a) == 0) {\\n            visited.insert(a);                                                                  // mark a as visited\\n            for (auto p : children[a]) {\\n                double temp = val * p.second;                                                   // potential result\\n                if (p.first == b) { return make_pair(true, temp); }                             // found result\\n                \\n                auto result = search(p.first, b, visited, temp);\\n                if (result.first) { return result; }\\n            }\\n        }\\n        return make_pair(false, -1.0);\\n    }\\n    \\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries) {\\n        vector<double> ans;\\n        \\n        for (int i = 0; i < equations.size(); i++) {\\n            children[equations[i].first].push_back(make_pair(equations[i].second, values[i]));      // build graph list a->b\\n            children[equations[i].second].push_back(make_pair(equations[i].first, 1.0 / values[i]));// build graph list b->a\\n        }\\n        \\n        for (auto p : queries) {\\n            unordered_set<string> visited;                                                          // to record visited nodes\\n            // p.first == p.second is special case\\n            ans.push_back(p.first == p.second && children.count(p.first) ? 1.0 : search(p.first, p.second, visited, 1.0).second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
		}
	],
	"id":"399",
	"title":"Evaluate Division",
	"content":"<p>\r\nEquations are given in the format <code>A / B = k</code>, where  <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.\r\n</p>\r\n<p><b>Example:</b><br/>\r\nGiven <code> a / b = 2.0, b / c = 3.0.</code> <br/>queries are: <code> a / c = ?,  b / a = ?, a / e = ?,  a / a = ?, x / x = ? .</code> <br/>return <code> [6.0, 0.5, -1.0, 1.0, -1.0 ].</code>\r\n</p>\r\n<p>\r\nThe input is: <code> vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries </code>, where <code>equations.size() == values.size()</code>, and the values are positive. This represents the equations. Return <code> vector&lt;double&gt;</code>.\r\n</p>\r\n\r\n<p>According to the example above:\r\n<pre>equations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\r\nvalues = [2.0, 3.0],\r\nqueries = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. </pre>\r\n</p>\r\n\r\n<p>\r\nThe input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.\r\n</p>",
	"frequency":"271",
	"ac_num":"24635"
}