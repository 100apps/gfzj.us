{
	"difficulty":"2",
	"submit_num":"67088",
	"show_id":"406",
	"leetcode_id":"406",
	"answers":[
		{
			"lc_ans_id":"89345",
			"view":"39158",
			"top":"0",
			"title":"Easy concept with Python/C++/Java Solution",
			"vote":"173",
			"content":"1. **Pick out tallest group of people and sort them** in a subarray (S). Since there's no other groups of people taller than them, therefore **each guy's index will be just as same as his k value**.\\n2. For 2nd tallest group (and the rest), insert each one of them into (S) by k value. So on and so forth.\\n\\nE.g.\\ninput: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\\nsubarray after step 1: [**[7,0], [7,1]**]\\nsubarray after step 2: [[7,0], **[6,1]**, [7,1]]\\n...\\n\\nIt's not the most concise code, but I think it well explained the concept.\\n\\n```\\nclass Solution(object):\\n    def reconstructQueue(self, people):\\n        if not people: return []\\n\\n        # obtain everyone's info\\n        # key=height, value=k-value, index in original array\\n        peopledct, height, res = {}, [], []\\n        \\n        for i in xrange(len(people)):\\n            p = people[i]\\n            if p[0] in peopledct:\\n                peopledct[p[0]] += (p[1], i),\\n            else:\\n                peopledct[p[0]] = [(p[1], i)]\\n                height += p[0],\\n\\n        height.sort()      # here are different heights we have\\n\\n        # sort from the tallest group\\n        for h in height[::-1]:\\n            peopledct[h].sort()\\n            for p in peopledct[h]:\\n                res.insert(p[0], people[p[1]])\\n\\n        return res\\n\\n```\\n\\n**EDIT:**\\nPlease also check:\\n@tlhuang 's concise Python code.\\n@wsurvi 's 4 lines Python code.\\n@tonygogogo 's 8 lines C++ solution.\\n@zeller2 's Java version.\\n@hotpro 's Java 8 solution."
		},
		{
			"lc_ans_id":"89359",
			"view":"15857",
			"top":"1",
			"title":"Explanation of the neat Sort+Insert solution",
			"vote":"77",
			"content":"Below is my explanation of the following neat solution where we sort people from tall to short (and by increasing k-value) and then just insert them into the queue using their k-value as the queue index:\\n\\n    def reconstructQueue(self, people):\\n        people.sort(key=lambda (h, k): (-h, k))\\n        queue = []\\n        for p in people:\\n            queue.insert(p[1], p)\\n        return queue\\n\\nI didn't come up with that myself, but here's my own explanation of it, as I haven't seen anybody explain it (and was asked to explain it):\\n\\nPeople are only counting (in their k-value) taller or equal-height others standing in front of them. So a smallest person is **completely irrelevant** for all taller ones. And of all smallest people, the one standing most in the back is even completely irrelevant for **everybody** else. Nobody is counting that person. So we can first arrange everybody else, ignoring that one person. And then just insert that person appropriately. Now note that while this person is irrelevant for everybody else, everybody else is relevant for this person - this person counts exactly everybody in front of them. So their count-value tells you exactly the index they must be standing.\\n\\nSo you can first solve the sub-problem with all but that one person and then just insert that person appropriately. And you can solve that sub-problem the same way, first solving the sub-sub-problem with all but the last-smallest person of the subproblem. And so on. The base case is when you have the sub-...-sub-problem of zero people. You're then inserting the people in the reverse order, i.e., that overall last-smallest person in the very end and thus the first-tallest person in the very beginning. That's what the above solution does, Sorting the people from the first-tallest to the last-smallest, and inserting them one by one as appropriate.\\n\\nNow that's **my** explanation. If you have a different one, I'm interested to see it :-)"
		},
		{
			"lc_ans_id":"89348",
			"view":"10327",
			"top":"2",
			"title":"6 lines  Concise C++",
			"vote":"35",
			"content":"```\\nvector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) {\\n    auto comp = [](const pair<int, int>& p1, const pair<int, int>& p2)\\n                    { return p1.first > p2.first || (p1.first == p2.first && p1.second < p2.second); };\\n    sort(people.begin(), people.end(), comp);\\n    vector<pair<int, int>> res;\\n    for (auto& p : people) \\n        res.insert(res.begin() + p.second, p);\\n    return res;\\n}\\n```"
		},
		{
			"lc_ans_id":"89350",
			"view":"10637",
			"top":"3",
			"title":"Java solution using Arrays.sort() and \"insert sorting\" idea",
			"vote":"20",
			"content":"We first sort the people to make them stand from the highest to shortest. For people with same height, sort them according to the count of people before them from small to big.\\n\\nThen, we use the way similar to insert sorting to reorder the people. For a given person to insert, all the people already sorted are higher, so we just insert him in the \"right\" place to make the people before him as his \"count\" indicates. Since he is shorter than all the people in the sorted list, the \"count\" of the \"existing\" people does not be broken by the insertion.\\n\\n```\\n    public int[][] reconstructQueue(int[][] people) {\\n        if (people == null || people.length == 0 || people[0].length == 0)\\n            return new int[0][0];\\n            \\n        Arrays.sort(people, new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (b[0] == a[0]) return a[1] - b[1];\\n                return b[0] - a[0];\\n            }\\n        });\\n        \\n        int n = people.length;\\n        ArrayList<int[]> tmp = new ArrayList<>();\\n        for (int i = 0; i < n; i++)\\n            tmp.add(people[i][1], new int[]{people[i][0], people[i][1]});\\n\\n        int[][] res = new int[people.length][2];\\n        int i = 0;\\n        for (int[] k : tmp) {\\n            res[i][0] = k[0];\\n            res[i++][1] = k[1];\\n        }\\n        \\n        return res;\\n    }\\n```"
		},
		{
			"lc_ans_id":"89367",
			"view":"8667",
			"top":"4",
			"title":"O(n sqrt(n)) solution",
			"vote":"14",
			"content":"Based on this solution which I first saw brought up by @bigoffer4all [**here**](https://discuss.leetcode.com/topic/24320/line-reconstruction-by-height/8) (and which I [**explained here**](https://discuss.leetcode.com/topic/60981/explanation-of-the-neat-sort-insert-solution)):\\n\\n    def reconstructQueue(self, people):\\n        queue = []\\n        for p in sorted(people, key=lambda (h, t): (-h, t)):\\n            queue.insert(p[1], p)\\n        return queue\\n\\nThat takes O(n^2) because each `insert` into the list takes O(n).\\n\\nInstead of just one long list of all people, I break the queue into O(sqrt(n)) blocks of size up to sqrt(n). Then to insert at the desired index, I find the appropriate block, insert the person into that block, and potentially have to break the block into two. Each of those things takes O(sqrt(n)) time.\\n\\n    def reconstructQueue(self, people):\\n        blocks = [[]]\\n        for p in sorted(people, key=lambda (h, t): (-h, t)):\\n            index = p[1]\\n\\n            for i, block in enumerate(blocks):\\n                m = len(block)\\n                if index <= m:\\n                    break\\n                index -= m\\n            block.insert(index, p)\\n            if m * m > len(people):\\n                blocks.insert(i + 1, block[m/2:])\\n                del block[m/2:]\\n\\n        return [p for block in blocks for p in block]\\n\\n\"Unfortunately\", Python's `list.insert` is really fast compared to doing things in Python myself, and with the inputs allowed here (less than 1100 people), the O(n^2) solution wins. Locally I tested with larger inputs, and around 200000 people the two solutions were about equally fast. With 300000 people, the O(n sqrt(n)) solution was about factor 1.25 faster, and with a million people, the O(n sqrt(n)) solution was about factor 2.2 faster\\n\\nThe testing code:\\n```\\n# The original O(n^2) solution.\\nclass Solution(object):\\n    def reconstructQueue(self, people):\\n        queue = []\\n        for p in sorted(people, key=lambda (h, t): (-h, t)):\\n            queue.insert(p[1], p)\\n        return queue\\nnsquared = Solution().reconstructQueue\\n\\n# The O(n sqrt(n)) solution.\\nclass Solution(object):\\n    def reconstructQueue(self, people):\\n        blocks = [[]]\\n        for p in sorted(people, key=lambda (h, t): (-h, t)):\\n            index = p[1]\\n\\n            for i, block in enumerate(blocks):\\n                m = len(block)\\n                if index <= m:\\n                    break\\n                index -= m\\n            block.insert(index, p)\\n            if m * m > len(people):\\n                blocks.insert(i + 1, block[m/2:])\\n                del block[m/2:]\\n\\n        return [p for block in blocks for p in block]\\nnsqrtn = Solution().reconstructQueue\\n\\n# Generate a large test case and time it.\\nfrom bisect import bisect\\nfrom random import randint, shuffle\\nfrom timeit import timeit\\nn = 300000\\nheights = [randint(1, n) for _ in range(n)]\\nstanding = []\\npeople = []\\nfor h in heights:\\n    i = bisect(standing, -h)\\n    standing.insert(i, -h)\\n    people.append([h, i])\\nshuffle(people)\\nfor solution in nsquared, nsqrtn, nsquared, nsqrtn:\\n    print timeit(lambda: solution(people), number=1)\\n```"
		},
		{
			"lc_ans_id":"89342",
			"view":"1596",
			"top":"5",
			"title":"O(nlogn) Binary Index Tree C++ solution",
			"vote":"9",
			"content":"```\\n1. Sort by height, if height is equal, sort by second item\\n\\n2. Naive Algorithm:\\n   for each item in seq:\\n         find the new insert position and assign it to the item\\n\\n3. Case analysis:\\n    [4,4], [5,0], [5,2], [6,1], [7,0], [7,1], total 6 sorted items\\n    that means we must fill 6 blankets.     _ _ _ _ _ _ \\n    (1)[4,4] means there are 4 items before it, since no other items less than it, so it must be at the 5th pos. \\n    (2)[5,0] means there are 0 items before it, so it must be at the first pos.\\n    ......\\n    (6)same as before\\n    \\n   visualize process\\n   -----------------\\n\\n     _      _      _      _      _      _\\n     _      _      _      _    [4,4]    _\\n   [5,0]    _      _      _    [4,4]    _\\n   [5,0]    _    [5,2]    _    [4,4]    _\\n   [5,0]    _    [5,2]  [6,1]  [4,4]    _\\n   [5,0]  [7,0]  [5,2]  [6,1]  [4,4]    _\\n   [5,0]  [7,0]  [5,2]  [6,1]  [4,4]  [7,1]\\n\\n4. Improved Algorithm\\n    for each item in seq:\\n         pos = find Kth avaliable position in newArray // K = item.second\\n         newArray[pos] = item\\n         used[pos] = true\\n\\n   Implement find_Kth() method can be done in O(n), thus total complexity is O(n^2)\\n\\n5. Implement find_Kth() method in O(lgN*lgN) or O(lgN) use BIT\\n    (1)trick #1: to convert the former \"fill blanket\" to \"range sum\"\\n    (2)trick #2: if height[i] == height[i+1], we must delay the \"convert\" operation as below described\\n\\n   visualize process\\n   -----------------\\n     1   1   1   1   1   1      // first initialize all position with 1\\n     1   1   1   1   0   1     // find [4,4] pos by calling find_Kth(4+1), pos = 5, and convert 1 to 0\\n     1   1   1   1   0   1     // find [5,0] pos by calling find_Kth(0+1), pos = 1, do not convert 1 to 0 \\n     0   1   0   1   0   1     // find [5,2] pos by calling find_Kth(2+1), pos = 3, and convert 1 to 0\\n     0   1   0   0   0   1     // find [6,1] pos by calling find_Kth(1+1), pos = 4, and convert 1 to 0\\n     0   1   0   0   0   1     // find [7,0] pos by calling find_Kth(0+1), pos = 2, do not convert 1 to 0 \\n     0   0   0   0   0   0     // find [7,1] pos by calling find_Kth(1+1), pos = 6, convert 1 to 0\\n```\\nDirty Code Below......\\nHope someone can post a nice and clean code.....\\n\\n```c++\\nclass Solution {\\npublic:\\n    typedef pair<int,int> Node;\\n    vector<int> c;\\n    int n;\\n    vector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) {\\n        int len = people.size();\\n        vector<Node> ans(len);\\n        vector<int> tmp(len+2,0);\\n        c = tmp;\\n        n = len;\\n        \\n        //initialize\\n        for(int i = 1; i <= n; i++)update(i,1);\\n        sort(people.begin(), people.end());\\n        \\n        int pre = -1;\\n        vector<int> preNum;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            //amotized O(1) operation\\n            if(people[i].first != pre)\\n            {\\n                for(int j = 0; j < preNum.size(); j++)update(preNum[j],-1);\\n                preNum.clear();\\n                    \\n            }\\n            int num = findKth(people[i].second+1);\\n            ans[num-1] = people[i];\\n            \\n            preNum.push_back(num);\\n            pre = people[i].first;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n   //Binary Index Tree update\\n    void update(int idx, int val)\\n    {\\n        while(idx <= n)\\n        {\\n            c[idx] += val;\\n            idx += idx & -idx;\\n        }\\n    }\\n    \\n    //Binary Index Tree getSum [1, idx]\\n    int getsum(int idx)\\n    {\\n        int sum = 0;\\n        while(idx > 0)\\n        {\\n            sum += c[idx];\\n            idx -= idx & -idx;\\n        }\\n        return sum;\\n    }\\n    \\n    //find-Kth position, Here I use Binary-search, So complexity is O(lgN*lgN)\\n    int findKth(int k)\\n    {\\n        int l = 1, r = n, mid;\\n        while(l <= r)\\n        {\\n            mid = (l + r) >> 1;\\n            if(getsum(mid) >= k)r = mid - 1;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n    \\n    bool static cmp(Node a, Node b)\\n    {\\n        if(a.first == b.first)return a.second < b.second;\\n        return a.first < b.first;\\n    }\\n};\\n\\n\\n//Another O(lgN) find_Kth implementaiton\\n/*\\nint find_kth(int k)\\n{\\n    int cnt = 0, ans = 0;\\n    for(int i = 20; i >=0; i--)\\n    {\\n        ans += 1 << i;\\n        if(ans >= n || cnt + c[ans] >= k)ans -= 1 << i;\\n        else cnt += c[ans];\\n    }\\n    return ans + 1;\\n}\\n*/\\n```"
		},
		{
			"lc_ans_id":"89407",
			"view":"641",
			"top":"6",
			"title":"[Python] Documented solution in O(n*n) time that is easy to understand",
			"vote":"7",
			"content":"```\\nclass Solution(object):\\n    def reconstructQueue(self, people):\\n        if not people:\\n            return []\\n        ordered_line = []\\n        # this sorts the list by height where the largest heights are first. \\n        # each group of heights is also sorted in ascending order\\n        # (e.g. [[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]] would be the\\n        # resulting list after sorting the default test case for run code)\\n        insertion_order = sorted(people, key = lambda (h,k): (-h,k))\\n        \\n        for person in insertion_order:\\n            # by inserting each person into the new list using k as the insertion\\n            # index and by starting with the tallest people we leverage the what \\n            # insertion does: push every element behind it back 1. By inserting \\n            # from tallest to shortest, we make sure that, at the time of insertion,\\n            # everything is being put into the list with exactly k people in front\\n            # of them that are taller or equal in height\\n            ordered_line.insert(person[1], person)\\n            \\n        return ordered_line\\n```\\n\\nJust as a proof of concept I will show what happens if we run this on the default test case. First, we sort it and store the produced list, **[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]**, in our new list, **\"insertion_order\"**. After that we iterate over it and copy each element into **\"ordered_line\"**.\\n* 1st element: We insert [7,0] at 0 in ordered_line: [[7,0]]\\n* 2nd element: We insert [7,1] at 1 in ordered_line: [[7,0], [7,1]]\\n* 3rd element: We insert [6,1] at 1 in ordered_line: [[7,0], [6,1], [7,1]] \\n(Notice how it moved all elements at index 1 or greater to the right 1)\\n* 4th element: We insert [5,0] at 0 in ordered_line: [[5,0], [7,0], [6,1], [7,1]]\\n(Notice how, although we have inserted another element in front of [6,1], because of the order we are doing it it, the new element is not taller or the same height so it doesn't matter)\\n* 5th element: We insert [5,2] at 2 in ordered_line: [[5,0], [7,0], [5,2], [6,1], [7,1]]\\n* 6th element: We insert [4,4] at 4 in ordered_line: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\\n* Then we return the ordered_line\\n\\nHere is the code without comments for the Python wizards out there:\\n```\\nclass Solution(object):\\n    def reconstructQueue(self, people):\\n        if not people:\\n            return []\\n        ordered_line = []\\n        insertion_order = sorted(people, key = lambda (h,k): (-h,k))\\n        for person in insertion_order: ordered_line.insert(person[1], person)\\n        return ordered_line\\n```"
		},
		{
			"lc_ans_id":"89455",
			"view":"1065",
			"top":"7",
			"title":"Worse case O(n^2) and O(nlogn) in average using binary tree travel",
			"vote":"7",
			"content":"The main idea is as follows:\\n1. Sort the array with `h` descending and if the height equal sorted with `k` ascending. \\n2. Building the binary tree as following rules:\\n2.1 using the first sorted people as root\\n2.2 iterate insert the people. \\nif the `k` of current people less than the root, insert the people in the left node, and increase the root with 1. It means that how many people preceding the root when doing inorder travel.\\nOtherwise, insert the node to the right. At the same time, you need to decrease the node `k` with `k-root.val` which means the preceding already has k in the left subtree. \\n3. Inorder travel the tree to get the final result.\\n\\nNOTE: For the sort, why we should sort the value with same height in ascending? if not, the node with same height can't order correctly. It's possible that the node with less `k`(height count) could be preceding the node with more `k`. EX: `(5,3), (5,2)`. The `(5,3)` could be preceding `(5,2)`.\\n\\n```python\\nclass Node(object):\\n    def __init__(self,p):\\n        \"\"\"\\n        For general programming, it's better to create Person class.\\n        \"\"\"\\n        self.person=p\\n        self.hcnt=1\\n        self.left=None\\n        self.right=None\\n\\nclass Solution(object):\\n    def reconstructQueue(self,people):\\n        if not people:\\n            return []\\n        # sort the people with height descending\\n        # if height equal sort with hcnt ascending\\n        people.sort(cmp=lambda x,y:y[0]-x[0] if x[0]!=y[0] else x[1]-y[1])\\n        root=Node(people[0])\\n        for p in people[1:]:\\n            self.insert(root,p,p[1])\\n        res=[]\\n        self.inorder(root,res)\\n        return res\\n            \\n    def insert(self,root,p,hcnt):\\n        # compare the height cnt with root\\n        # if the hight count less than the root, go to the left\\n        if hcnt<root.hcnt:\\n            if not root.left:\\n                root.left=Node(p)\\n            else:\\n                self.insert(root.left,p,hcnt)\\n            # increase the root cnt,means number preceding in the left subtree\\n            root.hcnt+=1\\n        else:\\n            if not root.right:\\n                root.right=Node(p)\\n            else:\\n                # decrease the hcnt since it already has root.cnt before the left subtree\\n                self.insert(root.right,p,hcnt-root.hcnt)\\n                \\n    def inorder(self,root,res):\\n        if not root:\\n            return \\n        self.inorder(root.left,res)\\n        res.append(root.person)\\n        self.inorder(root.right,res)\\n```"
		},
		{
			"lc_ans_id":"89439",
			"view":"2625",
			"top":"8",
			"title":"Java solution using PriorityQueue and LinkedList",
			"vote":"6",
			"content":"Instead of using ArrayList for insertion, using LinkedList is more efficient. [Here](http://stackoverflow.com/questions/322715/when-to-use-linkedlist-over-arraylist) is the discussion of when to use LinkedList over ArrayList on StackOverFlow. \\n````\\npublic class Solution {\\n    class PairComp implements Comparator<int[]> {\\n        public int compare(int[] p1, int[] p2){\\n            int comp_h = Integer.compare(p2[0], p1[0]);\\n            return comp_h == 0 ? Integer.compare(p1[1], p2[1]): comp_h;\\n        }\\n    }\\n    public int[][] reconstructQueue(int[][] people) {\\n        LinkedList<int[]> list = new LinkedList();\\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(1, new PairComp() );\\n        for (int[] ppl: people){\\n            queue.offer( ppl );\\n        }\\n        while ( ! queue.isEmpty() ) {\\n            int[] pair = queue.poll();\\n            list.add(pair[1], pair);\\n        }\\n        int[][] ret = new int[people.length][];\\n        for (int i=0; i<list.size(); i++){\\n            ret[i] = list.get(i);\\n        }\\n        return ret;\\n    }\\n}\\n````\\nShorter version without using PriorityQueue:\\n````\\npublic class Solution {\\n    public int[][] reconstructQueue(int[][] people) {\\n        Arrays.sort(people,new Comparator<int[]>(){\\n           public int compare(int[] p1, int[] p2){\\n               return p1[0]!=p2[0]?Integer.compare(p2[0],p1[0]): Integer.compare(p1[1],p2[1]);\\n           }\\n        });\\n        List<int[]> list = new LinkedList();\\n        for (int[] ppl: people) list.add(ppl[1], ppl);\\n        return list.toArray(new int[people.length][] );\\n    }\\n}\\n````"
		},
		{
			"lc_ans_id":"89370",
			"view":"1486",
			"top":"9",
			"title":"Java O(n^2) greedy solution",
			"vote":"5",
			"content":"We always choose the current shortest height (so we need to sort input first), and then try to put it into the right position. We simply scan from the left and count how many persons are really >= its own height. Then we put the person into the empty slot.\\n```\\npublic class Solution {\\n    public int[][] reconstructQueue(int[][] people) {\\n        if (people == null || people.length <= 1) {\\n            return people;\\n        }\\n        Arrays.sort(people, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0];\\n            }\\n        });\\n        int n = people.length;\\n        int[][] ret = new int[n][];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0, ahead = 0; j < n; j++) {\\n                if (ahead < people[i][1]) {\\n                    ahead += (ret[j] == null || ret[j][0] >= people[i][0]) ? 1 : 0;\\n                } else if (ret[j] == null) {\\n                    ret[j] = people[i];\\n                    break;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```"
		}
	],
	"id":"406",
	"title":"Queue Reconstruction by Height",
	"content":"<p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers <code>(h, k)</code>, where <code>h</code> is the height of the person and <code>k</code> is the number of people in front of this person who have a height greater than or equal to <code>h</code>. Write an algorithm to reconstruct the queue.\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\nThe number of people is less than 1,100.\r\n</p>\r\n\r\n<br />\r\n\r\n<p><b>Example</b>\r\n<pre>\r\nInput:\r\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\r\n\r\nOutput:\r\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\r\n</pre>\r\n</p>",
	"frequency":"464",
	"ac_num":"38002"
}