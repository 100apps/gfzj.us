{
	"difficulty":"3",
	"submit_num":"39182",
	"show_id":"407",
	"leetcode_id":"407",
	"answers":[
		{
			"lc_ans_id":"89461",
			"view":"20901",
			"top":"0",
			"title":"Java solution using PriorityQueue",
			"vote":"106",
			"content":"Source code from:\\nhttps://github.com/shawnfan/LintCode/blob/master/Java/Trapping%20Rain%20Water%20II.java\\n\\n```\\n\\npublic class Solution {\\n\\n    public class Cell {\\n        int row;\\n        int col;\\n        int height;\\n        public Cell(int row, int col, int height) {\\n            this.row = row;\\n            this.col = col;\\n            this.height = height;\\n        }\\n    }\\n\\n    public int trapRainWater(int[][] heights) {\\n        if (heights == null || heights.length == 0 || heights[0].length == 0)\\n            return 0;\\n\\n        PriorityQueue<Cell> queue = new PriorityQueue<>(1, new Comparator<Cell>(){\\n            public int compare(Cell a, Cell b) {\\n                return a.height - b.height;\\n            }\\n        });\\n        \\n        int m = heights.length;\\n        int n = heights[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n\\n        // Initially, add all the Cells which are on borders to the queue.\\n        for (int i = 0; i < m; i++) {\\n            visited[i][0] = true;\\n            visited[i][n - 1] = true;\\n            queue.offer(new Cell(i, 0, heights[i][0]));\\n            queue.offer(new Cell(i, n - 1, heights[i][n - 1]));\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            visited[0][i] = true;\\n            visited[m - 1][i] = true;\\n            queue.offer(new Cell(0, i, heights[0][i]));\\n            queue.offer(new Cell(m - 1, i, heights[m - 1][i]));\\n        }\\n\\n        // from the borders, pick the shortest cell visited and check its neighbors:\\n        // if the neighbor is shorter, collect the water it can trap and update its height as its height plus the water trapped\\n       // add all its neighbors to the queue.\\n        int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        int res = 0;\\n        while (!queue.isEmpty()) {\\n            Cell cell = queue.poll();\\n            for (int[] dir : dirs) {\\n                int row = cell.row + dir[0];\\n                int col = cell.col + dir[1];\\n                if (row >= 0 && row < m && col >= 0 && col < n && !visited[row][col]) {\\n                    visited[row][col] = true;\\n                    res += Math.max(0, cell.height - heights[row][col]);\\n                    queue.offer(new Cell(row, col, Math.max(heights[row][col], cell.height)));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"89460",
			"view":"4956",
			"top":"1",
			"title":"Alternative approach using Dijkstra in O(rc max(log r, log c)) time",
			"vote":"19",
			"content":"This problem can also be solved in a more general approach way using Dijkstra.\\n\\nConstruct a graph `G = (V, E)` as follows:\\nV = all cells plus a dummy vertex, `v`, corresponding to the outside region.\\nIf `cell(i, j)` is adjacent to `cell(i', j')`, then add an direct edge from `(i, j)` to `(i', j')` with weight `height(i', j')`.\\nAdd an edge with zero weight from any boundary cell to the dummy vertex `v`.\\n\\nThe weight of a path is defined as the weight of the heaviest edge along it. Then, for any cell `(i, j)`, the height of water it can save is equal to the weight, denoted by `dist(i, j)`, of the shortest path from `(i, j)` to `v`. (If the weight is less than or equal to `height(i, j)`, no water can be accumulated at that particular position.)\\n\\nWe want to compute the `dist(i, j)` for all pairs of `(i, j)`. Here, we have multiple sources and one destination, but this problem essentially can be solved using one pass of Dijkstra algorithm if we **reverse** the directions of all edges. The graph is sparse, i.e., there are O(rc) edges, resulting an `O(rc log(rc)) = O(rc max(log r, log c))` runtime and using `O(rc)` space.\\n\\n\\nJava Code:\\n```Java\\npublic class Solution {\\n\\n    int[] dx = {0, 0, 1, -1};\\n    int[] dy = {1, -1, 0, 0};\\n\\n    List<int[]>[] g;\\n    int start;\\n\\n    private int[] dijkstra() {\\n        int[] dist = new int[g.length];\\n        Arrays.fill(dist, Integer.MAX_VALUE / 2);\\n        dist[start] = 0;\\n        TreeSet<int[]> tree = new TreeSet<>((u, v) -> u[1] == v[1] ? u[0] - v[0] : u[1] - v[1]);\\n        tree.add(new int[]{start, 0});\\n        while (!tree.isEmpty()) {\\n            int u = tree.first()[0], d = tree.pollFirst()[1];\\n            for (int[] e : g[u]) {\\n                int v = e[0], w = e[1];\\n                if (Math.max(d, w) < dist[v]) {\\n                    tree.remove(new int[]{v, dist[v]});\\n                    dist[v] = Math.max(d, w);\\n                    tree.add(new int[]{v, dist[v]});\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n\\n    public int trapRainWater(int[][] a) {\\n        if (a == null || a.length == 0 || a[0].length == 0) return 0;\\n        int r = a.length, c = a[0].length;\\n\\n        start = r * c;\\n        g = new List[r * c + 1];\\n        for (int i = 0; i < g.length; i++) g[i] = new ArrayList<>();\\n        for (int i = 0; i < r; i++)\\n            for (int j = 0; j < c; j++) {\\n                if (i == 0 || i == r - 1 || j == 0 || j == c - 1) g[start].add(new int[]{i * c + j, 0});\\n                for (int k = 0; k < 4; k++) {\\n                    int x = i + dx[k], y = j + dy[k];\\n                    if (x >= 0 && x < r && y >= 0 && y < c) g[i * c + j].add(new int[]{x * c + y, a[i][j]});\\n                }\\n            }\\n\\n        int ans = 0;\\n        int[] dist = dijkstra();\\n        for (int i = 0; i < r; i++)\\n            for (int j = 0; j < c; j++) {\\n                int cb = dist[i * c + j];\\n                if (cb > a[i][j]) ans += cb - a[i][j];\\n            }\\n\\n        return ans;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"89476",
			"view":"5572",
			"top":"2",
			"title":"concise C++ priority_queue solution",
			"vote":"15",
			"content":"```\\nclass Solution {\\npublic:\\n    int trapRainWater(vector<vector<int>>& heightMap) {\\n        if(heightMap.size()==0) return 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\\n        int row = heightMap.size(), col = heightMap[0].size();\\n        vector<vector<int>> visited(row, vector<int>(col, 0));\\n        int ans = 0, Max = INT_MIN;\\n        for(int i = 0; i < row; i++)\\n        {\\n            for(int j = 0; j < col; j++)\\n            {\\n                if(!(i==0 || i==row-1 || j==0 || j==col-1)) continue;\\n                que.push(make_pair(heightMap[i][j], i*col+j));\\n                visited[i][j] = 1;\\n            }\\n        }\\n        vector<vector<int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        while(!que.empty())\\n        {\\n            auto val = que.top(); que.pop();\\n            int height = val.first, x = val.second/col, y = val.second%col;\\n            Max = max(Max, height);\\n            for(auto d: dir)\\n            {\\n                int x2 = x + d[0], y2 = y + d[1];\\n                if(x2>=row || x2<0 || y2<0 || y2>=col || visited[x2][y2]) continue;\\n                visited[x2][y2] = 1;\\n                if(heightMap[x2][y2] < Max) ans += Max - heightMap[x2][y2];\\n                que.push(make_pair(heightMap[x2][y2], x2*col+y2));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"89472",
			"view":"1865",
			"top":"3",
			"title":"Visualization - No Code",
			"vote":"14",
			"content":"A visualization of the most popular priority queue algorithm.\\nhttps://www.youtube.com/watch?v=cJayBq38VYw"
		},
		{
			"lc_ans_id":"89466",
			"view":"2976",
			"top":"4",
			"title":"python solution with heap",
			"vote":"14",
			"content":"```\\nclass Solution(object):\\n    def trapRainWater(self, heightMap):\\n        if not heightMap or not heightMap[0]:\\n            return 0\\n        \\n        import heapq    \\n        m, n = len(heightMap), len(heightMap[0])\\n        heap = []\\n        visited = [[0]*n for _ in xrange(m)]\\n\\n        # Push all the block on the border into heap\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if i == 0 or j == 0 or i == m-1 or j == n-1:\\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\\n                    visited[i][j] = 1\\n        \\n        result = 0\\n        while heap:\\n            height, i, j = heapq.heappop(heap)    \\n            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\\n                if 0 <= x < m and 0 <= y < n and not visited[x][y]:\\n                    result += max(0, height-heightMap[x][y])\\n                    heapq.heappush(heap, (max(heightMap[x][y], height), x, y))\\n                    visited[x][y] = 1\\n        return result\\n```\\n\\nThe idea is that we maintain all the points of the current border in a min heap and always choose the point with the lowest length. This is actually an optimized searching strategy over the trivial brute force method: instead of dfs each point to find the lowest \"border\" of its connected component, we can always start a search from the lowest border and update the points adjacent to it."
		},
		{
			"lc_ans_id":"89467",
			"view":"6445",
			"top":"5",
			"title":"[Why reinvent the wheel??] An easy understood commented solution based on trapping rain 1",
			"vote":"9",
			"content":"```\\n/*\\nBasic physics:\\nUnlike bricks, water flows to wherever it could. \\ni.e we can't have the follwoing config made with water, but can do it with bricks\\n000\\n010\\n000\\nIn the case above, if the \"1\" is built with water, that water can't stay. It needs to be spilled!\\n\\n2 steps Algorithm: \\n1. Since we know how to trap rain water in 1d, we can just transfor this 2D problem into 2 1D problems\\n    we go row by row, to calculate each spot's water\\n    we go column by column, to calculate each spot's water\\n\\n2. Then, here comes the meat,\\n    For every spot that gets wet, from either row or column calculation, the water can possibly spill.\\n    We need to check the water height aganist it's 4 neighbors. \\n        If the water height is taller than any one of its 4 neightbors, we need to spill the extra water.\\n        If we spill any water from any slot, then its 4 neightbors needs to check themselves again.\\n            For example, if we spill some water in the current slot b/c its bottm neighbor's height, current slot's top neighbor's height might need to be updated again.\\n        we keep checking until there is no water to be spilled.\\n*/\\n\\n\\npublic class Solution {\\n    public int trapRainWater(int[][] heightMap) {\\n        /*FIRST STEP*/\\n        if(heightMap.length == 0) return 0;\\n        int[][] wetMap = new int[heightMap.length][heightMap[0].length];\\n        int sum = 0;\\n        /*row by row*/\\n        for(int i = 1; i < wetMap.length - 1; i++){\\n            wetMap[i] = calculate(heightMap[i]);\\n        }\\n        /*column by column*/\\n        for(int i = 1; i < heightMap[0].length - 1; i++){\\n            int[] col = new int[heightMap.length];\\n            for(int j = 0; j < heightMap.length; j++){\\n                col[j] = heightMap[j][i];\\n            }\\n            int[] colResult = calculate(col);\\n            /*update the wetMap to be the bigger value between row and col, later we can spill, don't worry*/\\n            for(int j = 0; j < heightMap.length; j++){\\n                wetMap[j][i] = Math.max(colResult[j], wetMap[j][i]);\\n                sum += wetMap[j][i];\\n            }\\n        }\\n        /*SECOND STEP*/\\n        boolean spillWater = true;\\n        int[] rowOffset = {-1,1,0,0};\\n        int[] colOffset = {0,0,1,-1};\\n        while(spillWater){\\n            spillWater = false;\\n            for(int i = 1; i < heightMap.length - 1; i++){\\n                for(int j = 1; j < heightMap[0].length - 1; j++){\\n                    /*If this slot has ever gotten wet, exammine its 4 neightbors*/\\n                    if(wetMap[i][j] != 0){\\n                        for(int m = 0; m < 4; m++){\\n                            int neighborRow = i + rowOffset[m];\\n                            int neighborCol = j + colOffset[m];\\n                            int currentHeight = wetMap[i][j] + heightMap[i][j];\\n                            int neighborHeight = wetMap[neighborRow][neighborCol] + \\n                                                              heightMap[neighborRow][neighborCol];\\n                            if(currentHeight > neighborHeight){\\n                                int spilledWater = currentHeight - Math.max(neighborHeight, heightMap[i][j]);\\n                                wetMap[i][j] = Math.max(0, wetMap[i][j] - spilledWater);\\n                                sum -= spilledWater;\\n                                spillWater = true;\\n                            }\\n                        }    \\n                    }    \\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    /*Nothing interesting here, the same function for trapping water 1*/\\n    private int[] calculate (int[] height){\\n        int[] result = new int[height.length];\\n        Stack<Integer> s = new Stack<Integer>();\\n        int index = 0;\\n        while(index < height.length){\\n            if(s.isEmpty() || height[index] <= height[s.peek()]){\\n                s.push(index++);\\n            }else{\\n                int bottom = s.pop();\\n                if(s.size() != 0){\\n                    for(int i = s.peek() + 1; i < index; i++){\\n                        result[i] += (Math.min(height[s.peek()], height[index]) - height[bottom]);\\n                    }    \\n                }\\n            }\\n        }\\n        return result;\\n    }   \\n    \\n}\\n````"
		},
		{
			"lc_ans_id":"89496",
			"view":"937",
			"top":"6",
			"title":"Concise C++ method with explanation",
			"vote":"5",
			"content":"It takes me a long time to figure it out, but actually the idea is quite straightforward. Imagine the pool is surrounded by many bars. The water can only go out from the lowest bar. So we always start from the lowest boundary and keep pushing the bar from boundary towards inside. It works as if we are replacing the old bars with a bar higher than it.\\nSee the following simple example:\\n4 4 4 4\\n4 0 1 2\\n4 4 4 4\\nit looks like we push the bar of 2 towards left and record the difference. Then you can use the same procedure with the following figure\\n4 4 4 4\\n4 0 2 2\\n4 4 4 4\\n```\\n    int trapRainWater(vector<vector<int>>& heightMap) {\\n        typedef pair<int,int> cell;\\n        priority_queue<cell, vector<cell>, greater<cell>> q;\\n        int m = heightMap.size();\\n        if (m == 0) return 0;\\n        int n = heightMap[0].size();\\n        vector<int> visited(m*n, false);\\n        \\n        for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            if (i == 0 || i == m-1 || j == 0  || j == n-1) {\\n                if (!visited[i*n+j])\\n                    q.push(cell(heightMap[i][j], i*n+j));\\n                visited[i*n+j] = true;\\n            }\\n        }\\n        \\n        int dir[4][2] = {{0,1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int ans = 0;\\n        while(!q.empty()) {\\n            cell c = q.top();\\n            q.pop();\\n            int i = c.second/n, j = c.second%n;\\n            \\n            for (int r = 0; r < 4; ++r) {\\n                int ii = i+dir[r][0], jj = j+dir[r][1];\\n                if (ii < 0 || ii >= m || jj < 0 || jj >= n || visited[ii*n+jj])\\n                    continue;\\n                ans += max(0, c.first - heightMap[ii][jj]);\\n                q.push(cell(max(c.first, heightMap[ii][jj]), ii*n+jj));\\n                visited[ii*n+jj] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n```"
		},
		{
			"lc_ans_id":"89477",
			"view":"1382",
			"top":"7",
			"title":"Java solution beating 100%",
			"vote":"4",
			"content":"My method is still based on PriorityQueue(heap). But it is combined with flood fill.\\nMaintain a heap which contains the current walls, the boundary of the water pool.\\nEvery time we pick the lowest wall as a bar, then recursively travel from this wall to its neighbors to find if they can trap the water.\\nIf we meet a position which is lower than the bar, we trap some water, else we meet a new wall and put it into the heap.\\nWe can use a 2-D array to memorize the visited position and a member variable to records the water we have trapped.\\n```\\npublic class Solution {\\n    private static class Cell implements Comparable<Cell> {\\n        private int row;\\n        private int col;\\n        private int value;\\n        public Cell(int r, int c, int v) {\\n            this.row = r;\\n            this.col = c;\\n            this.value = v;\\n        }\\n        @Override\\n        public int compareTo(Cell other) {\\n            return value - other.value;\\n        }\\n    }\\n    private int water;\\n    private boolean[][] visited1;\\n    public int trapRainWater(int[][] heightMap) {\\n        if (heightMap.length == 0) return 0;\\n        PriorityQueue<Cell> walls = new PriorityQueue<Cell>();\\n        water = 0;\\n        visited1 = new boolean[heightMap.length][heightMap[0].length];\\n        int rows = heightMap.length, cols = heightMap[0].length;\\n        //build wall;\\n        for (int c = 0; c < cols; c++) {\\n        \\twalls.add(new Cell(0, c, heightMap[0][c]));\\n        \\twalls.add(new Cell(rows - 1, c, heightMap[rows - 1][c]));\\n        \\tvisited1[0][c] = true;\\n        \\tvisited1[rows - 1][c] = true;\\n        }\\n        for (int r = 1; r < rows - 1; r++) {\\n        \\twalls.add(new Cell(r, 0, heightMap[r][0]));\\n        \\twalls.add(new Cell(r, cols - 1, heightMap[r][cols - 1]));\\n        \\tvisited1[r][0] = true;\\n        \\tvisited1[r][cols - 1] = true;\\n        }\\n        //end build wall;\\n        while(walls.size() > 0) {\\n            Cell min = walls.poll();\\n            visit(heightMap, min, walls);\\n        }\\n        return water;\\n    }\\n    private void visit(int[][] height, Cell start, PriorityQueue<Cell> walls) {\\n        fill(height, start.row + 1, start.col, walls, start.value);\\n        fill(height, start.row - 1, start.col, walls, start.value);\\n        fill(height, start.row, start.col + 1, walls, start.value);\\n        fill(height, start.row, start.col - 1, walls, start.value);\\n    }\\n    private void fill(int[][] height, int row, int col, PriorityQueue<Cell> walls, int min) {\\n        if (row < 0 || col < 0) return;\\n        else if (row >= height.length || col >= height[0].length) return;\\n        else if (visited1[row][col]) return;\\n        else if (height[row][col] >= min) {\\n            walls.add(new Cell(row, col, height[row][col]));\\n            visited1[row][col] = true;\\n            return;\\n        } else {\\n//        \\tSystem.out.println(row + \", \" + col + \" height = \" + height[row][col] + \", bar = \" + min);\\n            water += min - height[row][col];\\n            visited1[row][col] = true;\\n            fill(height, row + 1, col, walls, min);\\n            fill(height, row - 1, col, walls, min);\\n            fill(height, row, col + 1, walls, min);\\n            fill(height, row, col - 1, walls, min);\\n        }\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"89495",
			"view":"730",
			"top":"8",
			"title":"How to get the solution to 2-D \"Trapping Rain Water\" problem from 1-D case",
			"vote":"3",
			"content":"First let's recall the solution to the 1-D \"Trapping Rain Water\" problem:\\n```\\npublic int trap(int[] height) {\\n    int res = 0, l = 0, r = height.length - 1;\\n        \\n    while (l < r) {\\n        if (height[l] <= height[r]) {\\n            if (l + 1 < r) {\\n                res += Math.max(0, height[l] - height[l + 1]);\\n                height[l + 1] = Math.max(height[l], height[l + 1]);\\n            }\\n                \\n            l++;\\n                \\n        } else {\\n            if (l < r - 1) {\\n                res += Math.max(0, height[r] - height[r - 1]);\\n                height[r - 1] = Math.max(height[r], height[r - 1]);\\n            }\\n                \\n            r--;\\n        }\\n    }\\n        \\n    return res;\\n}\\n```\\nThe code above is not optimized but it does show the most prominent features of the solution to the \"Trapping Rain Water\" problem:\\n1. **Rain water \"container\"**:  To hold the rain water, we need some sort of \"container\", which will be defined by its boundary. \\n\\n2. [**Liebig's law of the minimum**](https://en.wikipedia.org/wiki/Liebig%27s_law_of_the_minimum): The maximum height of  water for current container is determined by the lowest part of its boundary.\\n\\n3. **Boundary replacement**: The above \"law of the minimum\" applies only to neighbors of the lowest part of current boundary. After that the lowest part will be replaced by its neighbors. The height of the new parts of the boundary will be the larger one of the old boundary height and the height from the elevation map.\\n\\nIn the 1-D case, the boundary of the container contains only two points, i.e., the left and right edges (l and r in the above code) from the elevation map. We then apply the \"law of the minimum\" to find the minimum height of the boundary (corresponding to the two cases involving comparing height[l]  and height[r]). After that we replace the old part of the boundary with its neighbors and continue until the container shrinks to a point.\\n\\nNow let's turn to the 2-D case. \\n\\nFirst, what will the boundary of the container look like? Apparently it will no longer just be two edges, but instead, an enclosed area. Since our input is a matrix, the initial boundary will be the four edges of the matrix, which forms a rectangle.\\n\\nSecond, how do we apply the \"law of the minimum\"? This involves finding the minimum of the boundary, which is no longer as straightforward as in the 1-D case due to the rectangular boundary. Fortunately we have a data structure called \"PriorityQueue\" which can help find the minimum in log(queue_size) time.\\n\\nLastly, how do we replace the boundaries? Keep in mind we have 2-D elevation map now so each cell can have at most four neighbors. Also there are possibilities that one cell is neighbor of multiple cells on the boundary so we need to keep track of which cell has been visited to avoid repetition.\\n\\nThe following is the java solution according to the above analyses:\\n```\\nint[][] dirs = new int[][] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\npublic int trapRainWater(int[][] heightMap) {\\n    int m = heightMap.length;\\n    int n = (m == 0 ? 0 : heightMap[0].length);\\n    int res = 0;\\n        \\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n    boolean[][] visited = new boolean[m][n];\\n        \\n    for (int i = 0; i < m; i++) {\\n        pq.offer(new int[] {i, 0, heightMap[i][0]});\\n        pq.offer(new int[] {i, n - 1, heightMap[i][n - 1]});\\n        visited[i][0] = visited[i][n - 1] = true;\\n    }\\n        \\n    for (int j = 1; j < n - 1; j++) {\\n        pq.offer(new int[] {0, j, heightMap[0][j]});\\n        pq.offer(new int[] {m - 1, j, heightMap[m - 1][j]});\\n        visited[0][j] = visited[m - 1][j] = true;\\n    }\\n        \\n    while (!pq.isEmpty()) {\\n        int[] cell = pq.poll();\\n        \\t\\n        for (int[] d : dirs) {\\n            int i = cell[0] + d[0], j = cell[1] + d[1];\\n            if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j]) continue;\\n            res += Math.max(0, cell[2] - heightMap[i][j]);\\n            pq.offer(new int[] {i, j, Math.max(heightMap[i][j], cell[2])});\\n            visited[i][j] = true;\\n        }\\n    }\\n        \\n    return res;\\n}\\n```\\n\\nThe element in the PriorityQueue is an array with three elements encoding the row number, column number and the height of the cell on the boundary. We first build the initial boundary by enqueuing all cells on the outer edges of the input matrix and mark them as visited. We then apply the \"law of the minimum\" by polling the cell with minimum height on the boundary. After obtaining the water contained for each of its neighbor, we replace it with its neighbor and form a new boundary. Again we continue until the container shrinks to a point.\\n\\nThe time complexity is O(mnlog(mn)) and space complexity is O(mn). Space complexity is straightforward. For time complexity, we can think as follows: each cell will be pushed into and popped out of the queue only once, which will cost O(log(queue_size)). So the total will be O(mnlog(queue_size)). The queue size is apparently limited by the total number of cells, which is mn. Therefore the total time complexity is O(mnlog(mn))."
		},
		{
			"lc_ans_id":"89487",
			"view":"809",
			"top":"9",
			"title":"Python solution using heap + dfs beats 99%",
			"vote":"2",
			"content":"`bd` stores the current boundary(boundaries) of the water container. \\nNote that since the heights are always positive, we can set `heightMap[x][y] = 0` as `visited`. No need to use another O(mn) space.\\n```\\nfrom heapq import *\\nclass Solution(object):\\n    def trapRainWater(self, heightMap):\\n        \"\"\"\\n        :type heightMap: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\n        if len(heightMap) < 3 or len(heightMap[0]) < 3: return 0\\n        m, n, bd = len(heightMap), len(heightMap[0]), []\\n        for x, y in zip([0]*n+[m-1]*n+range(1,m-1)*2, range(n)*2+[0]*(m-2)+[n-1]*(m-2)):\\n\\t\\theappush(bd, [heightMap[x][y], x, y])\\n\\t\\theightMap[x][y] = -1\\n        res = 0\\n        while bd:\\n        \\th, x, y = heappop(bd)\\n        \\tres = self.dfs(h, x, y, bd, heightMap, m, n, res)\\n    \\treturn res\\n\\n    def dfs(self, h, x, y, bd, heightMap, m, n, res):\\n    \\tfor dx, dy in zip([-1,1,0,0], [0,0,-1,1]):\\n    \\t\\tif x+dx > 0 and x+dx < m - 1 and y+dy > 0 and y+dy < n - 1 and heightMap[x+dx][y+dy] >= 0:\\n    \\t\\t\\ttmpH = heightMap[x+dx][y+dy]\\n    \\t\\t\\theightMap[x+dx][y+dy] = -1\\n    \\t\\t\\tif tmpH <= h:\\n    \\t\\t\\t\\tres += h - tmpH\\n    \\t\\t\\t\\tres = self.dfs(h, x+dx, y+dy, bd, heightMap, m, n, res)\\n    \\t\\t\\telse: heappush(bd, [tmpH, x+dx, y+dy])\\n    \\treturn res\\n```"
		}
	],
	"id":"407",
	"title":"Trapping Rain Water II",
	"content":"<p>Given an <code>m x n</code> matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\nBoth <i>m</i> and <i>n</i> are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.\r\n</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nGiven the following 3x6 height map:\r\n[\r\n  [1,4,3,1,3,2],\r\n  [3,2,1,3,2,4],\r\n  [2,3,3,2,3,1]\r\n]\r\n\r\nReturn 4.\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<img src=\"/static/images/problemset/rainwater_empty.png\" /><br />\r\nThe above image represents the elevation map <code>[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</code> before the rain.\r\n</p>\r\n\r\n<p>\r\n<img src=\"/static/images/problemset/rainwater_fill.png\" /><br />\r\nAfter the rain, water is trapped between the blocks. The total volume of water trapped is 4.\r\n</p>",
	"frequency":"203",
	"ac_num":"14836"
}