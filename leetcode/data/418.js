{
	"difficulty":"2",
	"submit_num":"60545",
	"show_id":"418",
	"leetcode_id":"418",
	"answers":[
		{
			"lc_ans_id":"90845",
			"view":"23094",
			"top":"0",
			"title":"21ms 18 lines Java solution",
			"vote":"140",
			"content":"**Update**: See @iambright's post below for optimized code.\\n**Update**: If you want to shorten the code by getting rid of either the while loop or the if-else check, see update below.\\n```\\npublic class Solution {\\n    public int wordsTyping(String[] sentence, int rows, int cols) {\\n        String s = String.join(\" \", sentence) + \" \";\\n        int start = 0, l = s.length();\\n        for (int i = 0; i < rows; i++) {\\n            start += cols;\\n            if (s.charAt(start % l) == ' ') {\\n                start++;\\n            } else {\\n                while (start > 0 && s.charAt((start-1) % l) != ' ') {\\n                    start--;\\n                }\\n            }\\n        }\\n        \\n        return start / s.length();\\n    }\\n}\\n```\\n**Update (4/7/2017)**: There is a way to get rid of the if-else check (see discussion below). If you would like to shorten the code, see the shorter code below first.\\n```\\n    public int wordsTyping(String[] sentence, int rows, int cols) {\\n        String s = String.join(\" \", sentence) + \" \";\\n        int[] offset = new int[s.length()];\\n        IntStream.range(1, s.length()).forEach(i -> offset[i] = s.charAt(i) == ' ' ? 1 : offset[i-1]-1);\\n        return IntStream.range(0, rows).reduce(0, (a, b) -> a + cols + offset[(a+cols) % s.length()]) / s.length();\\n    }\\n```\\n\\n**Explanation**:\\n\\nSay `sentence=[\"abc\", \"de\", \"f]`, `rows=4`, and `cols=6`.\\nThe screen should look like\\n```\\n\"abc de\"\\n\"f abc \"\\n\"de f  \"\\n\"abc de\"\\n```\\nConsider the following repeating **sentence string**, with positions of the start character of each row on the screen.\\n```\\n\"abc de f abc de f abc de f ...\"\\n ^      ^     ^    ^      ^\\n 0      7     13   18     25\\n```\\nOur goal is to find the start position of the row next to the last row on the screen, which is 25 here. Since actually it's the length of everything earlier, we can get the answer by dividing this number by the length of (non-repeated) **sentence string**. Note that the non-repeated **sentence string** has a space at the end; it is `\"abc de f \"` in this example.\\n\\nHere is how we find that position. In each iteration, we need to adjust `start` based on spaces either added or removed.\\n```\\n\"abc de f abc de f abc de f ...\" // start=0\\n 012345                          // start=start+cols+adjustment=0+6+1=7 (1 space removed in screen string)\\n        012345                   // start=7+6+0=13\\n              012345             // start=13+6-1=18 (1 space added)\\n                   012345        // start=18+6+1=25 (1 space added)\\n                          012345\\n```\\nHope this helps."
		},
		{
			"lc_ans_id":"90846",
			"view":"9242",
			"top":"1",
			"title":"JAVA optimized solution 17ms",
			"vote":"50",
			"content":"First off, we can easily come up with a brute-force solution. The basic idea of optimized solution is that \\n1. sub-problem: if there's a new line which is starting with certain index in sentence, what is the starting index of next line (nextIndex[]). BTW, we compute how many times the pointer in current line passes over the last index (times[]).\\n2. relation :  ans += times[i], i = nextIndex[i], for _ in 0..<row. where i indicates what is the first word in the current line.\\n\\nTime complexity : O(n*(cols/lenAverage)) + O(rows), where n is the length of sentence array, lenAverage is the average length of the words in the input array.\\n\\nWell, It's not a typical \"DP\" problem and I am not even sure it is a \"DP\" problem. ( \\u0361\\xb0 \\u035c\\u0296 \\u0361\\xb0)\\n\\n```\\npublic int wordsTyping(String[] sentence, int rows, int cols) {\\n        int[] nextIndex = new int[sentence.length];\\n        int[] times = new int[sentence.length];\\n        for(int i=0;i<sentence.length;i++) {\\n            int curLen = 0;\\n            int cur = i;\\n            int time = 0;\\n            while(curLen + sentence[cur].length() <= cols) {\\n                curLen += sentence[cur++].length()+1;\\n                if(cur==sentence.length) {\\n                    cur = 0;\\n                    time ++;\\n                }\\n            }\\n            nextIndex[i] = cur;\\n            times[i] = time;\\n        }\\n        int ans = 0;\\n        int cur = 0;\\n        for(int i=0; i<rows; i++) {\\n            ans += times[cur];\\n            cur = nextIndex[cur];\\n        }\\n        return ans;\\n    }\\n```"
		},
		{
			"lc_ans_id":"90874",
			"view":"6608",
			"top":"2",
			"title":"12ms Java solution using DP",
			"vote":"27",
			"content":"It's kind of like a jump game. I use a array to record for each word, how far it can jump.\\neg. dp[index] means if the row start at index then the start of next row is dp[index].\\ndp[index] can be larger than the length of the sentence, in this case, one row can span multiple sentences.\\nI comment the check whether a word is longer than the row since there is no such test case. But it's better to check it. And it make little difference to the speed.\\n```\\npublic class Solution {\\n    public int wordsTyping(String[] sentence, int rows, int cols) {\\n        int[] dp = new int[sentence.length];\\n        int n = sentence.length;\\n        for(int i = 0, prev = 0, len = 0; i < sentence.length; ++i) {\\n            // remove the length of previous word and space\\n            if(i != 0 && len > 0) len -= sentence[i - 1].length() + 1;\\n            // calculate the start of next line.\\n            // it's OK the index is beyond the length of array so that \\n            // we can use it to count how many words one row has.\\n            while(len + sentence[prev % n].length() <= cols) len += sentence[prev++ % n].length() + 1;\\n            dp[i] = prev;\\n        }\\n        int count = 0;\\n        for(int i = 0, k = 0; i < rows; ++i) {\\n            // count how many words one row has and move to start of next row.\\n            // It's better to check if d[k] == k but I find there is no test case on it. \\n            // if(dp[k] == k) return 0;\\n            count += dp[k] - k;\\n            k = dp[k] % n;\\n        }\\n        // divide by the number of words in sentence\\n        return count / n;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"90839",
			"view":"3531",
			"top":"3",
			"title":"C++ memorized search",
			"vote":"15",
			"content":"I use `num` to represent how many words can be put in the screen. we use a `map<i, cnt>` to record for each line how many words `cnt` can be put when starting with word `i`. So when we scan each line of the screen, we first get the starting word should be put on this line.  If this starting words is already in the map, then just read it; otherwise, create a new entry in this map.  \\n```\\n    int wordsTyping(vector<string>& sentence, int rows, int cols) {\\n        unordered_map<int, int> umap;\\n        int num = 0, n = sentence.size();\\n        for(int i = 0; i < rows; i++){\\n            int start = num % n;\\n            if(umap.count(start) == 0){\\n                int cnt = 0, len = 0;\\n                for(int i = start; len < cols; i = (i+1) % n, cnt++){\\n                    if(len + sentence[i].size() > cols)\\n                        break;\\n                    len += sentence[i].size() + 1;\\n                }\\n                num += cnt;\\n                umap.emplace(start, cnt);\\n            }\\n            else\\n                num += umap[start];\\n        }\\n        return num / n;\\n    }\\n```"
		},
		{
			"lc_ans_id":"90881",
			"view":"2477",
			"top":"4",
			"title":"Python 108ms solution",
			"vote":"13",
			"content":"My solution was to preprocess the sentence in order to determine at each index of the sentence how many more words can fit in the column. After that I simply iterate through the rows and increment the total word count. \\n```\\nclass Solution(object):\\n    def wordsTyping(self, sentence, rows, cols):\\n        word_nums = self.preprocess(sentence, cols)          \\n        word_count = 0                \\n        for _ in xrange(rows):\\n            word_count += word_nums[word_count % len(sentence)]\\n        return word_count/len(sentence)\\n        \\n    # Preprocessing \\n    def preprocess(self, sentence, cols):\\n        word_nums = [0] * len(sentence)\\n        word_ptr, word_sum = 0, 0\\n        word_len = len(sentence[0])\\n        for i, word in enumerate(sentence):\\n            while(word_sum + word_len <= cols):\\n                word_sum += word_len\\n                word_ptr += 1\\n                word_len = len(sentence[word_ptr % len(sentence)]) + 1\\n            word_nums[i] = word_ptr - i\\n            word_sum -= (len(word) + 1)\\n        return word_nums\\n```"
		},
		{
			"lc_ans_id":"90869",
			"view":"642",
			"top":"5",
			"title":"Python with explanation",
			"vote":"10",
			"content":"Given [\\u2018AB\\u2019, \\u2018CDE\\u2019, \\u2018F\\u2019, \\u2026, \\u2018YZ\\u2019]\\nWidth: w\\n1. join the words with empty space\\n2. get the index of the end of a screen line w - 1\\n\\nthere are 3 cases:\\n\\n\\nCase 1:\\n\\u201cAB-CDE-F-\\u2026.-YZ\\u201d (\\u2018-\\u2019 denotes a space)\\nreach to the space before F\\n\\n\\nCase 2:\\n\\u201cAB-CDE-F-\\u2026._YZ\\u201d (\\u2018-\\u2019 denotes a space)\\n reach to exactly E\\n\\n\\nCase 3:\\n\\u201cAB-CDE-F-\\u2026.-YZ\\u201d (\\u2018-\\u2019 denotes a space)\\nreach to D\\n\\n\\ncase 1, I can count one more bit and go to next line\\ncase 2, I can count two more bits and go to next line\\ncase 3, I have to move the cursor back until it reach to some space, and go to next line\\n\\nWhen I go through all the rows, how many bits did I counted? Let\\u2019s say L, then the answer should be L / length of the string\\n\\n```\\nclass Solution(object):\\n    def wordsTyping(self, sentence, rows, cols):\\n        s = ' '.join(sentence) + ' '\\n        start = 0\\n        for i in xrange(rows):\\n            start += cols - 1\\n            if s[start % len(s)] == ' ':\\n                start += 1\\n            elif s[(start + 1) % len(s)] == ' ':\\n                start += 2\\n            else:\\n                while start > 0 and s[ (start - 1) % len(s) ] != ' ':\\n                    start -= 1\\n        return start/ len(s)\\n```"
		},
		{
			"lc_ans_id":"90870",
			"view":"1210",
			"top":"6",
			"title":"99% 0ms O(n) c++ solution where n = #words. Detailed explanation and analysis included.",
			"vote":"6",
			"content":"Sorry for the ugly code, not sure how to make it cleaner. Here are the key points being used to make it O(n).\\n\\n1. When `cols` is really large, find `length` of a complete sentence and shrink cols to a smaller size.\\ni). For example: `cols = max( 0, ((cols+1)%(length+1))-1 );` This takes **O(n) time**.\\nii). Also, keep track of `numSentenceInRow = (cols+1)/(total+1);`.\\n\\n2. Build a DP table, where `DP[i]=j` means that if a line start with the `i`th word, then the next line will start with the `j`th word. Using a sliding window approach, this will take **O(n) time**, since` cols` is now `<length`.\\n\\n3. Finally to handle large `rows`, we will use `DP` table to find the period where the first word start repeating.\\ni). For example, the pattern may look like this `0->7->4->1->8->5->2->8->5->2...` **O(n) time** since cycle cannot be longer than `n`.\\nii) Shrink the number of rows to newRows as follows:\\n`if( rows > n ) {`\\n    `newRows = (rows-n)%period + n;`\\n    `numCycle = (rows-n)/period;`\\n`}`\\n4. Compute the number of sentences in each `cycle` and in the first `newRows`. **O(n) time** since `newRows<2*n`.\\n`Total = numCycle*numSentenceInCycle + numSentence + rows*numSentenceInRow`\\n\\nMy ugly code...\\n```\\nclass Solution {\\n    vector<int> dp, visited;\\npublic:\\n    int wordsTyping(vector<string>& sentence, int rows, int cols) {\\n        int total = -1, n = sentence.size();\\n        dp = vector<int>( 2*n , 0 );\\n        visited = vector<int>( 2*n , -1 );\\n        \\n        //if cols is too large, check for cycle and shrink it\\n        for( auto w: sentence ) total += w.size() + 1;\\n        int numSentenceInRow = (cols+1)/(total+1);\\n        cols = max( 0, ((cols+1)%(total+1))-1 );\\n\\n        //build dp table using sliding window for o(n) performance\\n        total = -1;\\n        int j = 0;\\n        for( int i = 0; i< n*2; i ++){\\n            int k = i%n;\\n            while( total + 1 + (int)sentence[k].size() > cols ){\\n                dp[j%n] = k;\\n                total = total - ( 1 + sentence[(j++)%n].size() ) ;\\n            }\\n            total += (1 + sentence[k].size());\\n        }\\n\\n        //find cycle\\n        int curr = 0, i = 0, count = 0;\\n        while( visited[curr] == -1 ){\\n            visited[curr] = i++;\\n            curr = dp[curr];\\n        }\\n        int period = i-visited[curr], start = curr;\\n        int newRows = rows, numCycle = 0;\\n        \\n        //if rows is too large, check for cycle and shrink it\\n        if( rows > n ) {\\n            newRows = (rows-n)%period + n;\\n            numCycle = (rows-n)/period;\\n        }\\n        \\n        //count number of sentence in each cycle o(n)\\n        int numSentenceInCycle = dp[start] < start;\\n        curr = dp[start];\\n        while( curr != start ){\\n            if( dp[curr] < curr ) numSentenceInCycle ++;\\n            curr = dp[curr];\\n        }\\n        \\n        //count number of sentence in first few lines o(n)\\n        int numSentence = 0;\\n        curr = 0;\\n        for( int m = 0; m < newRows; m ++){\\n            if( dp[curr] < curr ) numSentence ++;\\n            curr = dp[curr];\\n        }\\n        return numCycle*numSentenceInCycle + numSentence + rows*numSentenceInRow;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"90862",
			"view":"2729",
			"top":"7",
			"title":"A simple simulation",
			"vote":"6",
			"content":"We spend `O(n)` time on padding each row, resulting in an `O(n * rows)`-time solution. Here, `n` denotes the number of sentences.\\nConceptually, each row consists of the following three parts:\\n 1. a **nullable** suffix of the given list, followed by\\n 2. as many as complete given lists, followed by \\n 3. a **nullable proper** prefix of the given list\\n\\nPart 1 and 3 can be handled by brute-force in `O(n)` time, and part 2 can be done in `O(1)` time via a division after we pre-compute the total length of the sentences. Therefore, the overall runtime is `O(n * rows)`.\\n\\n\\n\\n```Java\\npublic class Solution {\\n    public int wordsTyping(String[] sentence, int rows, int cols) {\\n        int sum = 0, ans = 0, which = 0;\\n        for (String s : sentence) sum += s.length();\\n        for (int i = 0; i < rows; i++) {\\n            int remaining = cols + 1; // reserve an extra space for the dummy space to the left of the first letter\\n            while (which < sentence.length && sentence[which].length() + 1 <= remaining)\\n                remaining -= sentence[which++].length() + 1;\\n            if (which >= sentence.length) {\\n                which = 0;\\n                ans = ans + 1 + remaining / (sum + sentence.length);\\n                remaining %= sum + sentence.length;\\n                while (which < sentence.length && sentence[which].length() + 1 <= remaining)\\n                    remaining -= sentence[which++].length() + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"90856",
			"view":"1139",
			"top":"8",
			"title":"Java, 10ms, starting with 12ms-java-solution-using-dp but then using a binary progression",
			"vote":"5",
			"content":"Using the very elegant solution, https://discuss.leetcode.com/topic/65173/12ms-java-solution-using-dp\\nI shaved off 2 ms by using a binary progression rather than linear.\\nIf w = # of words, then this is O(w * cols + w * log(rows)) instead of O(w*cols + rows)\\nIf a word w starts a line, we have an array that computes which word starts the next line.\\nThen, we turn it into an array that computes which word starts the next next line.\\nThen, we turn it into an array that computes which word starts the next next next next line.\\nand so on.\\n\\n```\\n\\n// starting point:  https://discuss.leetcode.com/topic/65173/12ms-java-solution-using-dp\\npublic class Solution {\\n    public int wordsTyping(String[] sentence, int rows, int cols) {\\n        int n = sentence.length;\\n        int[] nextWord = new int[n];\\n\\n        int len = 0;\\n        int word = 0;\\n        for (int i = 0; i < n; i++) {\\n            // remove the length of previous word and space\\n            if(i != 0 && len > 0) len -= sentence[i - 1].length() + 1;\\n            // calculate the start of next line.\\n            // it's OK the index is beyond the length of array so that \\n            // we can use it to count how many words one row has.\\n            while(len + sentence[word % n].length() <= cols) len += sentence[word++ % n].length() + 1;\\n            nextWord[i] = word;\\n        }\\n        int[] nextWordPow = new int[n];\\n        int[] swap;\\n        int count = 0;\\n        int k = 0;\\n        for (int pow = 1; pow <= rows; pow <<= 1) {\\n            if ((pow & rows) != 0) {\\n                count += nextWord[k] - k;\\n                k = nextWord[k] % n;\\n            }\\n            for (int i = 0; i < n; i++) {\\n                int nextLineWord = nextWord[i];\\n                int nextLineWordMod = nextLineWord % n;\\n                int nextNextLineWord = nextWord[nextLineWordMod] - (nextLineWordMod) + nextLineWord;\\n                nextWordPow[i] = nextNextLineWord;\\n            }\\n            swap = nextWord;\\n            nextWord = nextWordPow;\\n            nextWordPow = swap;\\n        }\\n        // divide by the number of words in sentence\\n        return count / n;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"90842",
			"view":"729",
			"top":"9",
			"title":"9 lines in Python",
			"vote":"4",
			"content":"Re: [21ms 18 lines Java solution](/topic/62455/21ms-18-lines-java-solution)\\n\\n```\\ndef wordsTyping(self, sentence, rows, cols):\\n        s = ' '.join(sentence)+' '\\n        start, l = 0,len(s)\\n        for i in xrange(rows):\\n            start+=cols\\n            while s[start % l]!=' ':\\n                start-=1\\n            start+=1\\n        return start/l\\n\\n```"
		}
	],
	"id":"418",
	"title":"Sentence Screen Fitting",
	"content":"<p>Given a <code>rows x cols</code> screen and a sentence represented by a list of <b>non-empty</b> words, find <b>how many times</b> the given sentence can be fitted on the screen.\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<ol>\r\n<li>A word cannot be split into two lines.</li>\r\n<li>The order of words in the sentence must remain unchanged.</li>\r\n<li>Two consecutive words <b>in a line</b> must be separated by a single space.</li>\r\n<li>Total words in the sentence won't exceed 100.</li>\r\n<li>Length of each word is greater than 0 and won't exceed 10.</li>\r\n<li>1 &le; rows, cols &le; 20,000.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\n<b>Example 1:</b> \r\n<pre>\r\n<b>Input:</b>\r\nrows = 2, cols = 8, sentence = [\"hello\", \"world\"]\r\n\r\n<b>Output:</b> \r\n1\r\n\r\n<b>Explanation:</b>\r\nhello---\r\nworld---\r\n\r\nThe character '-' signifies an empty space on the screen.\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Example 2:</b> \r\n<pre>\r\n<b>Input:</b>\r\nrows = 3, cols = 6, sentence = [\"a\", \"bcd\", \"e\"]\r\n\r\n<b>Output:</b> \r\n2\r\n\r\n<b>Explanation:</b>\r\na-bcd- \r\ne-a---\r\nbcd-e-\r\n\r\nThe character '-' signifies an empty space on the screen.\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Example 3:</b> \r\n<pre>\r\n<b>Input:</b>\r\nrows = 4, cols = 5, sentence = [\"I\", \"had\", \"apple\", \"pie\"]\r\n\r\n<b>Output:</b> \r\n1\r\n\r\n<b>Explanation:</b>\r\nI-had\r\napple\r\npie-I\r\nhad--\r\n\r\nThe character '-' signifies an empty space on the screen.\r\n</pre>\r\n</p>",
	"frequency":"168",
	"ac_num":"17017"
}