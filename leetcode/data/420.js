{
	"difficulty":"3",
	"submit_num":"20248",
	"show_id":"420",
	"leetcode_id":"420",
	"answers":[
		{
			"lc_ans_id":"91007",
			"view":"6843",
			"top":"0",
			"title":"C++ 0ms O(n) 35 lines solution with detailed explanation",
			"vote":"25",
			"content":"\\nI've separated the problem into three cases: \\n(1) ```s.length() < 6```\\n(2) ```6 <= s.length() <= 20```\\n(3) ```s.length() > 20```\\n\\n******\\nLet's look at case (1) first. If ```s.length() < 6```, we know we have room to insert some more letters into ```s```. Question is how to use the insertions effectively to reduce the number of potential replacements. I'm using a greedy approach for this one: I'm inserting one char between the second and third chars whenever I see a repetition of 3 letters as substring.\\n\\ne.g. Say we have room to insert some chars in string and we see a substring of ```\"aaaa\"```. I'll insert a ```'B'``` to make it ```\"aaBaa\"``` to break the 3-char repetition, thus reducing potential replacement by 1. And we'll do this until we can't insert any more chars into ```s```. When we reach this point, we'll start dealing with case (2)\\n\\n******\\nFor case (2), I still follow a greedy approach. I'm simply searching for 3-char repetitions, and replacing one of the chars to break the repetition. \\ne.g. If we see a substring of ```\"aaaa\"```, we'll make it ```\"aaBa\"```.\\n\\nMy code deals with (1) and (2) together as ```s.length() <= 20```.\\n\\n******\\nCase (3) is a little bit tricky because simple greedy doesn't work any more. \\nWhen ```s.length() > 20```, we want to delete some chars instead of inserting chars to reduce potential replacements. Question is the same: how to do it effectively? Let's do some observations here:\\n\\nSay ```len``` is the length of each repetition. \\n(a) ```len % 3``` only has three possible values, namely 0, 1 and 2. \\n(b) Minimum number of replacements needed to break each repetition is ```len / 3```.\\n(c) Based on (a) and (b), we know that deletion can reduce replacements only if the deletion can change the value of ```len / 3```\\n(d) Based on (c), we know if we want to reduce 1 replacement, we need 1 deletion for ```len % 3 == 0```, and 2 deletions for ```len % 3 == 1```, and 3 deletions for ```len % 3 == 2```.\\n\\nGiven above observations, I simply implemented the solution to do (d).\\n\\nAlso note that missing of upper case char, lower case char, or digit can always be resolved by insertion or replacement.\\n\\n******\\nI've pasted two versions of the solutions below, with and without comments, for easier reference. \\n\\nWithout comments:\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                               \\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     \\n                    if (toAdd < addTarget) { toAdd++, l = r; }  \\n                    else { toReplace++, l = r + 1; }           \\n                } else { l++; }                                 \\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        toReplace = 0;                                         \\n        vector<unordered_map<int, int>> lenCnts(3);            \\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {    \\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } \\n                l = r;\\n            }\\n        }\\n        \\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters, it->second -= dec;                          \\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                \\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```\\n\\nWith comments:\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it's a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we'll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"91003",
			"view":"5768",
			"top":"1",
			"title":"O(n) java solution by analyzing changes allowed to fix each problem",
			"vote":"20",
			"content":"The basic principle is straightforward: if we want to make MINIMUM changes to turn `s` into a strong password, each change made should fix as many problems as possible.\\n\\nSo to start, let's first identify all the problems in the input string `s` and list what changes are suitable for righting each of them. To clarify, each change should be characterized by at least two parts: the **type of operation** it takes and the **position in the string** where the operation is applied (`Note`: Ideally we should also include the characters involved in the operation and the \"power\" of each operation for eliminating problems but they turn out to be partially relevant so I will mention them only when appropriate).\\n\\n1. `Length problem`: if the total length is **less than 6**, the change that should be made is  (**insert, any position**), which reads as \"the operation is insertion and it can be applied to anywhere in the string\". If the total length is **greater than 20**, then the change should be (**delete, any position**).\\n\\n2. `Missing letter or digit`: if any of the lowercase/uppercase letters or digits is missing, we can do either (**insert, any position**) or (**replace, any position**) to correct it. (`Note` here the characters for insertion or replacement can only be those missing.)\\n\\n3. `Repeating characters`:  for repeating characters, all three operations are allowed but the positions where they can be applied are limited within the repeating characters. For example, to fix `\"aaaaa\"`, we can do one replacement (replace the middle `'a'`) or two insertions (one after the second `'a'` and one after the fourth `'a'`) or three deletions (delete any of the three `'a'`s). So the possible changes are (**replace, repeating characters**), (**insert, repeating characters**), (**delete, repeating characters**). (`Note` however the \"power\" of each operation for fixing the problem are different -- replacement is the strongest while deletion is the weakest.)\\n\\nAll right, what's next? If we want a change to eliminate as many problems as it can,  it must be shared among the possible solutions to each problem it can fix. So our task is to find out possible overlapping among the changes for fixing each problem.\\n\\nSince there are most (three) changes allowed for the third problem, we may start from combinations `first problem & third problem` and `second problem & third problem`.  It's not too hard to conclude that any change that can fix the first or second problems is also able to fix the third one (since the type of operation here is irrelevant, we are free to choose the position of the operation to match those of the repeating characters). For combination `first problem & second problem`, depending on the length of the string, there will be overlapping if length is less than 6 or no overlapping if length is greater than 20.\\n\\nFrom the analyses above, it seems worthwhile to distinguish between the two cases: when the input string is too short or too long. \\n\\nFor the former case, it can be shown that the total changes needed to fix the first and second problems always outnumber those for the third one. Since whatever change used fixing the first two problems can also correct the third one, we may concern ourselves with only the first two. Also as there is overlapping between the changes for fixing the first two problems, we will prefer those overlapping ones, i.e. (**insert, any position**). Another point is that the characters involved in the operation matters now. To fix the first problem, only those missing characters can be inserted while for the second condition, it can be any character. Therefore correcting the first problem takes precedence over the second one.\\n\\nFor the latter case, there is overlapping between the **first & third** and **second & third** problems, so those overlapping changes will be taken, i.e., first problem => (**delete, any position**), second problem => (**replace, any position**). The reason not to use (**insert, any position**) for the second problem is that it contradicts the changes made to the first problem (therefore has the tendency to cancel its effects). After fixing the first two problems, what operation(s) should we choose for the third one? \\n\\nNow the \"power\" of each operation for eliminating problems comes into play. For the third problem, the \"power\" of each operation will be measured by the maximum number of repeating characters it is able to get rid of. For example, one replacement can eliminate at most `5` repeating characters while insertion and deletion can do at most `4` and `3`, respectively.  In this case, we say replacement has more \"power\" than insertion or deletion. Intuitively the more \"powerful\" the operation is, the less number of changes is needed for correcting the problem. Therefore (**replace, repeating characters**) triumphs in terms of fixing the third problem.\\n\\nFurthermore, another very interesting point shows up when the \"power\" of operation is taken into consideration (And thank **[yicui](https://discuss.leetcode.com/user/yicui)** for pointing it out). As I mentioned that there is overlapping between changes made for fixing the first two problems and for the third one, which means the operations chosen above for the first two problems will also be applied to the third one. For the second problem with change chosen as (**replace, any position**), we have no problem adapting it so that it coincides with the optimal change (**replace, repeating characters**) made for the third problem.  However, there is no way to do the same for the first problem with change (**delete, any position**). We have a conflict now!\\n\\nHow do we reconcile it? The trick is that for a sequence of repeating characters of length `k` (`k >= 3`), instead of turning it all the way into a sequence of length `2` (so as to fix the repeating character problem) by the change (**delete, any position**), we will first reduce its length to (`3m + 2`), where (`3m + 2`) is the largest integer of the form yet no more than `k`. That is to say, if `k` is a multiple of `3`, we apply once such change so its length will become (`k - 1`); else if `k` is a multiple of `3` plus `1`, we apply twice such change to cut its length down to (`k - 2`), provided we have more such changes to spare (be careful here as we need at least two changes but the remaining available changes may be less than that, so we should stick to the smaller one: `2` or the remaining available changes). The reason is that the optimal change (**replace, repeating characters**) for the third problem will be most \"powerful\" when the total length of the repeating characters is of this form. Of course, if we still have more changes (**delete, any position**) to do after that, then we are free to turn the repeating sequence all the way into a sequence of length `2`.\\n\\nHere is the java program based on the above analyses. Both time and space complexity is `O(n)`. Not sure if we can reduce the space down to `O(1)` by computing the `arr` array on the fly. A quick explanation is given at the end.\\n```\\npublic int strongPasswordChecker(String s) {\\n    int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = s.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = (a + A + d);\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n            \\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n}\\n```\\nA quick explanation of the program:\\n1. `res` denotes the minimum changes; `a`, `A` and `d` are the number of missing lowercase letters, uppercase letters and digits, respectively; `arr` is an integer array whose element will be the number of repeating characters starting at the corresponding position in the string.\\n\\n2. In the following loop we fill in the values for `a`, `A`, `d` and `arr` to identify the problems for each condition. The total number of missing characters `total_missing` will be the summation of `a`, `A`, `d` and fixing this problem takes at least `total_missing` changes.\\n\\n3. We then distinguish the two cases when the string is too short or too long. If it is too short, we pad its length to at least `6` (note in this case we've already inserted `total_missing` characters so the new length is the summation of the original length and `total_missing`). \\n\\n4. Otherwise, to fix the first condition, we need to delete `over_len` (number of surplus characters) characters. Since fixing the first problem also corrects the third one, we need to get rid of those parts from the `arr` array. And as I mentioned, we need to first turn all numbers in the `arr` array greater than `2` into the form of (`3m + 2`) and then reduce them all the way to `2` if `over_len` is still greater than `0`. After that, we need to replace `total_missing` characters to fix the second problem, which also fixes part (or all) of the third problem. Therefore we only need to take the larger number of changes needed for fixing the second problem (which is `total_missing`) and for the third one (which is `left_over`, since it is the number of changes still needed after fixing the first problem)."
		},
		{
			"lc_ans_id":"91008",
			"view":"1621",
			"top":"2",
			"title":"Simple Python solution",
			"vote":"16",
			"content":"The len < 6 and 6 <= len <= 20 cases are easy. When len > 20, we need to do len - 20 times deletion. Also we need to do a change for every three repeating characters. \\n\\nFor any repeating sequences with len % 3 == 0, we can reduce one replacement by deleting one character. For any repeating sequences with len % 3 == 1, we can reduce one replacement by deleting two character. For the remaining sequences, we can reduce every replacement by deleting three character.\\n\\n\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any('a' <= c <= 'z' for c in s): missing_type -= 1\\n        if any('A' <= c <= 'Z' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```"
		},
		{
			"lc_ans_id":"91002",
			"view":"5974",
			"top":"3",
			"title":"JAVA Easy Solution with explanation",
			"vote":"12",
			"content":"There are 2 wrong test cases which I list at the beginning.\\n\\nThe general idea is to record some states, and calculate the edit distance at the end. All detail are explained in the comments.\\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        \\n        if(s.length()<2) return 6-s.length();\\n        \\n        //Initialize the states, including current ending character(end), existence of lowercase letter(lower), uppercase letter(upper), digit(digit) and number of replicates for ending character(end_rep)\\n        char end = s.charAt(0);\\n        boolean upper = end>='A'&&end<='Z', lower = end>='a'&&end<='z', digit = end>='0'&&end<='9';\\n        \\n        //Also initialize the number of modification for repeated characters, total number needed for eliminate all consequnce 3 same character by replacement(change), and potential maximun operation of deleting characters(delete). Note delete[0] means maximum number of reduce 1 replacement operation by 1 deletion operation, delete[1] means maximun number of reduce 1 replacement by 2 deletion operation, delete[2] is no use here. \\n        int end_rep = 1, change = 0;\\n        int[] delete = new int[3];\\n        \\n        for(int i = 1;i<s.length();++i){\\n            if(s.charAt(i)==end) ++end_rep;\\n            else{\\n                change+=end_rep/3;\\n                if(end_rep/3>0) ++delete[end_rep%3];\\n                //updating the states\\n                end = s.charAt(i);\\n                upper = upper||end>='A'&&end<='Z';\\n                lower = lower||end>='a'&&end<='z';\\n                digit = digit||end>='0'&&end<='9';\\n                end_rep = 1;\\n            }\\n        }\\n        change+=end_rep/3;\\n        if(end_rep/3>0) ++delete[end_rep%3];\\n        \\n        //The number of replcement needed for missing of specific character(lower/upper/digit)\\n        int check_req = (upper?0:1)+(lower?0:1)+(digit?0:1);\\n        \\n        if(s.length()>20){\\n            int del = s.length()-20;\\n            \\n            //Reduce the number of replacement operation by deletion\\n            if(del<=delete[0]) change-=del;\\n            else if(del-delete[0]<=2*delete[1]) change-=delete[0]+(del-delete[0])/2;\\n            else change-=delete[0]+delete[1]+(del-delete[0]-2*delete[1])/3;\\n            \\n            return del+Math.max(check_req,change);\\n        }\\n        else return Math.max(6-s.length(), Math.max(check_req, change));\\n    }\\n}\\n````\\n\\nThe author is already fixed all the test cases."
		},
		{
			"lc_ans_id":"91006",
			"view":"1372",
			"top":"4",
			"title":"java with detailed explanation",
			"vote":"3",
			"content":"![0_1477253856645_Screen Shot 2016-10-23 at 4.16.42 PM.png](/uploads/files/1477253858862-screen-shot-2016-10-23-at-4.16.42-pm.png) \\n\\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int minReplace = getMinReplace(s);\\n\\n        if (s.length() < 6){\\n            int insersion = 6 - s.length();\\n            return Math.max(insersion, minReplace);\\n        } else if (s.length() <= 20){\\n            List<Integer> groups = generateGroups(s);\\n            int replace = 0;\\n            for (int group : groups){\\n                replace += group / 3;\\n            }\\n            return Math.max(replace, minReplace);\\n        } else {\\n\\n            List<Integer> groups = generateGroups(s);\\n\\n            Collections.sort(groups);\\n\\n            int charCount = 0;\\n            int n = 0;\\n            while (charCount < 20 && n < groups.size()) {\\n                charCount += groups.get(n);\\n                n++;\\n            }\\n\\n            while (groups.size() > n) {\\n                groups.remove(groups.size() - 1);\\n            }\\n\\n            charCount = 0;\\n\\n            int badGroup = 0;\\n            for (int i = 0; i < groups.size(); i++) {\\n                if (groups.get(i) > 20) {\\n                    groups.set(i, 20);\\n                }\\n                charCount += groups.get(i);\\n                if (groups.get(i) > 2){\\n                    badGroup++;\\n                }\\n            }\\n\\n            int deletion = s.length() - 20;\\n\\n            int toDelete = charCount - 20;\\n\\n            int remainder = 0;\\n            while (toDelete > 0 && badGroup > 0) {\\n\\n                for (int i = 0; i < n; i++) {\\n                    if (groups.get(i) > 2 && groups.get(i) % 3 == remainder) {\\n                        int del = Math.min(toDelete, remainder + 1);\\n                        groups.set(i, groups.get(i) - del);\\n                        toDelete -= del;\\n                        if (groups.get(i) <= 2){\\n                            badGroup--;\\n                        }\\n                        if (toDelete == 0 || badGroup == 0) {\\n                            break;\\n                        }\\n                    }\\n                }\\n                remainder = (remainder + 1) % 3;\\n            }\\n\\n            int replace = 0;\\n            for (int i = 0; i < groups.size(); i++) {\\n                replace += groups.get(i) / 3;\\n            }\\n\\n            return deletion + Math.max(replace, minReplace);\\n        }\\n    }\\n\\n    /**\\n     * generate sorted groups\\n     * groups: # of continuous characters in S\\n     */\\n    private List<Integer> generateGroups(String s){\\n        List<Integer> groups = new ArrayList<>();\\n        for (int i = 0 ; i < s.length();){\\n            int j = i;\\n            while (j < s.length() && s.charAt(j) == s.charAt(i)){\\n                j++;\\n            }\\n            groups.add(j - i);\\n            i = j;\\n        }\\n        return groups;\\n    }\\n\\n    /**\\n     * return # of replacements needed to satisfy 2\\n     */\\n    private int getMinReplace(String s){\\n        boolean[] dls = new boolean[3];\\n        for(char c : s.toCharArray()){\\n            dls[getClass(c)] = true;\\n        }\\n        int replace = 0;\\n        for (int i = 0; i < dls.length; i++){\\n            if (!dls[i]) replace++;\\n        }\\n        return replace;\\n    }\\n\\n    private int getClass(char c){\\n        if (c >= '0' && c <= '9'){\\n            return 0;\\n        } else if (c >= 'a' && c <= 'z'){\\n            return 1;\\n        } else{\\n            return 2;\\n        }\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"91004",
			"view":"118",
			"top":"5",
			"title":"Java O(n) Greedy solution with super clear explanation",
			"vote":"2",
			"content":"We discuss in three cases:\\n1. Case (n=s.length)<6: return 6-n>nMiss?6-n:nMiss, where nMiss = hasLower?0:1+hasUpper?0:1+hasDigit?0:1;  (just check every possible n, using appropriate insertions)\\n\\n2. Case n>=6&&n<=20: Replacement is the best choice! (Replacing every third by another char is the best change.) return max(nMiss, nRep=sum{ni/3}), where ni is the length of a substring with repeating characters (SSRC).\\n\\n3. Case n>20: It is for sure that (n-20) deletions must be applied no matter what, and for sure that no insertions are needed (since 1 insert needs 1 delete, which is equivalent to 1 replace+1 delete or even 1 delete). Hence we greedily apply deletions first.\\n\\nGreedy strategies for applying deletions - clearly the best choice is to apply on a SSRC to possibly reduce nRep (when the length of s becomes 20). Immediately, we have the best of the best choice is to delete a char of a SSRC of length 3k (recalling how nRep is calculated as in case 2), and that length becomes 3(k-1)+2. Hence if possible, we apply 1 del per each such SSRC.\\n\\nIf still delete-able, the second best is to apply del on a SSRC of length 3k+1, (since nRep is reduced by 1 per 2 del, but if applying on 3k+2, nRep is reduced by 1 per 3 del). Notice that applying 1 del on such a SSRC makes its length 3k, and immediately this has the highest priority for the next possible deletion. Hence if possible, we apply 2 del per each such SSRC (to make its length become 3(k-1)+2).\\n\\nIf still delete-able, we then apply del on each (updated) SSRC until its length =2. Notice that nRep is reduced by 1 per 3 del since each has length 3k+2.\\n\\nIf still delete-able, return n-20+nMiss, (n-20 del, nMiss many rep).\\n\\nOtherwise, return n-20+max(updated_nRep, nMiss).\\n\\n\\n```\\npublic int strongPasswordChecker(String s) { \\n\\tint n = s.length();\\n\\tboolean hasLower = false, hasUpper = false, hasDigit = false;\\n\\tint nRep = 0, sum = 0; // sum=sum{length>=3 of a SSRC}\\n\\tint[] m = new int[3]; // # of SSRC of length 3k, 3k+1, 3k+2\\n\\n\\tint i = 0, j, t;\\n\\tchar c;\\n\\twhile (i < n) {\\n\\t\\tc = s.charAt(i);\\n\\n\\t\\thasLower |= (c >= 'a' && c <= 'z');\\n\\t\\thasUpper |= (c >= 'A' && c <= 'Z');\\n\\t\\thasDigit |= (c >= '0' && c <= '9');\\n\\n\\t\\tj = i + 1;\\n\\t\\twhile (j < n && s.charAt(j) == c)\\n\\t\\t\\tj++;\\n\\n\\t\\tt = j - i;\\n\\t\\tif (t >= 3) {\\n\\t\\t\\tnRep += t / 3;\\n\\t\\t\\tsum += t;\\n\\t\\t\\tm[t % 3]++;\\n\\t\\t}\\n\\t\\ti = j;\\n\\t}\\n\\n\\tint nMiss = (hasLower ? 0 : 1) + (hasUpper ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n\\tif (n < 6) \\n\\t\\treturn (6 - n) > nMiss ? (6 - n) : nMiss;\\n\\n\\tif (n <= 20)\\n\\t\\treturn Math.max(nRep, nMiss);\\n\\n\\t// n > 20\\n\\tint nDel = n - 20;\\n\\tif (nDel <= m[0])\\n\\t\\treturn nDel + Math.max(nRep - nDel, nMiss);\\n\\n\\tint rNDel = nDel - m[0];\\n\\tnRep -= m[0];\\n\\tif (rNDel <= 2 * m[1])\\n\\t\\treturn nDel + Math.max(nRep - rNDel / 2, nMiss);\\n\\n\\trNDel -= 2 * m[1];\\n\\tnRep -= m[1];\\n\\tif (nDel <= sum - 2 * (m[0] + m[1] + m[2]))\\n\\t\\t/**\\n\\t\\t * This condition is equivalent to nDel-m[0]-2m[1]<=\\n\\t\\t * sum{3(k_i-1)}+sum{3(k'_i-1)}+sum{3k''_i},\\n\\t\\t * where {3k_i, 1<=i<=m[0]}, {3k'_i+1, 1<=i<=m[1]}, \\n\\t\\t * {3k''_i+2, 1<=i<=m[2]} are the sets of lengths of SSRCs\\n\\t\\t */\\n\\t\\treturn nDel + Math.max(nRep - rNDel / 3, nMiss);\\n\\n\\treturn nDel + nMiss;\\n}\\n```"
		},
		{
			"lc_ans_id":"91011",
			"view":"513",
			"top":"6",
			"title":"Java - O(n) simple solution",
			"vote":"2",
			"content":"Repeating sequences like aaa with len % 3 == 0, we replace by deleting one character. For any repeating sequences aaaa with len % 3 == 1, we can reduce one replacement by deleting two character. For the rest, reduce every replacement by deleting three character.\\n\\nThis is my first post and pls do let me know if any errors or improvements. Thank you\\n\\n~~~\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        \\n        char [] str = s.toCharArray();\\n        boolean isUpper = false, isLower = false, isDigit = false;\\n        int missinType = 3;\\n        for(char c: str)\\n        {\\n            if(!isUpper && Character.isUpperCase(c)) { isUpper = true; missinType-=1; } //uppercase\\n            if(!isLower && Character.isLowerCase(c)) { isLower = true; missinType-=1; } //lowercase\\n            if(!isDigit && Character.isDigit(c)) { isDigit = true; missinType-=1; } //atleast one number\\n            \\n        }\\n       \\n        int totalChangeCnt = 0, OneChangeCnt =0, TwoChangeCnt =0, pos=2;\\n        while(pos < s.length())\\n        {\\n            if(str[pos]==str[pos-1] && str[pos-1]==str[pos-2] && str[pos-2]==str[pos])\\n            {\\n                int length = 2;\\n                while(pos < s.length() && str[pos]==str[pos-1])\\n                {\\n                    length += 1; pos +=1;\\n                }\\n                totalChangeCnt += length/3;\\n                if(length%3==0) OneChangeCnt += 1;\\n                else if(length%3==1) TwoChangeCnt += 1;\\n                \\n            }\\n            else\\n            {\\n                pos=pos+1;\\n            }\\n        }\\n        \\n        if(s.length()<6)\\n            return Math.max(missinType, 6-s.length());\\n        else if(s.length() <=20)\\n            return Math.max(missinType,totalChangeCnt );\\n        else\\n        {\\n            int deleteCount = s.length()-20;\\n            totalChangeCnt -= Math.min(deleteCount,OneChangeCnt*1)/1;\\n            totalChangeCnt -= Math.min(Math.max(deleteCount - OneChangeCnt, 0), TwoChangeCnt * 2) / 2;\\n            totalChangeCnt -= Math.max(deleteCount - OneChangeCnt - 2 * TwoChangeCnt, 0) / 3;\\n            \\n                \\n            return deleteCount + Math.max(missinType, totalChangeCnt);\\n        }       \\n    }\\n}\\n\\n~~~"
		},
		{
			"lc_ans_id":"91039",
			"view":"898",
			"top":"7",
			"title":"The correct answer of \"AAAAA\" should be 2, not 3",
			"vote":"2",
			"content":"The correct answer of \"AAAAA\" should be 2, not 3\\n\\nAAAAA -> AAbAA0, modify 1 char + add 1 char = 2"
		},
		{
			"lc_ans_id":"91009",
			"view":"114",
			"top":"8",
			"title":"May be the longest code but easy understand Java solution.",
			"vote":"0",
			"content":"I use code to deal with all details.\\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int len = s.length(),count = 1;\\n        boolean hasLower = false,hasUpper = false,hasNumber = false;\\n        List<Integer> repeatNum = new ArrayList<Integer>();\\n        for(int i=0;i<len;i++){\\n            if(i>0){\\n                if(s.charAt(i) == s.charAt(i-1)){\\n                    count += 1;\\n                }\\n                else{\\n                    if(count >= 3) repeatNum.add(count);\\n                    count = 1;\\n                }\\n            }\\n            char ch = s.charAt(i);\\n            if('a'<= ch && ch<='z') hasLower = true;\\n            if('A'<= ch && ch<='Z') hasUpper = true;\\n            if('0'<= ch && ch<='9') hasNumber = true;\\n        }\\n        if(count >= 3) repeatNum.add(count);\\n        int needAdd = 0,res = 0;\\n        if(!hasLower) needAdd += 1;\\n        if(!hasUpper) needAdd += 1;\\n        if(!hasNumber) needAdd += 1;\\n        Collections.sort(repeatNum,new Comparator(){\\n            @Override\\n            public int compare(Object o1,Object o2){\\n                int val1 = (Integer)(o1),val2 = (Integer)(o2);\\n                return (val1%3)-(val2%3);\\n            }\\n        });\\n        if(6<=len && len<=20){\\n            int needChange = 0;\\n            for(int i=0;i<repeatNum.size();i++){\\n                needChange += repeatNum.get(i)/3;\\n            }\\n            res = Math.max(needChange,needAdd);\\n        }else{\\n            if(len>20) \\n            {\\n                int needChange = 0,needDel = len-20,index = 0;\\n                while(needDel>0 && repeatNum.size()>0){\\n                    int val = repeatNum.get(index);\\n                    if(val/3 == (val-1)/3+1){\\n                        needDel -= 1;\\n                        if((val-1)/3==0) repeatNum.remove(index);\\n                        else repeatNum.set(index,val-1);\\n                    }\\n                    index += 1;\\n                    if(index >= repeatNum.size()) break;\\n                }\\n                index = 0;\\n                while(needDel>1 && repeatNum.size()>0){\\n                    int val = repeatNum.get(index);\\n                    if(val/3 == (val-2)/3+1){\\n                        needDel -= 2;\\n                        if((val-2)/3 == 0) repeatNum.remove(index);\\n                        else repeatNum.set(index,val-2);\\n                    }\\n                    index += 1;\\n                    if(index >= repeatNum.size()) break;\\n                }\\n                index = 0;\\n                while(needDel>2 && repeatNum.size()>0){\\n                    int val = repeatNum.get(index);\\n                    if(val/3 == (val-3)/3+1){\\n                        needDel -= 3;\\n                        if((val-3)/3 == 0) repeatNum.remove(index);\\n                        else repeatNum.set(index,val-3);\\n                    }\\n                    index += 1;\\n                    if(index >= repeatNum.size()) index = 0;\\n                }\\n                for(int i=repeatNum.size()-1;i>-1 && needDel>0;i--){\\n                    if(repeatNum.get(i)-2<=needDel){\\n                        needDel -= repeatNum.get(i)-2;\\n                        repeatNum.remove(i);\\n                    }else{\\n                        repeatNum.set(i,repeatNum.get(i)-1);\\n                        needDel = 1;\\n                    }\\n                }\\n                \\n                for(int i=0;i<repeatNum.size();i++){\\n                    needChange += repeatNum.get(i)/3;\\n                }\\n                res = len-20 + Math.max(needChange,needAdd);\\n            }\\n            else {\\n                res = Math.max(needAdd,6-len);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"91010",
			"view":"165",
			"top":"9",
			"title":"Short and clear JavaScript solution, works for different password requirements",
			"vote":"0",
			"content":"```\\nvar strongPasswordChecker = function(s, a = 6, b = 20, c = 3) {\\n    const clusters = buildClusters(s, c);\\n    for (let i = 0; i < s.length - b && clusters.minReplaceCount; i++) {\\n        deleteOne(clusters, c);\\n    }\\n    const mustAddCount = !/[a-z]/.test(s) + !/[A-Z]/.test(s) + !/\\\\d/.test(s);\\n    return Math.max(0, s.length - b) + Math.max(a - s.length, mustAddCount, clusters.minReplaceCount);\\n};\\n\\nfunction buildClusters(s, c) {\\n    const clusters = new Array(c).fill(0).map(cl => new Map());\\n    clusters.minReplaceCount = 0;\\n    let re = new RegExp(`(.)\\\\\\\\1{${c - 1},}`, 'g'), match;\\n    while (match = re.exec(s)) {\\n        let len = match[0].length;\\n        clusters[len % c].set(len, (clusters[len % c].get(len) || 0) + 1);\\n        clusters.minReplaceCount += Math.floor(len / c);\\n    }\\n    return clusters;\\n}\\n\\nfunction deleteOne(clusters, c) {\\n    const cluster = clusters.find(cl => cl.size);\\n    for (const [len, count] of cluster) {\\n        cluster.set(len, count - 1);\\n        if (count === 1) cluster.delete(len);\\n        clusters.minReplaceCount -= len % c === 0;\\n        if (len === c) break;\\n        const clusterUpdate = clusters[(len - 1) % c];\\n        clusterUpdate.set(len - 1, (clusterUpdate.get(len - 1) || 0) + 1);\\n        break;\\n    }\\n}\\n```\\nThe answer for `s.length <= b` is straightforward since we needn't make any deletions. It's covered by `Math.max(a - s.length, mustAddCount, clusters.minReplaceCount)` whose components I explain soon.\\n\\nFor `s.length > b` we need to make `s.length - b` deletions, followed by the requisite replacements to satisfy condition #2. However, we must make our deletions prioritizing repeating character clusters which have the smallest length modulo `c`. This is because clusters divisible by `c` will reduce the number of replacements necessary to uncluster them (satisfy condition #3). For example, deleting one character from either of `'aaa'` or `'aaaaaa'` for `c = 3` decrements the necessary replacements, from `1->0` and `2->1` respectively.\\n\\nWe store maps of each cluster type (its length modulo `c`) in the `clusters` array. `clusters.minReplaceCount` tracks the minimum number of replacements to satisfy condition #3 over all clusters. Finally, `mustAddCount` tracks the replacements necessary to satisfy condition #2.\\n\\nThe complexity is O(1) time and space when `s.length <= b` and O(n) time with O(count(clusters)) space when `s.length > b`. Even though `c` is a parameter, we can treat it as a constant with respect to time complexity since c * min(n - b, count(clusters)) is bounded by n (`s.length`)."
		}
	],
	"id":"420",
	"title":"Strong Password Checker",
	"content":"<p>A password is considered strong if below conditions are all met:</p>\r\n\r\n<ol>\r\n<li> It has at least 6 characters and at most 20 characters. </li>\r\n<li> It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. </li>\r\n<li> It must NOT contain three repeating characters in a row (\"...aaa...\" is weak, but \"...aa...a...\" is strong, assuming other conditions are met). </li>\r\n</ol>\r\n\r\n<p>Write a function strongPasswordChecker(s), that takes a string s as input, and return the <b>MINIMUM</b> change required to make s a strong password. If s is already strong, return 0.</p>\r\n\r\n<p>Insertion, deletion or replace of any one character are all considered as one change.</p>",
	"frequency":"493",
	"ac_num":"4112"
}