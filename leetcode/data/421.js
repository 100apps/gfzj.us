{
	"difficulty":"2",
	"submit_num":"41730",
	"show_id":"421",
	"leetcode_id":"421",
	"answers":[
		{
			"lc_ans_id":"91049",
			"view":"44682",
			"top":"0",
			"title":"Java O(n) solution using bit manipulation and HashMap",
			"vote":"161",
			"content":"```\\npublic class Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int max = 0, mask = 0;\\n        for(int i = 31; i >= 0; i--){\\n            mask = mask | (1 << i);\\n            Set<Integer> set = new HashSet<>();\\n            for(int num : nums){\\n                set.add(num & mask);\\n            }\\n            int tmp = max | (1 << i);\\n            for(int prefix : set){\\n                if(set.contains(tmp ^ prefix)) {\\n                    max = tmp;\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"91050",
			"view":"14560",
			"top":"1",
			"title":"Python 6 lines, bit by bit",
			"vote":"52",
			"content":"    def findMaximumXOR(self, nums):\\n        answer = 0\\n        for i in range(32)[::-1]:\\n            answer <<= 1\\n            prefixes = {num >> i for num in nums}\\n            answer += any(answer^1 ^ p in prefixes for p in prefixes)\\n        return answer\\n\\nBuild the answer bit by bit from left to right. Let's say we already know the largest first seven bits we can create. How to find the largest first eight bits we can create? Well it's that maximal seven-bits prefix followed by 0 or 1. Append 0 and then try to create the 1 one (i.e., `answer ^ 1`) from two eight-bits prefixes from `nums`. If we can, then change that 0 to 1."
		},
		{
			"lc_ans_id":"91059",
			"view":"15686",
			"top":"2",
			"title":"Java O(n) solution using Trie",
			"vote":"47",
			"content":"```\\n    class Trie {\\n        Trie[] children;\\n        public Trie() {\\n            children = new Trie[2];\\n        }\\n    }\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        // Init Trie.\\n        Trie root = new Trie();\\n        for(int num: nums) {\\n            Trie curNode = root;\\n            for(int i = 31; i >= 0; i --) {\\n                int curBit = (num >>> i) & 1;\\n                if(curNode.children[curBit] == null) {\\n                    curNode.children[curBit] = new Trie();\\n                }\\n                curNode = curNode.children[curBit];\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for(int num: nums) {\\n            Trie curNode = root;\\n            int curSum = 0;\\n            for(int i = 31; i >= 0; i --) {\\n                int curBit = (num >>> i) & 1;\\n                if(curNode.children[curBit ^ 1] != null) {\\n                    curSum += (1 << i);\\n                    curNode = curNode.children[curBit ^ 1];\\n                }else {\\n                    curNode = curNode.children[curBit];\\n                }\\n            }\\n            max = Math.max(curSum, max);\\n        }\\n        return max;\\n    }\\n```"
		},
		{
			"lc_ans_id":"91052",
			"view":"6853",
			"top":"3",
			"title":"C++ Trie 69ms beats 85%",
			"vote":"15",
			"content":"```\\nclass Solution {\\npublic:\\n    class TreeNode {\\n    public:\\n        TreeNode* next[2];\\n        TreeNode () {next[0] = NULL; next[1] = NULL;};\\n    };\\n    TreeNode* buildTree(vector<int>& nums) {\\n        TreeNode* root = new TreeNode(), *cur;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n            cur = root;\\n            for (int j = 31; j >= 0; j--) {\\n                int index = ((num >> j) & 1);\\n                if (cur->next[index] ==  NULL)\\n                    cur->next[index] = new TreeNode();\\n                cur = cur->next[index];\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    int helper(TreeNode* cur, int num) {\\n        int res = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int index = ((num >> i) & 1) ? 0 : 1;\\n            if (cur->next[index]) {\\n                res <<= 1;\\n                res |= 1;\\n                cur = cur->next[index];\\n            } else {\\n                res <<= 1;\\n                res |= 0;\\n                cur = cur->next[index ? 0 : 1];\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        TreeNode* root = buildTree(nums);\\n        \\n        for (auto i : nums) {\\n            res = max(res, helper(root, i));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"91103",
			"view":"7234",
			"top":"4",
			"title":"C++, O(n) solution, explanation added",
			"vote":"13",
			"content":"```\\nint findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n == 0 || n == 1)\\n            return 0;\\n        if (n == 2)\\n            return nums.at(0) ^ nums.at(1);\\n        \\n        list<int> set0;\\n        list<int> set1;\\n        int i;\\n        int j;\\n        int maxValue;\\n        \\n        for (i = 30; i >= 0; i--) {\\n            for (j = 0; j < n; j++) {\\n                if ((nums.at(j) & (1<<i)) == 0)\\n                    set0.push_back(nums.at(j));\\n                else\\n                    set1.push_back(nums.at(j));\\n            }\\n            \\n            if (set0.size() != 0 && set1.size() != 0) {\\n                maxValue = pow(2, i);\\n                break;\\n            }\\n            else {\\n                set0.clear();\\n                set1.clear();\\n            }\\n        }\\n        \\n        if (i == -1)\\n            return 0;\\n        \\n        maxValue += getMaxXor(set0, set1, i-1);\\n        \\n        return maxValue;\\n}\\n\\nint getMaxXor(list<int>& set0, list<int>& set1, int pos) {\\n        int maxValue;\\n        list<int> set0list0;\\n        list<int> set0list1;\\n        list<int> set1list0;\\n        list<int> set1list1;\\n        int i;\\n        list<int>::iterator it;\\n        \\n        if (set0.size() == 0 || set1.size() == 0 || pos < 0)\\n            return 0;\\n        \\n        for (it = set0.begin(); it != set0.end(); it++) {\\n            int value = *it;\\n            if ((value & (1<<pos)) == 0)\\n                set0list0.push_back(value);\\n            else\\n                set0list1.push_back(value);\\n        }\\n        \\n        for (it = set1.begin(); it != set1.end(); it++) {\\n            int value = *it;\\n            if ((value & (1<<pos)) == 0)\\n                set1list0.push_back(value);\\n            else\\n                set1list1.push_back(value);\\n        }\\n        \\n        if (set0list0.size() == 0 && set1list0.size() == 0)\\n            maxValue = getMaxXor(set0, set1, pos-1);\\n        else if (set0list1.size() == 0 && set1list1.size() == 0)\\n            maxValue = getMaxXor(set0, set1, pos-1);\\n        else {\\n            int maxValue1 = getMaxXor(set0list0, set1list1, pos-1);\\n            int maxValue2 = getMaxXor(set0list1, set1list0, pos-1);\\n            maxValue = pow(2, pos) + (maxValue1 > maxValue2 ? maxValue1 : maxValue2);\\n        }\\n        \\n        return maxValue;\\n }\\n```\\n\\nExample input: [42, 5, 69, 22, 23, 8, 1, 17, 30, 75, 99]\\n\\nThe max XOR value is (30 ^ 99) = 125. Below are the binary represntations of each number.\\n\\n42 = 0 1 0 1 0 1 0\\n\\n5  = 0 0 0 0 1 0 1\\n\\n69 = 1 0 0 0 1 0 1\\n\\n22 = 0 0 1 0 1 1 0\\n\\n23 = 0 0 1 0 1 1 1\\n\\n8  = 0 0 0 1 0 0 0\\n\\n1  = 0 0 0 0 0 0 1\\n\\n17 = 0 0 1 0 0 0 1\\n\\n30 = 0 0 1 1 1 1 0\\n\\n75 = 1 0 0 1 0 1 1\\n\\n99 = 1 1 0 0 0 1 1\\n\\nEach number in the array is >= 0 and < pow(2,31). So, any number in the array can be represented by atmost 31 bits (bits[30:0]).\\nThe for loop in findMaximumXOR (lines 17-33) finds the max bit position where some of the numbers have '0' in that bit position and the other numbers have '1' in that bit position.\\nThe numbers that have '0' in that bit position go to set0 and the numbers that have '1' in that bit position go to set1. So, for the example above, we have:\\nset0 = {42, 5, 22, 23, 8, 1, 17,30}\\nset1 = {69, 75, 99}\\nBit position = 6.\\nThe value obtained by XORing bit 6 between set0 and set1 (forgetting the low order bits) is pow(2, 6) = 64.\\n\\nNext, findMaximumXOR() calls getMaxXor() passing set0 and set1 to recursively find the max value of the XOR between numbers in set0 and set1 for the remaning low order bits. The max XOR value would then be 64 + (the max value returned by getMaxXor()).\\n\\nThe first call would be getMaxXor({42, 5, 22, 23, 8, 1, 17,30}, {69, 75, 99}, 5).\\nWhat getMaximumXOR() does is for bit position 5, it splits set0 into two sets - the numbers that have '0' in bit position 5 go to set0list0. The numbers that have '1' in bit position 5 goto set0list1. The same is done for set1 i.e. set1 is also split into two sets set1list0 and set1list1. For this specific example, we have:\\n\\nset0list0 = {5, 22, 23, 8, 1, 17, 30}\\nset0list1 = {42}\\nset1list0 = {69, 75}\\nset1list1 = {99}\\n\\nSince at bit position 5 we found set0list0 and set1list1, that means XORing bit 5 (forgetting the low order bits) of numbers between set0list0 and set1list1 woul give pow(2, 5) = 32.\\nSo, the maximum XOR value between numbers in set0list0 and set1list1 would be 32 + (set0list0, set1list1, 4).\\nArguing on the same lines, the maximum XOR value between numbers in set0list1 and set1list0 would be 32 + (set0list1, set1list0, 4).\\nNote that we pair the \"opposite\" resulting sets to get to the max XOR value i.e. (set0list0, set1list1) and (set0list1, set1list0).\\n\\nFor this specific example the recursive calls would be:\\n\\ngetMaxXor({5, 22, 23, 8, 1, 17, 30}, {99}, 4);\\nset0list0 = {5, 8, 1}\\nset0list1 = {22, 23, 17, 30}\\nset1list0 = {99}\\nset1list1 = {}\\n\\ngetMaxXor({5, 8, 1}, {}, 3); ==> This call returns 0 as set1 is empty.\\n\\ngetMaxXor({22, 23, 17, 30}, {99}, 3);\\nset0list0 = {22, 23, 17}\\nset0list1 = {30}\\nset1list0 = {99}\\nset1list1 = {}\\n\\ngetMaxXor({22, 23, 17}, {}, 2); ==> This call returns 0 as set1 is empty.\\n\\ngetMaxXor({30}, {99}, 2);\\nset0list0 = {}\\nset0list1 = {30}\\nset1list0 = {99}\\nset1list1 = {}\\n\\ngetMaxXor{{30}, {99}, 1};\\nset0list0 = {}\\nset0list1 = {30}\\nset1list0 = {}\\nset1list1 = {99}\\n\\nSince both set0list0 and set1list0 are empty, we simply ignore this bit position and check the next lower bit position. So:\\n\\ngetMaxXor({30}, {99}, 0);\\n\\nset0list0 = {30}\\nset0list1 = {}\\nset1list0 = {}\\nset1list1 = {99}\\n\\ngetMaxXor({30}, {99}, -1) ==>This call would return 0, as bit position is invalid.\\n\\ngetMaxXor({42}, {69, 75}, 4);\\nset0list0 = {42}\\nset0list1 = {}\\nset1list0 = {69, 75}\\nset1list1 = {}\\n\\ngetMaxXor({42}, {69, 75}, 3);\\n\\nset0list0 = {}\\nset0list1 = {42}\\nset1list0 = {69}\\nset1list1 = {75}\\n\\ngetMaxXor({}, {75}, 2); ==> This call returns 0 as set0 is empty\\n\\ngetMaxXor({42}, {75}, 2)\\nset0list0 = {42}\\nset0list1 = {}\\nset1list0 = {75}\\nset1list1 = {}\\n\\ngetMaxXor({42}, {75}, 1)\\nset0list0 = {}\\nset0list1 = {42}\\nset1list0 = {}\\nset1list1 = {75}\\n\\ngetMaxXor({42}, {75}, 0)\\nset0list0 = {42}\\nset0list1 = {}\\nset1list0 = {}\\nset1list1 = {75}\\n\\ngetMaxXor({42}, {75}, -1)\\n\\nIn the recursive calls above, the max value is returned by the path:\\ngetMaxXor({42, 5, 22, 23, 8, 1, 17,30}, {69, 75, 99}, 5) //maxValue = 32\\ngetMaxXor({5, 22, 23, 8, 1, 17, 30}, {99}, 4) //maxValue = 16\\ngetMaxXor({22, 23, 17, 30}, {99}, 3) //maxValue = 8\\ngetMaxXor({30}, {99}, 2) //maxValue = 4\\ngetMaxXor{{30}, {99}, 1} //maxValue = 0\\ngetMaxXor({30}, {99}, 0) //maxValue = 1\\ngetMaxXor({30}, {99}, -1) //maxValue = 0\\n\\nSo, the final max XOR value returned = 64 + 32 + 16 + 8 + 4 + 1 = 125.\\n\\nThe run time is O(n) because we iterate 31 times, once for each bit position (i.e. bits 30 to 0). During each bit position, we check/visit each number at most once. So, the time complexity would be 31xn or O(n)."
		},
		{
			"lc_ans_id":"91065",
			"view":"1441",
			"top":"5",
			"title":"A solution based on @bartoszkp's, with missing test cases",
			"vote":"6",
			"content":"Let's say we find the MSB that can be set to 1 in the result. Then we can partition the whole thing into two subsets. One element must be taken from one subset, the other from the other one. Then we move on to next bit that could possibly be set to one, but this time we're restricted to picking elements from different subsets generated at the first step. We do that by partitioning each subset in two subsets again based on the value of the next candidate bit, and we try to combine elements in such a way so that bit is set to one. There are two subsets now in each of the original subsets, so we try to combine elements in two ways based on that next bit: 1-0 and 0-1. The whole thing goes on recursively until we run out of bits, and then we just return the maximum, and everyone is happy. Or at least that's the idea.\\n\\nThis idea occurred to me when I was solving this problem at first, but I thought it would be too slow because I may get bad splits, so I switched to prefixes/sets instead. But then I saw [this solution](https://discuss.leetcode.com/topic/63759/c-o-nlogk-solution-with-ordering-bits-with-o-logk-additional-memory-for-recursion-stack) based on the same idea, which looked pretty impressive. During the discussion with the author we came to the conclusion that bad splits won't degrade runtime to O(n^2) because recursion depth is limited by the number of bits anyway.\\n\\nUnlike that solution, my original idea was to use a mask that indicates which bits could be possibly set. Say, if a certain bit is 1 in all numbers, or is 0 in all numbers, there is no way to get 1 in that position. That means we should only consider bits that are set in some numbers, but not in all of them. \\u201cSet in some\\u201d = OR, \\u201cset in all\\u201d = AND, \\u201dset in not all\\u201d = NOT AND, and therefore the mask for such bits is `or & ~and`.\\n\\nWhile I was at it, I realized that the original solution by @bartoszkp had a bug that wasn't detected by the OJ. It started with the MSB of the maximum element, but if that bit is set in all numbers, then the very first split will be wrong. The use of my mask incidentally fixed that too. A simple test case to demonstrate the problem: `[4, 6, 7]`.\\n\\nAnother interesting test case: `[8, 10, 2]`. The code below fails it if the two lines testing for `(mask & msb) == 0` in the helper function are commented out. That's because it tries to partition the array on the mask `4`, but that bit is cleared in all numbers. And yet, it passes the OJ too.\\n\\nNow here is one version of the code, that is *wrong* too. I'm posting it because it clearly demonstrates a flaw with this approach in general.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        auto orOp = [](int a, int b) { return a | b; };\\n        auto andOp = [](int a, int b) { return a & b; };\\n        mask = accumulate(nums.cbegin(), nums.cend(), 0, orOp)\\n            & ~accumulate(nums.cbegin(), nums.cend(), 0x7FFFFFFF, andOp);\\n        auto msb = computeMsb(mask);\\n        auto msbSplit = msbPartition(nums.begin(), nums.end(), msb);\\n        return findMaximumXor(nums.begin(), msbSplit, msbSplit, nums.end(), msb >> 1);\\n    }\\n    \\n    int computeMsb(int n) {\\n        auto msb = n;\\n        msb |= msb >> 1;\\n        msb |= msb >> 2;\\n        msb |= msb >> 4;\\n        msb |= msb >> 8;\\n        msb |= msb >> 16;\\n        return msb - (msb >> 1);\\n    }\\n    \\n    vector<int>::iterator msbPartition(const vector<int>::iterator &beginIt,\\n                                       const vector<int>::iterator &endIt,\\n                                       int msb) {\\n        auto msbSet = [msb](int n) { return (n & msb) != 0; };\\n        return partition(beginIt, endIt, msbSet);\\n    }\\n    \\n    int findMaximumXor(const vector<int>::iterator& beginLeft,\\n                       const vector<int>::iterator& endLeft,\\n                       const vector<int>::iterator& beginRight,\\n                       const vector<int>::iterator& endRight,\\n                       int msb) {\\n        if (distance(beginLeft, endLeft) == 1 && distance(beginRight, endRight) == 1)\\n            return *beginLeft ^ *beginRight;\\n        if (msb == 0 || beginLeft == endLeft || beginRight == endRight)\\n            return 0;\\n        if ((mask & msb) == 0)\\n            return findMaximumXor(beginLeft, endLeft, beginRight, endRight, msb >> 1);\\n        auto splitLeft = msbPartition(beginLeft, endLeft, msb);\\n        auto splitRight = msbPartition(beginRight, endRight, msb);\\n        auto result1 = findMaximumXor(beginLeft, splitLeft, splitRight, endRight, msb >> 1);\\n        auto result2 = findMaximumXor(splitLeft, endLeft, beginRight, splitRight, msb >> 1);\\n        return max(result1, result2);\\n    }\\n\\nprivate:\\n    int mask;\\n};\\n```\\nThe test case where it fails is `[14, 15, 9, 3, 2]` (not in the OJ either). It goes like this: first we split it like `14, 15, 9 / 3, 2`, then we split the left part as `14, 15 / 9`. And then, when we try to match `14, 15` with `3, 2` we get a problem. Even though the next candidate power of 2 is 1, we can't set it because `2` is set in all numbers now. And yet it wasn't set in all numbers to begin with, so our mask fails to skip it.\\n\\nThis flaw originally comes from the idea that we match subsets having different values of a certain bit. However, there is no guarantee that subsets even exist for that bit. Our mask only provides guarantee for the MSB, and later on it's just a hint. That means we need to check for that *again* after we partition. The fixed code is below, and I hope I got it right this time:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        auto orOp = [](int a, int b) { return a | b; };\\n        auto andOp = [](int a, int b) { return a & b; };\\n        mask = accumulate(nums.cbegin(), nums.cend(), 0, orOp)\\n            & ~accumulate(nums.cbegin(), nums.cend(), 0x7FFFFFFF, andOp);\\n        if (mask == 0)\\n            return 0;\\n        auto msb = computeMsb(mask);\\n        auto msbSplit = msbPartition(nums.begin(), nums.end(), msb);\\n        return findMaximumXor(nums.begin(), msbSplit, msbSplit, nums.end(), msb >> 1);\\n    }\\n    \\n    int computeMsb(int n) {\\n        auto msb = n;\\n        msb |= msb >> 1;\\n        msb |= msb >> 2;\\n        msb |= msb >> 4;\\n        msb |= msb >> 8;\\n        msb |= msb >> 16;\\n        return msb - (msb >> 1);\\n    }\\n    \\n    vector<int>::iterator msbPartition(const vector<int>::iterator &beginIt,\\n                                       const vector<int>::iterator &endIt,\\n                                       int msb) {\\n        auto msbSet = [msb](int n) { return (n & msb) != 0; };\\n        return partition(beginIt, endIt, msbSet);\\n    }\\n    \\n    int findMaximumXor(const vector<int>::iterator& beginLeft,\\n                       const vector<int>::iterator& endLeft,\\n                       const vector<int>::iterator& beginRight,\\n                       const vector<int>::iterator& endRight,\\n                       int msb) {\\n        if (msb == 0 || (distance(beginLeft, endLeft) == 1 && distance(beginRight, endRight) == 1))\\n            return *beginLeft ^ *beginRight;\\n        if ((mask & msb) == 0)\\n            return findMaximumXor(beginLeft, endLeft, beginRight, endRight, msb >> 1);\\n        auto splitLeft = msbPartition(beginLeft, endLeft, msb);\\n        auto splitRight = msbPartition(beginRight, endRight, msb);\\n        auto result = 0;\\n        if (distance(beginLeft, splitLeft) > 0 && distance(splitRight, endRight) > 0)\\n            result = findMaximumXor(beginLeft, splitLeft, splitRight, endRight, msb >> 1);\\n        if (distance(splitLeft, endLeft) > 0 && distance(beginRight, splitRight) > 0)\\n            result = max(result, findMaximumXor(splitLeft, endLeft, beginRight, splitRight, msb >> 1));\\n        if (result == 0) // no way to set this bit to 1\\n            result = findMaximumXor(beginLeft, endLeft, beginRight, endRight, msb >> 1);\\n        return result;\\n    }\\n\\nprivate:\\n    int mask;\\n};\\n```\\nIt runs for 26 ms, beating 99%.\\n\\nThe `result == 0` line executes when both `if`s above fail to run. That happens if we have bad splits on *both* sides, just like in the last mentioned test case.\\n\\nAnother last funny test case is `[15, 15, 9, 3, 2]`. The problem description doesn't say numbers can't be duplicated. Well, the code above passes it thanks to the `msb == 0` check in the beginning of the recursive function. It looks kind of funny because we just return a XOR of two randomly picked elements from both sides in that case without even checking how many elements are there. However, when we get to `msb == 0`, we have already split both sides based on every possible bit, so it's either that both subsets have size 1, or it's that they are all duplicates, and therefore picking first elements is just as fine.\\n\\nThe last, but not least, is the test case where all numbers are duplicate. That is checked by `mask == 0` in the top-level function. Funny thing, that test could be removed, but only because partitioning happens to use `(n & msb) != 0`. If I change it to `(n & msb) == 0` (which is OK in general), then we'll have a problem: the first MSB partitioning will generate an N/0 partition, which means `beginRight` will be `end()`, and we'll get UB by trying to dereference it. With `(n & msb) != 0` it generates an 0/N partitioning, so both `beginLeft` and `beginRight` point to the same element, and therefore eventually we return zero.\\n\\nRecap of the test cases to be added: `[4, 6, 7]`, `[8, 10, 2]`, `[14, 15, 9, 3, 2]`, `[15, 15, 9, 3, 2]`."
		},
		{
			"lc_ans_id":"91058",
			"view":"2280",
			"top":"6",
			"title":"31ms O(n) Java solution using Trie",
			"vote":"4",
			"content":"We add the number into the trie and find the max possible XOR result at the same time.\\nNode.set() method will set the new node in the trie if needed and return the new node.\\nAfter setting the node, find the opposite bit in the trie to maximize the possible XOR result.\\n\\n```\\npublic class Solution {\\n    public class Node {\\n        Node one;\\n        Node zero;\\n        Node() {\\n            this.one = null;\\n            this.zero = null;\\n        }\\n        Node set(int n) {\\n            if (n == 0) {\\n                if (this.one == null) this.one = new Node();\\n                return this.one;\\n            }\\n            if (this.zero == null) this.zero = new Node();\\n            return this.zero;\\n        }\\n    }\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        Node root = new Node();\\n        int re = 0;\\n        for (int num : nums) {\\n            int digit = num;\\n            int tmp = 0;\\n            Node setNode = root;\\n            Node findNode = root;\\n            int pos = 30;\\n            while (pos >= 0) {\\n                digit = (num >> pos) & 1;\\n                setNode = setNode.set(digit);\\n                if (digit == 1) {\\n                    if (findNode.one != null) {\\n                        tmp = tmp | (1 << pos);\\n                        findNode = findNode.one;\\n                    } else {\\n                        findNode = findNode.zero;\\n                    }\\n                } else {\\n                    if (findNode.zero != null) {\\n                        tmp = tmp | (1 << pos);\\n                        findNode = findNode.zero;\\n                    } else {\\n                        findNode = findNode.one;\\n                    }\\n                }\\n                pos--;\\n            }\\n            re = Math.max(re, tmp);\\n        }\\n        return re;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"91122",
			"view":"1078",
			"top":"7",
			"title":"Java simple greedy + bit manipulation solution, O(n) time, with explanation (without HashMap)",
			"vote":"3",
			"content":"Hi there! I am posting my recursive solution based on bit manipulation. The idea is strightforward. Let us think about the resultant number. Well, it is clear that, in order to, maximize the resultant number, we have to maximize the number of set bits with higher order. In other words, starting from the left most possible bit position we check if there is a pair of numbers, such that their bits in the current position will   XOR'ed up to 1. Obviously there are only two options to satisfy that condition 1,0 or 0,1 for each bit position. Thus, we always divide the numbers into two parts, those that has set bits in current position and those that has zero bits in current position. Consequently if we can divide the numbers in such a way, it means we can obtain set bit by some combination in the current position. Otherwise, we decrease factor of two ( bit position) while we can't divide the numbers and we didn't reach the last bit position. For example \\n```\\n                       {1,2,3} <- bit position 1\\n                        /    \\\\\\n                    {1}      {2, 3} <- bit position 0\\n                    / \\\\        /  \\\\\\n                  X   {1}   {2}   {3}    \\n```\\nIn the example above, given array {1,2,3} we can start from bit position 1, because it is the highest bit order in current array. Then we divide it according to the values of current bit. Correspondingly {1} has 0 bit in position 1, whereas 2 and 3 have set bits. It means our resultant number has set bit in position 1. Next we divide the halves into halves similarly for bit position 0. Here you can see that array {1} does not have numbers which bits in position 0 are not set, but has a number which has set bit in that position({1}). In turn the right part is divided to {2} and {3} correspondingly, because 2 has 0 bit in 0th position and 3 has set bit in 0th position. That fact means that, we can also XOR 1 with 2 and get set bit in position 1, therefore the answer is 3 = 2^1+2^0;\\n Actually the running time of the algorithm isO(n*h) where h is the height of the tree, but according to the problem statement h is constant(32, only integers). Because of that fact the algorithm may be considered as linear.\\n```\\npublic class Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int max = 0;\\n        if(nums == null || nums.length == 0) return 0;\\n        List<Integer> left = new ArrayList<>(), right = new ArrayList<>();\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            max= Math.max(max, nums[i]);\\n        }\\n        int p = 31;\\n        while(p>0 && (max & (1<<p)) == 0) p--;\\n        int fact = 0;\\n        while(p>=0 && (left.isEmpty() || right.isEmpty())){\\n            fact = 1<<p;\\n            for(int i = 0;i<nums.length;i++){\\n                if((nums[i] & fact) == 0){\\n                    left.add(nums[i]);\\n                } else {\\n                    right.add(nums[i]);\\n                }\\n            }\\n            p--;\\n        }\\n        if(left.isEmpty() || right.isEmpty()) fact = 0;\\n        // System.out.println(fact);\\n        return fact+maxXOR(p, left, right);\\n    }\\n    \\n    public int maxXOR(int p, List<Integer> left, List<Integer> right){\\n        if(p<0) return 0;\\n        // int fact;\\n        List<Integer> leftZero  = new ArrayList<>(), rightZero  = new ArrayList<>();\\n        List<Integer> leftOne = new ArrayList<>(), rightOne = new ArrayList<>();\\n        int fact = 1<<p;\\n        \\n        while(p>=0 && ((leftZero.isEmpty() || rightOne.isEmpty()) && (leftOne.isEmpty() || rightZero.isEmpty()))){\\n            fact = 1<<p;\\n            leftZero.clear();\\n            leftOne.clear();\\n            rightZero.clear();\\n            rightOne.clear();\\n            fill(fact, left, leftZero, leftOne);\\n            fill(fact, right, rightZero, rightOne);\\n            p--;\\n        }\\n        if(((leftZero.isEmpty() || rightOne.isEmpty()) && (leftOne.isEmpty() || rightZero.isEmpty()))) {\\n            return 0;\\n        }\\n        // System.out.println(\"+\"+fact);\\n        return fact+Math.max(maxXOR(p, leftZero, rightOne), maxXOR(p, rightZero, leftOne)); \\n    }\\n    \\n    public void fill(int fact, List<Integer> list, List<Integer> zero, List<Integer> one){\\n        for(Integer num:list){\\n            if((fact & num) == 0) {\\n                zero.add(num);\\n            } else {\\n                one.add(num);\\n            }\\n        }\\n    }\\n}"
		},
		{
			"lc_ans_id":"91064",
			"view":"309",
			"top":"8",
			"title":"C++, 22 ms, beats 99.5%, array partitioning similar to quick sort",
			"vote":"2",
			"content":"I have put detailed comments in the code. Here I just highlight the logic of the method.\\n\\n1) working from most significant bit on the left towards right. Obviously, if the more significant bit is 1, the xor value is greater than those with this bit = 0.\\n2) Similar to quick sort, we partition a certain range of the array nums in place. The left subrange has current bit = 1, and the right subrange has current bit = 0. Let's name them as A and B.\\n3) In order to find the greatest XOR value, we have to take 1 number from A, and 1 number from B. And to set next bit to 1, there must be a subrange in A and a subrange in B having opposite bit; otherwise, next bit will be 0. So we partition range A and B recursively.\\n4) When partitioning range A and B, there are 3 cases. (1) A has both bit 1 and 0 ranges. We check whether B has bit 0 or bit 1 range or both. (2) A has only bit 1. We check whether B has bit 0. (3) A has only bit 0. We check whether B has bit 1.\\n\\nFor every recursive call, the runtime is O(n). There are totally 31 levels of calls, so the runtime is O(n). And extra space is O(1) because the code works in place. The code with comments is as below.\\n```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        return helper(nums, 0, n-1, 0, n-1, 0, 30);\\n    }\\nprivate:\\n    // (ls, le) and (rs, re) are two ranges of nums, which gives max xor value to current bit;\\n    // bit decreases from 30 to 0, i.e., working from most significant bit on the left towards right;\\n    // Similar to quicksort, partition (ls, le) to two ranges (ls, j-1) and (j, le) by swapping elements\\n    // the range on the left with current bit = 1, and the range on right is 0; We do the same to (rs, re)\\n    // In order to set the current bit in the answer, i.e. val, to be 1, the left (ls, le) and right (rs,re) ranges must have subranges with opposite bit. If so, val = (val << 1) + 1; otherwise, val = val << 1.\\n    int helper(vector<int>& nums, int ls, int le, int rs, int re, int val, int bit) {\\n        if (bit == -1) return val;\\n        int mask = 1<<bit, j = ls, k = rs;\\n        for (int i = ls; i <= le; i++) \\n            if (nums[i]&mask) swap(nums[i], nums[j++]);\\n        for (int i = rs; i <= re; i++) \\n            if (nums[i]&mask) swap(nums[i], nums[k++]);\\n        // the left range has two subranges, the answer is max of (bit 1 subrange on the left and bit 0 subrange on the right) or (bit 0 subrange on the left and bit 1 subrange on the right)\\n        if (j > ls && j <= le) {\\n            int ans = 0;\\n            if (k > rs) \\n                ans = helper(nums, j, le, rs, k-1, val*2+1, bit-1);\\n            if (k <= re) \\n                ans = max(ans, helper(nums, ls, j-1, k, re, val*2+1, bit-1));\\n            return ans;\\n        }\\n        // the left range has only bit 0 subrange\\n        else if (j <= ls) {\\n            // check whether the right range has bit 1 subrange\\n            if (k > rs) \\n                return helper(nums, ls, le, rs, k-1, val*2+1, bit-1);\\n            else \\n                return helper(nums, ls, le, rs, re, val*2, bit-1);\\n        }\\n        // the left range has only bit 1 subrange\\n        else {\\n            // check whether the right range has bit 0 subrange\\n            if (k <= re) \\n                return helper(nums, ls, le, k, re, val*2+1, bit-1);\\n            else \\n                return helper(nums, ls, le, rs, re, val*2, bit-1);\\n        }\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"91093",
			"view":"938",
			"top":"9",
			"title":"Java O(n) recursion solution 36ms",
			"vote":"2",
			"content":"This solution only supports an input array with unique elements. You can easily achieve that by filtering the input array with hashset.\\n```\\npublic class Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for(int i=0; i<nums.length; i++) {\\n            left.add(nums[i]);\\n            right.add(nums[i]);\\n        }\\n        return helper(left, right, 1<<30);\\n        \\n    }\\n    public int helper(List<Integer> left, List<Integer> right, int bit) {\\n        if(left.size()==0||right.size()==0) return 0;\\n        if(left.size()==1||right.size()==1) {\\n            int max = 0;\\n            for(Integer l: left) {\\n                for(Integer r: right) {\\n                    max = Math.max(max, l^r);\\n                }\\n            }\\n            return max;\\n        }\\n        List<Integer> oneLeft = new ArrayList<>();\\n        List<Integer> zeroLeft = new ArrayList<>();\\n        List<Integer> oneRight = new ArrayList<>();\\n        List<Integer> zeroRight = new ArrayList<>();\\n        while((oneLeft.size()==0||zeroRight.size()==0)&&(oneRight.size()==0||zeroLeft.size()==0)&&bit!=0) {\\n            oneLeft = new ArrayList<>();\\n            zeroLeft = new ArrayList<>();\\n            oneRight = new ArrayList<>();\\n            zeroRight = new ArrayList<>();\\n            for(Integer i:left) {\\n                if((i&bit)==0) zeroLeft.add(i);\\n                else oneLeft.add(i);\\n            }\\n            for(Integer i:right) {\\n                if((i&bit)==0) zeroRight.add(i);\\n                else oneRight.add(i);\\n            }\\n            bit >>= 1;\\n        }\\n        return Math.max(helper(oneLeft, zeroRight, bit), helper(zeroLeft, oneRight, bit));\\n    }\\n}\\n```"
		}
	],
	"id":"421",
	"title":"Maximum XOR of Two Numbers in an Array",
	"content":"<p>Given a <b>non-empty</b> array of numbers, a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>, â€¦ , a<sub>n-1</sub>, where 0 &le; a<sub>i</sub> < 2<sup>31</sup>.</p>\n\n<p>Find the maximum result of a<sub>i</sub> XOR a<sub>j</sub>, where 0 &le; <i>i</i>, <i>j</i> &lt; <i>n</i>.</p>\n\n<p>Could you do this in O(<i>n</i>) runtime?</p>\n\n<p><b>Example:</b>\n<pre>\n<b>Input:</b> [3, 10, 5, 25, 2, 8]\n\n<b>Output:</b> 28\n\n<b>Explanation:</b> The maximum result is <b>5</b> ^ <b>25</b> = 28.\n</pre>\n</p>",
	"frequency":"437",
	"ac_num":"19848"
}