{
	"difficulty":"3",
	"submit_num":"29288",
	"show_id":"425",
	"leetcode_id":"425",
	"answers":[
		{
			"lc_ans_id":"91333",
			"view":"17942",
			"top":"0",
			"title":"Explained. My Java solution using Trie [126ms 16/16]",
			"vote":"86",
			"content":"My first approach is brute-force, try every possible word sequences, and use the solution of Problem 422 (https://leetcode.com/problems/valid-word-square/) to check each sequence. This solution is straightforward, but too slow (TLE).\\n\\nA better approach is to check the validity of the word square while we build it.\\nExample: ```[\"area\",\"lead\",\"wall\",\"lady\",\"ball\"]```\\nWe know that the sequence contains 4 words because the length of each word is 4.\\nEvery word can be the first word of the sequence, let's take ```\"wall\"``` for example.\\nWhich word could be the second word? Must be a word start with ```\"a\"``` (therefore ```\"area\"```), because it has to match the second letter of word ```\"wall\"```.\\nWhich word could be the third word? Must be a word start with ```\"le\"``` (therefore ```\"lead\"```), because it has to match the third letter of word  ```\"wall\"``` and the third letter of word ```\"area\"```.\\nWhat about the last word? Must be a word start with ```\"lad\"``` (therefore ```\"lady\"```). For the same reason above.\\n\\nThe picture below shows how the prefix are matched while building the sequence.\\n\\n![0_1476809138708_wordsquare.png](/uploads/files/1476809120456-wordsquare.png) \\n\\nIn order for this to work, we need to fast retrieve all the words with a given **prefix**. There could be 2 ways doing this:\\n1. Using a hashtable, key is **prefix**, value is a list of words with that prefix.\\n2. Trie, we store a list of words with the **prefix** on each trie node.\\n\\nThe implemented below uses Trie.\\n\\n```\\npublic class Solution {\\n    class TrieNode {\\n        List<String> startWith;\\n        TrieNode[] children;\\n\\n        TrieNode() {\\n            startWith = new ArrayList<>();\\n            children = new TrieNode[26];\\n        }\\n    }\\n\\n    class Trie {\\n        TrieNode root;\\n\\n        Trie(String[] words) {\\n            root = new TrieNode();\\n            for (String w : words) {\\n                TrieNode cur = root;\\n                for (char ch : w.toCharArray()) {\\n                    int idx = ch - 'a';\\n                    if (cur.children[idx] == null)\\n                        cur.children[idx] = new TrieNode();\\n                    cur.children[idx].startWith.add(w);\\n                    cur = cur.children[idx];\\n                }\\n            }\\n        }\\n\\n        List<String> findByPrefix(String prefix) {\\n            List<String> ans = new ArrayList<>();\\n            TrieNode cur = root;\\n            for (char ch : prefix.toCharArray()) {\\n                int idx = ch - 'a';\\n                if (cur.children[idx] == null)\\n                    return ans;\\n\\n                cur = cur.children[idx];\\n            }\\n            ans.addAll(cur.startWith);\\n            return ans;\\n        }\\n    }\\n\\n    public List<List<String>> wordSquares(String[] words) {\\n        List<List<String>> ans = new ArrayList<>();\\n        if (words == null || words.length == 0)\\n            return ans;\\n        int len = words[0].length();\\n        Trie trie = new Trie(words);\\n        List<String> ansBuilder = new ArrayList<>();\\n        for (String w : words) {\\n            ansBuilder.add(w);\\n            search(len, trie, ans, ansBuilder);\\n            ansBuilder.remove(ansBuilder.size() - 1);\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void search(int len, Trie tr, List<List<String>> ans,\\n            List<String> ansBuilder) {\\n        if (ansBuilder.size() == len) {\\n            ans.add(new ArrayList<>(ansBuilder));\\n            return;\\n        }\\n\\n        int idx = ansBuilder.size();\\n        StringBuilder prefixBuilder = new StringBuilder();\\n        for (String s : ansBuilder)\\n            prefixBuilder.append(s.charAt(idx));\\n        List<String> startWith = tr.findByPrefix(prefixBuilder.toString());\\n        for (String sw : startWith) {\\n            ansBuilder.add(sw);\\n            search(len, tr, ans, ansBuilder);\\n            ansBuilder.remove(ansBuilder.size() - 1);\\n        }\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"91344",
			"view":"5677",
			"top":"1",
			"title":"Short Python/C++ solution",
			"vote":"53",
			"content":"## Python Solution <sup>(accepted in ~870 ms)</sup>\\n\\n    def wordSquares(self, words):\\n        n = len(words[0])\\n        fulls = collections.defaultdict(list)\\n        for word in words:\\n            for i in range(n):\\n                fulls[word[:i]].append(word)\\n        def build(square):\\n            if len(square) == n:\\n                squares.append(square)\\n                return\\n            for word in fulls[''.join(zip(*square)[len(square)])]:\\n                build(square + [word])\\n        squares = []\\n        for word in words:\\n            build([word])\\n        return squares\\n\\n## Explanation\\n\\nI try every word for the first row. For each of them, try every fitting word for the second row. And so on. The first few rows determine the first few columns and thus determine how the next row's word must start. For example:\\n```\\nwall      Try words      wall                     wall                      wall\\na...   => starting  =>   area      Try words      area                      area\\nl...      with \"a\"       le..   => starting  =>   lead      Try words       lead\\nl...                     la..      with \"le\"      lad.   => starting   =>   lady\\n                                                            with \"lad\"\\n```\\nFor quick lookup, my `fulls` dictionary maps prefixes to lists of words who have that prefix.\\n\\n<br>\\n\\n## C++ Solution <sup>(accepted in ~180 ms)</sup>\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> wordSquares(vector<string>& words) {\\n        n = words[0].size();\\n        square.resize(n);\\n        for (string word : words)\\n            for (int i=0; i<n; i++)\\n                fulls[word.substr(0, i)].push_back(word);\\n        build(0);\\n        return squares;\\n    \\n    }\\n    int n;\\n    unordered_map<string, vector<string>> fulls;\\n    vector<string> square;\\n    vector<vector<string>> squares;\\n    void build(int i) {\\n        if (i == n) {\\n            squares.push_back(square);\\n            return;\\n        }\\n        string prefix;\\n        for (int k=0; k<i; k++)\\n            prefix += square[k][i];\\n        for (string word : fulls[prefix]) {\\n            square[i] = word;\\n            build(i + 1);\\n        }\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"91354",
			"view":"5071",
			"top":"2",
			"title":"Java DFS+Trie 54 ms, 98% so far",
			"vote":"22",
			"content":"By considering the word squares as a symmetric matrix, my idea is to go through the top right triangular matrix in left-to-right and then down order.\\nFor example, with the case of [\"area\",\"lead\",\"wall\",\"lady\",\"ball\"] where length = 4,\\nwe start with 4 empty string\\n\"\"\\n\"\"\\n\"\"\\n\"\"\\nNext, [0,0] , \"a\",\"b\", \"l\", \"w\" can be placed, we start with \"a\"\\n\"a\"\\n\"\"\\n\"\"\\n\"\"\\n[0,1] go right, \"r\" can be placed after \"a\", but no words start with \"r\" at [1,0], so this DFS ends. \\n\"ar\" \\n\"\"\\n\"\"\\n\"\"\\nNow, start with \"b\" at [0,0]\\n\"b\"\\n\"\"\\n\"\"\\n\"\"\\nWe can have \"ba\" at [0,1] and there is a word start with \"a\"\\n\"ba\"\\n\"a\"\\n\"\"\\n\"\"\\nNext\\n\"bal\"\\n\"a\"\\n\"l\"\\n\"\"\\nNext\\n\"ball\"\\n\"a\"\\n\"l\"\\n\"l\"\\nWhen finish the first row, go down to next row and start at [1,1]\\n\"ball\"\\n\"ar\"\\n\"l\"\\n\"l\"\\n..... so on and so forth until reaching [4,4] \\n\\n\\n```\\npublic class Solution {\\n    class Node{\\n        Node[] nodes;\\n        String word;\\n        Node(){\\n            this.nodes = new Node[26];\\n            this.word = null;\\n        }\\n    }\\n    void add(Node root, String word){\\n        Node node = root;\\n        for (char c : word.toCharArray() ) {\\n            int idx = c-'a';\\n            if (node.nodes[idx] == null) node.nodes[idx] = new Node();\\n            node = node.nodes[idx];\\n        }\\n        node.word = word;\\n    }\\n    void helper(int row, int col, int len, Node[] rows, List<List<String>> ret) {\\n        if ( (col == row) && (row == len) ) { // last char\\n            List<String> res = new ArrayList<String>();\\n            for (int i=0; i<len; i++) {\\n                res.add(new String(rows[i].word) );\\n            }\\n            ret.add( res );\\n        } else { // from left to right and then go down to the next row\\n            if ( col < len  ) { // left to right first\\n                Node pre_row = rows[row];\\n                Node pre_col = rows[col];\\n                for (int i=0; i<26; i++) { // find all the possible next char\\n                    if ( (rows[row].nodes[i] != null) && (rows[col].nodes[i] != null) ) {\\n                        rows[row] = rows[row].nodes[i];\\n                        if (col != row) rows[col] = rows[col].nodes[i];\\n                        helper(row, col+1, len, rows, ret);\\n                        rows[row] = pre_row;\\n                        if (col != row) rows[col] = pre_col;\\n                    }\\n                }\\n            } else { // reach the end of column, go to the next row\\n                helper(row+1, row+1, len, rows, ret);\\n            }\\n        }\\n    }\\n    public List<List<String>> wordSquares(String[] words) {\\n        List<List<String>> ret = new ArrayList();\\n        if (words==null || words.length==0) return ret;\\n        Node root = new Node();\\n        int len = words[0].length();\\n        for (String word: words) add(root, word);\\n        Node[] rows = new Node[len];\\n        for (int i=0; i<len; i++) rows[i]=root;\\n        helper(0, 0, len, rows, ret);\\n        return ret;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"91337",
			"view":"3196",
			"top":"3",
			"title":"70ms Concise C++ Solution Using Trie and Backtracking",
			"vote":"17",
			"content":"Optimized to 70ms by pre-size the vec instead of push_back and pop_back\\n\\n```\\nclass Solution {\\npublic:\\n    struct TrieNode {\\n        vector<int> indexs;\\n        vector<TrieNode*> children;\\n        TrieNode() {\\n            children.resize(26, nullptr);\\n        }\\n    };\\n\\n    TrieNode* buildTrie(vector<string>& words) {\\n        TrieNode* root = new TrieNode();\\n        for (int j = 0; j < words.size(); j++) {\\n            TrieNode* t = root;\\n            for (int i = 0; i < words[j].size(); i++) {\\n                if (!t->children[words[j][i] - 'a'])\\n                    t->children[words[j][i] - 'a'] = new TrieNode();\\n                t = t->children[words[j][i] - 'a'];\\n                t->indexs.push_back(j);\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    vector<vector<string>> res;\\n    vector<string> vec;\\n    void backtrack(vector<string>& words, int level, TrieNode* root) {\\n        if (level >= words[0].size()) {\\n            res.push_back(vec);\\n            return;\\n        }\\n        string str = \"\";\\n        for (int i = 0; i < level; i++) \\n            str += vec[i][level];\\n        TrieNode* t = root;     \\n        for (int i = 0; i < str.size(); i++) \\n            if (!(t = t->children[str[i] - 'a'])) return;\\n        for (auto index : t->indexs) {\\n            vec[level] = words[index];\\n            backtrack(words, level + 1, root);\\n        }\\n    }\\n    \\n    vector<vector<string>> wordSquares(vector<string>& words) {\\n        if (words.empty()) return res;\\n        TrieNode* root = buildTrie(words);\\n        vec.resize((int)words[0].size());\\n        for (auto& word : words) {\\n            vec[0] = word;\\n            backtrack(words, 1, root);\\n        }\\n        return res;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"91348",
			"view":"2116",
			"top":"4",
			"title":"My Java Solution using hashMap and backtracking 163ms",
			"vote":"9",
			"content":"The idea is borrowed from the discussion(https://discuss.leetcode.com/topic/63516/explained-my-java-solution-using-trie-126ms-16-16) , which is to first calculating all possible prefix, then do backtracking.\\n\\nWe can use Trie or hashMap to store the prefix information, while I think Trie might be more hard to implement, without saving any space. So I use hashMap to store prefix information.\\n\\n```\\npublic class Solution {\\n    public List<List<String>> wordSquares(String[] words) {\\n        List<List<String>> ret = new ArrayList<List<String>>();\\n        if(words.length==0 || words[0].length()==0) return ret;\\n        Map<String, Set<String>> map = new HashMap<>();\\n        int squareLen = words[0].length();\\n        // create all prefix\\n        for(int i=0;i<words.length;i++){\\n            for(int j=-1;j<words[0].length();j++){\\n                if(!map.containsKey(words[i].substring(0, j+1))) map.put(words[i].substring(0, j+1), new HashSet<String>());\\n                map.get(words[i].substring(0, j+1)).add(words[i]);\\n            }\\n        }\\n        helper(ret, new ArrayList<String>(), 0, squareLen, map);\\n        return ret;\\n    }\\n    public void helper(List<List<String>> ret, List<String> cur, int matched, int total, Map<String, Set<String>> map){\\n        if(matched == total) {ret.add(new ArrayList<String>(cur));return;}\\n        // build search string\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<=matched-1;i++) sb.append(cur.get(i).charAt(matched));\\n        // bachtracking\\n        Set<String> cand = map.get(sb.toString());\\n        if(cand==null) return;\\n        for(String str:cand){\\n            cur.add(str);\\n            helper(ret, cur, matched+1, total, map);\\n            cur.remove(cur.size()-1);\\n        }\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"91362",
			"view":"604",
			"top":"5",
			"title":"Python understandable solution (I guess)",
			"vote":"6",
			"content":"Read and learned from other posts. Basic idea is use trie + backtrack. Trie related functions are 'build_trie', 'add_str', 'search_str'. And backtrack function is just 'find_word_squares'. Hope it's more understandable. Leave comments if you have any thoughts.\\n\\n```\\nclass Solution(object):\\n    def wordSquares(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        trie = {}\\n        self.build_trie(words, trie)\\n        \\n        size = len(words[0])\\n        \\n        result = []\\n        self.find_word_squares(trie, size, [], result)\\n        return result\\n        \\n    def build_trie(self, words, trie):\\n        for word in words:\\n            self.add_str(word, trie)\\n            \\n    def add_str(self, string, root):\\n        node = root\\n        for letter in string:\\n            if letter not in node:\\n                node[letter] = {}\\n            node = node[letter]\\n        node['#'] = string\\n    \\n    def search_prefix(self, node, prefix, candidates):\\n        if '#' in node:\\n            candidates.append(node['#'])\\n            return\\n        \\n        for letter in prefix:\\n            if letter not in node:\\n                return\\n            node = node[letter]\\n        \\n        for letter in node:\\n            self.search_prefix(node[letter], '', candidates)\\n        \\n    def find_word_squares(self, trie, size, cur, result):\\n        if len(cur) == size:\\n            result.append(cur[:])\\n            return\\n            \\n        candidates = []\\n        prefix = ''.join([string[len(cur)] for string in cur])\\n        self.search_prefix(trie, prefix, candidates)\\n\\n        for candidate in candidates:\\n            self.find_word_squares(trie, size, cur + [candidate], result)\\n        \\n    \\n```"
		},
		{
			"lc_ans_id":"91342",
			"view":"1308",
			"top":"6",
			"title":"121ms Java solution using Trie and BackTracking",
			"vote":"4",
			"content":"```\\npublic class Solution {\\n    TrieNode root = new TrieNode();\\n    public List<List<String>> wordSquares(String[] words) {\\n        List<List<String>> ans = new ArrayList<>();\\n        if(words.length == 0) return ans;\\n        buildTrie(words);\\n        int length = words[0].length();\\n        findSquare(ans, length, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void findSquare(List<List<String>> ans, int length, List<String> temp) {\\n        if(temp.size() == length) {\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        int index = temp.size();\\n        StringBuilder sb = new StringBuilder();\\n        for(String s : temp) {\\n            sb.append(s.charAt(index));\\n        }\\n        String s = sb.toString();\\n        TrieNode node = root;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(node.next[s.charAt(i) - 'a'] != null) {\\n                node = node.next[s.charAt(i) - 'a'];\\n            } else {\\n                node = null;\\n                break;\\n            }\\n        }\\n        if(node != null) {\\n            for(String next : node.words) {\\n                temp.add(next);\\n                findSquare(ans, length, temp);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private void buildTrie(String[] words) {\\n        for(String word : words) {\\n            TrieNode node = root;\\n            char[] array = word.toCharArray();\\n            for(char c : array) {\\n                node.words.add(word);\\n                if(node.next[c - 'a'] == null) {\\n                    node.next[c - 'a'] = new TrieNode();\\n                }\\n                node = node.next[c - 'a'];\\n            }\\n            node.words.add(word);\\n        }\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] next = new TrieNode[26];\\n        List<String> words = new ArrayList<>();\\n    }\\n}"
		},
		{
			"lc_ans_id":"91360",
			"view":"245",
			"top":"7",
			"title":"3 Python Solutions with very detailed explanations",
			"vote":"2",
			"content":"**Solution with discussion** https://discuss.leetcode.com/topic/73514/3-python-solutions-with-very-detailed-explanations\\n\\n**Word Squares** https://leetcode.com/problems/word-squares/\\n\\n**Backtracking with Incremental Addition**\\n* All words are equal length. So the dimensions of a word square will be len(word[0])\\n* Now our approach will be to incrementally build a solution. The solution built will be kept in so_far array. This buildup of the solution will follow a general backtracking template - process_solution and generate_candidates.\\n* generate_candidates will produce prefix using the so_far array. Now the next word that can be added to the so_far array must have this prefix. Check the visual in this link to understand this better: https://discuss.leetcode.com/topic/63516/explained-my-java-solution-using-trie-126ms-16-16\\n```\\nclass Solution(object):\\n    def generate_candidates(self, so_far, words):\\n        prefix =  \"\".join([x[len(so_far)] for x in so_far])\\n        for w in words:\\n            if w.startswith(prefix):\\n                yield w\\n\\n    def helper(self, so_far, N, words, results):\\n        if len(so_far) == N:\\n            results.append([x for x in so_far])\\n        else:\\n            for c in self.generate_candidates(so_far, words):\\n                so_far.append(c)\\n                self.helper(so_far, N, words, results)\\n                so_far.pop()\\n        return\\n\\n    def wordSquares(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        results = []\\n        if words:\\n            self.helper([], len(words[0]), words, results)\\n        return results\\n```\\n\\n**Optimized solution using Hash-Tables**\\n* In the previous brute force solution, the bottle-neck was that we had to linearly scan all the words to filter those words which start with a prefix.\\n* What if we pre-process all words and store in a hash table. The key would be the prefix and value would be the list of words with that prefix.\\n* Then we can lookup all words with a prefix in constant time!\\n* We implement a new class called PrefixHashTable and store a mapping of all prefixes to words in it.\\n```\\nclass PrefixHashTable(object):\\n    def __init__(self, words):\\n        self.prefix_table = {}\\n        for w in words:\\n            for prefix in (w[0:i] for i in range(len(w))):\\n                self.prefix_table.setdefault(prefix, set([])).add(w)\\n        return\\n    \\n    def get_prefix_matches(self, prefix):\\n        candidates = self.prefix_table[prefix] if prefix in self.prefix_table else set([])        \\n        return candidates\\n\\nclass Solution(object):\\n    def helper(self, so_far, N, words, results, table):\\n        if len(so_far) == N:\\n            results.append([x for x in so_far])\\n        else:\\n            prefix = \"\".join([x[len(so_far)] for x in so_far])\\n            for c in table.get_prefix_matches(prefix):\\n                so_far.append(c)\\n                self.helper(so_far, N, words, results, table)\\n                so_far.pop()\\n        return\\n    \\n    def wordSquares(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        results = []\\n        if words:\\n            table = PrefixHashTable(words)\\n            self.helper([], len(words[0]), words, results, table)\\n        return results\\n```\\n\\n**Optimized solution using Tries**\\n* Prefix matching can also be done using Tries.\\n* We implement a simple Trie and encapsulate it within the PrefixTrie API.\\n\\n```\\nclass TrieNode(object):\\n    def __init__(self, value):\\n        self.nxt = [None]*26\\n        self.value = value\\n        return\\n\\nclass PrefixTrieTable(object):\\n    def __init__(self, words):\\n        self.root = TrieNode(None)\\n        for w in words:\\n            self.add_to_trie(w)\\n        return\\n    \\n    def add_to_trie(self, w):\\n        root = self.root\\n        for ch in w:\\n            offset = ord(ch)-ord('a')\\n            if root.nxt[offset] != None:\\n                root = root.nxt[offset]\\n            else:\\n                root.nxt[offset] = TrieNode(None)\\n                root = root.nxt[offset]\\n        root.value = w\\n        return\\n    \\n    def collect(self, root, candidates):\\n        if root.value:\\n            candidates.append(root.value)\\n        else:\\n            for i in range(26):\\n                if root.nxt[i]:\\n                    self.collect(root.nxt[i], candidates)\\n        return\\n    \\n    def get_prefix_matches(self, prefix):\\n        candidates, root = [], self.root\\n        for ch in prefix:\\n            offset = ord(ch)-ord('a')\\n            root = root.nxt[offset]\\n            if root == None:\\n                return candidates\\n        self.collect(root, candidates)            \\n        return candidates\\n\\nclass Solution(object):\\n    def helper(self, so_far, N, words, results, table):\\n        if len(so_far) == N:\\n            results.append([x for x in so_far])\\n        else:\\n            prefix = \"\".join([x[len(so_far)] for x in so_far])\\n            for c in table.get_prefix_matches(prefix):\\n                so_far.append(c)\\n                self.helper(so_far, N, words, results, table)\\n                so_far.pop()\\n        return\\n    \\n    def wordSquares(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        results = []\\n        if words:\\n            table = PrefixTrieTable(words)\\n            self.helper([], len(words[0]), words, results, table)\\n        return results\\n```"
		},
		{
			"lc_ans_id":"91356",
			"view":"200",
			"top":"8",
			"title":"Java 22ms solution, beat 100%. avoid any invalid words combination check",
			"vote":"1",
			"content":"The idea is to build dictionary with Trie for all words. Then search from inside the dictionary, explore all valid path to construct a square.  Invalid path is halted at earliest time possible. The valid check is not done on words, but on every possible path on the Trie.\\n\\n```\\npublic class Solution {    \\n    private Trie root = new Trie();\\n    \\n    public List<List<String>> wordSquares(String[] words) {\\n        List<List<String>> result = new ArrayList<>();\\n        for (String word : words) addWord(word);\\n        int len = words[0].length();\\n        Trie[] heads = new Trie[len];\\n        for (int i = 0; i < root.childrenSize; i++) {\\n            int cid = root.childrenIndexs[i];\\n            heads[0] = root.children[cid];\\n            wordSquares(result, heads, 0, new Trie[len], 0, root, len);\\n        }\\n        return result;\\n    }\\n    \\n    private void wordSquares(List<List<String>> result, Trie[] heads, int end, Trie[] newHeads, int newEnd, Trie progress, int len) {\\n        if (end == len - 1) {\\n            ArrayList<String> r = new ArrayList<>(len);\\n            for (Trie trie : heads) r.add(trie.word);\\n            result.add(r);\\n            return;\\n        }\\n        Trie current = newEnd > end ? progress : heads[newEnd];\\n        for (int i = 0; i < current.childrenSize; i++) {\\n            int cid = current.childrenIndexs[i];\\n            if (progress.children[cid] != null) {\\n                newHeads[newEnd] = current.children[cid];\\n                if (newEnd > end) wordSquares(result, newHeads, newEnd, new Trie[len], 0, root, len);\\n                else wordSquares(result, heads, end, newHeads, newEnd + 1, progress.children[cid], len);\\n            }\\n        }\\n    }\\n    \\n    class Trie {\\n        Trie[] children = new Trie[26];\\n        int[] childrenIndexs = new int[26];\\n        int childrenSize;\\n        String word;\\n    }\\n\\n    private void addWord(String word) {\\n        Trie curNode = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            if (curNode.children[word.charAt(i) - 'a'] == null) {\\n                curNode.children[word.charAt(i) - 'a'] = new Trie();\\n                curNode.childrenIndexs[curNode.childrenSize] = word.charAt(i) - 'a';\\n                curNode.childrenSize++;\\n            }\\n            curNode = curNode.children[word.charAt(i) - 'a'];\\n        }\\n        curNode.word = word;\\n    }\\n}\\n\\n```"
		},
		{
			"lc_ans_id":"91353",
			"view":"538",
			"top":"9",
			"title":"10-line DFS solution with prefix->word indices look-up (What is the time complexity?)",
			"vote":"1",
			"content":"Many has posted the similar DFS approach to build each word square by trying every possible word with expected prefix row by row. \\n\\nIt is interesting to see what is the time complexity of the algorithm. Let N be the number of words, and L be the length of each word.\\n* Build loop-up dictionary: for each word and each length of prefix, we invoke `substr` to get the prefix copy, so it is O(NL<sup>2</sup>). Any other way to achieve prefix to word list look-up can be substituted here.\\n* DFS recursion: The size of loop `for (int j : dict[pfx])` depends on the given words, and I think it will likely be larger if given words share more comment letters (and I think this is why the problem assumes no duplicates in given words). If naively using N for upper bound to estimate would be too conservative and lead to a huge complexity O(N<sup>L</sup>). \\n\\nNote that the real brute force solution would be look at all possible LxL word squares which are exactly N<sup>L</sup> of them (*assuming we could use a word multiple times in a word square even though the given word list has no duplicates*), and check each one of them if valid with O(L<sup>2</sup>) time, so the total time for brute force would be O(N<sup>L</sup>L<sup>2</sup>).\\n\\nInitially, I thought the even the popular method below is sort like brute force, so I gave up without giving a try. However, the given constraints that **N &le; 1000, L &le; 5** are indeed very critical.\\n```\\n    vector<vector<string>> wordSquares(vector<string>& words) {\\n      sq.resize(words[0].size());\\n      for (int i = 0; i < words.size(); ++i) // build prefix->word indices look-up\\n        for (int j=0; j<words[0].size(); dict[words[i].substr(0,j++)].push_back(i));\\n      return dfs(0, words), sqs;\\n    }\\n    \\n    // dfs routine to fill ith row of word sqaure\\n    void dfs(int i, const vector<string>& words) {\\n      if (i == words[0].size()) return sqs.push_back(sq);\\n      string pfx; for (int j=0; j<i; pfx += sq[j++][i]); // prefix for next look-up\\n      for (int j : dict[pfx]) sq[i] = words[j], dfs(i+1, words);\\n    }\\n    \\n    unordered_map<string, vector<int>> dict; // prefix -> word indices\\n    vector<vector<string>> sqs; // collection of word squares\\n    vector<string> sq; // a built word sqaure\\n```"
		}
	],
	"id":"425",
	"title":"Word Squares",
	"content":"<p>Given a set of words <b>(without duplicates)</b>, find all <a href=\"https://en.wikipedia.org/wiki/Word_square\" target=\"_blank\">word squares</a> you can build from them.</p>\r\n\r\n<p>A sequence of words forms a valid word square if the <i>k</i><sup>th</sup> row and column read the exact same string, where 0 &le; <i>k</i> &lt; max(numRows, numColumns).</p>\r\n\r\n<p>For example, the word sequence <code>[\"ball\",\"area\",\"lead\",\"lady\"]</code> forms a word square because each word reads the same both horizontally and vertically.</p>\r\n\r\n<pre>\r\nb a l l\r\na r e a\r\nl e a d\r\nl a d y\r\n</pre>\r\n\r\n<p><b>Note:</b><br />\r\n<ol>\r\n<li>There are at least 1 and at most 1000 words.</li>\r\n<li>All words will have the exact same length.</li>\r\n<li>Word length is at least 1 and at most 5.</li>\r\n<li>Each word contains only lowercase English alphabet <code>a-z</code>.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\n<b>Input:</b>\r\n[\"area\",\"lead\",\"wall\",\"lady\",\"ball\"]\r\n\r\n<b>Output:</b>\r\n[\r\n  [ \"wall\",\r\n    \"area\",\r\n    \"lead\",\r\n    \"lady\"\r\n  ],\r\n  [ \"ball\",\r\n    \"area\",\r\n    \"lead\",\r\n    \"lady\"\r\n  ]\r\n]\r\n\r\n<b>Explanation:</b>\r\nThe output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\n<b>Input:</b>\r\n[\"abat\",\"baba\",\"atan\",\"atal\"]\r\n\r\n<b>Output:</b>\r\n[\r\n  [ \"baba\",\r\n    \"abat\",\r\n    \"baba\",\r\n    \"atan\"\r\n  ],\r\n  [ \"baba\",\r\n    \"abat\",\r\n    \"baba\",\r\n    \"atal\"\r\n  ]\r\n]\r\n\r\n<b>Explanation:</b>\r\nThe output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).\r\n</pre>\r\n</p>",
	"frequency":"126",
	"ac_num":"12812"
}