{
	"difficulty":"3",
	"submit_num":"30594",
	"show_id":"432",
	"leetcode_id":"432",
	"answers":[
		{
			"lc_ans_id":"91400",
			"view":"14591",
			"top":"0",
			"title":"All in O(1), with detailed explantation",
			"vote":"33",
			"content":"The main idea is to maintain an ordered two-dimensional doubly-linked list (let's call it matrix for convenience), of which each row is corresponding to a value and all of the keys in the same row have the same value.\\n\\nSuppose we get the following key-value pairs after some increment operations. (\"A\": 4 means \"A\" is increased four times so its value is 4, and so on.)\\n```\\n\"A\": 4, \"B\": 4, \"C\": 2, \"D\": 1\\n```\\n\\nThen one possible matrix may look like this:\\n```\\nrow0: val = 4, strs = {\"A\", \"B\"}\\nrow1: val = 2, strs = {\"C\"}\\nrow2: val = 1, strs = {\"D\"}\\n```\\n\\nIf we can guarantee the rows are in descending order in terms of value, then GetMaxKey()/GetMinKey() will be easy to implement in O(1) time complexity. Because the first key in the first row will always has the maximal value, and the first key in the last row will always has the minimal value.\\n\\nOnce a key is increased, we move the key from current row to last row if last_row.val = current_row.val + 1. Otherwise, we insert a new row before current row with vallue current_row.val + 1, and move the key to to the new row. The logic of decrement operation is similar. Obviously, by doing this, the rows will keep its descending order.\\n\\nFor example, after Inc(\"D\"), the matrix will become\\n```\\nrow0: val = 4, strs = {\"A\", \"B\"}\\nrow1: val = 2, strs = {\"C\", \"D\"}\\n```\\n\\nInc(\"D\") again\\n```\\nrow0: val = 4, strs = {\"A\", \"B\"}\\nrow1: val = 3, strs = {\"D\"}\\nrow2: val = 2, strs = {\"C\"}\\n```\\n\\nNow the key problem is how to maintain the matrix in O(1) runtime when increase/decrease a key by 1.\\n\\nThe answer is hash map. By using a hash map to track the position of a key in the matrix, we can access  a key in the matrix in O(1). And since we use linked list to store the matrix, thus insert/move operations will all be O(1).\\n\\nThe psudocode of Inc() is as follows(Dec() is similar).\\n```\\nif the key isn't in the matrix:\\n    if the matrix is empty or the value of the last row isn't 1:\\n        insert a new row with value 1 to the end of the matrix, and put the key in the new row;\\n    else:\\n        put the key in the last row of the matrix;\\nelse:\\n    if the key is at the first row or last_row.value != current_row.value + 1:\\n        insert a new row before current row, with value current_row.value + 1, and move the key to the new row;\\n    else:\\n        move the key from current row to last row;\\n```\\n\\nHere is the code.\\n```\\nclass AllOne {\\npublic:\\n    struct Row {\\n        list<string> strs;\\n        int val;\\n        Row(const string &s, int x) : strs({s}), val(x) {}\\n    };\\n\\n    unordered_map<string, pair<list<Row>::iterator, list<string>::iterator>> strmap;\\n    list<Row> matrix;\\n\\n    /** Initialize your data structure here. */\\n    AllOne() {\\n        \\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    void inc(string key) {\\n        if (strmap.find(key) == strmap.end()) {\\n            if (matrix.empty() || matrix.back().val != 1) {\\n                auto newrow = matrix.emplace(matrix.end(), key, 1);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            else {\\n                auto newrow = --matrix.end();\\n                newrow->strs.push_front(key);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n        }\\n        else {\\n            auto row = strmap[key].first;\\n            auto col = strmap[key].second;\\n            auto lastrow = row;\\n            --lastrow;\\n            if (lastrow == matrix.end() || lastrow->val != row->val + 1) {\\n                auto newrow = matrix.emplace(row, key, row->val + 1);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            else {\\n                auto newrow = lastrow;\\n                newrow->strs.push_front(key);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            row->strs.erase(col);\\n            if (row->strs.empty()) matrix.erase(row);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    void dec(string key) {\\n        if (strmap.find(key) == strmap.end()) {\\n            return;\\n        }\\n        else {\\n            auto row = strmap[key].first;\\n            auto col = strmap[key].second;\\n            if (row->val == 1) {\\n                row->strs.erase(col);\\n                if (row->strs.empty()) matrix.erase(row);\\n                strmap.erase(key);\\n                return;\\n            }\\n            auto nextrow = row;\\n            ++nextrow;\\n            if (nextrow == matrix.end() || nextrow->val != row->val - 1) {\\n                auto newrow = matrix.emplace(nextrow, key, row->val - 1);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            else {\\n                auto newrow = nextrow;\\n                newrow->strs.push_front(key);\\n                strmap[key] = make_pair(newrow, newrow->strs.begin());\\n            }\\n            row->strs.erase(col);\\n            if (row->strs.empty()) matrix.erase(row);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    string getMaxKey() {\\n        return matrix.empty() ?  \"\" : matrix.front().strs.front();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    string getMinKey() {\\n        return matrix.empty() ?  \"\" : matrix.back().strs.front();\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"91416",
			"view":"7303",
			"top":"1",
			"title":"Java AC all strict O(1) not average O(1), easy to read",
			"vote":"32",
			"content":"Main idea is to maintain a list of Bucket's, each Bucket contains all keys with the same count.\\n1. ```head``` and ```tail``` can ensure both ```getMaxKey()``` and ```getMaxKey()``` be done in O(1).\\n2. ```keyCountMap``` maintains the count of keys, ```countBucketMap``` provides O(1) access to a specific Bucket with given count. Deleting and adding a Bucket in the Bucket list cost O(1), so both ```inc()``` and ```dec()``` take strict O(1) time.\\n\\n```\\npublic class AllOne {\\n    // maintain a doubly linked list of Buckets\\n    private Bucket head;\\n    private Bucket tail;\\n    // for accessing a specific Bucket among the Bucket list in O(1) time\\n    private Map<Integer, Bucket> countBucketMap;\\n    // keep track of count of keys\\n    private Map<String, Integer> keyCountMap;\\n\\n    // each Bucket contains all the keys with the same count\\n    private class Bucket {\\n        int count;\\n        Set<String> keySet;\\n        Bucket next;\\n        Bucket pre;\\n        public Bucket(int cnt) {\\n            count = cnt;\\n            keySet = new HashSet<>();\\n        }\\n    }\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        head = new Bucket(Integer.MIN_VALUE);\\n        tail = new Bucket(Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.pre = head;\\n        countBucketMap = new HashMap<>();\\n        keyCountMap = new HashMap<>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (keyCountMap.containsKey(key)) {\\n            changeKey(key, 1);\\n        } else {\\n            keyCountMap.put(key, 1);\\n            if (head.next.count != 1) \\n                addBucketAfter(new Bucket(1), head);\\n            head.next.keySet.add(key);\\n            countBucketMap.put(1, head.next);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (keyCountMap.containsKey(key)) {\\n            int count = keyCountMap.get(key);\\n            if (count == 1) {\\n                keyCountMap.remove(key);\\n                removeKeyFromBucket(countBucketMap.get(count), key);\\n            } else {\\n                changeKey(key, -1);\\n            }\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return tail.pre == head ? \"\" : (String) tail.pre.keySet.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return head.next == tail ? \"\" : (String) head.next.keySet.iterator().next();        \\n    }\\n    \\n    // helper function to make change on given key according to offset\\n    private void changeKey(String key, int offset) {\\n        int count = keyCountMap.get(key);\\n        keyCountMap.put(key, count + offset);\\n        Bucket curBucket = countBucketMap.get(count);\\n        Bucket newBucket;\\n        if (countBucketMap.containsKey(count + offset)) {\\n            // target Bucket already exists\\n            newBucket = countBucketMap.get(count + offset);\\n        } else {\\n            // add new Bucket\\n            newBucket = new Bucket(count + offset);\\n            countBucketMap.put(count + offset, newBucket);\\n            addBucketAfter(newBucket, offset == 1 ? curBucket : curBucket.pre);\\n        }\\n        newBucket.keySet.add(key);\\n        removeKeyFromBucket(curBucket, key);\\n    }\\n    \\n    private void removeKeyFromBucket(Bucket bucket, String key) {\\n        bucket.keySet.remove(key);\\n        if (bucket.keySet.size() == 0) {\\n            removeBucketFromList(bucket);\\n            countBucketMap.remove(bucket.count);\\n        }\\n    }\\n    \\n    private void removeBucketFromList(Bucket bucket) {\\n        bucket.pre.next = bucket.next;\\n        bucket.next.pre = bucket.pre;\\n        bucket.next = null;\\n        bucket.pre = null;\\n    }\\n    \\n    // add newBucket after preBucket\\n    private void addBucketAfter(Bucket newBucket, Bucket preBucket) {\\n        newBucket.pre = preBucket;\\n        newBucket.next = preBucket.next;\\n        preBucket.next.pre = newBucket;\\n        preBucket.next = newBucket;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"91398",
			"view":"8669",
			"top":"2",
			"title":"C++ solution with comments",
			"vote":"26",
			"content":"For each value, I have a bucket with all keys which have that value. The buckets are in a list, sorted by value. That allows constant time insertion/erasure and iteration to the next higher/lower value bucket. A bucket stores its keys in a hash set for easy constant time insertion/erasure/check (see [first two posts here](https://discuss.leetcode.com/topic/53193/are-hash-tables-ok-here-they-re-not-really-o-1-are-they) if you're worried). I also have one hash map to look up which bucket a given key is in.\\n\\nBased on a previously flawed Python attempt (I just couldn't find a good way to get an arbitrary element from a set) but also influenced by an earlier version of @Ren.W's [solution](https://discuss.leetcode.com/topic/63741/c-o-1-0ms-ac-solution]). We ended up with quite similiar code, I guess there's not much room for creativity once you decide on the data types to hold the data.\\n```\\nclass AllOne {\\npublic:\\n\\n    void inc(string key) {\\n        \\n        // If the key doesn't exist, insert it with value 0.\\n        if (!bucketOfKey.count(key))\\n            bucketOfKey[key] = buckets.insert(buckets.begin(), {0, {key}});\\n            \\n        // Insert the key in next bucket and update the lookup.\\n        auto next = bucketOfKey[key], bucket = next++;\\n        if (next == buckets.end() || next->value > bucket->value + 1)\\n            next = buckets.insert(next, {bucket->value + 1, {}});\\n        next->keys.insert(key);\\n        bucketOfKey[key] = next;\\n        \\n        // Remove the key from its old bucket.\\n        bucket->keys.erase(key);\\n        if (bucket->keys.empty())\\n            buckets.erase(bucket);\\n    }\\n\\n    void dec(string key) {\\n\\n        // If the key doesn't exist, just leave.\\n        if (!bucketOfKey.count(key))\\n            return;\\n\\n        // Maybe insert the key in previous bucket and update the lookup.\\n        auto prev = bucketOfKey[key], bucket = prev--;\\n        bucketOfKey.erase(key);\\n        if (bucket->value > 1) {\\n            if (bucket == buckets.begin() || prev->value < bucket->value - 1)\\n                prev = buckets.insert(bucket, {bucket->value - 1, {}});\\n            prev->keys.insert(key);\\n            bucketOfKey[key] = prev;\\n        }\\n        \\n        // Remove the key from its old bucket.\\n        bucket->keys.erase(key);\\n        if (bucket->keys.empty())\\n            buckets.erase(bucket);\\n    }\\n\\n    string getMaxKey() {\\n        return buckets.empty() ? \"\" : *(buckets.rbegin()->keys.begin());\\n    }\\n    \\n    string getMinKey() {\\n        return buckets.empty() ? \"\" : *(buckets.begin()->keys.begin());\\n    }\\n\\nprivate:\\n    struct Bucket { int value; unordered_set<string> keys; };\\n    list<Bucket> buckets;\\n    unordered_map<string, list<Bucket>::iterator> bucketOfKey;\\n};\\n```"
		},
		{
			"lc_ans_id":"91383",
			"view":"3310",
			"top":"3",
			"title":"An accepted JAVA solution, detailed explanation.(HashMap + double linked list)",
			"vote":"12",
			"content":" ![0_1477786494175_\\u65e0\\u6807\\u9898.png](/uploads/files/1477786496396-\\u65e0\\u6807\\u9898.png) \\n\\nMy key thought of this problem is to  the HashMap + Double Linked Node.\\n\\nWhen Inc (A) we could using the hashmap to find out we store the A at the node 1 , which means there is only 1 A in the data structure. (which is also the tail of the double linked list.)\\nThen we can delete the A in the level 1 and put the A into the level 2. Meanwhile , we should also change the <k,v> = <A, node 1> to the <k,v > = <A, node 2>.\\n\\nActually , the situation could be more complicated. You can check the detail categories in my code. But the key thought is :\\n        \\n* 1. Using the hashmap as the index to find out where is the key.\\n\\n* 2. Dealing with the key in a double linked list.\\n\\nAlso, I think there is many improvements should be done in my code.  Maybe someone could finish it.\\n1. to optimal the category method.\\n2. to change the list inside the node to be HashSet.(which could really be o(1).)\\n3.  checkEmpty() method should be substitute by  some steps with different situation.\\n\\n```\\npublic class AllOne {\\n    class valueNode {\\n        valueNode preNode;             \\n        valueNode nextNode;           \\n        int value;                     // curNode.value;\\n        List<String> curKeys;         // store the key at the value of curNode.value;\\n        \\n        valueNode(int value,String key) {\\n            this.value = value;\\n            curKeys = new LinkedList<String>();\\n            curKeys.add(key);\\n        }\\n    }\\n    \\n    private valueNode head;\\n    private valueNode tail;\\n    private valueNode curNode;\\n    private HashMap<String, valueNode> keyMap;\\n    \\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        keyMap = new HashMap<String,valueNode>();\\n        head = null;\\n        tail = null;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (tail == null) { // which means head must be null too and the keyMap must be empty.\\n                curNode = new valueNode(1,key);\\n                head = curNode;\\n                tail = curNode;\\n                keyMap.put(key,curNode);\\n        } else if (!keyMap.containsKey(key)){ //which means that this key should be add to the tail.\\n                if (tail.value == 1) {//which means just add the key to the tail list.\\n                    tail.curKeys.add(key);\\n                    keyMap.put(key,tail);\\n                }else {    //which means have to add a value= 1 node.\\n                    curNode = new valueNode(1,key);\\n                    curNode.preNode = tail;\\n                    tail.nextNode = curNode;\\n                    tail = curNode;\\n                    keyMap.put(key,curNode);\\n                }\\n        } else { //which the string already exists.\\n            curNode = keyMap.get(key);\\n            if (curNode.preNode != null) {  //which means the node is in the middle.\\n                if (curNode.preNode.value == curNode.value + 1){\\n                    curNode.preNode.curKeys.add(key);\\n                    curNode.curKeys.remove(key); \\n                    keyMap.put(key,curNode.preNode);\\n                    checkEmpty(curNode);\\n                }else {                     //which means the preNode value != curNode.value;\\n                    valueNode newNode = new valueNode(curNode.value+1, key);\\n                    newNode.preNode = curNode.preNode;\\n                    newNode.nextNode= curNode;\\n                    newNode.preNode.nextNode = newNode;\\n                    curNode.preNode = newNode;\\n                    curNode.curKeys.remove(key); \\n                    keyMap.put(key,newNode);\\n                    checkEmpty(curNode);\\n                }\\n            }else {//which means the node is the head. so we build a new head.\\n                head = new valueNode(curNode.value+1,key);\\n                head.nextNode = curNode;\\n                curNode.preNode = head;\\n                curNode.curKeys.remove(key);\\n                keyMap.put(key,head);\\n                checkEmpty(curNode);\\n            }\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n            if (head ==null ||!keyMap.containsKey(key)) return; //which means nothing here.\\n                                                         //or  means no key in the structrue.\\n            curNode = keyMap.get(key);\\n            if (curNode.nextNode != null) {  //which means the node is in the middle.\\n                if (curNode.nextNode.value == curNode.value - 1){ //which means we can just \\n                    curNode.nextNode.curKeys.add(key);\\n                    curNode.curKeys.remove(key); \\n                    keyMap.put(key,curNode.nextNode);\\n                    checkEmpty(curNode);\\n                }else {                     //which means the nextNode value != curNode.value-1;\\n                        valueNode newNode = new valueNode(curNode.value-1, key);\\n                        newNode.nextNode = curNode.nextNode;\\n                        newNode.preNode= curNode;\\n                        newNode.nextNode.preNode = newNode;\\n                        curNode.curKeys.remove(key); \\n                        curNode.nextNode = newNode;\\n                        keyMap.put(key,newNode);\\n                        checkEmpty(curNode);\\n                }\\n            } else {    //which means the node is the tail. so we build a new head.\\n                if (curNode.value == 1) {     //just to delete the key.\\n                    curNode.curKeys.remove(key);  \\n                    keyMap.remove(key);\\n                    checkEmpty(curNode);\\n                }else {                         // build another tail.\\n                    tail = new valueNode(curNode.value-1,key);\\n                    tail.preNode = curNode;\\n                    curNode.nextNode = tail;\\n                    curNode.curKeys.remove(key);  \\n                    keyMap.put(key,tail);\\n                    checkEmpty(curNode);\\n                }\\n            }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n         if (head == null) return \"\";//which means nothing here.\\n         return head.curKeys.get(0);\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n         if (tail == null) return \"\";//which means nothing here.\\n         return tail.curKeys.get(0);\\n        \\n    }\\n    // to check whether the node should be delete because the keyList is empty.\\n    private void checkEmpty(valueNode checkNode) {\\n            if (checkNode.curKeys.size() != 0) return;\\n            if (checkNode.preNode == null && checkNode.nextNode == null){\\n                tail = null;\\n                head = null;\\n            }else if (checkNode.preNode == null && checkNode.nextNode != null) {\\n                head = checkNode.nextNode;\\n                head.preNode = null;\\n            }else if (checkNode.nextNode == null && checkNode.preNode != null){\\n                tail = checkNode.preNode;\\n                tail.nextNode = null;\\n            }else {\\n                checkNode.preNode.nextNode = checkNode.nextNode;\\n                checkNode.nextNode.preNode  = checkNode.preNode; \\n            } \\n    }\\n}\\n\\n..."
		},
		{
			"lc_ans_id":"91445",
			"view":"1896",
			"top":"4",
			"title":"AC Java Solution using hashMap and two heaps",
			"vote":"5",
			"content":"```\\npublic class AllOne {\\n\\n    class Node{\\n        String key;\\n        int val;\\n        public Node(String key, int val) {\\n            this.key = key;\\n            this.val = val;\\n        }\\n    }\\n    /** Initialize your data structure here. */\\n    HashMap<String, Node> map;\\n    PriorityQueue<Node> minQ;\\n    PriorityQueue<Node> maxQ;\\n    public AllOne() {\\n        map = new HashMap<String, Node>();\\n        minQ = new PriorityQueue<Node>(new Comparator<Node>(){\\n            public int compare(Node a, Node b) {\\n                return a.val - b.val;\\n            }\\n        });        \\n        maxQ = new PriorityQueue<Node>(new Comparator<Node>(){\\n            public int compare(Node a, Node b) {\\n                return b.val - a.val;\\n            }\\n        });\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (!map.containsKey(key)) {\\n            map.put(key, new Node(key, 1));\\n            Node node = map.get(key);\\n            minQ.add(node);\\n            maxQ.add(node);\\n        } else {\\n            Node node = map.get(key);\\n            minQ.remove(node);\\n            maxQ.remove(node);\\n            node.val++;\\n            map.put(key, node);\\n            minQ.add(node);\\n            maxQ.add(node);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            if (node.val == 1) {\\n                map.remove(key);\\n                minQ.remove(node);\\n                maxQ.remove(node);\\n            } else {\\n                minQ.remove(node);\\n                maxQ.remove(node);\\n                node.val--;\\n                map.put(key, node);\\n                minQ.add(node);\\n                maxQ.add(node);\\n            }\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return maxQ.isEmpty() ? \"\" : maxQ.peek().key;\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return minQ.isEmpty() ? \"\" : minQ.peek().key;\\n    }\\n}\\n\\n/**\\n * Your AllOne object will be instantiated and called as such:\\n * AllOne obj = new AllOne();\\n * obj.inc(key);\\n * obj.dec(key);\\n * String param_3 = obj.getMaxKey();\\n * String param_4 = obj.getMinKey();\\n */\\n```"
		},
		{
			"lc_ans_id":"91428",
			"view":"527",
			"top":"5",
			"title":"Python solution with detailed comments",
			"vote":"4",
			"content":"**Solution** \\n\\n**All Oone Data Structure** https://leetcode.com/problems/all-oone-data-structure/\\n\\n**Data-Structures**\\nhttps://goo.gl/photos/YLhF2qCcBwRpAn58A\\n\\nNode: A node type to support a doubly linked list. It is a container to hold a bag of keys. It supports:\\n* add_key(key): Add a key to the bag\\n* remove_key(key): Remove a key from the bag\\n* get_any_key(): Returns any random key from the bag. Returns None if bag is empty.\\n* is_empty(): Returns true if the bag is empty\\n\\nDoubleLinkedList\\n* The linked list is implemented using the idea of sentinel nodes, i.e. we have two dummy nodes to represent head and tail. Initially head.next points to tail and tail.prev points to head. Using two dummy nodes dramatically simplifies the implementation.\\n* insert_after(x): Add a node after node x\\n* insert_before(x): Add a node before node x\\n* remove(x): Remove the node from the list\\n* get_head(): Returns the reference to the real head node\\n* get_tail() Returns the reference to the real tail node\\n\\nnode_freq: Hashmap with key as frequency and value as Node.\\nkey_counter: Hashmap with key as input key and value as frequency of the key.\\n\\n**Algorithm Idea**\\n\\n* A node in the doubly linked list represents a bucket containing a bag of words with a certain frequency. The doubly linked list is maintained in a sorted order with the head node containing words with the least frequency and the tail node containing words with maximum frequency.\\n* Using this list, getMaxKey and getMinKey can be implemented in O(1) by returning any word contained in the tail and head respectively.\\n* key_counter is hashmap which allows us to increment or decrement frequency of a key in O(1).\\n* node_freq is a hashmap which maps a frequency integer to the bucket node in the linked list. Note that we initialize frequency 0 to head sentinel node.\\n* Now, if we can maintain the sorted order of the linked list in O(1) while performing the increment and decrement operations, we would have a working solution!\\n\\n**Increment Details**\\n* While incrementing a key, we first update the key_counter ro reflect the new frequency (cf) of the key.\\n* Then we test if there is already a bucket with cf using node_freq hashmap. If not, then we need to add a bucket to the linked list. \\n* To maintain the sorted invariant, this new bucket must be after the bucket for frequency pf (cf-1). \\n* Now unless pf is 0, we are guaranteed that a pf bucket already exists. Therefore, either we add the new bucket after the head node or after the pf bucket. Note that we initialize frequency 0 to head sentinel node. This allows us to use \"insert_after\" API when previous frequency were zero.\\n* pf bucket can be retrieved in O(1) using node_freq. insertion in doubly linked list can be done in O(1) as well. Once we have inserted, we add the key to the new bucket.\\n* Finally we need to remove the key from the previous bucket if pf > 0 (i.e. if a previous bucket exists). Again this can be done in O(1). If the previous bucket becomes empty after removing the key, then we need to also drop the entire bucket from the list.\\n\\n**Decrement Details**\\n* While decrementing a key, we first check if the key exisits in key_counter or not. If not, then we simply return. if it does exist, we update the key_counter to reflect the new frequency (cf) of the key. If cf is 0, then we drop this key from the key counter.\\n* If cf is not in node_freq and cf is not 0, then we need to add a new bucket in the linked list such that the sorted invariant is maintained. Again we are guaranteed to have pf bucket!\\n* We add the key to the new bucket and remove it from the previous bucket - O(1) operations.\\n\\n```\\nfrom collections import defaultdict\\nclass Node(object):\\n    def __init__(self):\\n        self.key_set = set([])\\n        self.prev, self.nxt = None, None \\n\\n    def add_key(self, key):\\n        self.key_set.add(key)\\n\\n    def remove_key(self, key):\\n        self.key_set.remove(key)        \\n\\n    def get_any_key(self):\\n        if self.key_set:\\n            result = self.key_set.pop()\\n            self.add_key(result)\\n            return result\\n        else:\\n            return None\\n    \\n    def count(self):\\n        return len(self.key_set)\\n\\n    def is_empty(self):\\n        return len(self.key_set) == 0\\n\\n\\nclass DoubleLinkedList(object):\\n    def __init__(self):\\n        self.head_node, self.tail_node = Node(), Node()\\n        self.head_node.nxt, self.tail_node.prev = self.tail_node, self.head_node\\n        return\\n\\n    def insert_after(self, x):\\n        node, temp = Node(), x.nxt\\n        x.nxt, node.prev = node, x\\n        node.nxt, temp.prev = temp, node\\n        return node\\n    \\n    def insert_before(self, x):\\n        return self.insert_after(x.prev)\\n\\n    def remove(self, x):\\n        prev_node = x.prev\\n        prev_node.nxt, x.nxt.prev = x.nxt, prev_node\\n        return\\n\\n    def get_head(self):\\n        return self.head_node.nxt\\n    \\n    def get_tail(self):\\n        return self.tail_node.prev\\n\\n    def get_sentinel_head(self):\\n        return self.head_node\\n\\n    def get_sentinel_tail(self):\\n        return self.tail_node\\n    \\nclass AllOne(object):\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dll, self.key_counter = DoubleLinkedList(), defaultdict(int)\\n        self.node_freq = {0:self.dll.get_sentinel_head()}\\n\\n    def _rmv_key_pf_node(self, pf, key):\\n        node = self.node_freq[pf]\\n        node.remove_key(key)\\n        if node.is_empty():\\n            self.dll.remove(node)\\n            self.node_freq.pop(pf)\\n        return\\n\\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        self.key_counter[key] += 1\\n        cf, pf = self.key_counter[key], self.key_counter[key]-1\\n        if cf not in self.node_freq:\\n            # No need to test if pf = 0 since frequency zero points to sentinel node\\n            self.node_freq[cf] = self.dll.insert_after(self.node_freq[pf])\\n        self.node_freq[cf].add_key(key)\\n        if pf > 0:\\n            self._rmv_key_pf_node(pf, key)\\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key in self.key_counter:\\n            self.key_counter[key] -= 1\\n            cf, pf = self.key_counter[key], self.key_counter[key]+1\\n            if self.key_counter[key] == 0:\\n                self.key_counter.pop(key)\\n            if cf != 0:\\n                if cf not in self.node_freq:\\n                    self.node_freq[cf] = self.dll.insert_before(self.node_freq[pf])\\n                self.node_freq[cf].add_key(key)\\n            self._rmv_key_pf_node(pf, key)\\n\\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        return self.dll.get_tail().get_any_key() if self.dll.get_tail().count() > 0 else \"\"\\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        return self.dll.get_head().get_any_key() if self.dll.get_tail().count() > 0 else \"\"\\n```"
		},
		{
			"lc_ans_id":"91442",
			"view":"826",
			"top":"6",
			"title":"Accepted Java and Python solution",
			"vote":"4",
			"content":"\\n\\n\\nJava:\\n````\\npublic class AllOne {\\n    Node head;\\n    Node tail;\\n    \\n    Map<String, Integer> keyCountMap;\\n    Map<Integer, Node> countNodeMap;\\n    Map<Integer, Set<String>> countKeyMap;\\n    \\n    class Node {\\n        int count;\\n        Node prev;\\n        Node next;\\n        \\n        public Node(int cnt) {\\n            count = cnt;\\n            prev = null;\\n            next = null;\\n        }\\n    }\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        head = new Node(0);\\n        tail = new Node(Integer.MAX_VALUE);\\n        head.next = tail;\\n        tail.prev = head;\\n        \\n        keyCountMap = new HashMap<>();\\n        countNodeMap = new HashMap<>();\\n        countKeyMap = new HashMap<>();\\n        \\n        countNodeMap.put(0, head);\\n        countNodeMap.put(Integer.MAX_VALUE, tail);\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (!keyCountMap.containsKey(key)) {\\n            keyCountMap.put(key, 0);\\n        }\\n        \\n        int preCount = keyCountMap.get(key);\\n        Node preNode = countNodeMap.get(preCount);\\n        \\n        keyCountMap.put(key, preCount + 1);\\n        int newCount = keyCountMap.get(key);\\n        \\n        //insert\\n        //new count is created\\n        if (newCount != preNode.next.count) {\\n            Node newNode = new Node(newCount);\\n            insert(preNode, newNode);\\n            \\n            countKeyMap.put(newCount, new HashSet<String>());\\n            countNodeMap.put(newCount, newNode);\\n        }\\n        countKeyMap.get(newCount).add(key);\\n        \\n        //delete old\\n        if (preCount > 0) {\\n            Set<String> oldSet = countKeyMap.get(preCount);\\n            oldSet.remove(key);\\n            if (oldSet.isEmpty()) {\\n                delete(preNode);\\n                countKeyMap.remove(preCount);\\n                countNodeMap.remove(preCount);\\n            }            \\n        }\\n\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!keyCountMap.containsKey(key)) return;\\n        \\n        int preCount = keyCountMap.get(key);\\n        Node preNode = countNodeMap.get(preCount);\\n        \\n        keyCountMap.put(key, preCount - 1);\\n        int newCount = keyCountMap.get(key);\\n        \\n        //insert\\n        //new count occurs\\n        if (newCount != 0) {\\n            if (newCount != preNode.prev.count) {\\n                Node newNode = new Node(newCount);\\n                insert(preNode.prev, newNode);\\n                \\n                countKeyMap.put(newCount, new HashSet<String>());\\n                countNodeMap.put(newCount, newNode);\\n            }\\n            countKeyMap.get(newCount).add(key);            \\n        }\\n        else keyCountMap.remove(key);\\n\\n        //delete\\n        Set<String> oldSet = countKeyMap.get(preCount);\\n        oldSet.remove(key);\\n        if (oldSet.isEmpty()) {\\n            delete(preNode);\\n            countKeyMap.remove(preCount);\\n            countNodeMap.remove(preCount);\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if (head.next == tail) {\\n            System.out.println(\"head == tail\");\\n            return \"\";\\n        }\\n        Set<String> set = countKeyMap.get(tail.prev.count);\\n        return set.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if (head.next == tail) return \"\";\\n        Set<String> set = countKeyMap.get(head.next.count);\\n        return set.iterator().next();\\n    }\\n    \\n    public void insert(Node preNode, Node node) {\\n        node.next = preNode.next;\\n        node.prev = preNode;\\n        \\n        node.next.prev = node;\\n        node.prev.next = node;\\n    }\\n    \\n    public void delete(Node node) {\\n        node.next.prev = node.prev;\\n        node.prev.next = node.next;\\n    }\\n}\\n````\\n\\nPython:\\n\\n````\\nfrom sets import Set\\nclass Node:\\n    def __init__(self, cnt):\\n        self.count = cnt\\n        self.prev = None\\n        self.next = None\\n\\n\\nclass AllOne(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        #Key:count, Value:set of key who has been incremented by 'count' time\\n        self.count_key_map = {}\\n        #Key:key, Value: the number of counts of this key\\n        self.key_count_map = {}\\n        #Key: the count, Value: the node\\n        self.count_node_map = {}\\n        \\n        #initialize the linkedlist with dummy node\\n        self.head = Node(0)\\n        self.tail = Node(float('inf'))\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n        self.count_node_map[0] = self.head\\n        self.count_node_map[float('inf')] = self.tail\\n\\n    def inc(self, key):\\n        \"\"\"\\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key not in self.key_count_map:\\n            self.key_count_map[key] = 0\\n        \\n        prev_count = self.key_count_map[key]\\n        prev_node = self.count_node_map[prev_count]\\n        \\n        #update the key map:\\n        self.key_count_map[key] += 1\\n        #insert new node:\\n        #new count occurs\\n        if prev_node.next.count != self.key_count_map[key]:\\n            #if a new count is created insert then node\\n            new_node = Node(self.key_count_map[key])\\n            self.insert(prev_node, new_node)\\n         \\n            #update 'node_map' and 'count_map'\\n            self.count_node_map[self.key_count_map[key]] = new_node\\n            self.count_key_map[self.key_count_map[key]] = Set()\\n        #if the new count is the same as the count in next node\\n        self.count_key_map[self.key_count_map[key]].add(key)\\n        \\n        #delelte the key in the prev-node\\n        if prev_count != 0:\\n            self.count_key_map[prev_count].remove(key)\\n            if len(self.count_key_map[prev_count]) == 0:\\n                self.delete(prev_node)\\n                self.count_key_map.pop(prev_count)\\n                self.count_node_map.pop(prev_count)\\n    \\n        \\n\\n    def dec(self, key):\\n        \"\"\"\\n        Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\\n        :type key: str\\n        :rtype: void\\n        \"\"\"\\n        if key not in self.key_count_map:\\n            return\\n        \\n        prev_count = self.key_count_map[key]\\n        prev_node = self.count_node_map[prev_count]\\n        \\n        self.key_count_map[key] -= 1\\n        \\n        #insert new node\\n        #if the count becomes 0\\n        if self.key_count_map[key] == 0:\\n            self.key_count_map.pop(key)\\n        else:\\n            if self.key_count_map[key] !=  prev_node.prev.count:\\n                new_node = Node(self.key_count_map[key])\\n                self.insert(prev_node.prev, new_node)\\n                \\n                self.count_node_map[self.key_count_map[key]] = new_node\\n                self.count_key_map[self.key_count_map[key]] = Set()\\n\\n            self.count_key_map[self.key_count_map[key]].add(key)\\n                \\n        #delete\\n        self.count_key_map[prev_count].remove(key)\\n        if len(self.count_key_map[prev_count]) == 0:\\n            self.delete(prev_node)\\n            self.count_key_map.pop(prev_count)\\n            self.count_node_map.pop(prev_count)\\n            \\n    def getMaxKey(self):\\n        \"\"\"\\n        Returns one of the keys with maximal value.\\n        :rtype: str\\n        \"\"\"\\n        if self.head.next == self.tail:\\n            return \"\"\\n        x = self.count_key_map[self.tail.prev.count].pop()\\n        self.count_key_map[self.tail.prev.count].add(x)\\n        return x\\n        \\n\\n    def getMinKey(self):\\n        \"\"\"\\n        Returns one of the keys with Minimal value.\\n        :rtype: str\\n        \"\"\"\\n        if self.head.next == self.tail:\\n            return \"\"\\n        x = self.count_key_map[self.head.next.count].pop()\\n        self.count_key_map[self.head.next.count].add(x)\\n        return x\\n        \\n    #insert 'node' after prev_node O(1) \\n    def insert(self, prev_node, node):\\n        node.next = prev_node.next\\n        node.prev = prev_node\\n        \\n        node.next.prev = node\\n        node.prev.next = node\\n        \\n    def delete(self, node):\\n        node.next.prev = node.prev\\n        node.prev.next = node.next\\n````"
		},
		{
			"lc_ans_id":"91444",
			"view":"1045",
			"top":"7",
			"title":"Java Accepted solution",
			"vote":"3",
			"content":"```\\npublic class AllOne {\\n\\n    // Map that stores key to the node\\n    Map<String, Integer> map;\\n    \\n    // Map that groups keys having same value using double\\n    // linked list as value\\n    Map<Integer, Set<String>> valueMap;\\n    \\n    // MinMax linkedlist to keep track of\\n    // min and max values\\n    LinkedList<Integer> minMax;\\n\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap<>();\\n        valueMap = new HashMap<>();\\n        minMax = new LinkedList<Integer>();\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        // If new key, just insert into the map\\n        // and place it in the appropriate position\\n        // in value map\\n        if(!map.containsKey(key)) {\\n            map.put(key, 1);\\n            putInValueMap(1, key);\\n        } else {\\n            // If already existing\\n            int val = map.get(key);\\n            // Remove from value map for old value\\n            removeFromValueMap(val, key);\\n            // Increment value\\n            map.put(key, val + 1);\\n            // Place it the new value in value map\\n            putInValueMap(val + 1, key);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        // If this key not found, just return\\n        if(!map.containsKey(key)) {\\n            return;\\n        }\\n        \\n        int val = map.get(key);\\n        // If value is 1, then remove from map\\n        if(val == 1) {\\n            map.remove(key);\\n            // Remove from value map too\\n            removeFromValueMap(1, key);\\n        } else {\\n            // Remove from old value\\n            removeFromValueMap(val, key);\\n            // Decrement value\\n            map.put(key, val - 1);\\n            \\n            // Insert at new value\\n            putInValueMap(val - 1, key);\\n        }\\n        \\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        if(minMax.isEmpty()) {\\n            return \"\";\\n        }\\n        // minMax.getFirst() always has max value\\n        return valueMap.get(minMax.getFirst()).iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        if(minMax.isEmpty()) {\\n            return \"\";\\n        }\\n        // minMax.getFirst() always has min value\\n        return valueMap.get(minMax.getLast()).iterator().next();\\n    }\\n    \\n    private void putInValueMap(int count, String node) {\\n        // If not seen before, create a new dll\\n        if(!valueMap.containsKey(count)) {\\n            valueMap.put(count, new HashSet<String>());\\n        }\\n        // Add to dll\\n        valueMap.get(count).add(node);\\n        \\n        // Update min max\\n        if(minMax.isEmpty() || minMax.getFirst() < count) {\\n            minMax.addFirst(count);\\n        }\\n        \\n        if(!minMax.isEmpty() && minMax.getLast() > count) {\\n            minMax.addLast(count);\\n        }\\n    }\\n    \\n    private void removeFromValueMap(int count, String node) {\\n        // If not present in value map, just return\\n        if(!valueMap.containsKey(count)) {\\n            return;\\n        }\\n        \\n        // Remove from dll in value map\\n        valueMap.get(count).remove(node);\\n        \\n        // If no elements present with this value\\n        if(valueMap.get(count).size() == 0) {\\n            // Remove from value map all together\\n            valueMap.remove(count);\\n            \\n            // Update min max\\n            if(!minMax.isEmpty() && minMax.getFirst() == count) {\\n                minMax.removeFirst();\\n            }\\n            if(!minMax.isEmpty() && minMax.getLast() == count) {\\n                minMax.removeLast();\\n            }\\n        }\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"91469",
			"view":"505",
			"top":"8",
			"title":"Problem is not clear",
			"vote":"3",
			"content":"What does the following mean? Increment a string by 1 (integer)?\\n>increments an existing key by 1\\n\\nI think it means the value of the key : can be clearly written in the question."
		},
		{
			"lc_ans_id":"91421",
			"view":"240",
			"top":"9",
			"title":"Only ONE HashMap() Java solution, beats 99%",
			"vote":"2",
			"content":"The most difficult part of this kind of problem, is not the idea or the thought, but the 30-minute **bug-free** implementation. I actually did more than 1 hour and finally get passed. I recommend to draw a graph when you try to solve this kind of problems.\\n\\n```\\npublic class AllOne {\\n    Map<String, Node> map;\\n    Node head, tail;\\n    // head - min\\n    // tail - max\\n    /** Initialize your data structure here. */\\n    public AllOne() {\\n        map = new HashMap();\\n        head = tail = null;\\n    }\\n    \\n    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */\\n    public void inc(String key) {\\n        if (map.containsKey(key)) {\\n            // get old node\\n            Node node = map.get(key);\\n            // get old val\\n            int val = node.val;\\n            // remove old key in the old node\\n            node.keys.remove(key);\\n            // add new node with new val\\n            if (node.next == null || node.next.val != val + 1) {\\n                Node newNode = new Node(val + 1);\\n                newNode.pre = node;\\n                newNode.next = node.next;\\n                node.next = newNode;\\n                if (newNode.next != null) newNode.next.pre = newNode;\\n            }\\n            // add new key to the next node\\n            node.next.keys.add(key);\\n            // update node\\n            map.put(key, node.next);\\n            \\n            // udate head\\n            if (node.keys.isEmpty()) {\\n                if (node == head) head = node.next;\\n                node.next.pre = node.pre;\\n                if (node.pre != null) node.pre.next = node.next;\\n            }\\n            // update tail\\n            if (tail == node) tail = node.next;\\n        } else {\\n            if (head == null || head.val > 1) {\\n                Node node = new Node(1);\\n                node.next = head;\\n                if (head != null) head.pre = node;\\n                head = node;\\n                if (tail == null) tail = node;\\n            }\\n            head.keys.add(key);\\n            map.put(key, head);\\n        }\\n    }\\n    \\n    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */\\n    public void dec(String key) {\\n        if (!map.containsKey(key)) return;\\n        // get old node\\n        Node node = map.get(key);\\n        // get old val\\n        int val = node.val;\\n        // remove old val from old node\\n        node.keys.remove(key);\\n        // remove old key\\n        map.remove(key);\\n        // if it's head, update head and tail\\n        if (val == 1) {\\n            if (node.keys.isEmpty()) {\\n                if (head == node) head = node.next;\\n                if (head != null) head.pre = null;\\n                if (tail == node) tail = null;\\n            }\\n        } else {\\n            // add new node at pre position\\n            if (node.pre == null || node.pre.val != val - 1) {\\n                Node newNode = new Node(val - 1);\\n                newNode.next = node;\\n                newNode.pre = node.pre;\\n                node.pre = newNode;\\n                if (newNode.pre != null) newNode.pre.next = newNode;\\n            }\\n            // add new key to the newNode or pre node\\n            node.pre.keys.add(key);\\n            // update node\\n            map.put(key, node.pre);\\n            \\n            // update tail\\n            if (node.keys.isEmpty()) {\\n                if (tail == node) tail = node.pre;\\n                node.pre.next = node.next;\\n                if (node.next != null) node.next.pre = node.pre;\\n            }\\n            // update head\\n            if (head == node) head = node.pre;\\n        }\\n    }\\n    \\n    /** Returns one of the keys with maximal value. */\\n    public String getMaxKey() {\\n        return tail == null ? \"\" : tail.keys.iterator().next();\\n    }\\n    \\n    /** Returns one of the keys with Minimal value. */\\n    public String getMinKey() {\\n        return head == null ? \"\" : head.keys.iterator().next();\\n    }\\n    \\n    class Node {\\n        int val;\\n        LinkedHashSet<String> keys;\\n        Node next, pre;\\n        public Node(int val) {\\n            this.val = val;\\n            keys = new LinkedHashSet();\\n            next = pre = null;\\n        }\\n    }\\n}\\n```"
		}
	],
	"id":"426",
	"title":"All O`one Data Structure",
	"content":"<p>Implement a data structure supporting the following operations:</p>\r\n\r\n<p>\r\n<ol>\r\n<li>Inc(Key) - Inserts a new key <Key> with value 1. Or increments an existing key by 1. Key is guaranteed to be a <b>non-empty</b> string.</li>\r\n<li>Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a <b>non-empty</b> string.</li>\r\n<li>GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string <code>\"\"</code>.</li>\r\n<li>GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string <code>\"\"</code>.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nChallenge: Perform all these in O(1) time complexity.\r\n</p>",
	"frequency":"245",
	"ac_num":"8564"
}