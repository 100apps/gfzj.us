{
	"difficulty":"3",
	"submit_num":"21497",
	"show_id":"440",
	"leetcode_id":"440",
	"answers":[
		{
			"lc_ans_id":"92242",
			"view":"10534",
			"top":"0",
			"title":"Concise/Easy-to-understand Java 5ms solution with Explaination",
			"vote":"92",
			"content":"Original idea comes from \\nhttp://bookshadow.com/weblog/2016/10/24/leetcode-k-th-smallest-in-lexicographical-order/\\n\\nActually this is a denary tree (each node has 10 children). Find the kth element is to do a k steps preorder traverse of the tree.\\n![0_1477293053966_upload-40379731-118a-4753-bed9-1cb372790d4b](/uploads/files/1477293057263-upload-40379731-118a-4753-bed9-1cb372790d4b.png) \\n\\nInitially, image you are at node 1 (variable: curr), \\nthe goal is move (k - 1) steps to the target node x.  (substract steps from k after moving)\\nwhen k is down to 0, curr will be finally at node x, there you get the result.\\n\\nwe don't really need to do a exact k steps preorder traverse of the denary tree, **the idea is to calculate the steps between curr and curr + 1 (neighbor nodes in same level), in order to skip some unnecessary moves.**\\n\\n**Main function**\\nFirstly, calculate how many steps curr need to move to curr + 1.\\n1. if the steps <= k, we know we can move to curr + 1, and narrow down k to k - steps.\\n\\n2. else if the steps > k, that means the curr + 1 is actually behind the target node x in the preorder path, we can't  jump to curr + 1. What we have to do is to move forward only 1 step (curr * 10 is always next preorder node) and repeat the iteration.\\n\\n\\n\\n**calSteps function**\\n\\n1.  how to calculate the steps between curr and curr + 1?\\n   Here we come up a idea to calculate by level.\\n   Let n1 = curr, n2 = curr + 1.\\n   n2 is always the next right node beside n1's right most node (who shares the same ancestor \"curr\")\\n(refer to the pic, 2 is right next to 1, 20 is right next to 19, 200 is right next to 199).\\n\\n   2. so, if n2 <= n, what means n1's right most node exists, we can simply add the number of nodes from n1 to n2 to steps.\\n\\n   3. else if n2 > n, what means n (the biggest node) is on the path between n1 to n2, add (n + 1 - n1) to  steps.\\n\\n   4. organize this flow to \"steps += Math.min(n + 1, n2) - n1; n1 *= 10; n2 *= 10;\"\\n\\n\\n\\n**Here is the code snippet:**\\n\\n    public int findKthNumber(int n, int k) {\\n        int curr = 1;\\n        k = k - 1;\\n        while (k > 0) {\\n            int steps = calSteps(n, curr, curr + 1);\\n            if (steps <= k) {\\n                curr += 1;\\n                k -= steps;\\n            } else {\\n                curr *= 10;\\n                k -= 1;\\n            }\\n        }\\n        return curr;\\n    }\\n    //use long in case of overflow\\n    public int calSteps(int n, long n1, long n2) {\\n        int steps = 0;\\n        while (n1 <= n) {\\n            steps += Math.min(n + 1, n2) - n1;\\n            n1 *= 10;\\n            n2 *= 10;\\n        }\\n        return steps;\\n    }"
		},
		{
			"lc_ans_id":"92254",
			"view":"4072",
			"top":"1",
			"title":"C++/Python 0ms O((log n)^2)-time O(1)-space super easy solution with detailed explanations",
			"vote":"33",
			"content":"This solution is inspired by @mgch's code.\\n\\n**General ideas:**\\n**1. Calculate the number of numbers that prefix with `result`.**\\n    Numbers prefixed by `result` are the union of the following intervals:\\n     [`result`, `result`+1)\\n     [`result`*10,  (`result`+1)*10 )\\n     [`result`*100,  (`result`+1)*100 )\\n    ...\\n    But they also shall belong to [1, n]\\n    Therefore, we can easily calculate the number of elements prefixed by `result` using the following code (not considering overflow):\\n\\n                int count = 0;\\n                for (int first = result, last = result + 1; // the first interval contains only one element: {result}\\n                    first <= n; // the interval is not empty\\n                    first *= 10, last *= 10) // increase a digit\\n                {\\n                    // valid interval = [first, last) union [first, n]\\n                    count += (min(n + 1, last) - first); // add the length of interval\\n                }\\n\\n**2. Search the next prefix, or search more detailedly.**\\n* If the number of numbers that prefixed by `result` is smaller than the remaining `k`, we do not need to consider the numbers prefixed by `result` any more, and march to the next prefix: `result`+1;\\n* Otherwise, we need to search more detailedly, by appending another digit to the prefix. Such search shall start with `result`*10.\\n\\n**C++**\\n\\n    class Solution {\\n    public:\\n        int findKthNumber(int n, int k)\\n        {\\n            int result = 1;\\n            for(--k; k > 0; )\\n            {\\n                // calculate #|{result, result*, result**, result***, ...}|\\n                int count = 0;\\n                for (long long first = static_cast<long long>(result), last = first + 1;\\n                    first <= n; // the interval is not empty\\n                    first *= 10, last *= 10) // increase a digit\\n                {\\n                    // valid interval = [first, last) union [first, n]\\n                    count += static_cast<int>((min(n + 1LL, last) - first)); // add the length of interval\\n                }\\n                \\n                if (k >= count)\\n                {   // skip {result, result*, result**, result***, ...}\\n                    // increase the current prefix\\n                    ++result;\\n                    k -= count;\\n                }\\n                else\\n                {   // not able to skip all of {result, result*, result**, result***, ...}\\n                    // search more detailedly\\n                    result *= 10;\\n                    --k;\\n                }\\n            }\\n            return result;\\n        }\\n    };\\n\\n**Python**\\n\\n    class Solution(object):\\n        def findKthNumber(self, n, k):\\n            result = 1;\\n            k -= 1\\n            while k > 0:\\n                count = 0\\n                interval = [result, result+1]\\n                while interval[0] <= n:\\n                    count += (min(n+1, interval[1]) - interval[0])\\n                    interval = [10*interval[0], 10*interval[1]]\\n                \\n                if k >= count:\\n                    result += 1\\n                    k -= count\\n                else:\\n                    result *= 10\\n                    k -= 1\\n            return result\\n\\n\\n\\n**Complexities:**\\n\\n* **Time Complexity:**   *O*( (log*n*) ^ 2 )\\nHere, log*n* is the number of digits in *n*, and it is also the number of replications of  appending zero to search detailedly. Each such appending introduces the increasement of prefix at most 10 times, and each increasement may require *O*(log*n*) time to calculate the number of numbers that prefixed by the `result`.\\n* **Space Complexity:** *O*(1)"
		},
		{
			"lc_ans_id":"92248",
			"view":"2857",
			"top":"2",
			"title":"Java 7ms denary(trie?) tree solution with detailed explanation",
			"vote":"5",
			"content":"There is a good explanation at  [there](https://discuss.leetcode.com/topic/64387/it-s-a-denary-tree).\\n\\nThe solution used DFS to search in a trie tree. The trick is to skip the sub-tree if the (current index + node number of the sub-tree) is smaller than the k.\\n\\nThe key problem is - How to count the nodes in a sub-tree?\\n\\nThe trie tree was made up of two kinds of sub-tree, the complete sub-tree with each node either has ten or zero children and the incomplete sub-tree with some inner nodes can has 1 to 9 children.\\n\\nThe complete tree's nodes number is easy to get, it will be something like 1, 11, 111, 1111...(each node has ten children plus the root)\\n\\nThe incomplete tree can be calculated like the flowing example:\\n\\nfor n = 213, the tree will be something like this:\\n\\n```\\n                                      $\\n  /                 /                /                 \\\\\\n 1                 2                 3                 [4 ~ 9]                                 \\n /\\\\                 /\\\\              /\\\\                  /\\\\\\n0, [1~9]         0,   1,[2~9]    0,[1~9]               ...\\n/      \\\\          /   /           \\n[0~9]  ...     [0~9] [0~3] \\n```\\n\\nthe sub-trees start with char '1' and '3'~'9' are complete trees, which '1' sub-tree with ranges in 1,10~19, 100~199 has 111 nodes and '3'~'9' each has 11 nodes (e.g. 3 with ranges in 3, 30~39).\\n\\nthe sub-tree starts with '2' is not full, i.e. the ranges are 2, 20~29, 200~213. But the '2' sub-tree still has a 'complete' tree like  '3'~'9' with range in 2, 20~29, and we just need to add the remained leaf nodes which is (213%200)+1 or (213-200)+1. \\n\\nThe 200 is the most left node in the '2' sub-tree and 299 is the most right node in '2' sub-tree if it is complete.  \\nit also showed the idea about how to judge a given sub-three is complete or incomplete:\\n\\nWe first **assume all sub-trees are complete** and test by following:\\n\\n```\\n{\\nif (the most right node in a sub-tree is not greater than the number n) \\n\\n    the sub-tree is complete with nodes number  = 111..(log10(n)+1 1s)\\n\\nelse if (the most left node in a sub-tree is greater than the number n) \\n\\n    the sub-tree is complete with nodes number  = 11...  (log10(n) 1s)\\n\\nelse\\n\\n    the sub-tree is incomplete with nodes number = \\nn - (the most left node in the subree) + 1 + 11... (log10(n) 1s)\\n}\\n```\\n\\nThe nodes number in a complete tree can be  [cached.](https://discuss.leetcode.com/topic/64419/3ms-c-solution) \\n\\nThen we just need to recursively decrease k by the nodes number of the skipped \\nsub-tree until k reached 1.\\n\\nAlso be carefully the first layer is start from 1 while other layers are start from 0.\\n\\n```\\npublic class Solution {\\n    int countNum(int n){\\n        int i=0;\\n        while(n>0){\\n            n/=10;\\n            i++;\\n        }\\n        return i;\\n    }\\n    int getFullTreeNum(int depth){\\n        int sum=0, children=1;\\n        while(depth>0){\\n            sum+=children;\\n            children*=10;\\n            depth--;\\n        }\\n        return sum;\\n    }\\n    int getMax(int prefix, int depth){\\n        while(depth>0){\\n            prefix*=10;\\n            prefix+=9;\\n            depth--;\\n        }\\n        return prefix;\\n    }\\n    int getMin(int prefix, int depth){\\n        while(depth>0){\\n            prefix*=10;\\n            depth--;\\n        }\\n        return prefix;\\n    }\\n    int helper(int n, int k, int prefix, int depth){\\n        int lowNum=getFullTreeNum(depth), highNum=getFullTreeNum(depth-1);\\n        for(int i=(prefix==0?1:0);i<=9;i++){\\n            int nodeNum=0;\\n            if(getMax(prefix*10+i, depth-1)<=n){\\n                nodeNum=lowNum;\\n            }\\n            else if(getMin(prefix*10+i, depth-1)>n){\\n                nodeNum=highNum;\\n            }\\n            else{\\n                nodeNum=highNum+((n-getMin(prefix*10+i, depth-1))+1);\\n            }\\n            k-=nodeNum;\\n            if(k<=0){\\n                k+=nodeNum;\\n                if(k==1){\\n                    return prefix*10+i;\\n                }\\n                else {\\n                    return helper(n, k-1, prefix*10+i, depth-1);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public int findKthNumber(int n, int k) {\\n        int depth=countNum(n);\\n        int index=0;\\n        return helper(n, k, 0, depth);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"92270",
			"view":"2383",
			"top":"3",
			"title":"It's a denary tree",
			"vote":"4",
			"content":"A naive solution is pre-order traversal of the tree. We can do better by skipping over a sub-tree if the k is larger than the number of nodes in that sub-tree + current index. \\n\\nFunction **count** does the part of counting number of nodes in a sub-tree given prefix of number in lexicographical order.\\n\\n```\\npublic class Solution {\\n    int index = 0;\\n    int ans = 0;\\n    public int findKthNumber(int n, int k) {\\n        for(int i=1;i<=9;i++) {\\n            int c = count(n, i, \"\");\\n            if(k>c+index) {\\n                index+=c;\\n                continue;\\n            }\\n            if(helper(n, k, \"\"+i)) break;\\n        }\\n        return ans;\\n    }\\n    public boolean helper(int n, int k, String cur) {\\n        index++;\\n        if(index==k) {\\n            ans = Integer.valueOf(cur);\\n            return true;\\n        }\\n        for(int i=0; i<=9; i++) {\\n            int c = count(n, i, cur);\\n            if(k>c+index) {\\n                index+=c;\\n                continue;\\n            }\\n            if(Integer.valueOf(cur+i)<=n) if(helper(n, k, cur+i)) return true;\\n        }\\n        return false;\\n    }\\n    public int count(int n, int i, String prefix) {\\n        long cur = Long.valueOf(prefix+i);\\n        int ans = 0;\\n        int number = 1;\\n        while(cur<=n) {\\n            ans += number;\\n            cur *= 10;\\n            number *= 10;\\n        }\\n        if(n<(cur/10+number/10-1)) ans -= cur/10+number/10-1-n;\\n        return ans;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"92255",
			"view":"578",
			"top":"4",
			"title":"C++ 0ms solution, digit by digit",
			"vote":"1",
			"content":"Let n = 1500, how many numbers has the prefix \\u201c1\\u201d and in the range of n?\\n10-19: 10\\n100-199: 100\\n1000-1999: 501\\nIf k <= 611, the answer has the prefix \"1\", otherwise, remove all the numbers have the prefix \"1\", and search the prefix \"2\".\\nTime complexity should be O(digits^3).\\n\\n``` CPP\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k, int start = 0) {\\n        if(k > 0) {\\n            for(int i = (start==0)?1:0; i <= 9; i++) { // append 0-9 to the prefix\\n                int count = numbersBeginWith(n, 10*start+i);\\n                if(k <= count) // if k <= count, the answer is begin with the prefix\\n                    return findKthNumber(n, k-1, 10*start+i);\\n                k -= count; // if the answer does not begin with the prefix, remove all the numbers begin with this prefix\\n            }\\n        }\\n        return start;\\n    }\\n    \\n    // return how many numbers are begin with the prefix and in the range of N\\n    int numbersBeginWith(int n, long long prefix) \\n    {\\n        long long fac = 1;\\n        int count = 0;\\n        for(int digit = 1; digit <= 9; digit++) {\\n            long long min = prefix*fac;\\n            long long max = prefix*fac+fac-1;\\n            if(n < min)\\n                break;\\n            else if(min <= n && n <= max) {\\n                count += (n-min+1);\\n                break;\\n            }\\n            else\\n                count += fac;\\n            fac *= 10;\\n        }\\n        return count;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"92261",
			"view":"273",
			"top":"5",
			"title":"Digit by digit java solution",
			"vote":"1",
			"content":"To start, let's denote the answer as `res`. Without much thinking, we know `res` will always be an integer in the range `[1, n]`, therefore it's possible to obtain its value **digit by digit**. To implement the idea, here are the two questions you may ask yourself:\\n1. Should we go from most significant digit (MSD) to least significant digit (LSD) or the other way around?\\n\\n2. What are the conditions for determining the value of each digit?\\n\\nFor the first question, since the numbers will be arranged in lexicographical order, which means they will be compared from MSD to LSD, going in the same direction will be a wise choice (Otherwise later comparisons may override prior ones).\\n\\nAs to the second one, we can proceed in a \"trial and error\" fashion since there are at most `10` choices (`0 - 9`) for each digit (note `MSD` cannot be `0`). Okay, which one should go first, `0` or `9`? Remember we were asked to get the `k-th` smallest integer, so obviously we'd like to try from `0` up to `9`.\\n\\nBut how exactly do we choose the value for each digit? The principle is simple: count the total number of integers that have the same prefix as the current value of `res`, yet no more than `n`. For example, if `res = 0`, we count all integers starting with `1` (such as `1`, `10`, `100`,...),  then with `2` (such as `2`, `20`, `200`...), then with `3`, ..., up to `9` (`note` if `res = 0`, the digit will be MSD so it cannot be `0`); If `res = 13`, we will count all integers starting with `130` such as `130`, `1300`, `13500`, ..., then with `131` like `131`, `1310`,..., up to `139` (and of course `1390`, ...). For a given `k`, if the total count starting with (`res * 10 + i`), where `0 <= i <= 9`, is no less than `k`, then the next digit of `res` will be set as `i`, i.e., `res = res * 10 + i`. Otherwise subtract that total number from `k` and continue with `i` increased by `1`. Eventually `k` will be reduced to `1` and the corresponding value of `res` will be the `k-th` smallest integer in the lexicographical order.\\n\\nAll right, it looks like we are almost there except for how to count the total number of integers with some given prefix. Here is a quick idea: let the prefix be `res` and initially we have a count of `0`. First add one digit to the end of `res` to form a new integer (the value of the digit can be `0 - 9`) and check if the maximum one (i.e. digit added with value `9`) is no more than `n`. If so, increase count by `10` and continue adding another digit to each of the newly-obtained integers above (from smallest to largest) like doing \"DFS\", until the integer value exceeds `n`. As you can see, for each digit added, the total count for that particular digit will be ten times as that of the previous one. One tricky case is for some digit it cannot take all values up to `9` as doing so would render the number greater than `n`. In such cases we only count values that make the number no more than `n`.\\n\\nLet's do an example: let `res = 13`, `n = 1350` and `count = 0`. Adding one digit to `res` and  check its maximum value `139 < 1350`, so `count = 10`. Then adding another digit and again check its maximum value `1399 > 1350` so now we only retain those valid counts which are from `1300` up to `1350` so `count = 10 + (1350 - 1300 + 1) = 61`. \\n\\nFinally here is the java program for this digit by digit solution:\\n```\\npublic int findKthNumber(int n, int k) {\\n    int res = 0;\\n    \\n    do {\\n    \\tres *= 10;\\n    \\tint i = (res == 0 ? 1 : 0);\\n    \\t\\n    \\tfor (int count; i < 10; i++) {\\n            long base = 1, max = (res + i + 1) * base - 1;\\n            for (count = 0; max <= n; base *= 10, max = (res + i + 1) * base - 1) count += base;\\n            if (n >= (res + i) * base) count += (n - (res + i) * base + 1);\\n            if (k <= count) break;\\n            k -= count;\\n        }\\n    \\t\\t\\n    \\tres += i;\\n    \\t\\t\\n    } while (k-- > 1);\\n    \\t\\n    return res;\\n}\\n```\\nSome explanation of the program:\\n1. res is the final result, which is initialized to 0. \\n2. At the beginning of the do-while loop,  we shift res one digit to the left so we can determine the value of its current LSD. Also if res is 0, we are up to find the MSD of the final result so the starting digit value will be 1 instead of 0.\\n3. We then count the total number of integers starting with (res + i) and determine the digit value i. Here base denotes how many digits have been shifted and max is the maximum value with that many digits shifted (with prefix, of course). After counting the normal cases we then double check the corner cases when some of the digit values do not yield valid counts.\\n4. We set the corresponding digit value of res and continue until k is 1.\\n\\nCorrect me if I was wrong: time complexity is (logn)^2, which can be analyzed as follows: let T(n) be the original problem. For each digit, the total counts for each value are roughly equal so T(n) will be reduced to T(n/10) in logn time, i.e., T(n) = T(n/10) + O(logn) and by Master's theorem we have T(n) = O((logn)^2).\\n\\nAdvanced perspective: all the numbers can be arranged into a denary tree. The sequence 1, 2, .., n will be the result of level order traversal while the sequence of lexicographical order will be preorder traversal. Of course naive simulation of preorder traversal will result  in either TLE or StackOverFlow. The right way is again to count the total number of nodes in the subtrees for each node and choose the proper subtree to continue. Since each subtree is a complete tree, it is possible to obtain its total nodes in time proportional to its height, which is logn time with n the total number of nodes. For more details you can refer to [pureklkl](https://discuss.leetcode.com/topic/64539/java-7ms-denary-trie-tree-solution-with-detailed-explanation)'s post."
		},
		{
			"lc_ans_id":"92263",
			"view":"239",
			"top":"6",
			"title":"Hint - size of subtree",
			"vote":"1",
			"content":"So, we arrange numbers in a tree. If we know the size (the number of nodes) of every subtree, we can navigate the tree to find the digits of the target number.\\n\\nSuppose `n=4xx`. It's easy to see that any subtree rooted at `1,2,3` has a size of `111`, and any subtree rooted at `5,6,7,8,9` has a size of `11`. -- What about the subtree at `4`?\\n\\nSince the size of all subtrees at this level is `n`, the size of subtree rooted at `4` is `n-3*111-5*11`.\\n\\nGiven any `k`, we can easily find the first digit of the solution. We then adjust `n` and `k`, and descend to a lower level to find other digits."
		},
		{
			"lc_ans_id":"92267",
			"view":"859",
			"top":"7",
			"title":"Easy to understand JS solution",
			"vote":"1",
			"content":"```\\n// Calculates the amount of\\n// numbers <= n that starts with prefix.\\n\\nfunction countForPrefix (n, prefix) {\\n    let a = parseInt(prefix);\\n    let b = a + 1;\\n    if (a > n || a === 0)\\n        return 0;\\n\\n    let res = 1;\\n    a *= 10; b *= 10;\\n    while (a <= n) {\\n        res += Math.min(n + 1, b) - a;\\n        a *= 10; b *= 10;\\n    }\\n\\n    return res;\\n}\\n\\n// Constructs resulting number digit by digit\\n// starting with the most significant.\\n\\nfunction findKthNumber (n, k) {\\n    let i, prefix = '';\\n    while (k !== 0) {\\n        for (i = 0; i <= 9; i++) {\\n            const count = countForPrefix(n, prefix + i);\\n            if (count < k)\\n                k -= count;\\n            else\\n                break;\\n        }\\n        prefix = prefix + i;\\n        k--; // number equal to prefix\\n    }\\n\\n    return parseInt(prefix, 10);\\n}\\n```"
		},
		{
			"lc_ans_id":"92243",
			"view":"55",
			"top":"8",
			"title":"Java 5ms recursive solution traversing the DFS tree generating the lexicographical items",
			"vote":"0",
			"content":"```\\nclass Solution {\\n    private static int[] treeSize = new int[10];\\n    private static int[] pows = new int[10];\\n    \\n    static {\\n        treeSize[0] = 1;\\n        pows[0] = 1;\\n        for (int a = 1; a <= 9; ++a) {\\n            pows[a] = pows[a - 1] * 10;\\n            treeSize[a] = treeSize[a - 1]+pows[a];\\n        }\\n    }\\n    \\n    public int findKthNumber(int n, int k) {\\n        int pow = 0;\\n        for (int a = n/10; a > 0; a /= 10, ++pow) ;\\n        return findKthNumber(n, n, k - 1, pow, 1, 0);\\n    }\\n\\n    private int findKthNumber(int n, int size, int k, int pow, int lo, int pfx) {\\n        if (k < 0){\\n            return pfx;\\n        }\\n        if (pow == 0) {\\n            return 10 * pfx + lo + k;\\n        }\\n        int msd = n / pows[pow];\\n        int before = (msd - lo) * treeSize[pow];\\n        int after = (Math.min(size, 9) - msd) * treeSize[pow - 1];\\n        int mid = size - before - after;\\n        if (k < before) {\\n            return findInCompleteTree(k - 1 - (k / treeSize[pow]) * treeSize[pow], pow - 1, 10 * pfx + lo + k / treeSize[pow]);\\n        }\\n        if (k < before + mid) {\\n            return findKthNumber(n - msd * pows[pow], mid - 1, k - before - 1, pow - 1, 0, 10 * pfx + msd);\\n        }\\n        return findInCompleteTree(k - 1 - before - mid - ((k-before-mid)/ treeSize[pow-1]) * treeSize[pow-1], pow - 2, 10 * pfx + msd + 1 + (k - before - mid) / treeSize[pow - 1]);\\n    }\\n\\n    private int findInCompleteTree(int k, int pow, int pfx) {\\n        if (k < 0){\\n            return pfx;\\n        }\\n        if (pow == 0) {\\n            return 10 * pfx + k;\\n        }\\n        return findInCompleteTree(k - 1 - (k/treeSize[pow])*treeSize[pow], pow - 1, 10 * pfx + k / treeSize[pow]);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"92244",
			"view":"104",
			"top":"9",
			"title":"C++ Worst Case O(logN) Time O(logN) Space Clean Solution w/ Detailed Explanation.",
			"vote":"0",
			"content":"```\\n/// O(log10(N)) Time & Space\\n/// The main idea to simplify the implementation is, when count, start with empty then 0's at a certain length;\\n/// E.g. when do n = 345, k = 250, instead of counting from 1, 10, 100, ...., count from EMPTY, 0, 00, 000, 001, 002..09, 091, 092, ..099, 1\\n/// Therefore, I count 112 (there is an EMPTY at first) more than you should. So I add this difference first;\\n/// The reason why I do it this way is it will greatly simplify the implementation later.\\n/// Suppose I'm in an intermediate round, I have prevdigs = 3. I want to calculate solve(45, 27) now,\\n/// because there is a leading digit, it makes 0, 00 or even EMPTY valid now -- they can make 30, 300, 3 respectively.\\n/// So in all intermediate rounds, it's beneficial to consider 0, 00, EMPTY before 1XX. The only exceptional round is the first one.\\n/// So I just need to do some manipulate with the first round, then we are all good.\\nclass Solution {\\n    int solve(int n, int k, int prevdigs, int len) /// prevdigs are all digits known so far.\\n    {\\n        if (k == 0)          /// in this function, k = 0 means the 1st number.\\n            return prevdigs; /// e.g. 3XX's 0th string is 3; just the prevdigs;\\n        k --;                /// take account of the \"3XX's 0th\" case. minus one here to make the code below cleaner.\\n        if (len == 1)        /// the ending condition of recursion. For 1 digit number, just get k;\\n            return prevdigs*10 + k;\\n        /// suppose n = 345 in all comments below;\\n        int whole = pow(10, len - 1); /// 100\\n        int sigdig = n / whole;       /// 3\\n        int remain = n % whole;       /// 45\\n        int allones_1 = (whole - 1) / 9;  /// 11\\n        int allones_0 = allones_1*10 + 1; /// 111\\n        int allones_2 = allones_1 / 10;   /// 1\\n        int low_bar =  allones_0 * sigdig; /// 111 * 3 = 333 The number of strs before 3 (containing 111 digits starting with 0)\\n        int high_bar = low_bar + allones_1 + remain + 1; /// 333 + 11 + 45 + 1 (11 is 3, 30, 31 ... 39)\\n        if (k < low_bar)   /// k is before 3\\n        {\\n            int curdig = k / allones_0; /// figure out the current digit is 0, 1 or 2;\\n            return solve(allones_1 * 9, k % allones_0, prevdigs*10 + curdig, len - 1); /// allones_1 * 9 makes 99, meaning search everything\\n        }                                                                              /// with length len-1\\n        if (k >= high_bar) /// k is after 39 (largest in 3XX)\\n        {\\n            k -= high_bar;\\n            int curdig = sigdig + k / allones_1 + 1; /// figure out the current digit among 4~9;\\n            return solve(allones_2 * 9, k % allones_1, prevdigs * 10 + curdig, len - 2); ///allones_2 * 9 makes 9, meaning search everything\\n        }                                                                                ///with length len-2\\n        k -= low_bar;\\n        int curdig = sigdig;\\n        return solve(remain, k, prevdigs * 10 + curdig, len - 1); /// search in 45 with length 2;\\n    }\\npublic:\\n    int findKthNumber(int n, int k)\\n    {\\n        int len = 0; /// length of n\\n        for(int m = n; m > 0; m/= 10, ++len);\\n        k += (pow(10, len) - 1)/9; /// solve function considers 0's before 1; we make up this difference first;\\n        return solve(n, k, 0, len); ///len is important, o/w when k = 5 in a middle round, you don't know it's X005 or X05,\\n    }                               ///they have different number of 0s before them\\n};\\n\\n```"
		}
	],
	"id":"434",
	"title":"K-th Smallest in Lexicographical Order",
	"content":"<p>Given integers <code>n</code> and <code>k</code>, find the lexicographically k-th smallest integer in the range from <code>1</code> to <code>n</code>.</p>\r\n\r\n<p>Note: 1 &le; k &le; n &le; 10<sup>9</sup>.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b>\r\nn: 13   k: 2\r\n\r\n<b>Output:</b>\r\n10\r\n\r\n<b>Explanation:</b>\r\nThe lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\r\n</pre>\r\n</p>\r\n",
	"frequency":"241",
	"ac_num":"5497"
}