{
	"difficulty":"2",
	"submit_num":"44874",
	"show_id":"444",
	"leetcode_id":"444",
	"answers":[
		{
			"lc_ans_id":"92580",
			"view":"9356",
			"top":"0",
			"title":"Java Solution using BFS Topological Sort",
			"vote":"46",
			"content":"```\\npublic class Solution {\\n    public boolean sequenceReconstruction(int[] org, int[][] seqs) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        Map<Integer, Integer> indegree = new HashMap<>();\\n        \\n        for(int[] seq: seqs) {\\n            if(seq.length == 1) {\\n                if(!map.containsKey(seq[0])) {\\n                    map.put(seq[0], new HashSet<>());\\n                    indegree.put(seq[0], 0);\\n                }\\n            } else {\\n                for(int i = 0; i < seq.length - 1; i++) {\\n                    if(!map.containsKey(seq[i])) {\\n                        map.put(seq[i], new HashSet<>());\\n                        indegree.put(seq[i], 0);\\n                    }\\n\\n                    if(!map.containsKey(seq[i + 1])) {\\n                        map.put(seq[i + 1], new HashSet<>());\\n                        indegree.put(seq[i + 1], 0);\\n                    }\\n\\n                    if(map.get(seq[i]).add(seq[i + 1])) {\\n                        indegree.put(seq[i + 1], indegree.get(seq[i + 1]) + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(Map.Entry<Integer, Integer> entry: indegree.entrySet()) {\\n            if(entry.getValue() == 0) queue.offer(entry.getKey());\\n        }\\n\\n        int index = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            if(size > 1) return false;\\n            int curr = queue.poll();\\n            if(index == org.length || curr != org[index++]) return false;\\n            for(int next: map.get(curr)) {\\n                indegree.put(next, indegree.get(next) - 1);\\n                if(indegree.get(next) == 0) queue.offer(next);\\n            }\\n        }\\n        return index == org.length && index == map.size();\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"92574",
			"view":"7935",
			"top":"1",
			"title":"Very short solution with explanation",
			"vote":"44",
			"content":"\\nFor `org` to be uniquely reconstructible from `seqs` we need to satisfy 2 conditions:\\n1. Every sequence in `seqs` should be a subsequence in `org`. This part is obvious.\\n2. Every 2 consecutive elements in `org` should be consecutive elements in some sequence from `seqs`. Why is that? Well, suppose condition 1 is satisfied. Then for 2 any consecutive elements `x` and `y` in `org` we have 2 options.\\n   * We have both `x`and `y` in some sequence from `seqs`. Then (as condition 1 is satisfied) they must be consequtive elements in this sequence.\\n   * There is no sequence in `seqs` that contains both `x` and `y`. In this case we cannot uniquely reconstruct `org` from `seqs` as sequence with `x` and `y` switched would also be a valid original sequence for `seqs`.\\n\\nSo this are 2 necessary criterions. It is pretty easy to see that this are also sufficient criterions for `org` to be uniquely reconstructible (there is only 1 way to reconstruct sequence when we know that condition 2 is satisfied).\\n\\nTo implement this idea I have `idxs` hash that maps item to its index in `org` sequence to check condition 1. And I have `pairs` set that holds all consequitive element pairs for sequences from `seqs` to check condition 2 (I also consider first elements to be paired with previous `undefined` elements, it is necessary to check this).\\n\\n```\\nvar sequenceReconstruction = function(org, seqs) {\\n    const pairs = {};\\n    const idxs = {};\\n    \\n    for (let i = 0; i < org.length; i++)\\n        idxs[org[i]] = i;\\n\\n    for (let j = 0; j < seqs.length; j++) {\\n        const s = seqs[j];\\n        for (let i = 0; i < s.length; i++) {\\n            if (idxs[s[i]] == null)\\n                return false;\\n            if (i > 0 && idxs[s[i - 1]] >= idxs[s[i]])\\n                return false;\\n            pairs[`${s[i - 1]}_${s[i]}`] = 1;\\n        }\\n    }\\n\\n    for (let i = 0; i < org.length; i++)\\n        if (pairs[`${org[i - 1]}_${org[i]}`] == null)\\n            return false;\\n\\n    return true;\\n};\\n```"
		},
		{
			"lc_ans_id":"92572",
			"view":"4614",
			"top":"2",
			"title":"Simple Solution : one-pass, using only array (C++ 92ms, Java 16ms)",
			"vote":"28",
			"content":"After reading a few posts on this topic, I guess most of people over-think about this problem.\\n\\nIMHO, We don't need to implement any graph theory expressively here; rather, it is sufficient to just check if every two adjacent elements also appears adjacently in the sub-sequences. (and of course, some basic boundary checking is also necessary)\\n\\nin C++:\\n```\\n    bool sequenceReconstruction(vector<int>& org, vector<vector<int>>& seqs) {\\n        if(seqs.empty()) return false;\\n        vector<int> pos(org.size()+1);\\n        for(int i=0;i<org.size();++i) pos[org[i]] = i;\\n        \\n        vector<char> flags(org.size()+1,0);\\n        int toMatch = org.size()-1;\\n        for(const auto& v : seqs) {\\n            for(int i=0;i<v.size();++i) {\\n                if(v[i] <=0 || v[i] >org.size())return false;\\n                if(i==0)continue;\\n                int x = v[i-1], y = v[i];\\n                if(pos[x] >= pos[y]) return false;\\n                if(flags[x] == 0 && pos[x]+1 == pos[y]) flags[x] = 1, --toMatch;\\n            }\\n        }\\n        return toMatch == 0;\\n    }\\n```\\nin Java:\\n```\\n    public boolean sequenceReconstruction(int[] org, int[][] seqs) {\\n        if(seqs.length == 0) return false; \\n        int[] pos = new int[org.length+1];\\n        for(int i=0;i<org.length;++i) pos[org[i]] = i;\\n        boolean[] flags = new boolean[org.length+1];\\n        int toMatch = org.length-1;\\n        for(int[] v : seqs) {\\n            for(int i=0;i<v.length;++i) {\\n                if(v[i]<=0 || v[i] > org.length)return false;\\n                if(i==0)continue;\\n                int x = v[i-1], y = v[i];\\n                if(pos[x] >= pos[y])return false;\\n                if(flags[x] == false && pos[x]+1 == pos[y]) {\\n                    flags[x] = true;\\n                    --toMatch;\\n                }\\n            }\\n        }\\n        return toMatch == 0;\\n    }\\n```"
		},
		{
			"lc_ans_id":"92611",
			"view":"2013",
			"top":"3",
			"title":"Java O(n) time,O(n) space AC solution 14ms like count sort",
			"vote":"9",
			"content":"The basic idea is to count how many numbers are smaller(self include) than the current number.\\nWe then compare this count to the org.\\nIt is pretty like the idea of count sort.\\n```\\npublic class Solution {\\n    public boolean sequenceReconstruction(int[] org, int[][] seqs) {\\n        int len = org.length;\\n        int[] map = new int[len + 1];//map number to its index\\n        Arrays.fill(map, -1);\\n        int[] memo = new int[org.length];//count how many numbers are smaller(on the right)\\n        for (int i = 0; i < len; i++) {\\n            map[org[i]] = i;\\n        }\\n        for (int[] seq : seqs) {\\n            if (seq.length == 0) continue;\\n            int prev = seq[0];\\n            if (prev <= 0 || prev > len || map[prev] == -1) return false;\\n            for (int i = 1; i < seq.length; i++) {\\n                int curr = seq[i];\\n                if (curr <= 0 || curr > len || map[curr] == -1) return false;\\n                memo[map[prev]] = Math.max(memo[map[prev]], len - map[curr] + 1);\\n                prev = curr;\\n            }\\n            memo[map[prev]] = Math.max(memo[map[prev]], 1);\\n        }\\n        for (int i = 0; i < memo.length; i++) {\\n            if (memo[i] != len - i) return false;\\n        }\\n        return true;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"92582",
			"view":"1728",
			"top":"4",
			"title":"C++ concise topological sort solution with comment",
			"vote":"7",
			"content":"Any suggestions will be appreciated\\n~~~\\nclass Solution {\\npublic:\\n    bool sequenceReconstruction(vector<int>& org, vector<vector<int>>& seqs) {\\n        if (seqs.size() == 0) return false;\\n        int n = org.size(), count = 0;\\n        unordered_map<int, unordered_set<int>> graph;   // record parents\\n        vector<int> degree(n+1, 0); // record out degree\\n        for (auto s : seqs) {   // build graph\\n            for (int i = s.size()-1; i >= 0; --i) {\\n                if (s[i] > n or s[i] < 0) return false; // in case number in seqs is out of range 1-n\\n                if (i > 0 and !graph[s[i]].count(s[i-1])) {\\n                    graph[s[i]].insert(s[i-1]);\\n                    if (degree[s[i-1]]++ == 0) count ++;\\n                }\\n            }\\n        }\\n        if (count != n-1) return false; // all nodes should have degree larger than 0 except the last one\\n        for (int i = n-1; i >= 0; --i) {    // topological sort\\n            if (degree[org[i]] > 0) return false;   // the last node should have 0 degree\\n            for (auto p : graph[org[i]]) \\n                if (--degree[p] == 0 and p != org[i-1]) // found a node that is not supposed to have 0 degree\\n                    return false;\\n        }\\n        return true;\\n    }\\n};\\n~~~"
		},
		{
			"lc_ans_id":"92576",
			"view":"647",
			"top":"5",
			"title":"Understanding the problem",
			"vote":"4",
			"content":"**EXAMPLE 1**\\nseqs = `[[1,2], [1,3]]`\\n\\n**Question:** Using `seqs`, what are the shortest common supersequences we can make?\\n**Answer:** `[1,2,3]` and `[1 3 2]`.\\n\\n**Explanation:**\\n- `[1,2,3]` is valid, since every sequence in `seqs` is a subsequence of `[1,2,3]`\\n```\\n[1,2,3]    [1,2,3]\\n * *        *   *\\n```\\n\\n- `[1,3,2]` is valid since every sequence in `seqs` is a subsequence of `[1,3,2]`\\n```\\n[1,3,2]    [1,3,2]\\n *   *      * *\\n```\\n\\n**Solution:** `False` - there are multiple such supersequences.\\n\\n_______________________________________________\\n\\n**EXAMPLE 3**\\nseqs = `[[1,2],[1,3],[2,3]]`\\n\\n**Question:** Using `seqs`, what are the shortest common supersequences we can make?\\n**Answer:** `[1,2,3]`\\n\\n**Explanation:**\\n- `[1,2,3]` is valid since every sequence in `seqs` is a subsequence of `[1,2,3]`\\n```\\n[1,2,3]    [1,2,3]    [1,2,3]\\n * *        *   *        * *\\n```\\n**Solution:** `True` - solution is unique and equal to target `[1,2,3]`."
		},
		{
			"lc_ans_id":"92578",
			"view":"562",
			"top":"6",
			"title":"Brief python solution using topological sort",
			"vote":"4",
			"content":"The basic is to get topological sort of seqs nodes, if it is unique and equal to org, then true, else False\\n\\nFollowing is how to implement in details:\\n\\nin each step,\\nif we have more than one node whose incoming nodes count is zero then org is not unique, return False\\n\\nAt last we check if the topological sort contain all nodes in the in seqs and equal to org\\n```\\nfrom collections import defaultdict\\n\\n\\nclass Solution(object):\\n    def sequenceReconstruction(self, org, seqs):\\n        \"\"\"\\n        :type org: List[int]\\n        :type seqs: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        adjacent = defaultdict(list)\\n        incoming_nodes = defaultdict(int)\\n        nodes = set()\\n        for arr in seqs:\\n            nodes |= set(arr)\\n            for i in xrange(len(arr)):\\n                if i == 0:\\n                    incoming_nodes[arr[i]] += 0\\n                if i < len(arr) - 1:\\n                    adjacent[arr[i]].append(arr[i + 1])\\n                    incoming_nodes[arr[i + 1]] += 1\\n        cur = [k for k in incoming_nodes if incoming_nodes[k] == 0]\\n        res = []\\n        while len(cur) == 1:\\n            cur_node = cur.pop()\\n            res.append(cur_node)\\n            for node in adjacent[cur_node]:\\n                incoming_nodes[node] -= 1\\n                if incoming_nodes[node] == 0:\\n                    cur.append(node)\\n        if len(cur) > 1:\\n            return False\\n        return len(res) == len(nodes) and res == org\\n```"
		},
		{
			"lc_ans_id":"92593",
			"view":"286",
			"top":"7",
			"title":"Since they updated this question. Here is a modified Topological solution and another simple solution in Java.",
			"vote":"2",
			"content":"They update `int[][] seqs` to `List<List<Integer>>`, and add new test cases like `[[][]]`. So, I modified my solution accordingly:\\n\\nThis is Topological solution:\\n```\\npublic class Solution {\\n    public boolean sequenceReconstruction(int[] org, List<List<Integer>> seqs) {\\n        if (org == null || org.length == 0) return seqs == null || seqs.size() == 0;\\n        if (seqs == null || seqs.size() == 0) return org == null || org.length == 0;\\n        int n = org.length;\\n        Set<Integer> vis = new HashSet();\\n        List<List<Integer>> graph = new ArrayList(n + 1);\\n        int[] inDegree = new int[n + 1];\\n        // init\\n        for (int i = 0; i <= n; i++) {\\n            graph.add(new ArrayList());\\n        }\\n        \\n        for (List<Integer> seq : seqs) {\\n            for (int i = 0; i < seq.size(); i++) {\\n                vis.add(seq.get(i));\\n                if (i + 1 < seq.size()) {\\n                    if (seq.get(i) > n || seq.get(i) <= 0 || seq.get(i + 1) > n || seq.get(i + 1) <= 0) return false;\\n                    graph.get(seq.get(i)).add(seq.get(i + 1));\\n                    inDegree[seq.get(i + 1)]++;\\n                }\\n            }\\n        }\\n        \\n        // start point\\n        if (inDegree[org[0]] != 0 || vis.size() != n) return false;\\n        \\n        Queue<Integer> q = new ArrayDeque();\\n        for (int i = 1; i <= n; i++) {\\n            if (inDegree[i] == 0) q.offer(i);\\n        }\\n        \\n        // traverse graph\\n        int idx = 0;\\n        while (!q.isEmpty()) {\\n            if (q.size() != 1) return false;\\n            int from = q.poll();\\n            if (idx >= n || org[idx++] != from) return false;\\n            for (int to : graph.get(from)) { // all \"to\" nodes\\n                inDegree[to]--;\\n                if (inDegree[to] == 0) q.offer(to);\\n            }\\n        }\\n        \\n        return idx == n;\\n    }\\n}\\n```\\n\\nThis is another simple solution from [here](https://discuss.leetcode.com/topic/65633/very-short-solution-with-explanation):\\n\\n```\\npublic class Solution {\\n    public boolean sequenceReconstruction(int[] org, List<List<Integer>> seqs) {\\n        if (seqs == null || seqs.size() == 0) return org == null || org.length == 0;\\n        int n = org.length;\\n        int[] idx = new int[n + 1];\\n        boolean[] pair = new boolean[n];\\n        Set<Integer> vis = new HashSet();\\n        \\n        for (int i = 0; i < n; i++) {\\n            idx[org[i]] = i;\\n        }\\n        \\n        for (List<Integer> seq : seqs) {\\n            for (int i = 0; i < seq.size(); i++) {\\n                vis.add(seq.get(i));\\n                if (seq.get(i) <= 0 || seq.get(i) > n) return false;\\n                if (i > 0 && idx[seq.get(i - 1)] >= idx[seq.get(i)]) return false;\\n                if (i > 0 && idx[seq.get(i - 1)] + 1 == idx[seq.get(i)]) pair[idx[seq.get(i - 1)]] = true;\\n            }\\n        }\\n        \\n        if (vis.size() != n) return false;\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            if (!pair[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"92600",
			"view":"196",
			"top":"8",
			"title":"C++ one pass solution with explanation and comments",
			"vote":"2",
			"content":"The idea is to build the graph and keep track of in-degrees of all the graph nodes. If the original sequence can be uniquely reconstructed, then we should be able to traverse each node in the graph in a deterministic fashion (instead of having to do a graph search):\\n\\n* There should be exactly one node with 0 in-degree, org[0], and this is the starting point to visit.\\n* When visiting node i, for each directed edge (i, j), we reduce j's in-degree by 1. This effectively removes node i from the graph. If j's in-degree becomes 0, then j is the next node to visit. \\n    * However, if there are more than one nodes with 0 in-degree, we should return false, because there is not an order dependency between these 0-in-degree nodes and therefore the original sequence cannot be uniquely reconstructed. \\n    * Similarly, if there is no such j, then either we reach the end or we are stuck. We will look at how many nodes we have visited to determine which is the case.\\n\\n* Nodes are integers from 1 to n. So to avoid MLE, we can use vectors instead of hashmaps to keep track of the states without sacrificing lookup time.\\n* This algorithm can also determine if ```seqs``` uniquely identifies an original sequence, even if ```org``` is not given.\\n\\n```\\n    bool sequenceReconstruction(vector<int>& org, vector<vector<int>>& seqs) {\\n    \\tif (seqs.empty())\\n    \\t    return false;\\n        int n = org.size();\\n        vector<int> inDegreeOf(n+1, 0);\\n        vector<set<int>> childrenOf(n+1);\\n\\n        for (auto seq : seqs) {\\n            for (int i = 0; i < seq.size(); i++) {\\n                /// check if a node is out of range\\n        \\tif (seq[i] < 1 || seq[i] > n)\\n           \\t    return false;\\n                // each pair of consecutive numbers give us an order dependency, represented by a directed edge in the graph\\n        \\tif (i > 0 && childrenOf[seq[i-1]].find(seq[i]) == childrenOf[seq[i-1]].end()) {\\n\\t    \\t    childrenOf[seq[i-1]].insert(seq[i]);\\n\\t\\t    inDegreeOf[seq[i]]++;\\n\\t\\t}\\n            }\\n        }\\n\\n        // cur should have 0 in-degree, and we want to make sure we always have exactly one child to visit\\n        int cur = org[0], countToVisit = 1;\\n\\tif (inDegreeOf[cur] != 0)\\n\\t    return false;\\n\\n        while (countToVisit == 1) {\\n            countToVisit = 0;\\n            set<int> children = childrenOf[cur];\\n            for (auto child : children) {\\n                // removing cur from the graph, and determine the next node to visit\\n        \\tinDegreeOf[child]--;\\n        \\tif (inDegreeOf[child] == 0) {\\n           \\t    countToVisit++;\\n        \\t    cur = child;\\n        \\t}\\n            }\\n            n--;\\n        }\\n        // if we break out of the loop early, n > 0; if there is an edge from end node to another node, then n < 0\\n        // return true only if n==0\\n        return n == 0;\\n    }\\n```"
		},
		{
			"lc_ans_id":"92591",
			"view":"1256",
			"top":"9",
			"title":"WHF! I can not figured out why MLE for the simple test case",
			"vote":"2",
			"content":"```\\nclass Solution {\\npublic:\\n    bool sequenceReconstruction(vector<int>& org, vector<vector<int>>& seqs) {\\n        unordered_map<int, unordered_set<int>> graph;\\n        unordered_map<int, int> degree;\\n        for (auto& s : seqs) {\\n            for (int i = 0; i < s.size(); i++) {\\n                if (!degree.count(s[i])) degree[s[i]] = 0;\\n                if (i == s.size() - 1 || graph[s[i]].count(s[i + 1])) continue;\\n                graph[s[i]].insert(s[i + 1]);\\n                degree[s[i + 1]]++;\\n            }    \\n        }\\n        int start = -1, counts = 0, index = 0, times = 0;\\n        for (auto& d : degree) {\\n            if (!d.second) {\\n                if (counts++ == 1) return false;\\n                degree[d.first] = -1;\\n                start = d.first;\\n                times++;\\n            }\\n        }\\n        if (!counts || index >= org.size() || org[index++] != start) return false;\\n        while (!graph[start].empty()) {\\n            counts = 0;\\n            for (auto neigh : graph[start]) {\\n                if (--degree[neigh] == 0) {\\n                    if (counts++ == 1) return false;\\n                    start = neigh;\\n                    times++;\\n                }\\n            }\\n            if (!counts || index >= org.size() || org[index++] != start) return false;\\n        }\\n        return index == org.size() && times == degree.size();\\n    }\\n};\\n```\\n\\nI can not figure out why It memory limited exceed for :\\n[1]\\n[[1,-9999],[-9999,-9998],[-9998,-9999]]\\n\\nI just test step by step, it return false directly in my computer. I can not figure out why it MLE in leetcode.\\n\\nWHT!!"
		}
	],
	"id":"438",
	"title":"Sequence Reconstruction",
	"content":"<p>Check whether the original sequence <code>org</code> can be uniquely reconstructed from the sequences in <code>seqs</code>. The <code>org</code> sequence is a permutation of the integers from 1 to n, with 1 &le; n &le; 10<sup>4</sup>. Reconstruction means building a shortest common supersequence of the sequences in <code>seqs</code> (i.e., a shortest sequence so that all sequences in <code>seqs</code> are subsequences of it). Determine whether there is only one sequence that can be reconstructed from <code>seqs</code> and it is the <code>org</code> sequence.</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\n<b>Input:</b>\r\norg: [1,2,3], seqs: [[1,2],[1,3]]\r\n\r\n<b>Output:</b>\r\nfalse\r\n\r\n<b>Explanation:</b>\r\n[1,2,3] is not the only one sequence that can be reconstructed, because [1,3,2] is also a valid sequence that can be reconstructed.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\n<b>Input:</b>\r\norg: [1,2,3], seqs: [[1,2]]\r\n\r\n<b>Output:</b>\r\nfalse\r\n\r\n<b>Explanation:</b>\r\nThe reconstructed sequence can only be [1,2].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b>\r\n<pre>\r\n<b>Input:</b>\r\norg: [1,2,3], seqs: [[1,2],[1,3],[2,3]]\r\n\r\n<b>Output:</b>\r\ntrue\r\n\r\n<b>Explanation:</b>\r\nThe sequences [1,2], [1,3], and [2,3] can uniquely reconstruct the original sequence [1,2,3].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 4:</b>\r\n<pre>\r\n<b>Input:</b>\r\norg: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]]\r\n\r\n<b>Output:</b>\r\ntrue\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b><font color=\"red\">UPDATE (2017/1/8):</font></b><br />\r\nThe <i>seqs</i> parameter had been changed to a list of list of strings (instead of a 2d array of strings). Please reload the code definition to get the latest changes.\r\n</p>",
	"frequency":"21",
	"ac_num":"8822"
}