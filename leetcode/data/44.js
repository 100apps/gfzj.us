{
	"difficulty":"3",
	"submit_num":"550625",
	"show_id":"44",
	"leetcode_id":"44",
	"answers":[
		{
			"lc_ans_id":"17810",
			"view":"61183",
			"top":"0",
			"title":"Linear runtime and constant space solution",
			"vote":"240",
			"content":"I found this solution from http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\n\\n----------\\n\\n\\nThe basic idea is to have one pointer for the string and one pointer for the pattern.  This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step. \\n\\n\\n----------\\n\\nHere is Yu's elegant solution in C++\\n\\n     bool isMatch(const char *s, const char *p) {\\n            const char* star=NULL;\\n            const char* ss=s;\\n            while (*s){\\n                //advancing both pointers when (both characters match) or ('?' found in pattern)\\n                //note that *p will not advance beyond its length \\n                if ((*p=='?')||(*p==*s)){s++;p++;continue;} \\n\\n                // * found in pattern, track index of *, only advancing pattern pointer \\n                if (*p=='*'){star=p++; ss=s;continue;} \\n\\n                //current characters didn't match, last pattern pointer was *, current pattern pointer is not *\\n                //only advancing pattern pointer\\n                if (star){ p = star+1; s=++ss;continue;} \\n\\n               //current pattern pointer is not star, last patter pointer was not *\\n               //characters do not match\\n                return false;\\n            }\\n \\n           //check for remaining characters in pattern\\n            while (*p=='*'){p++;}\\n\\n            return !*p;  \\n        }\\n\\n\\n----------\\n\\n\\nHere is my re-write in Java\\n\\n    \\ufeff\\ufeff\\ufeffboolean comparison(String str, String pattern) {\\n            int s = 0, p = 0, match = 0, starIdx = -1;            \\n            while (s < str.length()){\\n                // advancing both pointers\\n                if (p < pattern.length()  && (pattern.charAt(p) == '?' || str.charAt(s) == pattern.charAt(p))){\\n                    s++;\\n                    p++;\\n                }\\n                // * found, only advancing pattern pointer\\n                else if (p < pattern.length() && pattern.charAt(p) == '*'){\\n                    starIdx = p;\\n                    match = s;\\n                    p++;\\n                }\\n               // last pattern pointer was *, advancing string pointer\\n                else if (starIdx != -1){\\n                    p = starIdx + 1;\\n                    match++;\\n                    s = match;\\n                }\\n               //current pattern pointer is not star, last patter pointer was not *\\n              //characters do not match\\n                else return false;\\n            }\\n            \\n            //check for remaining characters in pattern\\n            while (p < pattern.length() && pattern.charAt(p) == '*')\\n                p++;\\n            \\n            return p == pattern.length();\\n    }"
		},
		{
			"lc_ans_id":"17812",
			"view":"22769",
			"top":"1",
			"title":"My java DP solution using 2D table",
			"vote":"47",
			"content":"    public class Solution {\\n        public boolean isMatch(String s, String p) {\\n            boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n            match[s.length()][p.length()]=true;\\n            for(int i=p.length()-1;i>=0;i--){\\n                if(p.charAt(i)!='*')\\n                    break;\\n                else\\n                    match[s.length()][i]=true;\\n            }\\n            for(int i=s.length()-1;i>=0;i--){\\n                for(int j=p.length()-1;j>=0;j--){\\n                    if(s.charAt(i)==p.charAt(j)||p.charAt(j)=='?')\\n                            match[i][j]=match[i+1][j+1];\\n                    else if(p.charAt(j)=='*')\\n                            match[i][j]=match[i+1][j]||match[i][j+1];\\n                    else\\n                        match[i][j]=false;\\n                }\\n            }\\n            return match[0][0];\\n        }\\n    }"
		},
		{
			"lc_ans_id":"17833",
			"view":"17585",
			"top":"2",
			"title":"Accepted C++ DP Solution with a Trick",
			"vote":"41",
			"content":"**Updated**: Since the OJ has relaxed the time constraint, the following DP solution is now accepted without the trick :-) \\n\\nWell, so many people has tried to solve this problem using DP. And almost all of them get TLE (if you see a **C++** DP solution that gets accepted, please let me know ^_^). Well, this post aims at providing an **accpted** DP solution which uses a **trick** to get around the largest test case, insteaed of a solution that is **fully correct**. So please do not give me down votes for that :-) \\n\\nLet's briefly summarize the idea of DP. We define the state `P[i][j]` to be whether `s[0..i)` matches `p[0..j)`. The state equations are as follows: \\n\\n 1. `P[i][j] = P[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '?')`, if `p[j - 1] != '*'`;\\n 2. `P[i][j] = P[i][j - 1] || P[i - 1][j]`, if `p[j - 1] == '*'`.\\n\\nIf you feel confused with the second equation, you may refer to [this link][1]. There is an explanation in the comments.\\n\\nWe optimize the DP code to `O(m)` space by recording `P[i - 1][j - 1]` using a single variable `pre`.\\n\\nThe trick to avoid TLE is to hard-code the result for the largest test case by \\n\\n    if (n > 30000) return false;  \\n\\nThe complete code is as follows.\\n\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) { \\n            int m = s.length(), n = p.length();\\n            if (n > 30000) return false; // the trick\\n            vector<bool> cur(m + 1, false); \\n            cur[0] = true;\\n            for (int j = 1; j <= n; j++) {\\n                bool pre = cur[0]; // use the value before update\\n                cur[0] = cur[0] && p[j - 1] == '*'; \\n                for (int i = 1; i <= m; i++) {\\n                    bool temp = cur[i]; // record the value before update\\n                    if (p[j - 1] != '*')\\n                        cur[i] = pre && (s[i - 1] == p[j - 1] || p[j - 1] == '?');\\n                    else cur[i] = cur[i - 1] || cur[i];\\n                    pre = temp;\\n                }\\n            }\\n            return cur[m]; \\n        }\\n    };\\n\\nFor those interested in a fully correct solution, [this link][2] has a nice Greedy solution. And I have rewritten the code below to fit the new C++ interface (changed from `char*` to `string`).\\n\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int m = s.length(), n = p.length();\\n            int i = 0, j = 0, asterisk = -1, match;\\n            while (i < m) {\\n                if (j < n && p[j] == '*') {\\n                    match = i; \\n                    asterisk = j++;\\n                }\\n                else if (j < n && (s[i] == p[j] || p[j] == '?')) {\\n                    i++; \\n                    j++;\\n                }\\n                else if (asterisk >= 0) {\\n                    i = ++match;\\n                    j = asterisk + 1;\\n                }\\n                else return false;\\n            }\\n            while (j < n && p[j] == '*') j++;\\n            return j == n;\\n        }\\n    };\\n\\n  [1]: https://leetcode.com/discuss/21634/c-dp-solution\\n  [2]: https://leetcode.com/discuss/10133/linear-runtime-and-constant-space-solution"
		},
		{
			"lc_ans_id":"17845",
			"view":"8079",
			"top":"3",
			"title":"Python DP solution",
			"vote":"28",
			"content":"    class Solution:\\n    # @return a boolean\\n    def isMatch(self, s, p):\\n        length = len(s)\\n        if len(p) - p.count('*') > length:\\n            return False\\n        dp = [True] + [False]*length\\n        for i in p:\\n            if i != '*':\\n                for n in reversed(range(length)):\\n                    dp[n+1] = dp[n] and (i == s[n] or i == '?')\\n            else:\\n                for n in range(1, length+1):\\n                    dp[n] = dp[n-1] or dp[n]\\n            dp[0] = dp[0] and i == '*'\\n        return dp[-1]\\n\\ndp[n] means the substring s[:n] if match the pattern i\\n\\ndp[0] means the empty string '' or s[:0] which only match the pattern '*'\\n\\nuse the reversed builtin because for every dp[n+1] we use the previous 'dp'\\n\\n\\n\\nadd Java O(m*n) version code\\n\\n    public boolean isMatch(String s, String p) {\\n        int count = 0;\\n        for (char c : p.toCharArray()) {\\n            if (c == '*')\\n                count++;\\n        }\\n        if (p.length() - count > s.length())\\n            return false;\\n        boolean[][] dp = new boolean[p.length() + 1][s.length() + 1];\\n        dp[0][0] = true;\\n        for (int j = 1; j <= p.length(); j++) {\\n            char pattern = p.charAt(j - 1);\\n            dp[j][0] = dp[j - 1][0] && pattern == '*';\\n            for (int i = 1; i <= s.length(); i++) {\\n                char letter = s.charAt(i - 1);\\n                if (pattern != '*') {\\n                    dp[j][i] = dp[j - 1][i - 1] && (pattern == '?' || pattern == letter);\\n                } else\\n                    dp[j][i] = dp[j][i - 1] || dp[j - 1][i];\\n            }\\n        }\\n        return dp[p.length()][s.length()];\\n    }"
		},
		{
			"lc_ans_id":"17811",
			"view":"9174",
			"top":"4",
			"title":"My three C++ solutions (iterative (16ms) & DP (180ms) & modified recursion (88ms))",
			"vote":"27",
			"content":"The reason that the iterative solution is much faster for this case is we only need to save (and deal with) the positions (iStar for s, jStar for p) of the last \"*\" we met. We only need to do traceback using iStar and jStar and all the previous \"*\" can be ignored since the last \"*\" will cover all the traceback cases for the previous \"*\". \\nWhat we need to do are\\n\\n - if the current p character is '*' (i.e. p[j]=='*'), then we update iStar and jStar with the cureent i and j values. iStar/jStar will be used for traceback. Also we do --i to start the depth first search with the case that '*' represents a null string.\\n - if p[j]!='*', then we check if mismatch occurs (i.e. p[j]!=s[i] and p[j]!='?'), if so we check if we met a '*' before (iStar>=0), if not, then we return false since no match can achieve. Otherwise, we traceback to the positions at which the last '*' happens and do the next possible dfs search (i.e.  i = iStar++;  j = jStar; remember to update iStar too to save the i position to try in the next traceback).\\n - The loop will quit when we reach the end of s. At last, we need to skip all the '*' in p to see if we can reach the end of p. if so, match, otherwise mismatch\\n\\n------------------------------------------------------------------------------------------------\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int  slen = s.size(), plen = p.size(), i, j, iStar=-1, jStar=-1;\\n    \\n            for(i=0,j=0 ; i<slen; ++i, ++j)\\n            {\\n                if(p[j]=='*')\\n                { //meet a new '*', update traceback i/j info\\n                    iStar = i;\\n                    jStar = j;\\n                    --i;\\n                }\\n                else\\n                { \\n                    if(p[j]!=s[i] && p[j]!='?')\\n                    {  // mismatch happens\\n                        if(iStar >=0)\\n                        { // met a '*' before, then do traceback\\n                            i = iStar++;\\n                            j = jStar;\\n                        }\\n                        else return false; // otherwise fail\\n                    }\\n                }\\n            }\\n            while(p[j]=='*') ++j;\\n            return j==plen;\\n        }\\n    };\\n\\nA DP solution is also given here. It has O(N^2) time complexity and O(N) space\\n\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int pLen = p.size(), sLen = s.size(), i, j, k, cur, prev;\\n            if(!pLen) return sLen == 0;\\n            bool matched[2][sLen+1];\\n            fill_n(&matched[0][0], 2*(sLen+1), false);\\n            \\n            matched[0][0] = true;\\n            for(i=1; i<=pLen; ++i)\\n            {\\n                cur = i%2, prev= 1-cur;\\n                matched[cur][0]= matched[prev][0] && p[i-1]=='*';\\n                if(p[i-1]=='*') for(j=1; j<=sLen; ++j) matched[cur][j] = matched[cur][j-1] || matched[prev][j];\\n                else for(j=1; j<=sLen; ++j)            matched[cur][j] =  matched[prev][j-1] && (p[i-1]=='?' || p[i-1]==s[j-1]) ;\\n            }\\n                return matched[cur][sLen];\\n        }\\n    };\\n\\n A recursion version. A typical recursion version will give us TLE due to too many unnecessary recursive calls. As we explained, all the traceback recursive calls at the '*' we met (except the last '*') are unneccessary and should be avoided. In the below version, we use recLevel to track the recursion level (i.e the total '*' we met) and we also use curLevel to save the order of '*' we currently process. If it is not the last '*' we met (i.e  if(recLevel>curLevel+1) ), then we will return false directly ( if(recLevel>curLevel+1) return false;) to skip all unneccessary recursion call at the '*' before the last '*'.\\n\\n    class Solution {\\n    private:\\n        bool helper(const string &s, const string &p, int si, int pi, int &recLevel)\\n        {\\n            int sSize = s.size(), pSize = p.size(), i, curLevel = recLevel;\\n            bool first=true;\\n            while(si<sSize && (p[pi]==s[si] || p[pi]=='?')) {++pi; ++si;} //match as many as possible\\n            if(pi == pSize) return si == sSize; // if p reaches the end, return\\n            if(p[pi]=='*')\\n            { // if a star is met\\n                while(p[++pi]=='*'); //skip all the following stars\\n                if(pi>=pSize) return true; // if the rest of p are all star, return true\\n                for(i=si; i<sSize; ++i)\\n                {   // then do recursion\\n                    if(p[pi]!= '?' && p[pi]!=s[i]) continue;\\n                    if(first) {++recLevel; first = false;}\\n                    if(helper(s, p, i, pi, recLevel)) return true;\\n                    if(recLevel>curLevel+1) return false; // if the currently processed star is not the last one, return\\n                }\\n            }\\n            return false;\\n        }\\n    public:\\n        bool isMatch(string s, string p) {\\n            int recLevel = 0;\\n            return helper(s, p, 0, 0, recLevel);\\n        }\\n    };"
		},
		{
			"lc_ans_id":"17839",
			"view":"2186",
			"top":"5",
			"title":"C++ recursive solution, 16 ms",
			"vote":"18",
			"content":"    class Solution {\\n        // return value:\\n        // 0: reach the end of s but unmatched\\n        // 1: unmatched without reaching the end of s\\n        // 2: matched\\n        int dfs(string& s, string& p, int si, int pi) {\\n            if (si == s.size() and pi == p.size()) return 2;\\n            if (si == s.size() and p[pi] != '*') return 0;\\n            if (pi == p.size()) return 1;\\n            if (p[pi] == '*') {\\n                if (pi+1 < p.size() and p[pi+1] == '*') \\n                    return dfs(s, p, si, pi+1); // skip duplicate '*'\\n                for(int i = 0; i <= s.size()-si; ++i) {\\n                    int ret = dfs(s, p, si+i, pi+1);\\n                    if (ret == 0 or ret == 2) return ret; \\n                }\\n            }\\n            if (p[pi] == '?' or s[si] == p[pi])\\n                return dfs(s, p, si+1, pi+1);\\n            return 1;\\n        }    \\n        \\n    public:\\n        bool isMatch(string s, string p) {\\n            return dfs(s, p, 0, 0) > 1;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"17836",
			"view":"7504",
			"top":"6",
			"title":"My Java DP Solution",
			"vote":"18",
			"content":"At first I cannot pass the the long 'aaa...' test case. Then I add more check and pass it.\\n\\n    public class Solution {\\n        public boolean isMatch(String s, String p) {\\n            int m = s.length(), n = p.length();\\n            int count = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (p.charAt(i) == '*') count++;\\n            }\\n            if (count==0 && m != n) return false;\\n            else if (n - count > m) return false;\\n            \\n            boolean[] match = new boolean[m+1];\\n            match[0] = true;\\n            for (int i = 0; i < m; i++) {\\n                match[i+1] = false;\\n            }\\n            for (int i = 0; i < n; i++) {\\n                if (p.charAt(i) == '*') {\\n                    for (int j = 0; j < m; j++) {\\n                        match[j+1] = match[j] || match[j+1]; \\n                    }\\n                } else {\\n                    for (int j = m-1; j >= 0; j--) {\\n                        match[j+1] = (p.charAt(i) == '?' || p.charAt(i) == s.charAt(j)) && match[j];\\n                    }\\n                    match[0] = false;\\n                }\\n            }\\n            return match[m];\\n        }\\n    }"
		},
		{
			"lc_ans_id":"17957",
			"view":"7810",
			"top":"7",
			"title":"C++ DP solution",
			"vote":"16",
			"content":"It seems that only Greedy solution can pass all test cases (sorry if I omit any DP solution that passes all test cases). My DP solution also fails to pass the s=aaaaaaaaaaaaaa.............. (lots of a's...). However, despite this very large case my DP solution passes all other cases. The idea is:\\n\\nf(i,j) == whether the first i chars of s match the first j chars of p. The transition equation is:\\n\\n    1). if(p[j-1]!='*') f(i, j) = f(i-1, j-1) && (s[i-1]==p[j-1] || p[j-1]=='?')\\n\\n    2). if(p[j-1]=='*') f(i, j) = f(i, j-1) || f(i-1, j)\\n\\n    bool isMatch(const char *s, const char *p) {\\n        const int m = strlen(s);\\n        const int n = strlen(p);\\n        if(m>30000) return false; // to skip the large test case\\n        vector<bool> prev(n+1,false); // to save space, just O(n) space is used\\n        prev[0]=true;\\n        for(int j=1; j<=n; j++)\\n            prev[j] = prev[j-1] && p[j-1]=='*';\\n        for(int i=1; i<=m; i++) {\\n            vector<bool> cur(n+1,false);\\n            for(int j=1; j<=n; j++) {\\n                if(p[j-1]=='*') {\\n                    cur[j] = cur[j-1] || prev[j];\\n                }\\n                else {\\n                    cur[j] = prev[j-1] && (s[i-1]==p[j-1] || p[j-1]=='?');\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[n];\\n    }\\n\\n> Equation 1). means that if p[j-1] is not *, f(i,j) is determined\\n> by if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] or\\n> p[j-1]=='?'). \\n> \\n> Equation 2). means that if p[j-1] is *, f(i,j) is true if either\\n> f(i,j-1) is true: s[0:i-1] matches p[0:j-2] and * is not used\\n> here; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * is\\n> used to match s[i-1]."
		},
		{
			"lc_ans_id":"17904",
			"view":"3002",
			"top":"8",
			"title":"Java solution -- O(n^2) DP solution with some explanations",
			"vote":"15",
			"content":"I had a solution for \"Regular Expression Matching\" problem: https://leetcode.com/discuss/66032/java-solution-o-n-2-dp-with-some-explanations.\\n\\nSlight change to that solution gives an O(n^3) DP solution for this \"Wildcard Matching\" problem:\\n\\n    // O(n^3) DP solution for understanding the algorightm:\\n    public boolean isMatch(String s, String p) {\\n        int sL = s.length(), pL = p.length();\\n        \\n        boolean[][] dp = new boolean[sL+1][pL+1];\\n        dp[0][0] = true; // If s and p are \"\", isMathch() returns true;\\n        \\n        for(int i=0; i<=sL; i++) {\\n            \\n            // j starts from 1, since dp[i][0] is false when i!=0;\\n            for(int j=1; j<=pL; j++) {\\n                char c = p.charAt(j-1);\\n                \\n                if(c != '*') {\\n                    // The last character of s and p should match;\\n                    // And, dp[i-1][j-1] is true;\\n                    dp[i][j] = i>0 && dp[i-1][j-1] && (c=='?' || c==s.charAt(i-1));\\n                }\\n                else {\\n                    // Two situations:\\n                    // (1) '*' is the first character in p;\\n                    // (2) For k>=0 and k<=i, there is some dp[k][j-1] being true;\\n                    //     and '*' will match the rest sequence in s after index k;\\n                    boolean flag = false;\\n                    for(int k=i; k>=0; k--) { flag = dp[k][j-1]; if(flag) break;};\\n                    \\n                    dp[i][j] = j==1 || flag;\\n                }\\n            }\\n        }\\n        \\n        return dp[sL][pL];\\n    }\\n\\nBased on the same idea, I transposed the dp[][] matric and got the O(n^2) DP solution:\\n\\n    // O(n^2) DP solution with dp[][] matric transposed:\\n    public boolean isMatch(String s, String p) {\\n        int sL = s.length(), pL = p.length();\\n        \\n        boolean[][] dp = new boolean[pL+1][sL+1];\\n        dp[0][0] = true;\\n\\n        for(int i=1; i<=pL; i++) {\\n            boolean flag = false; // The flag is moved here;\\n\\n            for(int j=0; j<=sL; j++) {\\n                flag = flag || dp[i-1][j];\\n                char c = p.charAt(i-1);\\n                \\n                if(c != '*') {\\n                    dp[i][j] = j>0 && dp[i-1][j-1] && (c=='?' || c==s.charAt(j-1));\\n                }\\n                else {\\n                    // For k>=0 and k<=j, if any dp[i-1][k] is true,\\n                    // then '*' will match the rest sequence in s after index k;\\n                    dp[i][j] = i==1 || flag;\\n                }\\n            }\\n        }\\n        \\n        return dp[pL][sL];\\n    }"
		},
		{
			"lc_ans_id":"17828",
			"view":"3220",
			"top":"9",
			"title":"Java DP Accepted",
			"vote":"14",
			"content":"    public class Solution {\\n        public boolean isMatch(String s, String p) {\\n            int m = s.length(), n = p.length();\\n            char[] ws = s.toCharArray();\\n            char[] wp = p.toCharArray();\\n            boolean[][] dp = new boolean[m+1][n+1];\\n            dp[0][0] = true;\\n            for (int j = 1; j <= n; j++)\\n                dp[0][j] = dp[0][j-1] && wp[j-1] == '*';\\n            for (int i = 1; i <= m; i++)\\n                dp[i][0] = false;\\n            for (int i = 1; i <= m; i++) {\\n                for (int j = 1; j <= n; j++) {\\n                \\tif (wp[j-1] == '?' || ws[i-1] == wp[j-1])\\n                \\t\\tdp[i][j] = dp[i-1][j-1];\\n                \\telse if (wp[j-1] == '*')\\n                \\t\\tdp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                }\\n            }\\n            return dp[m][n];\\n        }\\n    }"
		}
	],
	"id":"44",
	"title":"Wildcard Matching",
	"content":"<p>Implement wildcard pattern matching with support for <code>'?'</code> and <code>'*'</code>.</p>\r\n\r\n<pre>\r\n'?' Matches any single character.\r\n'*' Matches any sequence of characters (including the empty sequence).\r\n\r\nThe matching should cover the <b>entire</b> input string (not partial).\r\n\r\nThe function prototype should be:\r\nbool isMatch(const char *s, const char *p)\r\n\r\nSome examples:\r\nisMatch(\"aa\",\"a\") &rarr; false\r\nisMatch(\"aa\",\"aa\") &rarr; true\r\nisMatch(\"aaa\",\"aa\") &rarr; false\r\nisMatch(\"aa\", \"*\") &rarr; true\r\nisMatch(\"aa\", \"a*\") &rarr; true\r\nisMatch(\"ab\", \"?*\") &rarr; true\r\nisMatch(\"aab\", \"c*a*b\") &rarr; false\r\n</pre>",
	"frequency":"363",
	"ac_num":"114587"
}