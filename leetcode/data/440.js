{
	"difficulty":"3",
	"submit_num":"29107",
	"show_id":"446",
	"leetcode_id":"446",
	"answers":[
		{
			"lc_ans_id":"92822",
			"view":"7929",
			"top":"0",
			"title":"Detailed explanation for Java O(n^2) solution",
			"vote":"79",
			"content":"At first glance of the problem description, I had a strong feeling that the solution to the original problem can be built through its subproblems, i.e., the total number of arithmetic subsequence slices of the whole input array can be constructed from those of the subarrays of the input array. While I was on the right track to the final solution, it's not so easy to figure out the relations between the original problem and its subproblems. \\n\\nTo begin with, let's be ambitious and reformulate our problem as follows: let `T(i)` denote the total number of arithmetic subsequence slices that can be formed within subarray `A[0, i]`, where `A` is the input array and `0 <= i < n` with `n = A.length`. Then our original problem will be `T(n - 1)`, and the base case is `T(0) = 0`.\\n\\nTo make the above idea work, we need to relate `T(i)` to all `T(j)` with `0 <= j < i`. Let's take some specific `j` as an example. If we want to incorporate element `A[i]` into the subarray `A[0, j]`, what information do we need? As far as I can see, we need to know at least the total number of arithmetic subsequence slices ending at each index `k` with difference `d` where `0 <= k <= j` and `d = A[i] - A[k]`, (i.e., for each such slice, its last element is `A[k]` and the difference between every two consecutive elements is `d`), so that adding `A[i]` to the end of each such slice will make a new arithmetic subsequence slice.\\n\\nHowever, our original formulation of `T(i)` says nothing about the the total number of arithmetic subsequence slices ending at some particular index and with some particular difference. This renders it impossible to relate `T(i)` to all `T(j)`. **As a rule of thumb, when there is difficulty relating original problem to its subproblems, it usually indicates something goes wrong with your formulation for the original problem.** \\n\\nFrom our analyses above, each intermediate solution should at least contain information about the total number of arithmetic subsequence slices ending at some particular index with some particular difference. So let's go along this line and reformulate our problem as `T(i, d)`, which denotes the total number of arithmetic subsequence slices ending at index `i` with difference `d`. The base case and recurrence relation are as follows:\\n1. Base case: `T(0, d) = 0` (This is true for any `d`).\\n2. Recurrence relation: `T(i, d) = summation of (1 + T(j, d))` as long as `0 <= j < i && d == A[i] - A[j]`.\\n\\nFor the recurrence relation, it's straightforward to understand the `T(j, d)` part: for each slice ending at index `j` with difference `d == A[i] - A[j]`, adding `A[i]` to the end of the slice will make a new arithmetic subsequence slice, therefore the total number of such new slices will be the same as `T(j, d)`. What you are probably wondering is: where does the `1` come from?\\n\\nThe point here is that to make our recurrence relation work properly, the meaning of arithmetic subsequence slice has to be extended to include slices with only `two elements` (of course we will make sure these \"phony\" slices won't contribute to our final count). This is because for each slice, we are adding `A[i]` to its end to form a new one. If the original slice is of length two, after adding we will have a valid arithmetic subsequence slice with three elements. Our `T(i, d)` will include all these \"generalized\" slices. And for each pair of elements `(A[j], A[i])`, they will form one such \"generalized\" slice (with only two elements) and thus contribute to one count of `T(i, d)`.\\n\\nBefore jumping to the solution below, I'd like to point out that there are actually overlapping among our subproblems (for example, both `T(i, d)` and `T(i + 1, d)` require knowledge of `T(j, d)` with `0 <= j < i`). This necessitates memorization of the intermediate results. Each intermediate result is characterized by two integers: `i` and `d`. The former is bounded (i.e., `0 <= i < n`) since they are the indices of the element in the input array while the latter is not as `d` is the difference of two elements in the input array and can be any value. For bounded integers, we can use them to index arrays (or lists) while for unbounded ones, use of HashMap would be more appropriate. So we end up with an array of the same length as the input and whose element type is HashMap.\\n\\nHere is the Java program (with a quick explanation given at the end). Both time and space complexities are `O(n^2)`. Some minor points for improving the time and space performance are:\\n1. Define the type of the difference as Integer type instead of Long. This is because there is no valid arithmetic subsequence slice that can have difference out of the Integer value range. But we do need a long integer to filter out those invalid cases.\\n2. Preallocate the HashMap to avoid reallocation to deal with extreme cases.\\n3. Refrain from using lambda expressions inside loops.\\n\\n```\\npublic int numberOfArithmeticSlices(int[] A) {\\n    int res = 0;\\n    Map<Integer, Integer>[] map = new Map[A.length];\\n\\t\\t\\n    for (int i = 0; i < A.length; i++) {\\n        map[i] = new HashMap<>(i);\\n        \\t\\n        for (int j = 0; j < i; j++) {\\n            long diff = (long)A[i] - A[j];\\n            if (diff <= Integer.MIN_VALUE || diff > Integer.MAX_VALUE) continue;\\n        \\t\\t\\n            int d = (int)diff;\\n            int c1 = map[i].getOrDefault(d, 0);\\n            int c2 = map[j].getOrDefault(d, 0);\\n            res += c2;\\n            map[i].put(d, c1 + c2 + 1);\\n        }\\n    }\\n\\t\\t\\n    return res;\\n}\\n```\\nQuick explanation:\\n1. `res` is the final count of all valid arithmetic subsequence slices; `map` will store the intermediate results `T(i, d)`, with `i` indexed into the array and `d` as the key of the corresponding HashMap.\\n2. For each index `i`, we find the total number of \"generalized\" arithmetic subsequence slices ending at it with all possible differences. This is done by attaching `A[i]` to all slices of `T(j, d)` with `j` less than `i`.\\n3. Within the inner loop, we first use a long variable `diff` to filter out invalid cases, then get the counts of all valid slices (with element >= 3) as `c2` and add it to the final count. At last we update the count of all \"generalized\" slices for `T(i, d)` by adding the three parts together: the original value of `T(i, d)`, which is `c1` here, the counts from `T(j, d)`, which is `c2` and lastly the `1` count of the \"two-element\" slice `(A[j], A[i])`."
		},
		{
			"lc_ans_id":"92830",
			"view":"5173",
			"top":"1",
			"title":"JAVA 15 lines solution",
			"vote":"25",
			"content":"```Java\\n    public int numberOfArithmeticSlices(int[] A) {\\n        int re = 0;\\n        HashMap<Integer, Integer>[] maps = new HashMap[A.length];\\n        for(int i=0; i<A.length; i++) {\\n            maps[i] = new HashMap<>();\\n            int num = A[i];\\n            for(int j=0; j<i; j++) {\\n                if((long)num-A[j]>Integer.MAX_VALUE) continue;\\n                if((long)num-A[j]<Integer.MIN_VALUE) continue;\\n                int diff = num - A[j];\\n                int count = maps[j].getOrDefault(diff, 0);\\n                maps[i].put(diff, maps[i].getOrDefault(diff,0)+count+1);\\n                re += count;\\n            }\\n        }\\n        return re;\\n    }\\n```"
		},
		{
			"lc_ans_id":"92850",
			"view":"2603",
			"top":"2",
			"title":"O(N^2) MLE/TLE in C++? Try this one, Concise and Fast.",
			"vote":"13",
			"content":"First of all, the standard O(N^2) DP solution written with C++ goes MLE/TLE in LC, but works pretty well when written with JAVA/Python :(\\nIt looks like this (Python version):\\n```\\nclass Solution(object):\\n    def numberOfArithmeticSlices(self, A):\\n        dp = [defaultdict(int) for i in range(len(A))]\\n        res = 0\\n        for i in range(1, len(A)):\\n            for j in range(i):\\n                step = A[i]-A[j]\\n                dp[i][step] += 1\\n                if step in dp[j]:\\n                    dp[i][step]+= dp[j][step]\\n                    res += dp[j][step]\\n        return res\\n```\\nObviously, it maintains an array of dictionary to store the number of arithmetic subsequences (including length 2) ending with A[i]. As a result, the time and space complexity are both O(N^2) which I think is quite reasonable to deal with 0 \\u2264 N \\u2264 1000 in LC. But it fails in C++. So I tweak the meaning of DP equation from:\\n```\\nDP[i][d] = the number of arithmetic subsequences ending with A[i], difference is d. (NOTE here the length of valid subsequences can be 2)\\n```\\nto\\n```\\nDP[i][d] = the number of arithmetic subsequences whose last but one number is A[i], difference is d.\\n```\\nAfter that, the length of valid subsequences we record must be at least 3. It does save memory and finally passes LC in 423 ms:\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int n = A.size();\\n        vector<unordered_map<long long, int >> dp(n);\\n        unordered_set<int> s(A.begin(), A.end());\\n        int res = 0;\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = i-1; j >= 0; --j) {\\n                long long d = (long long)A[i] - (long long)A[j];\\n                int tmp = dp[j].count(d) ? dp[j][d] : 0;\\n                if (tmp) res += tmp;\\n                if (s.count(A[i]+d)) dp[i][d] += 1 + tmp;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"92837",
			"view":"2990",
			"top":"3",
			"title":"C++_DP_Accepted",
			"vote":"11",
			"content":"    class Solution {\\n    public:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        if(A.empty()) return 0;\\n        vector<unordered_map<int,int>> dp(A.size());//[index, [difference, count]]\\n        \\n        int res = 0;\\n        for(int i = 0; i < A.size(); ++i){\\n            for(int j = 0; j < i; ++j){\\n                if((long)A[i] - (long)A[j] > INT_MAX || (long)A[i] - (long)A[j] < INT_MIN) continue;// do not ignore this step, it will help you save time & space to pass OJ.\\n                int dif = A[i] - A[j];\\n                dp[i][dif] += 1;\\n                if(dp[j].find(dif) != dp[j].end()){\\n                    dp[i][dif] += dp[j][dif];\\n                    res += dp[j][dif];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    };"
		},
		{
			"lc_ans_id":"92852",
			"view":"915",
			"top":"4",
			"title":"11 line Python O(n^2) solution",
			"vote":"6",
			"content":"```\\ndef numberOfArithmeticSlices(self, A):\\n    from collections import defaultdict\\n    total = 0\\n    dp = [defaultdict(int) for item in A]\\n    for i in xrange(len(A)):\\n        for j in xrange(i):\\n            dp[i][A[i] - A[j]] += 1\\n            if A[i]-A[j] in dp[j]:\\n                dp[i][A[i] - A[j]] += dp[j][A[i]-A[j]]\\n                total += dp[j][A[i]-A[j]]\\n    return total\\n```\\nWe memoize with an array of dicts, `dp`, such that `dp[i][j]` stores the number of arithmetic slices (including those with only length 2) whose constant difference is `j` ending at `i`. The key is basically to store all 2+-length arithmetic slices (which is helps to build up the solution from its sub-problems)  while only adding valid 3+-length slices to the total.\\n\\nThe we iterate over all pairs in the array. Each `(A[j], A[i])` is a 2-length slice with constant difference `A[i] - A[j]` that we've never encountered before, so increment `dp[i][A[i] - A[j]]` by 1 (but leave the total as is, because its not length 3 or more). \\n\\nIf there are any slices with `A[i] - A[j]` length that finish at index `j` (`if A[i]-A[j] in dp[j]:`), we 'extend' them to index `i` and add to the total, since any slice that terminated at index `j` would now have at least length 3 terminating at `i`."
		},
		{
			"lc_ans_id":"92853",
			"view":"1620",
			"top":"5",
			"title":"Share my JAVA AC solution and my thoughts",
			"vote":"4",
			"content":"```\\npublic int numberOfArithmeticSlices(int[] A) {\\n        if(A==null||A.length<3) return 0;\\n        List<Map<Integer,Integer>> list=new ArrayList<Map<Integer,Integer>>();\\n        int res=0;\\n        for(int i=1;i<A.length;i++){\\n            Map<Integer,Integer> map=new HashMap<Integer,Integer>();\\n            for(int j=0;j<i;j++){\\n                if((long)A[i]-(long)A[j]>Integer.MAX_VALUE) continue;\\n                if((long)A[i]-(long)A[j]<Integer.MIN_VALUE) continue;\\n                int dif=A[i]-A[j];\\n                if(j==0){\\n                    map.put(dif,1);\\n                    continue;\\n                }\\n                Map<Integer,Integer> temp=list.get(j-1);\\n                int sum=0;\\n                if(temp.containsKey(dif)){\\n                    sum=temp.get(dif);\\n                }\\n                if(map.containsKey(dif)){\\n                    map.put(dif,map.get(dif)+sum+1);\\n                }else{\\n                    map.put(dif,sum+1);\\n                }\\n                res+=sum;\\n            }\\n            list.add(map);\\n        }\\n        return res;\\n    }\\n```\\nIt seems that there is no better way to solve this problem using O(N^2) space and time. If you have better algorithm, please share your thoughts or solution, thanks!\\n\\nI have viewed all four posts( at least there are four posts when I am still busy typing mine), and everyone seems to have the same issue facing TLE or MLE or both. Well, for me, I have encountered both.\\n\\nSince nobody has posted java solution, I will share my ways of tackling this problem.\\n\\nI will skip the logic and algorithms here, since everybody is doing it the same way, using DP. For each element, store all possible difference and its number of arithmetic sequences( including 2 element sequence). \\n\\nAt first, I was using Map<Long,Integer> instead of Map<Integer,Integer> considering subtraction of two integers could result in overflow. But later I realized if the result is bigger than the max value of integer or smaller than the min value of integer, there is no way to have a valid a 3rd integer element to form a arithmetic sequence. So by adding two if()*continue, and thus replacing Map<Long,Integer> to Map<Integer,Integer> it can save both time and memory. After doing this, my code can pass the judge about 4 out of 5 times, which means it can still have TLE or MLE sometimes. Then I modified the outer loop's parameter i to start from 1 instead of 0 and added if(j==0) statement to do less map operations for every j==0 case. And now it goes through every time! (Well, by saying every time, I mean I submitted 5 times in a row and they all went through.)\\n\\nI believe the first change is the main cause to help my code get through, and the second change is just the minor. Hope these can give you guys some hints and help, please do share your plans of reducing either time or space here if you have. \\nHappy coding!"
		},
		{
			"lc_ans_id":"92845",
			"view":"330",
			"top":"6",
			"title":"Dynamic Programming, Java Solution with detailed explanation!",
			"vote":"3",
			"content":"Given an array ```a1, a2, ..., ai, ..., an```\\n```T(i,d)``` is the number of arithmetic subsequence with difference d that ends at ```ai```\\n   \\nThus, we have ```T(i,d) = sum(T(j,d) + 1)``` for all the``` j < i ```and ```ai - aj = d```\\n```T(0, d) == 0```\\n\\nConsider the range of d could be from``` [Integer.MIN_VALUE, INTEGER.MAX_VALUE]```, it would be too space-consuming to initialize such 2-d array. However, we can combine the 1-d array with the hashmap to create a new dynamic 2-d array.\\n   \\nIn general, for this definition, it assumes that the length of subseqeunce can be``` >= 2```. However, according to the question, we only count subsequence of which the length is``` >= 3```. For example, given array ```[1, 2, 3]``` , ```1, 2``` is also considered to be a legal arithmetic sequence, but what we need to is just ```1, 2, 3```.\\n\\nAnd it is hard to adjust the definition above, because we need to know the length of subsequence, but the above definition does not provide this information. So we can only filter the 2 length subsequence in the code. Moreover, in the code below, we can only count the sequence of which the length is at least 4, 5, or more based on the requirement of problem.\\n\\nSpecial thanks to **fun4LeetCode**.\\n\\n```\\npublic class Solution {\\n    public int numberOfArithmeticSlices(int[] A) {\\n        if (A == null || A.length == 0) return 0;\\n        \\n        Map<Integer, Integer>[] map = new Map[A.length];         // dynamic 2-d array\\n        // <d, #>\\n        int res = 0;\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            map[i] = new HashMap<>();\\n            for (int j = 0; j < i; j++) {\\n                long diff = (long)A[i] - A[j];\\n                if (diff > Integer.MAX_VALUE || diff < Integer.MIN_VALUE) continue;\\n                int d = (int) diff;\\n                int T_jd = map[j].getOrDefault(d, 0);\\n                int increase = T_jd + 1;            // the amount of increase for each time\\n                \\n                /* This statement is used to adjust the acceptable subsequnce based on the requirement of problem\\n                   If the minimum length of subsequence should be 3, then res += increase > 1? (increase-1) : 0; Or simply res += increase-1;\\n                   If the minimum length of subsequence should be 4, then res += increase > 2? (increase-2) : 0;\\n                   If the minimum length of subsequence should be 5, then res += increase > 3? (increase-3) : 0;\\n                   ...\\n                   ...\\n                   ...\\n                 */\\n                res += increase > 1? (increase-1) : 0;  //filter\\n                map[i].put(d, map[i].getOrDefault(d, 0) + increase);\\n            }\\n        }\\n        return res;\\n        \\n        \\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"92823",
			"view":"611",
			"top":"7",
			"title":"Python Solution from the Author",
			"vote":"3",
			"content":"I see a lot people got TLE and it's been 2 weeks since the contest. So I am going to post my official solution.\\n\\n    class Solution(object):\\n        def numberOfArithmeticSlices(self, A):\\n            \"\"\"\\n            :type A: List[int]\\n            :rtype: int\\n            \"\"\"\\n\\n            lookup = {}\\n\\n            for i, a in enumerate(A):\\n                if a in lookup:\\n                    lookup[a].append(i)\\n                else:\\n                    lookup[a] = [i]\\n\\n            dp = []\\n            for _ in range(len(A)):\\n                dp.append({})\\n\\n            for k, num in enumerate(A):\\n                for i in range(0, k):\\n                    diff = A[k] - A[i]\\n                    X = A[i] - diff\\n                    if X in lookup:\\n                        for index in lookup[X]:\\n                            if index < i:\\n                                dp[k][diff] = dp[k].get(diff, 0) + 1\\n\\n                    if diff in dp[i]:\\n                        dp[k][diff] = dp[k].get(diff, 0) + dp[i][diff]\\n\\n            res = 0\\n            for x in dp:\\n                for k in x:\\n                    res += x[k]\\n\\n            return res"
		},
		{
			"lc_ans_id":"92851",
			"view":"441",
			"top":"8",
			"title":"200ms C++ DP solution",
			"vote":"3",
			"content":"```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int count = 0, n = (int)A.size();\\n        if (n == 0) return 0;\\n        unordered_map<long, set<int>> indices;\\n        for (int i = 0; i < n; ++i)\\n            indices[(long)A[i]].insert(i);\\n        vector<vector<int>> counts(n, vector<int>(n, 0));\\n        for (int j = 1; j < n - 1; ++j) {\\n            for (int k = j + 1; k < n; ++k) {\\n                long prev = (long)A[j] + A[j] - A[k];\\n                if (prev < INT_MIN || prev > INT_MAX || !indices.count(prev)) \\n                    continue;\\n                for (int i : indices[prev]) {\\n                    if (i >= j) break;\\n                    counts[j][k] += counts[i][j] + 1;\\n                }\\n                count += counts[j][k];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n`counts[j][k]` is the count of sequences (with lengths greater than 2) ending with indices `j` and `k`.\\n`counts[j][k] = sum{counts[i][j] + 1 | A[i] - A[j] == A[j] - A[k] and i < j}`\\n\\nObviously, this solution is not as good as those O(n^2) DP solutions. Any idea why it takes much less time to AC?"
		},
		{
			"lc_ans_id":"92857",
			"view":"839",
			"top":"9",
			"title":"Can anyone explain the algorithm in words?",
			"vote":"2",
			"content":"I couldn't understand the algorithm reading the codes. Can anyone explain the algorithm?"
		}
	],
	"id":"440",
	"title":"Arithmetic Slices II - Subsequence",
	"content":"<p>A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>\r\n\r\n<p>For example, these are arithmetic sequences:</p>\r\n<pre>1, 3, 5, 7, 9\r\n7, 7, 7, 7\r\n3, -1, -5, -9</pre>\r\n\r\n<p>The following sequence is not arithmetic.</p> <pre>1, 1, 2, 5, 7</pre> \r\n<br/>\r\n\r\n<p>A zero-indexed array A consisting of N numbers is given. A <b>subsequence</b> slice of that array is any sequence of integers (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>k</sub>) such that 0 &le; P<sub>0</sub> < P<sub>1</sub> < ... < P<sub>k</sub> < N.</p>\r\n\r\n<p>A <b>subsequence</b> slice (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>k</sub>) of array A is called arithmetic if the sequence A[P<sub>0</sub>], A[P<sub>1</sub>], ..., A[P<sub>k-1</sub>], A[P<sub>k</sub>] is arithmetic. In particular, this means that k &ge; 2.</p>\r\n\r\n<p>The function should return the number of arithmetic subsequence slices in the array A. </p>\r\n\r\n<p>The input contains N integers. Every integer is in the range of -2<sup>31</sup> and 2<sup>31</sup>-1 and 0 &le; N &le; 1000. The output is guaranteed to be less than 2<sup>31</sup>-1.</p>\r\n<br/>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b> [2, 4, 6, 8, 10]\r\n\r\n<b>Output:</b> 7\r\n\r\n<b>Explanation:</b>\r\nAll arithmetic subsequence slices are:\r\n[2,4,6]\r\n[4,6,8]\r\n[6,8,10]\r\n[2,4,6,8]\r\n[4,6,8,10]\r\n[2,4,6,8,10]\r\n[2,6,10]\r\n</pre>\r\n</p>",
	"frequency":"118",
	"ac_num":"8096"
}