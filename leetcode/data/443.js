{
	"difficulty":"2",
	"submit_num":"53664",
	"show_id":"449",
	"leetcode_id":"449",
	"answers":[
		{
			"lc_ans_id":"93175",
			"view":"20864",
			"top":"0",
			"title":"Java PreOrder + Queue solution",
			"vote":"36",
			"content":"Hi all, I think my solution is pretty straightforward and easy to understand, not that efficient though. And the serialized tree is compact.\\nPre order traversal of BST will output root node first, then left children, then right.\\n```\\nroot left1 left2 leftX right1 rightX\\n```\\nIf we look at the value of the pre-order traversal we get this:\\n```\\nrootValue (<rootValue) (<rootValue) (<rootValue) |separate line| (>rootValue) (>rootValue)\\n```\\nBecause of BST's property: before the |separate line| all the node values are **less than root value**, all the node values after |separate line| are **greater than root value**. We will utilize this to build left and right tree.\\n\\nPre-order traversal is BST's serialized string. I am doing it iteratively.\\nTo deserialized it, use a queue to recursively get root node, left subtree and right subtree.\\n\\n\\nI think time complexity is O(NlogN).\\nErrr, my bad, as @ray050899 put below, worst case complexity should be O(N^2), when the tree is really unbalanced. \\n\\n\\nMy implementation\\n```\\npublic class Codec {\\n    private static final String SEP = \",\";\\n    private static final String NULL = \"null\";\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if (root == null) return NULL;\\n        //traverse it recursively if you want to, I am doing it iteratively here\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n        while (!st.empty()) {\\n            root = st.pop();\\n            sb.append(root.val).append(SEP);\\n            if (root.right != null) st.push(root.right);\\n            if (root.left != null) st.push(root.left);\\n        }\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    // pre-order traversal\\n    public TreeNode deserialize(String data) {\\n        if (data.equals(NULL)) return null;\\n        String[] strs = data.split(SEP);\\n        Queue<Integer> q = new LinkedList<>();\\n        for (String e : strs) {\\n            q.offer(Integer.parseInt(e));\\n        }\\n        return getNode(q);\\n    }\\n    \\n    // some notes:\\n    //   5\\n    //  3 6\\n    // 2   7\\n    private TreeNode getNode(Queue<Integer> q) { //q: 5,3,2,6,7\\n        if (q.isEmpty()) return null;\\n        TreeNode root = new TreeNode(q.poll());//root (5)\\n        Queue<Integer> samllerQueue = new LinkedList<>();\\n        while (!q.isEmpty() && q.peek() < root.val) {\\n            samllerQueue.offer(q.poll());\\n        }\\n        //smallerQueue : 3,2   storing elements smaller than 5 (root)\\n        root.left = getNode(samllerQueue);\\n        //q: 6,7   storing elements bigger than 5 (root)\\n        root.right = getNode(q);\\n        return root;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"93167",
			"view":"4457",
			"top":"1",
			"title":"Concise C++ 19ms solution beating 99.4%",
			"vote":"22",
			"content":"Sharing my solution which doesn't have to parse string for comma at all!\\n\\nThe encoding schema is preorder of BST, and to decode this we can use the same preorder traversal to do it in one pass with recursion in O(n) time.\\n\\nTo minimize the memory, I used binary format instead of ascii format for each integer, just burn those int into 4 chars will save you a lot!!!\\n\\nReally if using ASCII numbers you are paying a lot of penalty memory for integers over 4 digit long and parsing comma is just as painful.\\n\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string order;\\n        inorderDFS(root, order);\\n        return order;\\n    }\\n    \\n    inline void inorderDFS(TreeNode* root, string& order) {\\n        if (!root) return;\\n        char buf[4];\\n        memcpy(buf, &(root->val), sizeof(int)); //burn the int into 4 chars\\n        for (int i=0; i<4; i++) order.push_back(buf[i]);\\n        inorderDFS(root->left, order);\\n        inorderDFS(root->right, order);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int pos = 0;\\n        return reconstruct(data, pos, INT_MIN, INT_MAX);\\n    }\\n    \\n    inline TreeNode* reconstruct(const string& buffer, int& pos, int minValue, int maxValue) {\\n        if (pos >= buffer.size()) return NULL; //using pos to check whether buffer ends is better than using char* directly.\\n        \\n        int value;\\n        memcpy(&value, &buffer[pos], sizeof(int));\\n        if (value < minValue || value > maxValue) return NULL;\\n        \\n        TreeNode* node = new TreeNode(value);\\n        pos += sizeof(int);\\n        node->left = reconstruct(buffer, pos, minValue, value);\\n        node->right = reconstruct(buffer, pos, value, maxValue);\\n        return node;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"93168",
			"view":"10417",
			"top":"2",
			"title":"Deserialize from preorder and computed inorder, reusing old solution",
			"vote":"18",
			"content":"I serialize the tree's values in preorder. For deserializing, I additionally compute inorder simply by sorting the preorder. And then I just use the `buildTree` function that I copied&pasted from [my old solution](https://discuss.leetcode.com/topic/16221/simple-o-n-without-map) for the old problem [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/).\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        def preorder(node):\\n            if node:\\n                vals.append(str(node.val))\\n                preorder(node.left)\\n                preorder(node.right)\\n        vals = []\\n        preorder(root)\\n        return ' '.join(vals)\\n\\n    def deserialize(self, data):\\n        preorder = map(int, data.split())\\n        inorder = sorted(preorder)\\n        return self.buildTree(preorder, inorder)\\n\\n    def buildTree(self, preorder, inorder):\\n        def build(stop):\\n            if inorder and inorder[-1] != stop:\\n                root = TreeNode(preorder.pop())\\n                root.left = build(root.val)\\n                inorder.pop()\\n                root.right = build(stop)\\n                return root\\n        preorder.reverse()\\n        inorder.reverse()\\n        return build(None)\\n```\\n(I had seen @shallpion's [title](https://discuss.leetcode.com/topic/65773/construct-bst-using-preorder-traversal) saying \"preorder\" before thinking about this problem, so can't be sure I would've had the idea myself, though I think I would've.)"
		},
		{
			"lc_ans_id":"93180",
			"view":"8432",
			"top":"3",
			"title":"Using lower bound and upper bound to deserialize BST",
			"vote":"15",
			"content":"The idea is to encode every non null root value by preorder traversal \\n\\nwhen deserializing the tree, we can pass by the lower bound and upper bound to know the boundary of a subtree.\\n\\nThis approach has an overhead of looking up one extra number, which would be O ( 2N )\\n\\n```\\n    // Encodes a tree to a single string.\\n    void serialize(TreeNode* root, ostringstream& out )\\n    {\\n        if ( !root ) return;\\n        out << root->val << \",\";\\n        serialize(root->left, out);\\n        serialize(root->right, out);\\n    }\\n    \\n    string serialize(TreeNode* root) {\\n        ostringstream ss;\\n        serialize(root, ss);\\n        return ss.str();\\n    }\\n\\n    TreeNode* deserialize(const string& s, int lower, int upper, int & pos )\\n    {\\n        // pos is a variable to record the end of decoded buffer \\n        if ( pos == s.size() ) return nullptr;\\n        int cur_pos = pos;\\n        int number = 0;\\n        while( s[cur_pos] != ',')\\n        {\\n            number = number * 10 + s[cur_pos] - '0';\\n            ++cur_pos;\\n        }\\n        ++cur_pos;\\n        // The next number is not part of current subtree, should return nullptr\\n        if ( number < lower || number > upper ) return nullptr;\\n\\n        TreeNode* root = new TreeNode( number );\\n        pos = cur_pos; // update pos \\n        root->left =  deserialize( s, lower, root->val, pos );\\n        root->right = deserialize( s, root->val, upper, pos );\\n        return root;\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int pos = 0;\\n        return deserialize( data, INT_MIN, INT_MAX, pos );\\n        \\n    }\\n```"
		},
		{
			"lc_ans_id":"93177",
			"view":"9230",
			"top":"4",
			"title":"what's the difference between this and #297 ?",
			"vote":"13",
			"content":"what's the difference between this and #297 ?"
		},
		{
			"lc_ans_id":"93179",
			"view":"3318",
			"top":"5",
			"title":"Java O(n) recursive DFS without \"null\" Changed from Serialize and Deserialize BT",
			"vote":"7",
			"content":"Thanks to [this post](https://discuss.leetcode.com/topic/66495/using-lower-bound-and-upper-bound-to-deserialize-bst), I realize that I can make use of lower and upper bound.\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) { // preorder\\n        StringBuilder sb = new StringBuilder();\\n        serializedfs(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serializedfs(TreeNode root, StringBuilder sb){\\n        if(root == null) return; // no \"null \"\\n        sb.append(root.val).append(\" \");\\n        serializedfs(root.left, sb);\\n        serializedfs(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data.length() == 0) return null;\\n        String[] list = data.split(\" \");\\n        TreeNode dummy = new TreeNode(0);\\n        deserializedfs(list, 0, dummy, true, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n        return dummy.left;\\n    }\\n    \\n    private int deserializedfs(String[] list, int pos, TreeNode par, boolean isleft, \\n                                                        int lower, int upper){\\n        if(pos >= list.length) return pos;\\n    \\n        int val = Integer.valueOf(list[pos]);\\n        if(val < lower || val > upper) return pos-1; // have not used this pos, so minus one\\n        TreeNode cur = new TreeNode(val);\\n        \\n        if(isleft) par.left = cur;\\n        else       par.right = cur;\\n\\n        pos = deserializedfs(list, ++pos, cur, true, lower, val);\\n        pos = deserializedfs(list, ++pos, cur, false, val, upper);\\n        return pos;\\n    }"
		},
		{
			"lc_ans_id":"93171",
			"view":"1055",
			"top":"6",
			"title":"Python O( N ) solution. easy to understand",
			"vote":"7",
			"content":"EDIT: Thanks to @WKVictor , this solution uses 'deque' instead of 'list' as queue. And the performance is O( N )\\n\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n\\n        return ' '.join(map(str, vals))\\n\\n    # O( N ) since each val run build once\\n    def deserialize(self, data):\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val, maxVal)\\n                return node\\n\\n        return build(float('-infinity'), float('infinity'))\\n\\n```"
		},
		{
			"lc_ans_id":"93170",
			"view":"341",
			"top":"7",
			"title":"pre or post order with only keeping one bound(beat 98% and 95%)",
			"vote":"5",
			"content":"the post-order:\\n\\n'''\\n\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            return;\\n        }\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n        sb.append(Integer.valueOf(root.val)).append(\" \");\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) {\\n            return null;\\n        }\\n        String[] nodes = data.split(\" \");\\n        int[] index = new int[] {nodes.length - 1};\\n        return deserialize(nodes, index, Integer.MIN_VALUE);\\n    }\\n    \\n    private TreeNode deserialize(String[] nodes, int[] index, int min) {\\n        if (index[0] < 0 || Integer.valueOf(nodes[index[0]]) <= min) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(nodes[index[0]--]));\\n        root.right = deserialize(nodes, index, root.val);\\n        root.left = deserialize(nodes, index, min);\\n        return root;\\n    }\\n}\\n\\n'''\\n\\npre-order\\n\\n'''\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            return;\\n        }\\n        sb.append(root.val).append(\" \");\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) {\\n            return null;\\n        }\\n        String[] nodes = data.split(\" \");\\n        int[] index = new int[] {0};\\n        return deserialize(nodes, index, Integer.MAX_VALUE);\\n    }\\n    \\n    private TreeNode deserialize(String[] nodes, int[] index, int max) {\\n        if (index[0] >= nodes.length || Integer.valueOf(nodes[index[0]]) >= max) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(nodes[index[0]++]));\\n        root.left = deserialize(nodes, index, root.val);\\n        root.right = deserialize(nodes, index, max);\\n        return root;\\n    }\\n}\\n\\n'''"
		},
		{
			"lc_ans_id":"93181",
			"view":"469",
			"top":"8",
			"title":"Preorder serialize and recursive deserialize C++ 26ms",
			"vote":"3",
			"content":"```\\nclass Codec {\\npublic:\\n    //Encodes a tree to a single string.\\n    void serialize(TreeNode* root, vector<int> &val)\\n    {\\n        if(root == NULL) return;\\n        val.push_back(root->val);\\n        serialize(root->left, val);\\n        serialize(root->right, val);\\n    }\\n\\n    string serialize(TreeNode* root) {\\n        vector<int> val;\\n        serialize(root, val);\\n        char *p = (char*)val.data();\\n        string str(p, val.size() * sizeof(int));\\n        return str;\\n    }\\n    \\n    // deserialize val[l .. r]\\n    TreeNode* deserializeSubtree(int *val, int l, int r)\\n    {\\n        if(l > r) return NULL;\\n        TreeNode *subRoot = new TreeNode(val[l]);\\n        int i = l+1;\\n        while(i <= r && val[i] < val[l]) ++i; \\n        subRoot->left = deserializeSubtree(val, l+1, i-1);\\n        subRoot->right = deserializeSubtree(val, i, r);\\n        return subRoot;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        //preorder traversed string\\n        int n = data.size() / sizeof(int);\\n        TreeNode *root = deserializeSubtree((int*)data.data(), 0, n-1);\\n        return root;\\n    }\\n    \\n};"
		},
		{
			"lc_ans_id":"93261",
			"view":"843",
			"top":"9",
			"title":"Java O(N) recursive solution",
			"vote":"3",
			"content":"```\\n// Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"*.\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(root.val);\\n        if (root.left == null && root.right == null) {\\n            sb.append(\"*.\");\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        sb.append(serialize(root.left));\\n        sb.append(serialize(root.right));\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        int[] begin = {0};\\n        return deserializeMethod(data, begin);\\n    }\\n\\n    private TreeNode deserializeMethod(String data, int[] begin) {\\n        int index = data.indexOf(\".\", begin[0]);\\n        TreeNode node = null;\\n        if (data.charAt(index - 1) == '*') {\\n            String str = data.substring(begin[0], index - 1);\\n            begin[0] = index + 1;\\n            if (str.equals(\"\")) {\\n                return null;\\n            }\\n            node = new TreeNode(Integer.parseInt(str));\\n        } else {\\n            String str = data.substring(begin[0], index);\\n            begin[0] = index + 1;\\n            node = new TreeNode(Integer.parseInt(str));\\n            node.left = deserializeMethod(data, begin);\\n            node.right = deserializeMethod(data, begin);\\n        }\\n        return node;\\n    }"
		}
	],
	"id":"443",
	"title":"Serialize and Deserialize BST",
	"content":"<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. </p>\r\n\r\n<p>Design an algorithm to serialize and deserialize a <b>binary search tree</b>. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\r\n\r\n<p>\r\n<b>The encoded string should be as compact as possible.</b>\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\r\n</p>",
	"frequency":"268",
	"ac_num":"22914"
}