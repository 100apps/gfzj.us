{
	"difficulty":"2",
	"submit_num":"56183",
	"show_id":"456",
	"leetcode_id":"456",
	"answers":[
		{
			"lc_ans_id":"94071",
			"view":"14207",
			"top":"0",
			"title":"Single pass C++ O(n) space and time solution (8 lines) with detailed explanation.",
			"vote":"89",
			"content":"QUESTION: To search for a subsequence (`s1,s2,s3`) such that `s1 < s3 < s2`.\\n\\nINTUITION: Suppose we want to find a `123` sequence with `s1 < s2 < s3`, we just need to find `s3`, followed by `s2` and `s1`. Now if we want to find a `132` sequence with `s1 < s3 < s2`, we need to switch up the order of searching. we want to first find `s2`, followed by `s3`, then `s1`. \\n\\nDETECTION: More precisely, we keep track of highest value of `s3` for each valid `(s2 > s3)` pair while searching for a valid `s1` candidate to the left.  Once we encounter any number on the left that is smaller than the largest `s3` we have seen so far, we know we found a valid sequence, since `s1 < s3` implies `s1 < s2`.\\n\\nALGORITHM: We can start from either side but I think starting from the right allow us to finish in a single pass. The idea is to start from end and search for valid `(s2,s3)` pairs, we just need to remember the largest valid `s3` value, using a `stack` will be effective for this purpose. A number becomes a candidate for `s3` if there is any number on the left bigger than it. \\n\\nCORRECTNESS: As we scan from right to left, we can easily keep track of the largest `s3` value of all `(s2,s3)` candidates encountered so far. Hence, each time we compare `nums[i]` with the largest candidate for `s3` within the interval `nums[i+1]...nums[n-1]` we are effectively asking the question: **Is there any 132 sequence with `s1 = nums[i]`?**  Therefore, if the function returns false, there must be no 132 sequence.\\n\\nIMPLEMENTATION: \\n1) Have a `stack`, each time we store a new number, we first `pop` out all numbers that are smaller than that number. The numbers that are `popped` out becomes candidate for `s3`.\\n2) We keep track of the `maximum` of such `s3` (which is always the most recently `popped` number from the `stack`).\\n3) Once we encounter any number smaller than `s3`, we know we found a valid sequence since `s1 < s3` implies `s1 < s2`.\\n\\nRUNTIME: Each item is `pushed` and `popped` once at most, the time complexity is therefore O(n).\\n\\nEXAMPLE: \\n`i = 6`, **nums** =  [ 9, 11, 8, 9, 10, 7, `9` ], **S1 candidate** = `9`, **S3 candidate** = `None`, **Stack** = `Empty`\\n`i = 5`, **nums** =  [ 9, 11, 8, 9, 10, `7`, 9 ], **S1 candidate** = `7`, **S3 candidate** = `None`, **Stack** = `[9]`\\n`i = 4`, **nums** =  [ 9, 11, 8, 9, `10`, 7, 9 ], **S1 candidate** = `10`, **S3 candidate** = `None`, **Stack** = `[9,7]`\\n`i = 3`, **nums** =  [ 9, 11, 8, `9`, 10, 7, 9 ], **S1 candidate** = `9`, **S3 candidate** = `9`, **Stack** = `[10]`\\n`i = 2`, **nums** =  [ 9, 11, `8`, 9, 10, 7, 9 ], **S1 candidate** = `8`, **S3 candidate** = `9`, **Stack** = `[10,9]` **We have `8<9`, sequence `(8,10,9)` found!**\\n\\nEDIT: Thanks @Pumpkin78 and @dalwise for pointing out that the maximum candidate for s3 is always the recently popped number from the stack, because if we encounter any entry smaller than the current candidate, the function would already have returned.\\nEDIT 2: Rephrased explanations and added a sketch of the correctness proof.\\n\\n```\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```"
		},
		{
			"lc_ans_id":"94089",
			"view":"4859",
			"top":"1",
			"title":"Java solutions from O(n^3) to O(n) for \"132\" pattern (updated with one-pass slution)",
			"vote":"45",
			"content":"This is a summary of the four solutions for this problem. It starts with the `O(n^3)` naive solution, then transition to the `O(n^2)` sub-optimal solution and finally to the two optimized `O(n)` solutions (one is two-pass while the other is one-pass). \\n\\n---\\n\\n**`I. Naive O(n^3) solution`**\\n\\nThe naive `O(n^3)` solution is a no-brainer --- simply check every `(i, j, k)` combination to see if there is any `132` pattern.\\n```\\npublic boolean find132pattern(int[] nums) {\\n    for (int i = 0; i < nums.length; i++) {\\n        for (int j = i + 1; j < nums.length; j++) {\\n            for (int k = j + 1; k < nums.length; k++) {\\n                if (nums[i] < nums[k] && nums[k] < nums[j]) return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\\nAnd of course it will get rejected due to TLE. So let's see how we can do better.\\n\\n---\\n\\n**`II. Improved O(n^2) solution`**\\n\\nTo reduce the time complexity down to `O(n^2)`, we need to do some observations. In the naive solution above, let's assume we have index `j` fixed, what should index `i` be so that it is most probable we will have a `132` pattern? Or in other words, what should `i` be so that we will be certain there is no such `132` pattern for combination `(*, j, *)` whenever there is no `132` pattern for combination of `(i, j, *)`? (Here `*` means any index before or after index `j`.)\\n\\nThe answer lies in the fact that once the first two numbers `nums[i]` and `nums[j]` are fixed, we are up to find the third number `nums[k]` which will be within the range `(nums[i], nums[j])` (the two boundaries are exclusive). Intuitively the larger the range is, the more likely there will be a number \"falling into\" it. Therefore we need to choose index `i` which will maximize the range `(nums[i], nums[j])`. Since the upper bound `nums[j]` is fixed, this is equivalent to minimizing the lower bound `nums[i]`. Thus it is clear `i` should be the index of the minimum element of the subarray `nums[0, j)` (left inclusive, right exclusive).\\n\\nSince we are scanning index `j` from the beginning of the input array `nums`, we can keep track of the minimum element of the subarray from index `0` up to `j - 1` without rescanning it. Therefore the first two loops in the naive solution can be combined into one and leads to the following `O(n^2)` solution:\\n```\\npublic boolean find132pattern(int[] nums) {\\n    for (int j = 0, min = Integer.MAX_VALUE; j < nums.length; j++) {\\n         min = Math.min(nums[j], min);\\n         if (min == nums[j]) continue;\\n         \\n         for (int k = nums.length - 1; k > j; k--) {\\n             if (min < nums[k] && nums[k] < nums[j]) return true;\\n         }\\n     }\\n     \\n     return false;\\n}\\n```\\nWhile this solution can be accepted, it runs slow. One obvious drawback is that in the second loop we are throwing away information about elements in the right part of `nums` that may be \"useful\" for later combinations. It turns out we can retain this \"useful\" information by applying the classic space-time tradeoff, which leads to the following `O(n)` time and `O(n)` space solution.\\n\\n---\\n\\n**`III. Optimized O(n) solution`**\\n\\nAs I mentioned, to further reduce the time complexity, we need to record the \"useful\" information about elements in the right part of the input array `nums`. Since these elements are located at the right part of `nums`, it will be hard to do so if we are scanning the array from the beginning. So the idea is to scan it from the end while in the meantime keep track of the \"useful\" information. But still at each index `j`, we need to know the minimum element for subarray `nums[0, j)`. This can be done by doing a pre-scan in the forward direction and memorize the results for each index in an auxiliary array (we will call the array as `arr` whose element `arr[j]` will denote the minimum element in the subarray `nums[0, j)`).\\n\\nUntil now we are kinda vague about the exact meaning of \"useful\" information, so let's try to be more specific. Assume we're currently scanning (from the end) the element with index `j`, our task is to find two elements `nums[i]` and `nums[k]` to determine if there exists a `132` pattern, with `i < j < k`. The left element `nums[i]`, as it has been shown in part `II`, will be chosen as `arr[j]`, the minimum element of subarray `nums[0, j)`. What about the right element `nums[k]`?\\n\\nThe answer to that will address the meaning of \"useful\" information. First note we are only interested in elements that are greater than `arr[j]`, so it is sensible to maintain only those elements. Second, among all these qualified elements, which one will be the most probable to fall into the range `(nums[i], nums[j])`? I would say it is the smallest one (i.e., if the smallest one is out of the range, all others will also be out of range). So to sum up, the \"useful\" information for current index `j` will be a collection of scanned elements that are greater than `arr[j]`, and `nums[k]` will be chosen as the smallest one if the collection is not empty.\\n\\nFrom the analyses above, it looks like we have to do some sorting stuff for the retained elements (or at least find a way to figure out its smallest element). Well, it turns out these elements will be sorted automatically due to the fact that `arr[j'] >= arr[j]` as long as `j' < j`. Here is how it goes, which is a proof by induction.\\n\\nAt the beginning we have an empty collection and of course it is sorted. Now suppose we are at index `j` and the corresponding collection is still sorted, let's see if it remains so at index `j - 1`. First we will check if `nums[j]` is greater than `arr[j]`. If not, we simply continue to `j - 1`. Since the collection is intact so it will be sorted at `j - 1`. Otherwise, we need to remove elements in the collection that are no greater than `arr[j]` (this is necessary because some smaller elements may be left over in the collection from previous steps). After removal, we then compare the first element in the collection with `nums[j]` to see if a `132` pattern has been found, provided the collection is not empty. If so, return true. Otherwise one of the following must be true: the collection is empty or `nums[j]` is no greater than the first element in the collection. In either case the collection is sorted. Now if we have `arr[j - 1] < nums[j]`, we need to add `nums[j]` to the collection since it is a qualified number for `arr[j - 1]`. Again in either case the collection will remain sorted after addition (if it is empty, after addition there is only one element; otherwise since the added element is no greater than the first element in the collection before addition, it will become the new first element after addition and the collection stays sorted).\\n\\nHere is the program with `O(n)` time and space complexity. There is one minor optimization based on the observation that the total number of elements in the collection will never exceed the total number of elements scanned so far. Therefore the right part of the `arr` array can be used to serve as the collection. For time complexity, each element in the input array `nums` will be pushed into and popped out from the collection (or stack to be exact) at most once, the time complexity will be `O(n)` despite of the nested loop.\\n```\\npublic boolean find132pattern(int[] nums) {\\n    int[] arr = Arrays.copyOf(nums, nums.length);\\n\\n    for (int i = 1; i < nums.length; i++) {\\n        arr[i] = Math.min(nums[i - 1], arr[i - 1]);\\n    }\\n    \\n    for (int j = nums.length - 1, top = nums.length; j >= 0; j--) {\\n        if (nums[j] <= arr[j]) continue;\\n        while (top < nums.length && arr[top] <= arr[j]) top++;\\n        if (top < nums.length && nums[j] > arr[top]) return true;\\n        arr[--top] = nums[j];\\n    }\\n        \\n    return false;\\n}\\n```\\n\\n---\\n\\n**`IV -- One-pass O(n) solution`**\\n\\nIt turned out that we don't need the `arr` array in part **`III`**, thus can get rid of the pre-scan. The idea is to do backward traversal of the input array and keep track of the maximum value (denoted as `third`) of all possible third numbers obtained so far (an element can be a candidate for the third number if and only if there is another element coming before and greater than it). This is because for two candidate third numbers `a` and `b`, if `a <= b` and there is no `132` pattern for `b`, then there must be no `132` pattern for `a` either. The idea is elaborated as follows. \\n\\nFor the current element being examined, we first check if it can be the first number by comparing it with `third`. If this is the case, a `132` pattern has been found. Otherwise, it will be treated as the second number to qualify scanned elements so far as candidate third numbers (note we are doing backward scan so the current element will always come before scanned elements). Of course we cannot do this for all scanned elements, as it will lead to an `O(n^2)` solution. Fortunately it suffices only to process scanned elements that are greater than `third`. This is because after an element is qualified to be the third number, it will only be used to update `third`. For those elements smaller than `third`, even if they are qualified to be the third number, they won't make `third` any larger and therefore can be ignored.\\n\\nSo we need to maintain a collection (stack, to be exact) for scanned elements that are greater than `third`. After the current element is done, it will be added to this collection for future processing. It can be shown by mathematical induction that elements in the collection will be sorted automatically, similar to that in part **`III`**. At the beginning the collection is empty so the base case is true. Assume the collection is sorted immediately before processing the current element, which is presumed to be `>= third` (otherwise a `132` pattern is found). We will scan the collection and pop all elements smaller than the current element to find all qualified third numbers and update `third` accordingly. At the end, all remaining elements in the collection are no less than the current element, therefore adding it to the collection won't break the sorted property. So our induction assumption is also true.\\n\\nHere is the one-pass `O(n)` solution. We can also optimize the space cost to `O(1)` if the input array can act as the collection by taking advantage of the fact that size of the collection will never exceed the number of elements scanned so far.\\n\\n```\\npublic boolean find132pattern(int[] nums) {\\n    for (int n = nums.length, i = n - 1, top = n, third = Integer.MIN_VALUE; i >= 0; i--) {\\n        if (nums[i] < third) return true;\\n        while (top < n && nums[i] > nums[top]) third = nums[top++];\\n        nums[--top] = nums[i];\\n    }\\n    \\n    return false;\\n}\\n```"
		},
		{
			"lc_ans_id":"94077",
			"view":"10776",
			"top":"2",
			"title":"Java O(n) solution using stack in detail explanation",
			"vote":"42",
			"content":"The idea is that we can use a stack to keep track of previous min-max intervals. \\n\\nHere is the principle to maintain the stack:\\n\\nFor each number ```num``` in the array\\n\\nIf stack is empty:\\n\\n* push a new Pair of ```num``` into stack\\n\\nIf stack is not empty:\\n\\n* if ```num``` < ```stack.peek().min```,  push a new Pair of ```num``` into stack\\n\\n* if ```num```  >= ```stack.peek().min```, we first pop() out the peek element, denoted as ```last```\\n     * if  ```num```  < ```last.max```, we are done, return ```true```;\\n     \\n     * if  ```num```  >= ```last.max```, we merge ```num``` into ```last```, which means ```last.max``` = ```num```.  \\nOnce we update ```last```,  if stack is empty, we just push back ```last```. \\n**However, the crucial part is:** \\nIf stack is not empty, the updated ```last``` might:  \\n       \\n         * Entirely covered stack.peek(), i.e. ```last.min``` < ```stack.peek().min``` (which is always true) && ```last.max``` >= ```stack.peek().max```, in which case we keep popping out stack.peek().\\n         * Form a 1-3-2 pattern, we are done ,return ```true```\\n\\nSo at any time in the stack, **non-overlapping** ```Pairs``` are formed in descending order by their min value, which means the min value of peek element in the stack is always the min value globally. \\n\\n```\\n   class Pair{\\n        int min, max;\\n        public Pair(int min, int max){\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Pair> stack = new Stack();\\n        for(int n: nums){\\n            if(stack.isEmpty() || n <stack.peek().min ) stack.push(new Pair(n,n));\\n            else if(n > stack.peek().min){ \\n                Pair last = stack.pop();\\n                if(n < last.max) return true;\\n                else {\\n                    last.max = n;\\n                    while(!stack.isEmpty() && n >= stack.peek().max) stack.pop();\\n                    // At this time, n < stack.peek().max (if stack not empty)\\n                    if(!stack.isEmpty() && stack.peek().min < n) return true;\\n                    stack.push(last);\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n```"
		},
		{
			"lc_ans_id":"94076",
			"view":"4219",
			"top":"3",
			"title":"Share my easy and simple solution",
			"vote":"8",
			"content":"Idea: Find peak and bottom\\n\\nFor every [bottom, peak], find if there is one number `bottom<number<peak`. \\n\\n```java\\npublic class Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length<3) return false;\\n        Integer low = null, high = null;\\n        int start = 0, end = 0;\\n        while(start<nums.length-1){\\n            while(start<nums.length-1 && nums[start]>=nums[start+1]) start++;\\n            // start is lowest now\\n            int m = start+1;\\n            while(m<nums.length-1 && nums[m]<=nums[m+1]) m++;\\n            // m is highest now\\n            int j = m+1;\\n            while(j<nums.length){\\n                if(nums[j]>nums[start] && nums[j]<nums[m]) return true;\\n                j++;\\n            }\\n            start = m+1;\\n        }\\n        return false;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"94090",
			"view":"1272",
			"top":"4",
			"title":"Python O(n) solution using stack",
			"vote":"3",
			"content":"Scan `nums` only once. The `stack` maintains a list of disjoint intervals (except the end point)  where the lower  and upper bound of each interval denote the minimum and maximum in the '132' pattern respectively. Thus any subsequent number which is strictly contained in any intervals in the `stack` will form a '132' pattern.\\n The order of intervals in the `stack` are maintained in a way such that if the right end of interval `A`  is less than or equal to the left end of interval `B`, then `A` is above `B` in the `stack`. The time complexity is O(N), since each number will at most be pushed and popped once. \\n```\\n    def find132pattern(self, nums):\\n        if len(set(nums)) < 3:\\n            return False\\n        stack = [[nums[0], nums[0]]]\\n        current_min = nums[0]\\n        for i in range(1, len(nums)):\\n            curr = nums[i]\\n            if curr >= stack[0][1]:  # curr >= max(nums[:i])\\n                stack = [[current_min, curr]]\\n            elif curr < current_min:  # curr < min(nums[:i])\\n                stack.append([curr, curr])\\n                current_min = curr\\n            elif curr == current_min:\\n                continue\\n            else:\\n                while stack and curr > stack[-1][0]:\\n                    if curr < stack[-1][1]:\\n                        return True\\n                    else:\\n                        stack.pop()\\n                stack.append([current_min, curr])\\n        return False\\n```"
		},
		{
			"lc_ans_id":"94092",
			"view":"240",
			"top":"5",
			"title":"C++ O(n) greedy solution using stack",
			"vote":"2",
			"content":"Since, it is 132 pattern. The smallest of the three is in front of the other two. We'd better scan from back to front. In this way, we can maintain a pair of biggest numbers (S3 and S2) and looking for S1 which is smaller than S2 (S1 < S2). Otherwise, we pop numbers in stack and update S2 accordingly.\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> stk;\\n        int s2 = INT_MIN;\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            if (nums[i] < s2)\\n                return true;\\n            \\n            while (!stk.empty() && stk.top() < nums[i]) {\\n                s2 = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"94133",
			"view":"393",
			"top":"6",
			"title":"Simple java accepted well explained O(n^2) solution",
			"vote":"2",
			"content":"```\\n    public boolean find132pattern(int[] nums) {\\n        if(nums == null || nums.length < 3) {\\n            return false;\\n        }\\n        \\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int bigger = nums[i];    \\n            for(int j = i + 1; j < nums.length; j++) {\\n                // 1. We don't care about numbers\\n                // less than a[i]\\n                if(nums[j] <= nums[i]) continue;\\n                \\n                // 2. If num is greater than bigger\\n                // then update bigger\\n                if(nums[j] >= bigger) {\\n                    bigger = nums[j];\\n                } else {\\n                    // Now this number is greater than nums[i]\\n                    // see 1. and less than bigger, see 2.\\n                    return true;\\n                }  \\n            }\\n        }\\n        return false;\\n    }\\n```"
		},
		{
			"lc_ans_id":"94137",
			"view":"317",
			"top":"7",
			"title":"O(nlogn) Solution Using STL Multimap",
			"vote":"2",
			"content":"class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        multiset<int> left;\\n        multiset<int> right;\\n        \\n        for(auto it: nums)\\n            right.insert(it);\\n        \\n        for(auto it: nums)\\n        {\\n            if(left.size() > 0 and right.size() > 0)\\n            {    \\n                int lo = *left.begin();\\n                auto it1 = right.lower_bound(it);\\n                if(it1 != right.begin())\\n                {\\n                    it1--;\\n                    int hi = *it1;\\n                    if(lo < it and hi < it and hi > lo)\\n                    return 1;\\n                }\\n            }\\n            \\n            left.insert(it);\\n            auto it2 = right.find(it);\\n            right.erase(it2);\\n        }\\n        \\n        return 0;\\n    }\\n};"
		},
		{
			"lc_ans_id":"94086",
			"view":"1054",
			"top":"8",
			"title":"Python solution in O(nlogn)",
			"vote":"2",
			"content":"I tried multiple O(n^2) solutions and it seems only O(nlogn) is accepted for Python.\\n\\nFirst we make the ```left``` list that maintains the min value up to index ```i```. \\nThen we make the ```right``` list backward that maintains the smallest number that is larger than ```left[i]``` up to ```i``` using a heap.\\nFinally we iterate through ```nums``` and check if ```left[i] < right[i] < num```.\\n\\n```\\nimport heapq\\n\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums:\\n            return False\\n        left = [nums[0]]\\n        for num in nums[1:]:\\n            left.append(min(left[-1], num))\\n        q = []\\n        right = [None] * len(nums)\\n        for i, num in enumerate(nums[::-1]):\\n            heapq.heappush(q, num)\\n            while q and q[0] <= left[len(nums) - i - 1]:\\n                heapq.heappop(q)\\n            if q:\\n                right[len(nums) - i - 1] = q[0]\\n        for i, num in enumerate(nums):\\n            if right and left[i] < right[i] < num:\\n                return True\\n        return False\\n```"
		},
		{
			"lc_ans_id":"94079",
			"view":"3052",
			"top":"9",
			"title":"C ++ solution ,in O(n)",
			"vote":"2",
			"content":"For each index i , we will find out the closest index j to the left , such that the number in the index is greater than it , and see if there exists an index k for which the number at index k is less that the number at index i,\\nwe maintain an array dp , that stores the closes index to the left such that it is greater that the number at any index , building this dp array is O(n).\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int i,j,k,n;\\n        n = nums.size();\\n        if(n<3)\\n            return false;\\n        vector<int> mn(nums.begin(),nums.end());\\n        for(i=1;i<n;i++)\\n            mn[i] = min(mn[i],mn[i-1]);\\n        int dp[n]{-1};\\n        for(i=0;i<n;i++)\\n            {\\n                j = i-1;\\n                while(j!= -1 && nums[j]<=nums[i])\\n                    j = dp[j];\\n                dp[i] = j;\\n            }\\n        for(i=2;i<n;i++)\\n            {\\n                j = dp[i];\\n                if(j>0 && mn[j-1]<nums[i])\\n                    return true;\\n            }\\n        return false;\\n    }\\n};\\n```"
		}
	],
	"id":"450",
	"title":"132 Pattern",
	"content":"<p>\r\nGiven a sequence of n integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, a 132 pattern is a subsequence a<sub><b>i</b></sub>, a<sub><b>j</b></sub>, a<sub><b>k</b></sub> such\r\nthat <b>i</b> < <b>j</b> < <b>k</b> and a<sub><b>i</b></sub> < a<sub><b>k</b></sub> < a<sub><b>j</b></sub>. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>\r\n\r\n<p><b>Note:</b> n will be less than 15,000.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1, 2, 3, 4]\r\n\r\n<b>Output:</b> False\r\n\r\n<b>Explanation:</b> There is no 132 pattern in the sequence.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [3, 1, 4, 2]\r\n\r\n<b>Output:</b> True\r\n\r\n<b>Explanation:</b> There is a 132 pattern in the sequence: [1, 4, 2].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> [-1, 3, 2, 0]\r\n\r\n<b>Output:</b> True\r\n\r\n<b>Explanation:</b> There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\r\n</pre>\r\n</p>",
	"frequency":"197",
	"ac_num":"15868"
}