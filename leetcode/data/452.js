{
	"difficulty":"1",
	"submit_num":"18287",
	"show_id":"458",
	"leetcode_id":"458",
	"answers":[
		{
			"lc_ans_id":"94266",
			"view":"24992",
			"top":"0",
			"title":"Another explanation and solution",
			"vote":"129",
			"content":"With 2 pigs, poison killing in 15 minutes, and having 60 minutes, we can find the poison in up to 25 buckets in the following way. Arrange the buckets in a 5&times;5 square:\\n\\n```\\n 1  2  3  4  5\\n 6  7  8  9 10\\n11 12 13 14 15\\n16 17 18 19 20\\n21 22 23 24 25\\n```\\nNow **use one pig to find the row** (make it drink from buckets 1, 2, 3, 4, 5, wait 15 minutes, make it drink from buckets 6, 7, 8, 9, 10, wait 15 minutes, etc). **Use the second pig to find the column** (make it drink 1, 6, 11, 16, 21, then 2, 7, 12, 17, 22, etc).\\n\\nHaving 60 minutes and tests taking 15 minutes means we can run four tests. If the row pig dies in the third test, the poison is in the third row. If the column pig doesn't die at all, the poison is in the fifth column (this is why we can cover five rows/columns even though we can only run four tests).\\n\\nWith 3 pigs, we can similarly use a 5&times;5&times;5 cube instead of a 5&times;5 square and again use one pig to determine the coordinate of one dimension (one pig drinks layers from top to bottom, one drinks layers from left to right, one drinks layers from front to back). So 3 pigs can solve up to 125 buckets.\\n\\nIn general, we can solve up to (&lfloor;minutesToTest / minutesToDie&rfloor; + 1)<sup>pigs</sup> buckets this way, so just find the smallest sufficient number of pigs for example like this:\\n\\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\\n        pigs = 0\\n        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:\\n            pigs += 1\\n        return pigs\\n\\nOr with logarithm like I've seen other people do it. That's also where I got the idea from (I didn't really try solving this problem on my own because the judge's solution originally [was wrong](https://discuss.leetcode.com/topic/66856/major-flaw-in-current-algorithm-fixed) and I was more interested in possibly helping to make it right quickly)."
		},
		{
			"lc_ans_id":"94273",
			"view":"13356",
			"top":"1",
			"title":"Solution with detailed explanation",
			"vote":"52",
			"content":"To be honest, I've spent several days thinking about this question. It's not only fun, but also confusing. it drives me up the wall, especially for its **easy** difficulty. \\U0001f629\\n\\n### Thinking Process\\n\\n***1. What if you only have one shot?***\\n\\n> Eg. **4** buckets, **15** mins to die, and **15** mins to test.\\n\\nThe answer is **2**. Suppose we use A and B to represent pigs, we could have\\n\\n![0_1478958363340_upload-5c96756b-ca9f-41f2-b597-ff57a040ebe8](/uploads/files/1478958363472-upload-5c96756b-ca9f-41f2-b597-ff57a040ebe8.png)\\n\\nObviously we could use the binary form to represent the solution.\\n\\n![0_1478958322597_upload-0812d848-8375-4422-813e-b97bdd37c653](/uploads/files/1478958322907-upload-0812d848-8375-4422-813e-b97bdd37c653.png) \\n\\n**Conclusion**: If we have `x` pigs,  we could use them to represent (encode) `2^x` buckets.\\n\\n***2. What if we could have more than one attempts?***\\n\\n> Eg. **4** buckets, **15** mins to die, and **30** mins to test.\\n\\nAt the moment, I consider the problem as an encoding problem: *With more attempts, how to use fewer pigs to represent all the buckets?*\\n\\nI got lost at this step by keep thinking the binary way. After hanging around the forum, I got the idea to change my views. Let's go back to the one shot situation. What does the binary form mean? It's much easier if we regard it as:\\n\\n+ `0` means the pig does not drink and die.\\n+ `1` means the pig drinks in the first (and only) round.\\n\\nWe could generalise with:\\n\\n+ `0` means the pig does not drink and die.\\n+ `1` means the pig drinks in the first round and die.\\n+ `2` means the pig drinks in the second round and die.\\n...\\n+ `t` means the pig drinks in the t-th round and die.\\n\\n**Conclusion**: If we have `t` attempts, we could use `t+1`-based number to represent (encode) the buckets. (That's also why the first conclusion uses the `2`-based number)\\n\\n### Example\\n\\n> Eg. **8** buckets, **15** mins to die, and **40** mins to test.\\n\\nWe have **2** (`= (40/15).floor`) attempts, as a result we'll use **3**-based number to encode the buckets. \\n\\nHow many pigs do we need? Answer is 2 (`= Math.log(8, 3).ceil`)\\n\\n![0_1478960257723_upload-0da5c126-bf43-4183-935d-c2c1a5b5df15](/uploads/files/1478960260176-upload-0da5c126-bf43-4183-935d-c2c1a5b5df15.png) \\n\\nFor example 3-based number `02` means: the pig **A** does not drink and die, and the pig **B** drinks in the second round and die.\\n\\n### Ruby Code\\n\\n```ruby\\nclass FooTest < Minitest::Test\\n  def poor_pigs(buckets, minutes_to_die, minutes_to_test)\\n    states = minutes_to_test / minutes_to_die + 1\\n\\n    Math.log(buckets, states).ceil\\n  end\\n\\n  def test_run\\n    assert_equal 1, poor_pigs(2, 10, 10)\\n    assert_equal 2, poor_pigs(4, 10, 10)\\n    assert_equal 3, poor_pigs(8, 10, 10)\\n    assert_equal 4, poor_pigs(16, 10, 10)\\n\\n    assert_equal 1, poor_pigs(2, 10, 20)\\n    assert_equal 2, poor_pigs(4, 10, 20)\\n    assert_equal 2, poor_pigs(8, 10, 20)\\n    assert_equal 3, poor_pigs(16, 10, 20)\\n\\n    assert_equal 5, poor_pigs(1000, 15, 60)\\n  end\\nend\\n\\n```"
		},
		{
			"lc_ans_id":"94299",
			"view":"7033",
			"top":"2",
			"title":"Why is the difficulty of this problem easy?",
			"vote":"27",
			"content":"I think it should be at least medium since the tricky idea is very hard to be figured out."
		},
		{
			"lc_ans_id":"94292",
			"view":"6231",
			"top":"3",
			"title":"Major flaw in current algorithm [FIXED]",
			"vote":"18",
			"content":"EDIT: This issue has now been fixed. \\nI personally feel that @ifyouseewendy's equivalent approach: [https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation] is significantly better explained than mine and would recommend that you read/upvote this to understand the problem. \\n\\n--\\n\\nThe basic case (and presumably a significant amount more) are incorrect as more efficient solutions can be generated if we do not use base 2.\\n\\nAssume for now we have: [**buckets**, 15, 60]\\n\\nPer pig, we have 5 states that we can detect: death on 15, 30, 45, 60, or life.\\n\\nAssume for the moment we have 5 buckets and one pig with the above timings.\\n\\nRepresent each bucket as an integer in base 5 (0-indexed).\\n\\nPig drinks from bucket 0 at 0 minutes, bucket 1 at time 15 etc...\\nIf the pig is still alive, by elimination, we know that bucket 4 would be poisonous. \\nThis should be trivial to see.\\n\\nWe now increase the number of buckets to 25, we have ceil(log_5(25)) = 2 pigs\\n\\nBucket 25 is labelled 44, bucket 1 is labelled 00.\\nAt time **t**, have the first pig drink from the buckets where the first digit is **t**, have the second pig drink when the second digit is **t**. As each pig represents a single digit in base 5, and 25 consists of two base 5 digits, two pigs are necessary. We can determine the value of each digit based on the time of death of each pig. An overlap of the death of two pigs gives us the information of two digits, so nothing is lost.\\n\\nExample: 18 is poisonous (33 in base 5).\\n\\nOn t=3, one pig is drinking [15,16,17,18,19] and the other is drinking [3,8,13,18,23]. We can see that if both die, the intersection of the sets yields 18.\\n\\nGiven the default input: 1000, 15, 60\\n\\nThe above yields the minimum number of pigs = ceil(log_5(1000)) = 5 pigs.\\n\\nThe OJ currently returns 8 pigs, which is significantly higher."
		},
		{
			"lc_ans_id":"94307",
			"view":"3179",
			"top":"4",
			"title":"Turn dynamic programming into mathematical formula",
			"vote":"11",
			"content":"Firstly, we define N = buckets, T = minutesToTest / minutesToDie (round below as integer division), so we can see T is the maximum times we can carry out our test (we can have all our pigs drinking water at the same time and regard it as ONE test).\\n\\nThen according to dynamic programming, define dp[n][t] as the maximum buckets we can detect when one of them contains poison, given the n pigs at the beginning and t times for carrying out tests. So let's go through some basic cases.\\n\\ndp[1][1] == 2, since if you have just one pig and can only do one test, the maximum buckets you can detect is 2: you can choose any one bucket to feed the pig, and if it dies after a certain time, the poison is in the chosen bucket, otherwise in the other one. \\n\\nThen we can know that dp[1][t] == t + 1, you can carry out tests that have the only one pig drinking bucket one by one and get the poisonous bucket. \\n\\nHow about dp[n][1]? This is a little tricky. We can encode the buckets with binary number, for example, there is 16 buckets and we encode them from 0 to 15 as 0000, 0001, 0010, ..., 1110, 1111, and also give each pig a sequence number from 0 to n - 1. After that, we feed these n pigs as binary number do, that is, we don't feed bucket 0 to any pig, since bucket 0's code is all 0s; we feed bucket 10 whose code is 1010 to pig 1 and pig 3, since the bit 1 and bit 3 of 1010 is 1s while other bits are 0s(we count the bit from LSB and start from 0). After feeding the pigs, we can view the state of each pig, and set state \"alive\" as 0 and \"died\" as 1, then these pigs' states form a binary number, for example 1100, means pig 2 and pig 3 are died, which means the code of poisonous bucket is exactly 1100, namely bucket 12. Thus, we can detect as many as 2^n buckets in one test with n pigs, that is, dp[n][1] == 2^n.\\n\\nWith these basic cases, we can construct our state transition equation now. For dp[n][t], how can we make full use of all 2^n states those pigs can generate after one test? The answer is simple. After one test, if all pigs dies, we must assure there is only one bucket that all pigs drank from, since we don't have any pigs to use afterwards. If we have k pigs alive(0 < k <= n), we can use these pigs to detect at most dp[k][t-1] buckets. With some knowledge of permutation and combination, the number of cases we can have k pigs alive after one test is C(n, k) (when k == 0, it also holds true). So our state transition equation is\\n\\n    dp[n][t] = \\n    C(n,0)+C(n,1)dp[1][t-1]+...+C(n,k)dp[k][t-1]+...+C(n,n)dp[n][t-1], where 0 <= k <= n, t >= 2\\n\\nThus\\n    \\n    dp[n][2] =  C(n,0)+C(n,1)dp[1][1]+...+C(n,k)dp[k][1]+...+C(n,n)dp[n][1]= \\n    C(n,0)+C(n,1)2^1+...+C(n,k)2^k+...+C(n,n)2^n=3^n\\n    dp[n][3] =  C(n,0)+C(n,1)dp[1][2]+...+C(n,k)dp[k][2]+...+C(n,n)dp[n][2]= \\n    C(n,0)+C(n,1)3^1+...+C(n,k)3^k+...+C(n,n)3^n=4^n\\n    ...\\n\\nA concise mathematical formula is generated! \\n\\n    dp[n][t] = (t+1)^n, for all n >= 1 and t >= 1.\\nCome back to our origin problem, if we can use minimum n pigs to detect N buckets with T tests, n should be \\n    \\n    ceil(log_(t+1)(N))\\n    == ceil((log(N)/log(t+1))\\n\\nCeil is rounding above. Here I give a illustration of dp[2][2] == (2+1)^2 == 9 as an example below:\\n\\nWe have 2 pigs at first and can carry out 2 tests. Firstly, we know 2 pigs can form 4 states of \"alive\"(0) or \"died\"(1), including 00, 01, 10, 11, each one is relative to a subproblem of dynamic programming. If after one test, two pigs both die, we can only handle one bucket in this case. However, if we have only one pig alive, we can handle dp[1][1](one pig left, with one chance of test left) namely 2 buckets, and there are actually two cases of only one pig left alive(2 == C(2, 1)). If both two are alive, we can handle  dp[2][1] = 2^2=4 buckets totally. Thus, we separate 9 into 4 groups, and each one respectively contains 1, 2, 2 and 4 buckets, and design our first test. We feed our pig 0 with bucket 0, bucket 1 and bucket 3, and feed our pig 1 with bucket 0, bucket 2 and bucket 4. So you can see no matter which code is generated after one test, the problem is reduced to a subproblem we have already solved before.\\n\\nBased on the analysis above, I can explain the answer for input [1000, 15, 60], in which according to my definition,  N == 1000 and T == 60/15=4, the minimum number of pigs we use should be ceil(log_(4+1)(1000))~=ceil(4.29)==5\\n\\nFinally, notice that if there is only 1 bucket, we can immediately detect this bucket containing poison, without any pigs or tests."
		},
		{
			"lc_ans_id":"94278",
			"view":"140",
			"top":"5",
			"title":"Very Clear Explanation by Short Examples",
			"vote":"5",
			"content":"Let's think in another way: \\n**If we get N pigs and can test T times, what is the maximum number of buckets that we can successfully detect the poison among them?**\\n\\n-----------\\n\\nHere we take T=1 (can only test once) and N=2 (2 pigs) as example:\\n```\\n    x -> not drink      o -> drink\\n\\nT=1  N=2:\\n\\n   buckets       1    2    3    4\\n     pig 1       x    x    o    o\\n     pig 2       x    o    x    o\\n\\n Result:   2 pigs and test 1 times -> 4 buckets\\n```\\n### Conclusion  T=1  N=n:\\n#### n pigs and test 1 times can deal with how many buckets\\n=  2^n    \\n\\n\\n----------------\\n\\n\\nWe take T=2 (can only test twice) and N=2 (2 pigs) as example:\\n```\\nT=2  N=2:\\n\\n   buckets       1    2    3    4    5    6    7    8    9  \\n     pig 1       o    x    x    o    o    x    x    x    x    \\n     pig 2       o    o    o    x    x    x    x    x    x\\n                                                  \\nResult:   2 pigs and test 2 times --> 9 buckets\\n\\nExplain:   \\n  pig 1 & 2 died     ->  1 possible bucket\\n  pig 1 died only    ->  2 possible buckets  -> 1 pig and 1 times can deal with 2 buckets(straight-forward)\\n  pig 2 died only    ->  2 possible buckets  -> 1 pig and 1 times can deal with 2 buckets(straight-forward)\\n  pig 1 & 2 survived ->  4 possible buckets  -> 2 pigs and 1 times can deal with 4 buckets(Previous case: T=1 N=2)\\n```\\n### Conclusion  T=2  N=n:\\n#### n pigs and test 2 times can deal with how many buckets\\n= C(n,n) * 2^0 + C(n,n-1) * 2^1 + ... + C(n,0) * 2^n \\n= (1+2)^n \\n= 3^n  \\n\\n**Explain:** \\n#(all pigs died) + #(1 pigs survived) * can test 2 buckets(T=1 N=1)  + #(2 pigs survived) * can test 4 buckets(T=1 N=2) + ..... + #(n pigs survived) * can test 2^n buckets(T=1 N=n)\\n\\n ----------------\\n\\nNow, try to think about the case T=3 (can test 3 times) and N=n (n pigs)\\n\\n### Conclusion (T=3  N=n): \\n#### n pigs and test 3 times can deal with how many buckets\\n= C(n,n) * 3^0 + C(n,n-1) * 3^1 + ... + C(n,0) * 3^n \\n= (1+3)^n \\n= 4^n\\n\\n**Explain:** \\n#(all pigs died) + #(1 pigs survived) * can test 3 buckets(T=2 N=1)  + #(2 pigs survived) * can test 9 buckets(T=2 N=2) + ..... + #(n pigs survived) * can test 3^n buckets(T=2 N=n)\\n\\n-----------------\\n\\n#### To sum it up, \\nIf we get **N** pig and can test **T** times, the maximum number of buckets that we can successfully detect the poison among them is ----> **(1+T)^N**.\\n\\n\\nTherefore, the answer to the question is:\\n```\\n MIN(n),   where (1+T)^n >= number of buckets    \\n                   Note: T = minutesToTest/minutesToDie\\n```"
		},
		{
			"lc_ans_id":"94328",
			"view":"1025",
			"top":"6",
			"title":"Math problem, Java AC code with brief explanations, 11/09/2016",
			"vote":"5",
			"content":"This is a Math problem.\\nThe table below shows how it works, n denotes the pig, and s is associated with each status of the pig. \\nfor each pig, there is t+1 status, which is death in 1st, 2nd, 3rd, 4th time slot and live eventually. \\nTherefore the question is asking for how many pigs can denote 1000 in 5-nary number system.\\n=======Table=======\\nn1 n2 n3 n4 n5 \\ns1  1   0   0   1   0\\ns2  0   0   0   0   1   \\ns3  0   1   0   0   0\\ns4  0   0   0   0   0\\ns5  0   0   1   0   0\\n\\nIn this case, the number is 13012 in 5-nary number system. \\n* Here is my Java AC code\\n```\\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        int status = minutesToTest/minutesToDie + 1;\\n        int num_of_pig = 0;\\n        while(Math.pow(status, num_of_pig) < buckets) {num_of_pig++;}\\n        return num_of_pig;\\n    }\\n```"
		},
		{
			"lc_ans_id":"94305",
			"view":"532",
			"top":"7",
			"title":"1-line solution with detailed problem clarification & math proof (please read if you really want to know what this problem means)",
			"vote":"3",
			"content":"**Clarifications:**\\nI definitely think the description in this problem needs to be clarified as I initially read it. After reading some posts, I finally got exactly what it expected and restricted in this problem of the storytelling style (which is likely to introduce ambiguity).\\n\\n**Here are the two key points that have to be clarified if you really want to work on this \"poorly\" defined problem**:\\n* **A pig can be allowed to drink simultaneously on as many buckets as one would like, and the feeding takes no time** (!). I guess this is the really bizarre assumption hidden behind this story. And I finally got this point after reading some posts.\\n* **After a pig has instantly finished drinking buckets, there has to be a \"cool down\" time of `minutesToDie` minutes**. During this time, only observation is allowed and no feedings at all. Actually, this is a derived hint from the problem instead of an assumption. Because after feeding on poison bucket, it is stated that a pig will die **within** `minutesToDie` minutes instead of **exact** minutes. This means that if you feed a pig more than once in a time frame less that `minutesToDie` minutes, there is no way to tell which feeding contains poison if the pig happens to die eventually\\n\\nWith the two key points above, I think the problem picked a \"bad\" story. Instead, it could be re-translated into a better story such as:\\n* Given `N` sources with exactly one of them sending bad signal. You are given `x` receivers to detect which source is sending bad signal. A receiver can be configured to pick up signals from any number of specified sources. The bad signal will permanently damage a receiver within `minutesToDie` minutes after received. Find the minimum `x` if given `minutesToTest` minutes to test.  \\n***\\n**Solution:**\\n```\\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n      return ceil(log(buckets)/log(minutesToTest/minutesToDie+1));  // log_{T+1}(N)\\n    }\\n```\\n**Proof:** For given `minutesToDie` and `minutesToTest`, with the clarification above, the only thing that matters here is the number of tests allowed `T = (int)(minutesToTest/minutesToDie)` because of the \"cool down\" restriction. Then the problem is translated equivalently to:\\n\\n* **How many states can we generate with `x` pigs and `T` tests** to cover `N` scenarios?\\n\\nThe number of states is exactly `(T+1)^x` and here is why. For each pig during `T` tests, it has exactly `T+1` states: dies at some test#`i` (`1<=i<=T`) or still alive eventually. For `x` pigs, obviously the maximum possible number of states we could have is `(T+1)^x` since each pig's well-being solely depends on whether it ever fed on poison bucket and nothing to do with other pigs. So all we need to do is to \\n* **find minimum `x` such that `(T+1)^x >= N`, which means `x = ceil(logN/log(T+1))`**.\\n\\nNow we have the optimal candidate, but can we actually implement a feeding solution to achieve that optimum solution? Sure, here it is:\\n1. Label buckets as a `(T+1)`-based number represented as `x`-dimensional vector `v = (v[1], v[2], ...,v[x])` consecutively ascending from `(0,0,...0)`. (each `0<=v[j]<=T`)\\n2. For each Test#`i` (`1<=i<=T`), if all pigs are dead by now, process is finished. Otherwise, for each pig`j` alive, feed it on all buckets with `v[j] = i` simultaneously, and record its death time `D[j] = i` if it dies after this test.\\n3. Default `D[j] = 0` if pig`j` is still alive after all `T` tests. \\n\\nThen we claim that: **bucket with label `(D[1],D[2],...,D[x])` must be the poison one**. \\n\\nBecause for each pig`j`, by design of Step 2, it is guaranteed to be alive before feeding on bucket `(D[1],D[2],...,D[x])` and all those pigs which have ever fed on this bucket died right after that test."
		},
		{
			"lc_ans_id":"94317",
			"view":"905",
			"top":"8",
			"title":"Three steps thinking process for poor pigs",
			"vote":"3",
			"content":"---\\n**`Step I -- Consider the reverse of the problem`**\\n\\nSuppose the total number of permissible tests are fixed, instead of thinking about the **minimum number of pigs** needed to find the poisonous bucket from the given number of buckets, let's consider the reverse: what is the **maximum number of buckets** from which we are able to find the poisonous one with the given number of pigs?\\n\\nTo make our problem more clear, let's define `T(n, k)`, which will be the **maximum number of buckets** from which we can determine the poisonous one with `n` pigs and `k` tests. Our mission is to find the general expression of `T(n, k)` in terms of `n` and `k` (we will assume `k > 0`, otherwise there can be only `1` bucket, the one with poison which can be identified without any testing).\\n\\n---\\n**`Step II -- Consider cases with only 1 pig`**\\n\\nLet's start with simple cases when there is only `1` pig at our disposal, i.e., `n = 1`. \\n\\nFirst given a bucket, how do we determine if it is poisonous or not? Well, we have got no better way other than feed the pig with its \"water\"(**can be poisonous!**) and check if the pig dies after some time. If it does, bingo we've found the right one. Or if the pig is lucky to be alive, we are still able to eliminate one bucket. \\n\\nCan we feed the pig with \"water\" from **two or more** buckets simultaneously? No. Because if the pig dies after drinking \"water\" from those buckets, we won't be able to nail down the exact one which is poisonous as there are no more live pigs, even if we are permitted to do more tests.\\n\\nSo with one pig, for each attempt, we can either find the poisonous bucket or eliminate an \"innocent\" one, depending on the status of the pig (dead or alive).\\n\\nIf only one test is allowed, i.e., `k = 1`, from the analyses above, we can either determine one bucket is poisonous or eliminate it. If the total number of bucket is `1`, we surely can find the poisonous bucket (which is just the one given). If the total number of bucket is '2', since testing results of one bucket will automatically reveal information about the other, we can still determine which of the two is poisonous. But if we have more than `2` buckets, we won't be able to make sure which one of the rest contains poison if the pig survives the test with one bucket at our choice, since we've run out of tests. Therefore, in this case, there can be at most two buckets from which we may be able to find the poisonous one with `1` pig and `1` test, or in a symbolic way, `T(1, 1) = 2`.\\n\\nHow about there are `k` tests permissible? Apparently we can check at least `k` buckets with `k` tests, so `T(1, k) >= k`. Can we do better? The key is to consider the extreme case when the pig survives all `k` tests (what a lucky pig, btw). How many more buckets can be left unchecked if we were able to figure out the poisonous one? The answer is `1` since we cannot do any more test so there has to be a way for us to point at a bucket and say it is poisonous with 100% sure. Therefore, we have `T(1, k) = k + 1`.\\n\\n---\\n**`Step III -- Consider general cases with n pigs`**\\n\\nFrom part `II`, we know there are at most `k + 1` buckets from which a poisonous one can be determined with `1` pig and `k` tests, or `T(1, k) = k + 1`. Now we have n pigs, and testing of each pig is **independent** from each other (feeding \"water\" to a pig is independent from feeding others, provided each bucket has enough \"water\"), we are free to combine the `k + 1` results of each pig and end up with `(k + 1)^n` total combinations.\\n\\nSo without digging deeper, we've found the general expression: `T(n, k) = (k + 1)^n`. And you can happily proceed to figure out the answer for the original problem. But in case you are wondering how exactly we will carry out the tests and do \"combination\" of the results, here is one possible interpretation.\\n\\nSuppose we have `N` total buckets from which the poisonous one is to be found. `n` is the minimum number of pigs such that `T(n, k) >= N`, with `T(n, k) = (k + 1)^n` and `k >= 1`. We can label all the buckets from `0` up to `N - 1` and express each of them as a number in the base-`(k + 1)` numeral system. Each pig will represent one digit for a number in the same numeral system (marked as pig `0` to `n - 1`, from least significant digit to most significant one). Since our final goal is equivalent to determining all the `n` digit values of the number of the poisonous bucket, we can do so by testing each value one by one since there are at most `k + 1` possible values for each digit, which can be done within `k` tests. Here is the detailed way to accomplish that: In the `1st` test, for each pig, feed it with \"water\" from all buckets whose number has a digit value of `1` at the corresponding digit. In the `2nd` test, for all **live** pigs, feed it with \"water\" from all buckets whose number has a digit value of `2` at the corresponding digit. And so on until either all pigs are dead or we've run out of tests. In either case the number of the poisonous bucket is guaranteed to be found.\\n\\nIf you are interested in examples for this interpretation, [ifyouseewendy](https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation) has done a great job here. \\n\\nAnother interpretation is to associate each pig with one dimension of a multi-dimensional array, as explained by [StefanPochmann](https://discuss.leetcode.com/topic/67666/another-explanation-and-solution). We first arrange all buckets into this multi-dimensional array. Then in each test, we feed each **live** pig with \"water\" from \"one unit\" of buckets belonging to the corresponding dimension (for example, in the `1st` test, feed pig `1` with all the `1st` rows; feed pig `2` with all the `1st` columns; feed pig `3` with all the `1st` pages...; in the `2nd` test, if pig `1` is still alive, feed it with all the `2nd` rows; if pig `2` is still alive, feed it with all the `2nd` columns; if pig `3` is still alive, feed it with all the `2nd` pages....). At the end of the test, all the indices of the poisonous bucket will be determined so we can index into the multi-dimensional array to find it.\\n\\nThe final code is rather simple once we've figured out the expression for `T(n, k)`. Some minor issues are dealing with corner cases such as only `1` bucket or it takes more time for the pig to die than it is allowed to wait. Also pay attention to computing logarithm for integers. Here is the Java program.\\n\\n```\\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n    if (buckets < 2) return 0;\\n    if (minutesToDie > minutesToTest) return Integer.MAX_VALUE;\\n    \\n    int k = minutesToTest / minutesToDie;\\n    return (int)Math.ceil((Math.log(buckets) / Math.log(k + 1)));\\n}\\n```"
		},
		{
			"lc_ans_id":"94311",
			"view":"1196",
			"top":"9",
			"title":"This problem is Easy. Seriously?",
			"vote":"3",
			"content":"I got my shit out to understand and solve the problem. Is this problem really easy or am I a dumbass?"
		}
	],
	"id":"452",
	"title":"Poor Pigs",
	"content":"<p>\r\nThere are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour. \r\n</p>\r\n<p>\r\nAnswer this question, and write an algorithm for the follow-up general case.\r\n</p>\r\n<p>\r\n<b>\r\nFollow-up:\r\n</b>\r\n</p>\r\n<p>\r\nIf there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the \"poison\" bucket within p minutes? There is exact one bucket with poison.\r\n</p>",
	"frequency":"617",
	"ac_num":"7603"
}