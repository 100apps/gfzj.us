{
	"difficulty":"3",
	"submit_num":"72099",
	"show_id":"460",
	"leetcode_id":"460",
	"answers":[
		{
			"lc_ans_id":"94515",
			"view":"31736",
			"top":"0",
			"title":"Java O(1) Accept Solution Using HashMap, DoubleLinkedList and LinkedHashSet",
			"vote":"57",
			"content":"Two HashMaps are used, one to store <key, value> pair, another store the <key, node>.\\nI use double linked list to keep the frequent of each key. In each double linked list node, keys with the same count are saved using java built in LinkedHashSet. This can keep the order.\\nEvery time, one key is referenced, first find the current node corresponding to the key, If the following node exist and the frequent is larger by one, add key to the keys of the following node, else create a new node and add it following the current node. \\nAll operations are guaranteed to be O(1).\\n```\\npublic class LFUCache {\\n    private Node head = null;\\n    private int cap = 0;\\n    private HashMap<Integer, Integer> valueHash = null;\\n    private HashMap<Integer, Node> nodeHash = null;\\n    \\n    public LFUCache(int capacity) {\\n        this.cap = capacity;\\n        valueHash = new HashMap<Integer, Integer>();\\n        nodeHash = new HashMap<Integer, Node>();\\n    }\\n    \\n    public int get(int key) {\\n        if (valueHash.containsKey(key)) {\\n            increaseCount(key);\\n            return valueHash.get(key);\\n        }\\n        return -1;\\n    }\\n    \\n    public void set(int key, int value) {\\n        if ( cap == 0 ) return;\\n        if (valueHash.containsKey(key)) {\\n            valueHash.put(key, value);\\n        } else {\\n            if (valueHash.size() < cap) {\\n                valueHash.put(key, value);\\n            } else {\\n                removeOld();\\n                valueHash.put(key, value);\\n            }\\n            addToHead(key);\\n        }\\n        increaseCount(key);\\n    }\\n    \\n    private void addToHead(int key) {\\n        if (head == null) {\\n            head = new Node(0);\\n            head.keys.add(key);\\n        } else if (head.count > 0) {\\n            Node node = new Node(0);\\n            node.keys.add(key);\\n            node.next = head;\\n            head.prev = node;\\n            head = node;\\n        } else {\\n            head.keys.add(key);\\n        }\\n        nodeHash.put(key, head);      \\n    }\\n    \\n    private void increaseCount(int key) {\\n        Node node = nodeHash.get(key);\\n        node.keys.remove(key);\\n        \\n        if (node.next == null) {\\n            node.next = new Node(node.count+1);\\n            node.next.prev = node;\\n            node.next.keys.add(key);\\n        } else if (node.next.count == node.count+1) {\\n            node.next.keys.add(key);\\n        } else {\\n            Node tmp = new Node(node.count+1);\\n            tmp.keys.add(key);\\n            tmp.prev = node;\\n            tmp.next = node.next;\\n            node.next.prev = tmp;\\n            node.next = tmp;\\n        }\\n\\n        nodeHash.put(key, node.next);\\n        if (node.keys.size() == 0) remove(node);\\n    }\\n    \\n    private void removeOld() {\\n        if (head == null) return;\\n        int old = 0;\\n        for (int n: head.keys) {\\n            old = n;\\n            break;\\n        }\\n        head.keys.remove(old);\\n        if (head.keys.size() == 0) remove(head);\\n        nodeHash.remove(old);\\n        valueHash.remove(old);\\n    }\\n    \\n    private void remove(Node node) {\\n        if (node.prev == null) {\\n            head = node.next;\\n        } else {\\n            node.prev.next = node.next;\\n        } \\n        if (node.next != null) {\\n            node.next.prev = node.prev;\\n        }\\n    }\\n    \\n    class Node {\\n        public int count = 0;\\n        public LinkedHashSet<Integer> keys = null;\\n        public Node prev = null, next = null;\\n        \\n        public Node(int count) {\\n            this.count = count;\\n            keys = new LinkedHashSet<Integer>();\\n            prev = next = null;\\n        }\\n    }\\n}"
		},
		{
			"lc_ans_id":"94521",
			"view":"12628",
			"top":"1",
			"title":"JAVA O(1) very easy solution using 3 HashMaps and LinkedHashSet",
			"vote":"55",
			"content":"```Java\\npublic class LFUCache {\\n    HashMap<Integer, Integer> vals;\\n    HashMap<Integer, Integer> counts;\\n    HashMap<Integer, LinkedHashSet<Integer>> lists;\\n    int cap;\\n    int min = -1;\\n    public LFUCache(int capacity) {\\n        cap = capacity;\\n        vals = new HashMap<>();\\n        counts = new HashMap<>();\\n        lists = new HashMap<>();\\n        lists.put(1, new LinkedHashSet<>());\\n    }\\n    \\n    public int get(int key) {\\n        if(!vals.containsKey(key))\\n            return -1;\\n        int count = counts.get(key);\\n        counts.put(key, count+1);\\n        lists.get(count).remove(key);\\n        if(count==min && lists.get(count).size()==0)\\n            min++;\\n        if(!lists.containsKey(count+1))\\n            lists.put(count+1, new LinkedHashSet<>());\\n        lists.get(count+1).add(key);\\n        return vals.get(key);\\n    }\\n    \\n    public void set(int key, int value) {\\n        if(cap<=0)\\n            return;\\n        if(vals.containsKey(key)) {\\n            vals.put(key, value);\\n            get(key);\\n            return;\\n        } \\n        if(vals.size() >= cap) {\\n            int evit = lists.get(min).iterator().next();\\n            lists.get(min).remove(evit);\\n            vals.remove(evit);\\n        }\\n        vals.put(key, value);\\n        counts.put(key, 1);\\n        min = 1;\\n        lists.get(1).add(key);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"94516",
			"view":"11358",
			"top":"2",
			"title":"Concise C++ O(1) solution using 3 hash maps with explanation",
			"vote":"29",
			"content":"//minFreq is the smallest frequency so far\\n//The main idea is to put all keys with the same frequency to a linked list so the most recent one can be evicted;\\n//mIter stored the key's position in the linked list;\\n\\n```\\nclass LFUCache {\\n    int cap;\\n    int size;\\n    int minFreq;\\n    unordered_map<int, pair<int, int>> m; //key to {value,freq};\\n    unordered_map<int, list<int>::iterator> mIter; //key to list iterator;\\n    unordered_map<int, list<int>>  fm;  //freq to key list;\\npublic:\\n    LFUCache(int capacity) {\\n        cap=capacity;\\n        size=0;\\n    }\\n    \\n    int get(int key) {\\n        if(m.count(key)==0) return -1;\\n        \\n        fm[m[key].second].erase(mIter[key]);\\n        m[key].second++;\\n        fm[m[key].second].push_back(key);\\n        mIter[key]=--fm[m[key].second].end();\\n        \\n        if(fm[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        return m[key].first;\\n    }\\n    \\n   void set(int key, int value) {\\n        if(cap<=0) return;\\n        \\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            m[key].first=value;\\n            return;\\n        }\\n        \\n        if(size>=cap )\\n        {\\n            m.erase( fm[minFreq].front() );\\n            mIter.erase( fm[minFreq].front() );\\n            fm[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        m[key]={value, 1};\\n        fm[1].push_back(key);\\n        mIter[key]=--fm[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"94657",
			"view":"2171",
			"top":"3",
			"title":"Java solutions of three different ways. PriorityQueue : O(capacity)  TreeMap : O(log(capacity)) DoubleLinkedList  : O(1)",
			"vote":"8",
			"content":"The first one: PriorityQueue + HashMap          set O(capacity)                get O(capacity)\\nThe second one: TreeMap + HashMap           set O(log(capacity))         get O(log(capacity))\\nThe third one: HashMap + HashMap + DoubleLinkedList                        set O(1)                      get O(1)\\n\\n**PriorityQueue + HashMap:  set O(capacity) get O(capacity)**\\n'''\\n\\n    long stamp;\\n    int capacity;\\n    int num;\\n    PriorityQueue<Pair> minHeap;\\n    HashMap<Integer, Pair> hashMap;\\n\\n    // @param capacity, an integer\\n    public LFUCache(int capacity) {\\n        // Write your code here\\n        this.capacity = capacity;\\n        num = 0;\\n        minHeap = new PriorityQueue<Pair>();\\n        hashMap = new HashMap<Integer, Pair>();\\n        stamp = 0;\\n    }\\n\\n    // @param key, an integer\\n    // @param value, an integer\\n    // @return nothing\\n    public void set(int key, int value) {\\n        if (capacity == 0) {\\n            return;\\n        }\\n        // Write your code here\\n        if (hashMap.containsKey(key)) {\\n            Pair old = hashMap.get(key);\\n            minHeap.remove(old);\\n            \\n            Pair newNode = new Pair(key, value, old.times + 1, stamp++);\\n            \\n            hashMap.put(key, newNode);\\n            minHeap.offer(newNode);\\n        } else if (num == capacity) {\\n            Pair old = minHeap.poll();\\n            hashMap.remove(old.key);\\n            \\n            Pair newNode = new Pair(key, value, 1, stamp++);\\n            \\n            hashMap.put(key, newNode);\\n            minHeap.offer(newNode);\\n        } else {\\n            num++;\\n            Pair pair = new Pair(key, value, 1, stamp++);\\n            hashMap.put(key, pair);\\n            minHeap.offer(pair);\\n        }\\n    }\\n\\n    public int get(int key) {\\n        if (capacity == 0) {\\n            return -1;\\n        }\\n        // Write your code here\\n        if (hashMap.containsKey(key)) {\\n            Pair old = hashMap.get(key);\\n            minHeap.remove(old);\\n            \\n            Pair newNode = new Pair(key, old.value, old.times + 1, stamp++);\\n            \\n            hashMap.put(key, newNode);\\n            minHeap.offer(newNode);\\n            return hashMap.get(key).value;\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    class Pair implements Comparable<Pair> {\\n        long stamp;\\n        int key;\\n        int value;\\n        int times;\\n        public Pair(int key, int value, int times, long stamp) {\\n            this.key = key;\\n            this.value = value;\\n            this.times = times;\\n            this.stamp = stamp;\\n        }\\n        \\n        public int compareTo(Pair that) {\\n            if (this.times == that.times) {\\n                return (int)(this.stamp - that.stamp);\\n            } else {\\n                return this.times - that.times;    \\n            }\\n        }\\n    }\\n'''\\n\\n**TreeMap + HashMap: set O(log(capacity))         get O(log(capacity))**\\n\\n'''\\n\\n    private int capacity;\\n    private int stamp;\\n    private HashMap<Integer, Tuple> hashMap;\\n    private TreeMap<Tuple, Integer> treeMap;\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        stamp = 0;\\n        hashMap = new HashMap<Integer, Tuple>(); \\n        treeMap = new TreeMap<Tuple, Integer>(new Comparator<Tuple>() {\\n            public int compare(Tuple t1, Tuple t2) {\\n                if (t1.times == t2.times) {\\n                    return t1.stamp - t2.stamp;\\n                }\\n                return t1.times - t2.times;\\n            }\\n        });\\n    }\\n    \\n    public int get(int key) {\\n        if (capacity == 0) {\\n            return -1;\\n        }\\n        if (!hashMap.containsKey(key)) {\\n            return -1;\\n        }\\n        Tuple old = hashMap.get(key);\\n        treeMap.remove(old);\\n        Tuple newTuple = new Tuple(old.value, stamp++, old.times + 1);\\n        treeMap.put(newTuple, key);\\n        hashMap.put(key, newTuple);\\n        return old.value;\\n    }\\n    \\n    public void set(int key, int value) {\\n        if (capacity == 0) {\\n            return;\\n        }\\n        if (hashMap.containsKey(key)) {\\n            Tuple old = hashMap.get(key);\\n            Tuple newTuple = new Tuple(value, stamp++, old.times + 1);\\n            treeMap.remove(old);\\n            hashMap.put(key, newTuple);\\n            treeMap.put(newTuple, key);\\n        } else {\\n            if (treeMap.size() == capacity) {\\n                int endKey = treeMap.pollFirstEntry().getValue();\\n                hashMap.remove(endKey);\\n            }\\n            Tuple newTuple = new Tuple(value, stamp++, 1);\\n            hashMap.put(key, newTuple);\\n            treeMap.put(newTuple, key);\\n        }\\n    }\\n    class Tuple {\\n        int value;\\n        int times;\\n        int stamp;\\n        public Tuple (int value, int stamp, int times) {\\n            this.value = value;\\n            this.stamp = stamp;\\n            this.times = times;\\n        }\\n    }\\n'''\\n **HashMap + HashMap + DoubleLinkedList:                    set O(1)   get O(1)**\\n\\n\\nmap1 save the nodes in the cache\\nfinalNodes save the newest node which has appeared  ''key''  times.\\nUsing a doubleLinkedList to save the nodes in the cache.if a node appeared more times or is a new comer, the position in the list of this node is as back as possible. \\n\\n\\n'''\\n\\n    private int capacity;\\n    private int count;\\n    private HashMap<Integer, Tuple> map1; // whether appeared\\n    private HashMap<Integer, Tuple> finalNodes; // value : the final node of key times\\n    private Tuple dummyHead;\\n    private Tuple dummyEnd;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        count = 0;\\n        map1 = new HashMap<Integer, Tuple>();\\n        finalNodes = new HashMap<>();\\n        dummyHead = new Tuple(0, 0, 0);\\n        dummyEnd = new Tuple(0, 0, 0);\\n        dummyHead.next = dummyEnd;\\n        dummyEnd.prev = dummyHead;\\n    }\\n\\n    public int get(int key) {\\n        if (capacity == 0 || !map1.containsKey(key)) {\\n            return -1;\\n        }\\n        Tuple old = map1.get(key);\\n        set(key, old.value);\\n        return old.value;\\n    }\\n\\n    public void set(int key, int value) {\\n        if (capacity == 0) {\\n            return;\\n        }\\n        if (map1.containsKey(key)) { // this key has appeared\\n            Tuple cur = map1.get(key);\\n            if (finalNodes.get(cur.times) == cur && finalNodes.get(cur.times + 1) == null) { // the position should not change\\n                finalNodes.put(cur.times, cur.prev.times == cur.times ? cur.prev : null);\\n                cur.times++;\\n                cur.value = value;\\n                finalNodes.put(cur.times, cur);\\n                return;\\n            }\\n            removeNode(cur); // remove node cur\\n            if (finalNodes.get(cur.times) == cur) {\\n                finalNodes.put(cur.times, cur.prev.times == cur.times ? cur.prev : null);\\n            }\\n            cur.times++;\\n            cur.value = value;\\n            Tuple finalNode = finalNodes.get(cur.times) == null ? finalNodes.get(cur.times - 1) : finalNodes.get(cur.times);\\n            insertNode(finalNode, cur); \\n            finalNodes.put(cur.times, cur); // cur is the final node whitch appeared cur.times\\n        } else if (count == capacity) { // reach limt of the cache\\n            Tuple head = dummyHead.next;\\n            removeNode(head); //remove the first which appeared least times and is the least Used\\n            map1.remove(head.key);\\n            if (finalNodes.get(head.times) == head) {\\n                finalNodes.remove(head.times);\\n            }\\n            Tuple cur = new Tuple(key, value, 1);\\n            if (finalNodes.get(1) == null) {\\n                insertNode(dummyHead, cur);\\n            } else {\\n                Tuple finalNode = finalNodes.get(1);\\n                insertNode(finalNode, cur);\\n            }\\n            finalNodes.put(1, cur);\\n            map1.put(key, cur);\\n        } else {\\n            count++;\\n            Tuple cur = new Tuple(key, value, 1);\\n            if (finalNodes.get(1) == null){\\n               insertNode(dummyHead, cur);\\n            } else {\\n                Tuple finalNode = finalNodes.get(1);\\n                insertNode(finalNode, cur);\\n            }\\n            finalNodes.put(1, cur);\\n            map1.put(key, cur);\\n        }\\n    }\\n\\n    public void insertNode(Tuple t1, Tuple t2) {\\n        t2.next = t1.next;\\n        t1.next.prev = t2;\\n        t1.next = t2;\\n        t2.prev = t1;\\n    }\\n\\n    public void removeNode(Tuple node) {\\n        node.next.prev = node.prev;\\n        node.prev.next = node.next;\\n    }\\n    class Tuple {\\n        int key;\\n        int value;\\n        int times;\\n        Tuple prev;\\n        Tuple next;\\n        public Tuple(int key, int value, int times) {\\n            this.key = key;\\n            this.value = value;\\n            this.times = times;\\n        }\\n    }\\n'''"
		},
		{
			"lc_ans_id":"94602",
			"view":"2020",
			"top":"4",
			"title":"C++ list with hashmap with explanation",
			"vote":"8",
			"content":"Based on ideas from this paper http://dhruvbird.com/lfu.pdf.\\n```\\n      Increasing frequencies\\n  ----------------------------->\\n\\n+------+    +---+    +---+    +---+\\n| Head |----| 1 |----| 5 |----| 9 |  Frequencies\\n+------+    +-+-+    +-+-+    +-+-+\\n              |        |        |\\n            +-+-+    +-+-+    +-+-+     |\\n            |2,3|    |4,3|    |6,2|     |\\n            +-+-+    +-+-+    +-+-+     | Most recent \\n                       |        |       |\\n                     +-+-+    +-+-+     |\\n key,value pairs     |1,2|    |7,9|     |\\n                     +---+    +---+     v\\n\\n```\\nSimilar to bucket sort, we place key,value pairs with the same frequency into the same bucket, within each bucket, the pairs are sorted according to most recent used, i.e., the one that is most recently used (set,get) is at the bottom of each bucket.\\n\\n```c++\\n\\nclass LFUCache\\n{\\n public:\\n  struct LRUNode\\n  {\\n    int freq;\\n    list<pair<int, int> > vals;\\n    LRUNode(int f = 0) : freq(f) { }\\n  };\\n\\n  typedef list<LRUNode>::iterator iptr;\\n  typedef list<pair<int, int> >::iterator jptr;\\n\\n  LFUCache(int capacity)\\n  {\\n    capacity_ = capacity;\\n  }\\n\\n  int get(int key)\\n  {\\n    int val = -1;\\n    if (kv_.find(key) != kv_.end()) {\\n      kv_[key] = promote(key);\\n      val = kv_[key].second->second;\\n    }\\n    return val;\\n  }\\n\\n  void set(int key, int value)\\n  {\\n    if (capacity_ <= 0) return;\\n    if (kv_.find(key) == kv_.end()) {\\n      if (kv_.size() == capacity_) evict();\\n      kv_[key] = insert(key, value);\\n    } else {\\n      kv_[key] = promote(key, value);\\n    }\\n  }\\n\\n private:\\n  pair<iptr, jptr> promote(int key, int val = -1)\\n  {\\n    iptr i; jptr j;\\n    tie(i, j) = kv_[key];\\n    iptr k = next(i);\\n\\n    if (val < 0) val = j->second;\\n    int freq = i->freq + 1;\\n\\n    i->vals.erase(j);\\n    if (i->vals.empty())\\n      cache_.erase(i);\\n\\n    if (k == cache_.end() || k->freq != freq)\\n      i = cache_.insert(k, LRUNode(freq));\\n    else i = k;\\n    j = i->vals.insert(i->vals.end(), {key, val});\\n    return {i, j};\\n  }\\n\\n  void evict()\\n  {\\n    iptr i = cache_.begin();\\n    jptr j = i->vals.begin();\\n    kv_.erase(j->first);\\n    i->vals.erase(j);\\n    if (i->vals.empty())\\n      cache_.erase(i);\\n  }\\n\\n  pair<iptr, jptr> insert(int key, int val)\\n  {\\n    iptr i = cache_.begin();\\n    if (i == cache_.end() || i->freq != 1)\\n      i = cache_.insert(i, LRUNode(1));\\n    jptr j = i->vals.insert(i->vals.end(), {key, val});\\n    return {i, j};\\n  }\\n\\n private:\\n  list<LRUNode> cache_;\\n  int capacity_;\\n  unordered_map<int, pair<iptr, jptr> > kv_;\\n};\\n```"
		},
		{
			"lc_ans_id":"94520",
			"view":"2697",
			"top":"5",
			"title":"Python shitty O(1) solution with two dict and one linkedlist",
			"vote":"7",
			"content":"```\\nclass ListNode(object):\\n    def __init__(self, key, val):\\n        self.prev = None\\n        self.next = None\\n        self.val = val\\n        self.key = key\\n\\n    def connect(self, nextNode):\\n        self.next = nextNode\\n        nextNode.prev = self\\n\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        \\n        :type capacity: int\\n        \"\"\"\\n        self.cap = capacity\\n        self.head = ListNode(None, None)\\n        self.tail = ListNode(None, None)\\n        self.head.connect(self.tail)\\n        #use to record the first ListNode of this count number\\n        self.cnt = {0: self.tail}\\n        # key: key , value:[ListNode, visit count]\\n        self.kv = {None:[self.tail, 0]}\\n\\n    def moveforward(self, key):\\n        node, cnt = self.kv[key]\\n        self.add('tmp', node.val, cnt + 1)\\n        self.remove(key)\\n        self.kv[key] = self.kv['tmp']\\n        self.kv[key][0].key = key\\n        del self.kv['tmp']\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.kv:\\n            return -1\\n        self.moveforward(key)\\n        return self.kv[key][0].val\\n\\n    def set(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if self.cap == 0:\\n            return\\n        if key in self.kv:\\n            self.kv[key][0].val = value\\n            self.moveforward(key)\\n            return\\n        if len(self.kv) > self.cap:\\n            self.remove(self.tail.prev.key)\\n        self.add(key, value, 0)\\n\\n\\n    def remove(self, key):\\n        node, cnt = self.kv[key]\\n        if self.cnt[cnt] != node:\\n            node.prev.connect(node.next)\\n        elif self.kv[node.next.key][1] == cnt:\\n            node.prev.connect(node.next)\\n            self.cnt[cnt] = self.cnt[cnt].next\\n        else:\\n            node.prev.connect(node.next)\\n            del self.cnt[cnt]\\n        del self.kv[key]\\n\\n    def add(self, key, value, cnt):\\n        if cnt in self.cnt:\\n            loc = self.cnt[cnt]\\n        else:\\n            loc = self.cnt[cnt - 1]\\n        node = ListNode(key, value)\\n        loc.prev.connect(node)\\n        node.connect(loc)\\n        self.cnt[cnt] = node\\n        self.kv[key] = [node, cnt]\\n        \\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.set(key,value)\\n```"
		},
		{
			"lc_ans_id":"94547",
			"view":"919",
			"top":"6",
			"title":"Java O(1) Solution Using Two HashMap and One DoubleLinkedList",
			"vote":"6",
			"content":"\\n\\n\\n```\\npublic class LFUCache {\\n    class Node {\\n        int key, val, cnt;\\n        Node prev, next;\\n        Node(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n            cnt = 1;\\n        }\\n    }\\n    \\n    class DLList {\\n        Node head, tail;\\n        int size;\\n        DLList() {\\n            head = new Node(0, 0);\\n            tail = new Node(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n        \\n        void add(Node node) {\\n            head.next.prev = node;\\n            node.next = head.next;\\n            node.prev = head;\\n            head.next = node;\\n            size++;\\n        }\\n        \\n        void remove(Node node) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n            size--;\\n        }\\n        \\n        Node removeLast() {\\n            if (size > 0) {\\n                Node node = tail.prev;\\n                remove(node);\\n                return node;\\n            }\\n            else return null;\\n        }\\n    }\\n    \\n    int capacity, size, min;\\n    Map<Integer, Node> nodeMap;\\n    Map<Integer, DLList> countMap;\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        nodeMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        Node node = nodeMap.get(key);\\n        if (node == null) return -1;\\n        update(node);\\n        return node.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        Node node;\\n        if (nodeMap.containsKey(key)) {\\n            node = nodeMap.get(key);\\n            node.val = value;\\n            update(node);\\n        }\\n        else {\\n            node = new Node(key, value);\\n            nodeMap.put(key, node);\\n            if (size == capacity) {\\n                DLList lastList = countMap.get(min);\\n                nodeMap.remove(lastList.removeLast().key);\\n                size--;\\n            }\\n            size++;\\n            min = 1;\\n            DLList newList = countMap.getOrDefault(node.cnt, new DLList());\\n            newList.add(node);\\n            countMap.put(node.cnt, newList);\\n        }\\n    }\\n    \\n    private void update(Node node) {\\n        DLList oldList = countMap.get(node.cnt);\\n        oldList.remove(node);\\n        if (node.cnt == min && oldList.size == 0) min++; \\n        node.cnt++;\\n        DLList newList = countMap.getOrDefault(node.cnt, new DLList());\\n        newList.add(node);\\n        countMap.put(node.cnt, newList);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"94536",
			"view":"7010",
			"top":"7",
			"title":"Java solution using PriorityQueue, with detailed explanation",
			"vote":"6",
			"content":"We need to implement `get()` and `set()` in average `O(logn)` time, or we will get TLE.\\n\\nObviously, we need a hashmap to remember `key-value` pair.\\nWhat we need to do, is to remember `(frequency, recentness)` for each key; and sort them to get the smallest one.\\nSo, we need to use `Collection` such as `TreeSet` or `PriorityQueue`.\\n\\nNow, the only question is, how to update?\\nIt is difficult to update `(frequency, recentness)` in the collection, as we don't know the index.\\n(Maybe using `binary search` or `hashmap` can do this, I haven't tried it.)\\n\\nThe trick is, just ***override equals() and hashCode() function***, in order to use `remove`.\\n\\nHere is the code with detailed comment.\\n\\n```Java\\npublic class LFUCache {\\n    \\n    class Cache { // a class to remember frequency and recentness\\n        int key, f, r;\\n        public Cache(int k, int f, int r) {key=k;this.f=f;this.r=r;}\\n        // override equals() and hashCode()\\n        public boolean equals(Object object) {return key==((Cache) object).key;}\\n        public int hashCode() {return key;}\\n    }\\n    \\n    int capacity, id;\\n    HashMap<Integer, Integer> hashMap, frequency;\\n    PriorityQueue<Cache> queue;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity=capacity;\\n        id=0;\\n        hashMap=new HashMap<>();\\n        frequency=new HashMap<>();\\n        // sort by frequency and recentness\\n        queue =new PriorityQueue<>((o1,o2) -> o1.f==o2.f?o1.r-o2.r:o1.f-o2.f); \\n    }\\n    \\n    public int get(int key) {\\n        id++;\\n        if (hashMap.containsKey(key)) {\\n            update(key);\\n            return hashMap.get(key);\\n        }\\n        return -1;\\n    }\\n    \\n    public void set(int key, int value) {\\n        if (capacity==0) return;\\n        id++;\\n        if (hashMap.containsKey(key)) {\\n            update(key);\\n            hashMap.put(key, value);\\n            return;\\n        }\\n        if (hashMap.size()==capacity) {\\n            Cache first= queue.poll(); // find the smallest one, and remove it\\n            hashMap.remove(first.key);\\n            frequency.remove(first.key);\\n        }\\n        hashMap.put(key, value);\\n        frequency.put(key, 1);\\n        queue.add(new Cache(key, 1, id));\\n    }\\n    \\n    private void update(int key) { // update the priority queue\\n        int f=frequency.get(key);\\n        frequency.put(key, f+1); // get and update the frequency\\n        Cache cache=new Cache(key, f+1, id); // make a new Cache\\n        // remove the member in queue, if its key equals to the current key.\\n        // Here, queue uses `equals()` to judge the equality\\n        queue.remove(cache); \\n        queue.add(cache); // add the current Cache to the queue.\\n    }\\n}\\n```\\n\\nPS: I tried `TreeSet` instead of `PriorityQueue`, but it didn't work. Can anyone tell me why?\\n\\n<br/>\\n\\n-----------------------------------------\\n\\n-----------------------------------------\\n\\n<br/>\\n\\n**Update 2016/11/22:**\\nAs priority queue uses `O(n)` time to remove, it's better to use `TreeSet`.\\n\\nHere is the code. It's similar to the code above.\\n```\\npublic class LFUCache {\\n    \\n    class Cache implements Comparable<Cache> {\\n        int key, f, r;\\n        public Cache(int k, int f, int r) {key=k;this.f=f;this.r=r;}\\n        public boolean equals(Object object) {return key==((Cache) object).key;}\\n        public int hashCode() {return key;}\\n        public int compareTo(Cache o) {return key==o.key?0:f==o.f?r-o.r:f-o.f;}\\n    }\\n\\n    int capacity,id;\\n    HashMap<Integer, Integer> hashMap;\\n    HashMap<Integer, Cache> caches;\\n    TreeSet<Cache> treeSet;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity=capacity;\\n        id=0;\\n        hashMap=new HashMap<>();\\n        caches=new HashMap<>();\\n        treeSet=new TreeSet<>();\\n    }\\n\\n    public int get(int key) {\\n        id++;\\n        if (hashMap.containsKey(key)) {\\n            update(key);\\n            return hashMap.get(key);\\n        }\\n        return -1;\\n    }\\n\\n    public void set(int key, int value) {\\n        if (capacity==0) return;\\n        id++;\\n        if (hashMap.containsKey(key)) {\\n            update(key);\\n            hashMap.put(key, value);\\n            return;\\n        }\\n        if (hashMap.size()==capacity) {\\n            Cache first=treeSet.pollFirst();\\n            hashMap.remove(first.key);\\n            caches.remove(first.key);\\n        }\\n        hashMap.put(key, value);\\n        Cache cache=new Cache(key, 1, id);\\n        caches.put(key, cache);\\n        treeSet.add(cache);\\n    }\\n\\n    private void update(int key) {\\n        int f=caches.get(key).f;\\n        treeSet.remove(caches.get(key));\\n        Cache cache=new Cache(key, f+1, id);\\n        caches.put(key, cache);\\n        treeSet.add(cache);\\n    }\\n\\n}\\n```"
		},
		{
			"lc_ans_id":"94523",
			"view":"1968",
			"top":"8",
			"title":"Concise Python O(1) beats 95% using two maps.",
			"vote":"5",
			"content":"Two hashmaps: the freq_map keeps track of freq-> linked list of node.\\nkey_map tracks key->val\\n\\n```\\nPREV,NEXT,KEY,VAL,FREQ = 0,1,2,3,4\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.freq_map = {}\\n        self.key_map = {}\\n        self.min_freq = 1\\n\\n    def get(self, key):\\n        key_map, freq_map = self.key_map, self.freq_map\\n        if key not in key_map:\\n            return -1\\n        else:\\n            val_node = key_map[key]\\n            val_node[PREV][NEXT],val_node[NEXT][PREV] = val_node[NEXT],val_node[PREV]\\n            if freq_map[self.min_freq] is freq_map[self.min_freq][NEXT]:\\n                self.min_freq+=1\\n            freq = val_node[FREQ]\\n            root = freq_map.setdefault(freq+1,[])\\n            if not root:\\n                root[:] = [root,root,None,None,freq+1]\\n            val_node[PREV],val_node[NEXT] = root[PREV],root\\n            val_node[FREQ]+=1\\n            root[PREV][NEXT] = root[PREV] = val_node\\n            return key_map[key][VAL]\\n\\n    def set(self, key, value):\\n        key_map, freq_map, cap = self.key_map, self.freq_map, self.capacity\\n        if not cap:\\n            return\\n        if key in key_map:\\n            key_map[key][VAL] = value\\n            self.get(key)\\n        else:\\n            if len(key_map) == cap:\\n                root = freq_map[self.min_freq]\\n                node_evict = root[NEXT]\\n                root[NEXT],node_evict[NEXT][PREV] = node_evict[NEXT], root\\n                del key_map[node_evict[KEY]]\\n            self.min_freq = 1\\n            val_node = [None,None,key,value,1]\\n            root = freq_map.setdefault(1,[])\\n            if not root:\\n                root[:] = [root,root,None,None,1]\\n            val_node[PREV],val_node[NEXT] = root[PREV],root\\n            root[PREV][NEXT] = root[PREV] = val_node\\n            key_map[key] = val_node\\n```"
		},
		{
			"lc_ans_id":"94673",
			"view":"2996",
			"top":"9",
			"title":"C++ solution with Detailed Explanations Using Indexed Priority Queue (i.e., HashMap + Priority Queue)",
			"vote":"5",
			"content":"Here is my solution to implement a Least Frequently Used Cache in C++. \\n\\n* The idea is straightforward. We maintain a min-PriorityQueue with the least frequently used element at the top. However, when we access any existing element using get() or set(), its usage frequency should be increased by one, which forces us to change its position in the priority queue (re-heapify). Unfortunately, native STL PriorityQueue does not support this operation. Therefore, we need to create our own priority queue and modify it. I found the so-called [Index Priority Queue](http://algs4.cs.princeton.edu/24pq/) is suitable for this task (*believe me, it is very simple to grasp. Use it to impress your interviewer!*).  It maintains not only a priority queue but also a hash map, \"indexMap\", that maps the key of an element to its position (index) in the priority queue. Now, we can quickly access any element in the priority queue and re-heapify the PriorityQueue, when the usage frequency of an element changes.\\n\\n* Another tricky point is that when we need to evict an element, but multiple elements have the same (minimum) usage frequency, we need to evict the least recently used (the oldest) element. To handle this, I maintain a time-stamp variable for each element in the LFU Cache, which indicates the latest time stamp when we access it. Therefore, we maintain the following invariant in the priority queue: **When two elements have the same usage frequency, the least recently used one will always be closer to root node**. When there are multiple least frequently used elements, we always retrieve the one closer to the root.\\n\\n```\\nclass LFUCache {\\npublic:\\n    struct Node {\\n        int key; // key of the element.\\n        int val; // value of the ement.\\n        int fre; // usage frequency\\n        int timeStamp; // the latest time stamp when this element is accessed.\\n        Node(): key(-1), val(-1), timeStamp(-1), fre(0) {}\\n        Node(int k, int v, int ts): key(k), val(v), timeStamp(ts), fre(1) {}\\n    };\\n\\n    LFUCache(int capacity) {\\n        Cap = capacity;\\n        Node* dummy = new Node();\\n        pq.push_back(dummy); // The pq start from pq[1].\\n        ts = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(!mp.count(key)) return -1;\\n        int index = mp[key];\\n        int val = pq[index]->val;\\n\\tpq[index]->fre++;\\n\\tpq[index]->timeStamp = ++ts;\\n        sink(index);\\n        return val;\\n    }\\n    \\n    void set(int key, int value) {\\n        if(Cap <= 0) return;\\n\\tif(mp.count(key)) {\\n\\t   int index = mp[key];\\n\\t   pq[index]->val = value;\\n\\t   get(key);\\n\\t}\\n\\telse {\\n\\t    if(pq.size() - 1 == Cap) {\\n\\t        int oldKey = pq[1]->key;\\n\\t\\tmp.erase(oldKey);\\n\\t\\tNode* newnode = new Node(key, value, ++ts);\\n\\t\\tpq[1] = newnode;\\n\\t\\tmp[key] = 1;\\n\\t\\tsink(1);\\n\\t    }\\n\\t    else {\\n\\t        Node* newnode = new Node(key, value, ++ts);\\n\\t\\tpq.push_back(newnode);\\n\\t\\tmp[key] = pq.size() - 1;\\n\\t\\tswim(pq.size() - 1);\\n\\t    }\\n\\t}\\n    }\\n    \\nprivate:\\n\\tvector<Node*> pq; // A priority queue, with the least usage frequency and least recently used element at the top.\\n\\tunordered_map<int, int> mp; // A mapping from the key of the element to its index in the priority queue.\\n\\tint Cap; // Capcity of the cache\\n\\tint ts; // time-stamp: indicate the time stamp of the latest operation of an element. According to the requirement of LFU cache, when we need to evict an element from the cache, but there are multiple elements with the same minimum frequency, then the least recently used element should be evicted.\\n\\n    /*\\n     * Recursively sink a node in priority queue. A node will be sinked, when its frequency is larger than any of its\\n     * children nodes, or the node has the same frequency with a child, but it is recently updated. \\n     */\\n\\tvoid sink(int index) {\\n\\t    int left = 2 * index, right = 2 * index + 1, target = index;\\n\\t    if(left < pq.size() && pq[left]->fre <= pq[target]->fre) // If the left child has the same frequency, we probably need to swap the parent node and the child node, because the parent node is recently accessed, and the left child node was accessed at an older time stamp.\\n               target = left;\\n            if(right < pq.size()) { \\n                if(pq[right]->fre < pq[target]->fre || (pq[right]->fre == pq[target]->fre && pq[right]->timeStamp < pq[target]->timeStamp)) // If right child has the same frequency and an older time stamp, we must swap it.\\n                     target = right;\\n\\t\\t}\\n\\t\\tif(target != index) {\\n\\t\\t    myswap(target, index);\\n\\t            sink(target);\\n\\t\\t}\\n\\t}\\n    \\n    /*a\\n     * Recursively swim a node in priority queue. A node will be swimmed, when its frequency is less than its\\n     * parent node. If the node has the same frequency with its parent, it is not needed to be swimmed, because\\n     * it is recently accessed.\\n     */\\n\\tvoid swim(int index) {\\n\\t    int par = index / 2;\\n\\t    while(par > 0 && pq[par]->fre > pq[index]->fre) {\\n\\t        myswap(par, index);\\n\\t\\tindex = par;\\n\\t\\tpar /= 2;\\n\\t    }\\n\\t}\\n\\n\\tvoid myswap(int id1, int id2) {\\n\\t    swap(pq[id1], pq[id2]);\\n\\t    mp[pq[id1]->key] = id1;\\n\\t    mp[pq[id2]->key] = id2;\\n\\t}\\n};\\n```"
		}
	],
	"id":"454",
	"title":"LFU Cache",
	"content":"<p>Design and implement a data structure for <a href=\"https://en.wikipedia.org/wiki/Least_frequently_used\" target=\"_blank\">Least Frequently Used (LFU)</a> cache. It should support the following operations: <code>get</code> and <code>put</code>.\r\n</p>\r\n\r\n<p>\r\n<code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>\r\n<code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least <b>recently</b> used key would be evicted.\r\n</p>\r\n\r\n<p><b>Follow up:</b><br />\r\nCould you do both operations in <b>O(1)</b> time complexity?</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nLFUCache cache = new LFUCache( 2 /* capacity */ );\r\n\r\ncache.put(1, 1);\r\ncache.put(2, 2);\r\ncache.get(1);       // returns 1\r\ncache.put(3, 3);    // evicts key 2\r\ncache.get(2);       // returns -1 (not found)\r\ncache.get(3);       // returns 3.\r\ncache.put(4, 4);    // evicts key 1.\r\ncache.get(1);       // returns -1 (not found)\r\ncache.get(3);       // returns 3\r\ncache.get(4);       // returns 4\r\n</pre>\r\n</p>",
	"frequency":"301",
	"ac_num":"17952"
}