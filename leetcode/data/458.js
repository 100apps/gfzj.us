{
	"difficulty":"2",
	"submit_num":"71087",
	"show_id":"464",
	"leetcode_id":"464",
	"answers":[
		{
			"lc_ans_id":"95277",
			"view":"31703",
			"top":"0",
			"title":"Java solution using HashMap with detailed explanation",
			"vote":"109",
			"content":"After solving several \"Game Playing\" questions in leetcode, I find them to be pretty similar. Most of them can be solved using the **top-down DP** approach, which \"brute-forcely\" simulates every possible state of the game. \\n\\nThe key part for the top-down dp strategy is that we need to **avoid repeatedly solving sub-problems**. Instead, we should use some strategy to \"remember\" the outcome of  sub-problems. Then when we see them again, we instantly know their result.  By doing this, ~~we can always reduce time complexity from **exponential** to **polynomial**~~. \\n(**EDIT:** Thanks for @billbirdh for pointing out the mistake here. For this problem, by applying the memo, we at most compute for every subproblem once, and there are ```O(2^n)``` subproblems, so the complexity is  ```O(2^n)``` after memorization. (Without memo, time complexity should be like ```O(n!)```)\\n\\nFor this question, the key part is: ```what is the state of the game```? Intuitively, to uniquely determine the result of any state, we need to know: \\n1) The unchosen numbers \\n2) The remaining desiredTotal to reach\\n\\nA second thought reveals that **1)** and **2)** are actually related because we can always get the **2)** by deducting the sum of chosen numbers from original desiredTotal.\\n\\nThen the problem becomes how to describe the state using **1)**.\\n\\nIn my solution, I use a **boolean array** to denote which numbers have been chosen, and  then a question comes to mind, if we want to use a Hashmap to remember the outcome of sub-problems, can we just use ```Map<boolean[], Boolean>``` ? **Obviously we cannot**, because the if we use boolean[] as a key, the reference to boolean[] won't reveal the actual content in boolean[]. \\n\\nSince in the problem statement, it says ```maxChoosableInteger``` will not be larger than ```20```, which means the length of our **boolean[] array** will be less than ```20```. Then we can use an ```Integer``` to represent this boolean[] array. How?\\n\\nSay the boolean[] is ```{false, false, true, true, false}```, then we can transfer it to an Integer with binary representation as ```00110```. Since Integer is a perfect choice to be the key of HashMap, then we now can \"memorize\" the sub-problems using ```Map<Integer, Boolean>```. \\n\\nThe rest part of the solution is just simulating the game process using the top-down dp.\\n\\n```\\npublic class Solution {\\n    Map<Integer, Boolean> map;\\n    boolean[] used;\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = (1+maxChoosableInteger)*maxChoosableInteger/2;\\n        if(sum < desiredTotal) return false;\\n        if(desiredTotal <= 0) return true;\\n        \\n        map = new HashMap();\\n        used = new boolean[maxChoosableInteger+1];\\n        return helper(desiredTotal);\\n    }\\n    \\n    public boolean helper(int desiredTotal){\\n        if(desiredTotal <= 0) return false;\\n        int key = format(used);\\n        if(!map.containsKey(key)){\\n    // try every unchosen number as next step\\n            for(int i=1; i<used.length; i++){\\n                if(!used[i]){\\n                    used[i] = true;\\n     // check whether this lead to a win (i.e. the other player lose)\\n                    if(!helper(desiredTotal-i)){\\n                        map.put(key, true);\\n                        used[i] = false;\\n                        return true;\\n                    }\\n                    used[i] = false;\\n                }\\n            }\\n            map.put(key, false);\\n        }\\n        return map.get(key);\\n    }\\n   \\n// transfer boolean[] to an Integer \\n    public int format(boolean[] used){\\n        int num = 0;\\n        for(boolean b: used){\\n            num <<= 1;\\n            if(b) num |= 1;\\n        }\\n        return num;\\n    }\\n}\\n```\\n\\n**Updated:** Thanks for @ckcz123 for sharing the great idea. In Java, to denote ```boolean[]```, an easier way is to use ```Arrays.toString(boolean[])```, which will transfer a ```boolean[]``` to sth like ```\"[true, false, false, ....]\"```, which is also not limited to how ```maxChoosableInteger``` is set, so it can be generalized to arbitrary large ```maxChoosableInteger```."
		},
		{
			"lc_ans_id":"95292",
			"view":"7911",
			"top":"1",
			"title":"Python solution, easy to understand",
			"vote":"14",
			"content":"Easy to understand baseline solution (not fast though), memorization is used to prune the search space. \\n```\\n    def canIWin(self, maxChoosableInteger, desiredTotal):\\n        \"\"\"\\n        :type maxChoosableInteger: int\\n        :type desiredTotal: int\\n        :rtype: bool\\n        \"\"\"\\n        if (1 + maxChoosableInteger) * maxChoosableInteger/2 < desiredTotal:\\n            return False\\n        self.memo = {}\\n        return self.helper(range(1, maxChoosableInteger + 1), desiredTotal)\\n\\n        \\n    def helper(self, nums, desiredTotal):\\n        \\n        hash = str(nums)\\n        if hash in self.memo:\\n            return self.memo[hash]\\n        \\n        if nums[-1] >= desiredTotal:\\n            return True\\n            \\n        for i in range(len(nums)):\\n            if not self.helper(nums[:i] + nums[i+1:], desiredTotal - nums[i]):\\n                self.memo[hash]= True\\n                return True\\n        self.memo[hash] = False\\n        return False"
		},
		{
			"lc_ans_id":"95294",
			"view":"7729",
			"top":"2",
			"title":"Java solution",
			"vote":"10",
			"content":"```\\npublic class Solution {\\n\\n    private Boolean[] win;\\n    int choosen = 0;\\n\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if (desiredTotal == 0) {\\n            return true;\\n        }\\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) {\\n            return false;\\n        }\\n        win = new Boolean[1 << maxChoosableInteger];\\n        return canWin(maxChoosableInteger, desiredTotal, 0);\\n    }\\n\\n    private boolean canWin(int n, int total, int now) {\\n        if (win[choosen] != null)\\n            return win[choosen];\\n        if (now >= total) {\\n            win[choosen] = false;\\n            return false;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            int bit = 1 << (i - 1);\\n            if ((choosen & bit) == 0) {\\n                choosen ^= bit;\\n                boolean ulose = !canWin(n, total, now + i);\\n                choosen ^= bit;\\n\\n                if (ulose) {\\n                    win[choosen] = true;\\n                    return true;\\n                }\\n            }\\n        }\\n        win[choosen] = false;\\n        return false;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"95320",
			"view":"1652",
			"top":"3",
			"title":"7-liner C++ beat 98.4%, DFS with early termination check (detailed explanation)",
			"vote":"9",
			"content":"For short notation, let `M = maxChoosableInteger` and `T = desiredTotal`.\\n\\n**Key Observation:** the state of the game is completely determined by currently available numbers to pick in the common pool.\\n\\n**State of Game:** initially, we have all `M` numbers `[1, M]` available in the pool. Each number may or may not be picked at a state of the game later on, so we have maximum `2^M` different states. Note that `M <= 20`, so `int` range is enough to cover it. For memorization, we define `int k` as the key for a game state, where \\n* the `i`-th bit of `k`, i.e., `k&(1<<i)` represents the availability of number `i+1` (`1`: picked; `0`: not picked).\\n\\nAt state `k`, the current player could pick any unpicked number from the pool, so state `k` can only go to one of the valid next states `k'`:\\n* if `i`-th bit of `k` is `0`, set it to be `1`, i.e., next state `k' = k|(1<<i)`.\\n\\n**Recursion:** apparently\\n* the current player can win at state `k` iff opponent can't win at some valid next state `k'`. \\n\\n**Memorization:** to speed up the recursion, we can use a `vector<int> m` of size `2^M` to memorize calculated results `m[k]` for state key `k`:\\n* ` 0` : not calculated yet;\\n* ` 1` : current player can win;\\n* `-1`: current player can't win.\\n\\n**Initial State Check:**\\nThere are several checks to be done at initial state `k = 0` for early termination so we won't waste our time for DFS process:\\n1. if `T < 2`, obviously, the first player wins by simply picking `1`.\\n2. if the sum of entire pool `S = M*(M+1)/2` is less than `T`, of course, nobody can reach `T`.\\n3. if the sum `S == T`, the order to pick numbers from the pool is irrelevant. Whoever picks the last will reach `T`. So the first player can win iff `M` is odd. \\n```\\n    bool canIWin(int M, int T) {\\n      int S = M*(M+1)/2; // sum of entire pool\\n      return T<2? true : S<T? false : S==T? M%2 : dfs(M,T,0);\\n    }\\n    \\n    bool dfs(int M, int T, int k) {\\n      if (T<=0 || m[k]) return T>0 && m[k]>0; // memorization or total reached by opponent\\n      for (int i = 0; i < M; ++i)\\n        if (!(k&1<<i) && !dfs(M, T-i-1, k|1<<i)) return m[k] = 1; // current player wins\\n      return !(m[k] = -1); // current player can't win\\n    }\\n    \\n    int m[1<<20] = {}; // m[key]: memorized result when pool state = key\\n```"
		},
		{
			"lc_ans_id":"95283",
			"view":"2776",
			"top":"4",
			"title":"brute force and memoization",
			"vote":"8",
			"content":"1. O(n!) brute force, n is maxChoosableInteger. T(n)=nT(n-1)\\n```\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(!desiredTotal) return 1;\\n        return canWin(~0<<maxChoosableInteger, maxChoosableInteger, desiredTotal);\\n    }\\n    bool canWin(int pool, int maxint, int tot) {\\n        if(tot<=0) return 0;\\n        for(int i=0;i<maxint;i++) {\\n            int mask = 1<<i;\\n            if(pool & mask) continue;\\n            pool|=mask;\\n            if(!canWin(pool,maxint, tot-i-1)) return 1;\\n            pool^=mask;\\n        }\\n        return 0;\\n    }\\n```\\n2. O(n2^n) Memoization. There is redundant computation in #1. A state with a pool and total may be computed many times. So we can cache the state and reuse it. At first glance, it seems that a state is determined by two values, the pool and the total. However, since the initial total is known, the remaining total is known given the pool. So a state can be identified by the pool only.\\n```\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(!desiredTotal) return 1;\\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2<desiredTotal) return 0;\\n        unordered_map<int,char> mem;\\n        return canWin(~0<<maxChoosableInteger, maxChoosableInteger, desiredTotal, mem);\\n    }\\n    bool canWin(int pool, int maxint, int tot, unordered_map<int,char>& mem) {\\n        if(tot<=0) return 0;\\n        auto it = mem.find(pool);\\n        if(it != mem.end()) return it->second;\\n        for(int i=0;i<maxint;i++) {\\n            int mask = 1<<i;\\n            if(pool & mask) continue;\\n            pool|=mask;\\n            if(!canWin(pool,maxint,tot-i-1,mem)) return mem[pool^=mask]=1;\\n            pool^=mask;\\n        }\\n        return mem[pool] = 0;\\n    }\\n```\\n3. Iterative dp. For most dp problems, the next step is to transform recursion with memoization to iterative dp. However, that does not help and is actually pretty bad for this problem. In iterative dp, we have to visit all the 2^n states to get the result. In #2 DFS with memoization, DFS terminates as soon as it finds a way to win. The worst case O(n2^n) rarely happens. So if DFS has early termination condition, then it should be better than dp that visits all the states. Similar problems are [word break](https://discuss.leetcode.com/topic/66356/evolve-from-brute-force-to-optimal-a-review-of-all-solutions) and [Concatenated Words](https://discuss.leetcode.com/topic/78569/a-review-of-top-solutions)."
		},
		{
			"lc_ans_id":"95293",
			"view":"6669",
			"top":"5",
			"title":"Java easy strightforward solution with explanation",
			"vote":"7",
			"content":"The solution is quite strightforward. First off we have to eliminate primitive cases. So,\\n * if the first player can choose a number, which is already greater than or equal to the desired total obviously it wins.\\n*  If max choosable integer is less than the desired total, but if it exceeds the desired total in sum with any other number then the  first player looses anyway. \\n* If the sum of all number in the pool cannot exceed or reach the desired total, then no one can win. \\n\\nNow, for the other cases we can use [MiniMax](https://en.wikipedia.org/wiki/Minimax) logic to reveal the winner. Because both player play optimally, In order to win, the first player has to make a choice, that leaves the second player no chance to win.  Thus, at each step we consider all the possible choices by the current player and give turn to the second player recursively. If we find a move, after which the second player looses anyway or we have already exceed the desired total by adding the chosen number, we return true, i.e the current player wins. This way the game looks like the following tree:\\n```\\n     player1 ->  0\\n              /| ...\\\\\\n  player2 -> 1 2 ....max \\n            /|\\\\ ..../ | \\\\\\nplayer1 -> 2 3...  1  2 ..max-1\\n           ...                \\\\\\nplayer1 ->   /      |     \\\\   loose\\nplayer2 -> loose   win   loose\\n```\\nThe figure above helps to imagine how the algorithm considers all possible scenarios of the game. The leafs of the game tree are loose or win states for one of the players. Finally the logic concludes to the idea, that if some branch does not contain any leaf that ends with win state for player2, the move associated with that branch is the optimal one for the first player.\\n\\nP.S: Time complexity of naive implementation will work for O(n!). Therefore we have to memorize branch states after traversing once.\\n\\n```\\npublic class Solution {\\n    Map<Integer, Boolean> set[];\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger >= desiredTotal) return true;\\n        if(maxChoosableInteger+1 >=desiredTotal) return false;\\n        set = new Map[301];\\n        for(int i  =0 ;i<301;i++) set[i] = new HashMap<>();\\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal) return false;\\n        return canWin((1<<maxChoosableInteger+1)-1, desiredTotal);\\n    }\\n    \\n    public boolean canWin(int set1, int total){\\n        if(set[total].containsKey(set1)) return set[total].get(set1);\\n        for(int i = 20;i>=1;i--){\\n            int p = (1<<i);\\n            if((p&set1) == p){\\n                int set1next = (set1^p);\\n                int totalNext = total - i;\\n                if(totalNext<=0) return true;\\n                boolean x;\\n                if(set[totalNext].containsKey(set1next)) x = set[totalNext].get(set1next);\\n                else x = canWin(set1next, totalNext);\\n                if(!x){\\n                    set[total].put(set1, true);\\n                    return true;\\n                }\\n            }\\n        }\\n        set[total].put(set1, false);\\n        return false;\\n    }\\n}"
		},
		{
			"lc_ans_id":"95288",
			"view":"1620",
			"top":"6",
			"title":"C++ DP solution 15ms 20 lines",
			"vote":"6",
			"content":"![alt text](https://lh5.googleusercontent.com/1LoMVftb488kkn6HKk3pgPl-_gXmWnpu1OA6UR2XT_Klghp_hJsjuP8kTmkZpA4WGwkBBEaut3X5Mjk=w1363-h930-rw)\\n\\n```\\nclass Solution {\\npublic:\\n\\u3000\\u3000bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\u3000\\u3000\\u3000\\u3000if (maxChoosableInteger >= desiredTotal) return true;\\n\\u3000\\u3000\\u3000\\u3000int sum = ((maxChoosableInteger + 1) * maxChoosableInteger) >> 1;\\n\\u3000\\u3000\\u3000\\u3000if (sum < desiredTotal) return false;\\n\\u3000\\u3000\\u3000\\u3000mp = vector<int>(1 << maxChoosableInteger, -1);\\n\\u3000\\u3000\\u3000\\u3000return canWin(0, maxChoosableInteger, desiredTotal);\\n\\u3000\\u3000}\\nprivate:\\n\\u3000\\u3000vector<int> mp;\\n\\u3000\\u3000bool canWin(int used, const int &maxChoosableInteger, int desiredTotal) {\\n\\u3000\\u3000\\u3000\\u3000if (mp[used] != -1) return mp[used];\\n\\u3000\\u3000\\u3000\\u3000for (int i = maxChoosableInteger, bits = 1 << (maxChoosableInteger - 1); i >= 1; --i, bits >>= 1) {\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000if ((used & bits) != 0) continue;\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000if (i >= desiredTotal || !canWin(used | bits, maxChoosableInteger, desiredTotal - i)) {\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000mp[used] = 1;\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000return true;\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000}\\n\\u3000\\u3000\\u3000\\u3000}\\n\\u3000\\u3000\\u3000\\u3000mp[used] = 0;\\n\\u3000\\u3000\\u3000\\u3000return false;\\n\\u3000\\u3000}\\n};\\n```"
		},
		{
			"lc_ans_id":"95304",
			"view":"3081",
			"top":"7",
			"title":"C++ easy understood 269ms solution with comments",
			"vote":"4",
			"content":"```\\nclass Solution {\\n    unordered_map<unsigned int,bool> cache;\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(maxChoosableInteger>=desiredTotal) return true;\\n        //the sum of all available numbers are less than desireTotal, which means it cannot reach the desireTotal\\n        if((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) return false;\\n        unsigned int used = (1<<maxChoosableInteger)-1; // use bit to record which number has been used (bit '1' means available, bit '0' means used)\\n        return play(desiredTotal,used,maxChoosableInteger);\\n    }\\n    bool play(int target, unsigned int used, int size){\\n        if(cache.find(used) != cache.end()) return cache[used];\\n        //exist available integer >= target, return true\\n        if(target-1<size && (used > (1<<target-1))){\\n            cache[used] = true;\\n            return true;\\n        }\\n        int bit = 1;\\n        for(int i = 0; i<size; i++,bit <<=1){\\n            if((used & bit)== 0) continue; // the (i+1)th bit is '0', means (i+1) is used\\n            used ^= bit;\\n            if(!play(target-i-1,used,size)){\\n                used |= bit;\\n                cache[used] = true;\\n                return true;\\n            }\\n            used |= bit;\\n        }\\n        cache[used] =  false;\\n        return false;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"95303",
			"view":"2405",
			"top":"8",
			"title":"C++ easy to understand DFS solution with explanation",
			"vote":"3",
			"content":"Player1 can win if and only if they can make a move after which player2 will lose no matter how they move. So we can check all possible moves of player1 and call the same function to see if player2 will lose after this move. This is the main idea. I use caching to memorize states for each possible desiredTotal and set of chosable integers. Since maxChoosableInteger is not greater than 20, all currently possible moves can be represented as a bit flag.\\n```\\nclass Solution {\\npublic:\\n    bool canWin(int key, int desiredTotal,vector<unordered_map<int,bool>> &cache, int mx) {\\n        if(cache[desiredTotal-1].find(key) != cache[desiredTotal-1].end())\\n           return cache[desiredTotal-1][key];\\n        for(int i = mx-1; i >= 0;--i)\\n           if(key & (1 << i))\\n           {\\n               key ^= (1 << i);\\n               if(i+1 >= desiredTotal || !canWin(key,desiredTotal-i-1,cache,mx))\\n               {\\n                  cache[desiredTotal-1][key] = true;\\n                  key |= (1 << i);\\n                  return true;\\n               }\\n               key |= (1 << i);\\n           }\\n        cache[desiredTotal-1][key] = false;\\n        return false;\\n    }\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        if(desiredTotal <= 1)\\n          return true;\\n        if(maxChoosableInteger*(maxChoosableInteger+1) < desiredTotal*2)\\n           return false;\\n        vector<unordered_map<int,bool>> cache(desiredTotal);\\n        vector<bool> v(maxChoosableInteger,true);\\n        int key = (1 << maxChoosableInteger)-1; \\n        return canWin(key,desiredTotal,cache,maxChoosableInteger);\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"95313",
			"view":"271",
			"top":"9",
			"title":"C++ solution with comments, 19 ms",
			"vote":"2",
			"content":"```\\nclass Solution {\\n   int _maxChoosableInteger;\\n   int _desiredTotal;\\n   vector<char> dp;\\n\\n   bool makeMove(int total, int movesMask) {\\n      // obviously loosing state, because the player cannot make any moves\\n      if (total >= _desiredTotal)\\n         return false;\\n\\n      // use already calculated state if any\\n      if (dp[movesMask] != -1)\\n         return dp[movesMask];\\n\\n      // try all possible moves that are left\\n      for (int i = 0; i < _maxChoosableInteger; ++i) {\\n         if (movesMask & (1 << i))\\n            continue;\\n         movesMask |= (1 << i);\\n         // if there is a move that leads from the current state to a losing state,\\n         // the current state is a winning state, and otherwise it is a losing state\\n         if (!makeMove(total + i + 1, movesMask))\\n         {\\n            movesMask &= ~(1 << i);\\n            dp[movesMask] = true;\\n            return true;\\n         }\\n         movesMask &= ~(1 << i);\\n      }\\n\\n      dp[movesMask] = false;\\n      return false;\\n   }\\n\\npublic:\\n   bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n      int sum = (1 + maxChoosableInteger) * maxChoosableInteger / 2;\\n      if (sum < desiredTotal) return false;\\n      if (desiredTotal <= 0) return true;\\n\\n      _maxChoosableInteger = maxChoosableInteger;\\n      _desiredTotal = desiredTotal;\\n      \\n      dp.assign(1 << maxChoosableInteger, -1);\\n      return makeMove(0, 0);\\n   }\\n};\\n```"
		}
	],
	"id":"458",
	"title":"Can I Win",
	"content":"<p>In the \"100 game,\" two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins. </p>\r\n\r\n<p>What if we change the game so that players cannot re-use integers? </p>\r\n\r\n<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100.</p>\r\n\r\n<p>Given an integer <code>maxChoosableInteger</code> and another integer <code>desiredTotal</code>, determine if the first player to move can force a win, assuming both players play optimally. </p>\r\n\r\n<p>You can always assume that <code>maxChoosableInteger</code> will not be larger than 20 and <code>desiredTotal</code> will not be larger than 300.\r\n</p>\r\n\r\n<p><b>Example</b>\r\n<pre>\r\n<b>Input:</b>\r\nmaxChoosableInteger = 10\r\ndesiredTotal = 11\r\n\r\n<b>Output:</b>\r\nfalse\r\n\r\n<b>Explanation:</b>\r\nNo matter which integer the first player choose, the first player will lose.\r\nThe first player can choose an integer from 1 up to 10.\r\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\r\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\r\nSame with other integers chosen by the first player, the second player will always win.\r\n</pre>\r\n</p>",
	"frequency":"161",
	"ac_num":"18063"
}