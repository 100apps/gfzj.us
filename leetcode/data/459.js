{
	"difficulty":"3",
	"submit_num":"17671",
	"show_id":"465",
	"leetcode_id":"465",
	"answers":[
		{
			"lc_ans_id":"95355",
			"view":"8228",
			"top":"0",
			"title":"11-liner 9ms DFS solution (detailed explanation)",
			"vote":"28",
			"content":"With all the given transactions, in the end, each person with ID = `id` will have an overall balance `bal[id]`. Note that the `id` value or any person coincidentally with `0` balance is irrelevant to debt settling count, so we can simply use an array `debt[]` to store all non-zero balances, where\\n* `debt[i] > 0` means a person needs to pay `$ debt[i]` to other person(s);\\n* `debt[i] < 0` means a person needs to collect `$ debt[i]` back from other person(s).\\n\\nStarting from first debt `debt[0]`, we look for all other debts `debt[i]` (`i>0`) which have opposite sign to `debt[0]`. Then each such `debt[i]` can make one transaction `debt[i] += debt[0]` to clear the person with debt `debt[0]`. From now on, the person with debt `debt[0]` is dropped out of the problem and we recursively drop persons one by one until everyone's debt is cleared meanwhile  updating the minimum number of transactions during DFS.\\n\\nNote: Thanks to @KircheisHe who found the following great paper about the debt settling problem:\\n* [Settling Multiple Debts Efficiently: An Invitation to Computing Science](http://www.mathmeth.com/tom/files/settling-debts.pdf) by T. Verhoeff, June 2003.\\n\\nThe question can be transferred to a [3-partition problem](https://en.wikipedia.org/wiki/3-partition_problem), which is NP-Complete.\\n\\n```\\npublic:\\n    int minTransfers(vector<vector<int>>& trans) {\\n        unordered_map<int, long> bal; // each person's overall balance\\n        for(auto& t: trans) bal[t[0]] -= t[2], bal[t[1]] += t[2];\\n        for(auto& p: bal) if(p.second) debt.push_back(p.second);\\n        return dfs(0, 0);\\n    }\\n    \\nprivate:\\n    int dfs(int s, int cnt) { // min number of transactions to settle starting from debt[s]\\n    \\twhile (s < debt.size() && !debt[s]) ++s; // get next non-zero debt\\n    \\tint res = INT_MAX;\\n    \\tfor (long i = s+1, prev = 0; i < debt.size(); ++i)\\n    \\t  if (debt[i] != prev && debt[i]*debt[s] < 0) // skip already tested or same sign debt\\n    \\t    debt[i] += debt[s], res = min(res, dfs(s+1,cnt+1)), prev = debt[i]-=debt[s];\\n    \\treturn res < INT_MAX? res : cnt;\\n    }\\n    \\n    vector<long> debt; // all non-zero balances\\n```"
		},
		{
			"lc_ans_id":"95365",
			"view":"6426",
			"top":"1",
			"title":"Easy java solution, with explanation",
			"vote":"17",
			"content":"Hi there! Guys in the problem, construct an isolated system. It mean the total amount of money in the system keeps constant. Thus, what matters is the amount of extra money each person have after all transactions complete. For example, if id1 gave id2 5$, then after that transaction id1's money decreased to 5$, on the contrary id2's money increased to 5$.  That way, we know how did change account of each person. For imagination let's consider the following input [[1,2,3],[2,3,5], [4,1,6]]:\\n```       \\n           id|  trans |  total |\\n          ---------------------\\n           1 | -3 + 6 |   +3   |\\n          ---------------------\\n           2 | +3 - 5 |   -2   |\\n         ----------------------\\n           3 |    +5  |   +5   |\\n         ----------------------\\n           4 |    -6  |   -6   |\\n         ----------------------\\n```\\nNow, we have some negative account changes and positive account changes. By the way it is not hard to see that they compensate each other. Now, our task is to balance the accounts, by performing minimal amount of transactions. For instance we can balance these accounts, by performing the following transactions:  [1,2,2], [3,4,5], [1,4,1]. After that, all accounts become balanced, i.e 0 extra money in total. But we have performed 3 transactions. Can we do better? May be. The number of transactions depend on the order of pairs taking part in each transaction. Consequently, the next question is, 'how to know which set of pairs give minimum number of transactions?'. One  solution idea is just, brute force through all pairs and just take the minimum number of transactions. Another idea is just take some random combinations of pairs and take the minimum number of trans so far. \\n\\nP.S: May be there are other elegant and exact solutions and this solution doesn't pretend to the best one, but it is quite reasonable. The more random shuffles you do, the more probability of hitting the answer. For that test cases 1000 is enough, may be less... \\n```\\npublic class Solution {\\n    public int minTransfers(int[][] transactions) {\\n        if(transactions == null || transactions.length == 0) return 0;\\n        Map<Integer, Integer> acc = new HashMap<>();\\n        for(int i = 0;i<transactions.length;i++){\\n            int id1 = transactions[i][0];\\n            int id2 = transactions[i][1];\\n            int m = transactions[i][2];\\n            acc.put(id1, acc.getOrDefault(id1, 0)-m);\\n            acc.put(id2, acc.getOrDefault(id2, 0)+m);\\n        }\\n        List<Integer> negs = new ArrayList<>();\\n        List<Integer> poss = new ArrayList<>();\\n        for(Integer key:acc.keySet()){\\n            int m = acc.get(key);\\n            if(m == 0) continue;\\n            if(m<0) negs.add(-m);\\n            else poss.add(m);\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        Stack<Integer> stNeg = new Stack<>(), stPos = new Stack<>();\\n        for(int i =0;i<1000;i++){\\n            for(Integer num:negs) stNeg.push(num);\\n            for(Integer num:poss) stPos.push(num);\\n            int cur = 0;\\n            while(!stNeg.isEmpty()){\\n                int n = stNeg.pop();\\n                int p = stPos.pop();\\n                cur++;\\n                if(n == p) continue;\\n                if(n>p){\\n                    stNeg.push(n-p);\\n                } else {\\n                    stPos.push(p-n);\\n                }\\n            }\\n            ans = Math.min(ans, cur);\\n            Collections.shuffle(negs);\\n            Collections.shuffle(poss);\\n        }\\n        return ans;\\n    }\\n    \\n}"
		},
		{
			"lc_ans_id":"95354",
			"view":"7104",
			"top":"2",
			"title":"Looks that this is a wrong question. The expected solution didn't consider this case.",
			"vote":"16",
			"content":"Given the input [[0,1,1], [2,3,2], [4,5,3], [6,7,4], [8,9,5], [10,11,6], [12,13,7], [14,15,2], [14,16,2], [14,17,2], [14,18,2]]\\n\\nThe provided expected result is 14. However, there are only 11 transactions, so the upper bound of the result should be 11."
		},
		{
			"lc_ans_id":"95356",
			"view":"3611",
			"top":"3",
			"title":"6ms ac easy to understand java solution with comments",
			"vote":"10",
			"content":"    public int minTransfers(int[][] transactions) {\\n        if (transactions == null || transactions.length == 0 || transactions[0].length == 0)\\n            return 0;\\n        //calculate delta for each account\\n        Map<Integer, Integer> accountToDelta = new HashMap<Integer, Integer>();\\n        for (int[] transaction : transactions) {\\n            int from = transaction[0];\\n            int to = transaction[1];\\n            int val = transaction[2];\\n            if (!accountToDelta.containsKey(from)) {\\n                accountToDelta.put(from, 0);\\n            }\\n            if (!accountToDelta.containsKey(to)) {\\n                accountToDelta.put(to, 0);\\n            }\\n            accountToDelta.put(from, accountToDelta.get(from) - val);\\n            accountToDelta.put(to, accountToDelta.get(to) + val);\\n        }\\n        List<Integer> deltas = new ArrayList<Integer>();\\n        for (int delta : accountToDelta.values()) {\\n            if (delta != 0)\\n                deltas.add(delta);\\n        }\\n        //since minTransStartsFrom is slow, we can remove matched deltas to optimize it\\n        //for example, if account A has balance 5 and account B has balance -5, we know\\n        //that one transaction from B to A is optimal.\\n        int matchCount = removeMatchDeltas(deltas);\\n        //try out all possibilities to get minimum number of transactions\\n        return matchCount + minTransStartsFrom(deltas, 0);\\n    }\\n    \\n    private int removeMatchDeltas(List<Integer> deltas) {\\n        Collections.sort(deltas);\\n        int left = 0;\\n        int right = deltas.size() - 1;\\n        int matchCount = 0;\\n        while (left < right) {\\n            if (-1 * deltas.get(left) == deltas.get(right)) {\\n                deltas.remove(left);\\n                deltas.remove(right - 1);\\n                right -= 2;\\n                matchCount++;\\n            } else if (-1 * deltas.get(left) > deltas.get(right)) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return matchCount;\\n    }\\n    \\n    private int minTransStartsFrom(List<Integer> deltas, int start) {\\n        int result = Integer.MAX_VALUE;\\n        int n = deltas.size();\\n        while (start < n && deltas.get(start) == 0)\\n            start++;\\n        if (start == n)\\n            return 0;\\n        for (int i = start + 1; i < n; i++) {\\n            if ((long) deltas.get(i) * deltas.get(start) < 0) {\\n                deltas.set(i, deltas.get(i) + deltas.get(start));\\n                result = Math.min(result, 1 + minTransStartsFrom(deltas, start + 1));\\n                deltas.set(i, deltas.get(i) - deltas.get(start));\\n        }\\n        }\\n        return result;\\n    }"
		},
		{
			"lc_ans_id":"95369",
			"view":"3099",
			"top":"4",
			"title":"Share My O(N!) NPC solution, TLE for large case",
			"vote":"4",
			"content":"```\\nimport java.util.*;\\n\\npublic class Solution {\\n    public int minTransfers(int[][] trans) {\\n        Map<Integer, Integer> net = new HashMap<>();\\n        for(int i = 0; i < trans.length; i++){\\n            net.put(trans[i][0], net.getOrDefault(trans[i][0], 0) - trans[i][2]);\\n            net.put(trans[i][1], net.getOrDefault(trans[i][1], 0) + trans[i][2]);\\n        }\\n        int[] temp = new int[net.size()];\\n        int i = 0;\\n        for(int j : net.values()){\\n            if(j != 0)temp[i++] = j;\\n        }\\n        int[] a = new int[i];\\n        System.arraycopy(temp, 0, a, 0, i);\\n        transactions.clear();\\n        number = Integer.MAX_VALUE;\\n        mintran(a, 0);\\n        return number;\\n    }\\n\\n    private List<int[]> transactions = new ArrayList<>();\\n    private int number = Integer.MAX_VALUE;\\n\\n    private void mintran(int[] a, int start){\\n        //System.out.println(Arrays.toString(a));\\n        if(transactions.size() >= number) return;\\n        if(number == (a.length + 1)/2) return;\\n\\n        if(a.length < 2){\\n            number = 0;\\n            return;\\n        }else if(a.length == 2) {\\n            number = a[0] == 0 ? 0 : 1;\\n            return;\\n        }else{\\n            int ind = -1;\\n            int max = Integer.MIN_VALUE;\\n            int i = start;\\n            for(; i < a.length; i++){\\n                if(Math.abs(a[i]) > max){\\n                    max = Math.abs(a[i]);\\n                    ind = i;\\n                }\\n            }\\n\\n            if(max == 0 || start == a.length){\\n                if(transactions.size() < number){\\n                    number = transactions.size();\\n                }\\n                return;\\n            }\\n\\n            int temp = a[ind];\\n            a[ind] = a[start];\\n            a[start] = temp;\\n\\n            for(i = start + 1; i < a.length; i++){\\n                if(a[i] * a[start] < 0) {\\n                    transactions.add(new int[]{a[i], a[start]});\\n                    temp = a[i];\\n                    a[i] += a[start];\\n                    mintran(a, start + 1);\\n                    a[i] = temp;\\n                    transactions.remove(transactions.size()-1);\\n                }\\n            }\\n\\n            temp = a[ind];\\n            a[ind] = a[start];\\n            a[start] = temp;\\n\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int[][] A = new int[][] {{0,1,1}, {2,3,2}, {4,5,3}, {6,7,4}, {8,9,5}, {10,11,6}, {12,13,7}, {14,15,2}, {14,16,2}, {14,17,2}, {14,18,2}};\\n        Solution solution = new Solution();\\n        System.out.println(solution.minTransfers(A));\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"95392",
			"view":"1042",
			"top":"5",
			"title":"Wrong dataset",
			"vote":"3",
			"content":"Think about this case:\\n[[0,3,2],[1,4,3],[2,3,2],[2,4,2]]\\n\\nThe correct answer should be 3, but the so-called standard answer is 4.\\nActually this question seems to be a NPC problem. And I don't know why there is no data scale."
		},
		{
			"lc_ans_id":"95375",
			"view":"374",
			"top":"6",
			"title":"Sharing a working C++ solution",
			"vote":"2",
			"content":"* Traverse all transactions, record the debt situation of each person.\\n* Do backtracking for each person. During each recursion, try to match this person's with every other person.\\nI am sure this is not an optimal solution. But it seems this problem is NP-hard, and we can only do searching.\\n```\\nclass Solution {\\npublic:\\n    int minTransfers(vector<vector<int>>& transactions) {\\n        unordered_map<int, long> debts;\\n        for(auto& tup: transactions) {\\n            debts[tup[0]] -= (long)tup[2];\\n            debts[tup[1]] += (long)tup[2];\\n        }\\n        vector<int> arr;\\n        for(auto& p: debts) {\\n            if(p.second != 0) arr.push_back(p.second);\\n        }\\n        return helper(arr, 0, arr.size(), 0);\\n    }\\n    \\nprivate:\\n    int helper(vector<int>& a, int start, int n, int num) {\\n        int ans = INT_MAX;\\n        while(start < n && a[start] == 0) start++;\\n        for (int i = start + 1; i < n; ++i) {\\n            if (a[i] < 0 && a[start] > 0 || a[i] > 0 && a[start] < 0) {\\n                a[i] += a[start];\\n                ans = min(ans, helper(a, start + 1, n, num + 1));\\n                a[i] -= a[start];\\n            }\\n        }\\n        return ans == INT_MAX ? num : ans;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"95363",
			"view":"766",
			"top":"7",
			"title":"Easy backtracking + greedy solution with explanation (Python, Accepted)",
			"vote":"2",
			"content":"Just to share a backtracking + greedy solution. The Python implementation was accepted.\\n\\nFirst, compute net profit for every person. \\n```\\nFor transactions:\\n[0, 1, 10]\\n[2, 0, 5]\\n\\nPerson, netProfit\\n0,         -5\\n1,         10\\n2,         -5\\n```\\nThen, preserve unsettled people only whose net profit != 0. \\n\\nNow backtrack to maintain the unsettled range [startIdx :]. Person X is settled means that X's net profit becomes 0 after one transaction with another unsettled person Y. Obviously, the amount of this transaction must be equal to X's net profit in their absolute values for X to be settled.\\n\\nNote that there may be some settled people within the unsettled range [startIdx :]. For instance, if someone within this unsettled range happened to be precisely closed out by someone else in the settled range.\\n\\nThe greedy condition is precise closing-out (two people's net profit sum = 0). Since precise closing-out reduces number of unsettled people by 2 rather than 1, it is in fact the optimal condition.\\n\\nIf greedy condition cannot be found, try non-greedy solutions.\\n\\nComments can be found in the following implementation.\\n\\n```\\nclass Solution(object):\\n    def minTransfers(self, transactions):\\n        # Compute net profit for every person.\\n        personNetProfit = dict()\\n        for lender, borrower, amount in transactions:\\n            personNetProfit[lender] = personNetProfit.get(lender, 0) - amount\\n            personNetProfit[borrower] = personNetProfit.get(borrower, 0) + amount\\n        # Preserve unsettled people only.\\n        netProfit = []\\n        for amount in personNetProfit.values():\\n            if amount != 0:\\n                netProfit.append(amount)\\n        return self.traverse(netProfit, 0, 0)\\n    \\n    def traverse(self, netProfit, startIdx, numTrans):\\n        # Skip settled people.\\n        while startIdx < len(netProfit) and netProfit[startIdx] == 0:\\n            startIdx += 1\\n        if startIdx + 1 >= len(netProfit):\\n            return numTrans\\n        else:\\n            for i in range(startIdx + 1, len(netProfit)):\\n                # Greedy condition.\\n                if netProfit[startIdx] + netProfit[i] == 0:\\n                    netProfit[i] += netProfit[startIdx]\\n                    minNumTrans = self.traverse(netProfit, startIdx + 1, numTrans + 1)\\n                    netProfit[i] -= netProfit[startIdx]\\n                    return minNumTrans\\n            minNumTrans = sys.maxint\\n            for i in range(startIdx + 1, len(netProfit)):\\n                # Non-greedy condition for possible closing out in the future.\\n                if netProfit[startIdx] * netProfit[i] < 0:\\n                    netProfit[i] += netProfit[startIdx]\\n                    minNumTrans = min(minNumTrans, self.traverse(netProfit, startIdx + 1, numTrans + 1))\\n                    netProfit[i] -= netProfit[startIdx]\\n            return minNumTrans\\n```"
		},
		{
			"lc_ans_id":"95385",
			"view":"981",
			"top":"8",
			"title":"Accepted Solution with comments [After the test case correction]",
			"vote":"2",
			"content":"```\\n/*\\nThis is a straight forward brutal force problem.\\nWe first replay all the transactions while keeping a balance for each people\\nThen we try to settle the money asap.\\n\\nHow do we settle?\\nWe group the balances into 2 arrays, pos and neg\\nWe use a nested for loop to try all the possible sequence of settlement.\\n\\n\\n*/\\npublic class Solution {\\n    public int minTransfers(int[][] trans) {\\n        Map<Integer, Integer> net = new HashMap<>();\\n        for(int i = 0; i < trans.length; i++){\\n            net.put(trans[i][0], net.getOrDefault(trans[i][0], 0) - trans[i][2]);\\n            net.put(trans[i][1], net.getOrDefault(trans[i][1], 0) + trans[i][2]);\\n        }\\n        int res = 0;\\n        List<Integer> pos = new ArrayList<Integer>();\\n        List<Integer> neg = new ArrayList<Integer>();\\n        \\n        for(int i : net.values()){\\n            if(i > 0) pos.add(i);\\n            if(i < 0) neg.add(i);\\n        }\\n        int result = (pos.size() == 0) ? 0 : trans.length;\\n        \\n        for(int i = 0; i < pos.size(); i++){\\n            int first = pos.remove(0);\\n            pos.add(first);\\n            for(int j = 0; j < neg.size(); j++){\\n                int second = neg.remove(0);\\n                neg.add(second);\\n                result =Math.min(collapse(pos, neg), result);\\n\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int collapse(List<Integer> positive, List<Integer> negative){\\n        int count = 0;\\n        List<Integer> pos = new ArrayList<Integer>();\\n        pos.addAll(positive);\\n        List<Integer> neg = new ArrayList<Integer>();\\n        neg.addAll(negative);\\n        /*Optionally remove either one or both of the front element in 2 lists*/    \\n        while(pos.size() != 0 && neg.size() != 0){\\n            if(pos.get(0) < Math.abs(neg.get(0))){\\n                neg.set(0, neg.get(0) + pos.get(0));\\n                pos.remove(0);\\n            }else if (pos.get(0) > Math.abs(neg.get(0))){\\n                pos.set(0, pos.get(0) + neg.get(0));\\n                neg.remove(0);\\n            }else{\\n                pos.remove(0);\\n                neg.remove(0);\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}"
		},
		{
			"lc_ans_id":"95370",
			"view":"610",
			"top":"9",
			"title":"Error Question?",
			"vote":"2",
			"content":"'''\\npublic class Solution {\\n    public int minTransfers(int[][] transactions) {\\n        int count = transactions.length;\\n        if (count == 0)\\n            return 0;\\n\\n        Map<Integer, Integer> consult = new HashMap<Integer, Integer>();\\n\\n        for(int i = 0; i < count; i++) {\\n            int left = transactions[i][0];\\n            int right = transactions[i][1];\\n            int z = transactions[i][2];\\n\\n            consult.put(left, consult.getOrDefault(left, 0) + z);\\n            consult.put(right, consult.getOrDefault(right, 0) - z);\\n        }\\n        // \\u6240\\u6709\\u4eba\\u8d26\\u76ee\\u5f52\\u4e00\\u4e4b\\u540e\\u5904\\u7406\\n        // \\u6070\\u597d\\u7684\\u8d26\\u76ee\\u62b5\\u6d88\\u6389\\n        Queue<Integer> posi = new PriorityQueue<>(20, (o1, o2) -> o2 - o1);\\n        Queue<Integer> nega = new PriorityQueue<>(20, (o1, o2) -> o2 - o1);\\n\\n        List<Integer> tmp = new ArrayList<>();\\n        System.out.println(consult.toString());\\n        for(int i: consult.values()) {\\n            if (i > 0) {\\n                posi.add(i);\\n            }\\n            else if (i < 0)\\n                tmp.add(-i);\\n        }\\n\\n        int res = 0;\\n\\n      //  System.out.println(tmp.toString());\\n       // System.out.println(posi.toString());\\n        //System.out.println(posi.toString());\\n        for(int i: tmp) {\\n           if(posi.contains(i)) {\\n               res++;\\n               posi.remove(Integer.valueOf(i));\\n            } else\\n                nega.add(i);\\n        }\\n\\n        //  System.out.println(nega.toString());\\n       // System.out.println(posi.toString());\\n        //System.out.println(res);\\n\\n        while (!nega.isEmpty() && !posi.isEmpty()) {\\n            int diff = posi.peek() - nega.peek();\\n            posi.poll();\\n            nega.poll();\\n            res++;\\n            if(diff > 0) {\\n                if (nega.contains(diff)) {\\n                    nega.remove(Integer.valueOf(diff));\\n                    res++;\\n                } else\\n                    posi.add(diff);\\n                } else if (diff < 0) {\\n                if (posi.contains(-diff)) {\\n                    posi.remove(Integer.valueOf(-diff));\\n                    res++;\\n                } else\\n                    nega.add(-diff);\\n            }\\n            //System.out.println(nega.toString());\\n            //System.out.println(posi.toString());\\n          //  System.out.println(res);\\n        }\\n        //System.out.println(nega.toString());\\n        //System.out.println(posi.toString());\\n        System.out.println(res);\\n        return res;\\n    }\\n\\n    public int minTransfers2(int[][] transactions) {\\n        Map<Integer, Long> bal = new HashMap<>();\\n        for(int[] tr: transactions){\\n            if(!bal.containsKey(tr[0])) bal.put(tr[0], 0L);\\n            if(!bal.containsKey(tr[1])) bal.put(tr[1], 0L);\\n            bal.put(tr[0], bal.get(tr[0])+(long)tr[2]);\\n            bal.put(tr[1], bal.get(tr[1])-(long)tr[2]);\\n        }\\n        System.out.println(bal.toString());\\n        TreeMap<Long, Integer> balancemap = new TreeMap<>();\\n        for(int person: bal.keySet()){\\n            long cur = bal.get(person);\\n            if(cur!=0L){\\n                balancemap.put(cur, balancemap.getOrDefault(cur, 0)+1);\\n            }\\n        }\\n        int payment = 0;\\n        while(!balancemap.isEmpty()){\\n            long lo = balancemap.firstKey();\\n            long hi = balancemap.lastKey();\\n            long sum = lo+hi;\\n\\n            if(balancemap.get(lo)==1){\\n                balancemap.remove(lo);\\n            }\\n            else{\\n                balancemap.put(lo, balancemap.get(lo)-1);\\n            }\\n            if(balancemap.get(hi)==1){\\n                balancemap.remove(hi);\\n            }\\n            else{\\n                balancemap.put(hi, balancemap.get(hi)-1);\\n            }\\n\\n            if(sum!=0){\\n                balancemap.put(sum, balancemap.getOrDefault(sum, 0)+1);\\n            }\\n            payment++;\\n        }\\n        System.out.println(payment);\\n        return payment;\\n\\n    }\\n\\n    public static void main(String[] args) {\\n        int[][] trs = {{6,29,18},{1,22,84},{4,25,16},{7,22,16},{5,27,79},{7,27,60},{3,28,95},{4,20,95},{7,25,99},{1,29,25},{9,21,87},{4,26,39},{5,23,67},{6,22,68},{3,29,94},{8,24,66},{6,28,33},{9,28,85},{8,28,28},{3,21,25},{7,26,3},{3,22,89},{6,28,58},{6,28,45},{1,29,3},{7,21,95},{0,25,14},{8,27,37},{5,21,98},{9,23,57},{8,24,21},{8,25,78},{2,23,15},{3,24,50},{1,26,66},{6,21,38},{6,28,30},{8,29,49},{3,20,86},{4,22,91},{1,21,18},{1,26,22},{5,25,75},{5,28,48},{2,26,83},{3,28,3},{2,27,76},{7,22,73},{8,27,97},{2,26,49},{0,20,83},{7,23,47},{9,29,94},{2,27,43},{5,25,50},{7,29,76},{1,20,26},{9,28,77},{1,29,63},{9,26,55},{1,25,17},{3,28,37}};\\n        int[][] trs2 = {{8,23,20},{3,24,78},{4,20,37},{0,29,66},{2,29,2},{0,20,23},{0,22,65},{5,24,34},{0,27,6},{6,21,16},{1,26,2},{4,21,73},{8,27,64},{6,27,39},{5,25,15},{5,23,28},{8,25,53},{6,27,98},{0,25,92},{5,28,91},{8,21,75},{1,25,39},{1,22,55},{1,25,14},{4,26,70},{6,29,30},{6,26,11},{1,28,68},{1,26,13},{7,21,4},{3,29,77},{0,26,93},{7,20,39},{5,22,91},{9,27,80},{1,23,71},{6,29,27},{8,26,95},{8,29,24},{7,25,70},{1,29,17},{9,29,98},{6,22,26},{1,24,74},{0,25,33},{0,24,68},{8,25,91},{8,23,36},{1,29,25},{8,27,82},{4,24,14}};\\n        new Solution().minTransfers(trs2);\\n        new Solution().minTransfers2(trs2);\\n    }\\n}\\n\\n'''\\n\\nI compared my answer(first one) with the No.1\\nI think some wrong with this question!"
		}
	],
	"id":"459",
	"title":"Optimal Account Balancing",
	"content":"<p>A group of friends went on holiday and sometimes lent each other money. For example, Alice paid for Bill's lunch for $10. Then later Chris gave Alice $5 for a taxi ride. We can model each transaction as a tuple (x, y, z) which means person x gave person y $z. Assuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person's ID), the transactions can be represented as <code>[[0, 1, 10], [2, 0, 5]]</code>.</p>\r\n\r\n<p>Given a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.</p>\r\n\r\n<p><b>Note:</b>\r\n<ol>\r\n<li>A transaction will be given as a tuple (x, y, z). Note that <code>x &ne; y</code> and <code>z > 0</code>.</li>\r\n<li>Person's IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\n<b>Input:</b>\r\n[[0,1,10], [2,0,5]]\r\n\r\n<b>Output:</b>\r\n2\r\n\r\n<b>Explanation:</b>\r\nPerson #0 gave person #1 $10.\r\nPerson #2 gave person #0 $5.\r\n\r\nTwo transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\n<b>Input:</b>\r\n[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]\r\n\r\n<b>Output:</b>\r\n1\r\n\r\n<b>Explanation:</b>\r\nPerson #0 gave person #1 $10.\r\nPerson #1 gave person #0 $1.\r\nPerson #1 gave person #2 $5.\r\nPerson #2 gave person #0 $5.\r\n\r\nTherefore, person #1 only need to give person #0 $4, and all debt is settled.\r\n</pre>\r\n</p>",
	"frequency":"85",
	"ac_num":"6844"
}