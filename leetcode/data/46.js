{
	"difficulty":"2",
	"submit_num":"459935",
	"show_id":"46",
	"leetcode_id":"46",
	"answers":[
		{
			"lc_ans_id":"18239",
			"view":"69258",
			"top":"0",
			"title":"A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partioning)",
			"vote":"421",
			"content":"This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/"
		},
		{
			"lc_ans_id":"18247",
			"view":"36740",
			"top":"1",
			"title":"My elegant recursive C++ solution with inline explanation",
			"vote":"187",
			"content":"This recursive solution is the my first response for this problem. I was surprised when I found no similar solution posted here. It is much easier to understand than DFS-based ones, at least in my opinion. Please find more explanations [here][1]. All comments are welcome.\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n    \\t    vector<vector<int> > result;\\n    \\t    \\n    \\t    permuteRecursive(num, 0, result);\\n    \\t    return result;\\n        }\\n        \\n        // permute num[begin..end]\\n        // invariant: num[0..begin-1] have been fixed/permuted\\n    \\tvoid permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)\\t{\\n    \\t\\tif (begin >= num.size()) {\\n    \\t\\t    // one permutation instance\\n    \\t\\t    result.push_back(num);\\n    \\t\\t    return;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor (int i = begin; i < num.size(); i++) {\\n    \\t\\t    swap(num[begin], num[i]);\\n    \\t\\t    permuteRecursive(num, begin + 1, result);\\n    \\t\\t    // reset\\n    \\t\\t    swap(num[begin], num[i]);\\n    \\t\\t}\\n        }\\n    };\\n\\n\\n  [1]: http://xiaohuiliucuriosity.blogspot.com/2014/12/permutations.html"
		},
		{
			"lc_ans_id":"18237",
			"view":"29455",
			"top":"2",
			"title":"My AC simple iterative java/python solution",
			"vote":"151",
			"content":"the basic idea is, to permute n numbers, we can add the nth number into the resulting `List<List<Integer>>` from the n-1 numbers, in every possible position. \\n\\nFor example, if the input num[] is {1,2,3}: First, add 1 into the initial `List<List<Integer>>` (let's call it \"answer\"). \\n\\nThen, 2 can be added in front or after 1. So we have to copy the List<Integer> in answer (it's just {1}), add 2 in position 0 of {1}, then copy the original {1} again, and add 2 in position 1. Now we have an answer of {{2,1},{1,2}}. There are 2 lists in the current answer.\\n\\nThen we have to add 3. first copy {2,1} and {1,2}, add 3 in position 0; then copy {2,1} and {1,2}, and add 3 into position 1, then do the same thing for position 3. Finally we have 2*3=6 lists in answer, which is what we want.\\n\\n    public List<List<Integer>> permute(int[] num) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        if (num.length ==0) return ans;\\n        List<Integer> l0 = new ArrayList<Integer>();\\n        l0.add(num[0]);\\n        ans.add(l0);\\n        for (int i = 1; i< num.length; ++i){\\n            List<List<Integer>> new_ans = new ArrayList<List<Integer>>(); \\n            for (int j = 0; j<=i; ++j){            \\n               for (List<Integer> l : ans){\\n            \\t   List<Integer> new_l = new ArrayList<Integer>(l);\\n            \\t   new_l.add(j,num[i]);\\n            \\t   new_ans.add(new_l);\\n               }\\n            }\\n            ans = new_ans;\\n        }\\n        return ans;\\n    }\\n\\n-------------------------------------------------------------------------\\npython version is more concise:\\n\\n    def permute(self, nums):\\n        perms = [[]]   \\n        for n in nums:\\n            new_perms = []\\n            for perm in perms:\\n                for i in xrange(len(perm)+1):   \\n                    new_perms.append(perm[:i] + [n] + perm[i:])   ###insert n\\n            perms = new_perms\\n        return perms"
		},
		{
			"lc_ans_id":"18255",
			"view":"16105",
			"top":"3",
			"title":"Share my short iterative JAVA solution",
			"vote":"55",
			"content":"    public List<List<Integer>> permute(int[] num) {\\n        LinkedList<List<Integer>> res = new LinkedList<List<Integer>>();\\n        res.add(new ArrayList<Integer>());\\n        for (int n : num) {\\n            int size = res.size();\\n            for (; size > 0; size--) {\\n                List<Integer> r = res.pollFirst();\\n                for (int i = 0; i <= r.size(); i++) {\\n                    List<Integer> t = new ArrayList<Integer>(r);\\n                    t.add(i, n);\\n                    res.add(t);\\n                }\\n            }\\n        }\\n        return res;\\n    }"
		},
		{
			"lc_ans_id":"18241",
			"view":"9045",
			"top":"4",
			"title":"One-Liners in Python",
			"vote":"46",
			"content":"**Solution 1: *Recursive, take any number as first***\\n\\nTake any number as the first number and append any permutation of the other numbers.\\n\\n    def permute(self, nums):\\n        return [[n] + p\\n                for i, n in enumerate(nums)\\n                for p in self.permute(nums[:i] + nums[i+1:])] or [[]]\\n\\n---\\n\\n**Solution 2: *Recursive, insert first number anywhere***\\n\\nInsert the first number anywhere in any permutation of the remaining numbers.\\n\\n    def permute(self, nums):\\n        return nums and [p[:i] + [nums[0]] + p[i:]\\n                         for p in self.permute(nums[1:])\\n                         for i in range(len(nums))] or [[]]\\n\\n---\\n\\n**Solution 3: *Reduce, insert next number anywhere***\\n\\nUse `reduce` to insert the next number anywhere in the already built permutations.\\n\\n    def permute(self, nums):\\n        return reduce(lambda P, n: [p[:i] + [n] + p[i:]\\n                                    for p in P for i in range(len(p)+1)],\\n                      nums, [[]])\\n\\n---\\n\\n**Solution 4: *Using the library***\\n\\n    def permute(self, nums):\\n        return list(itertools.permutations(nums))\\n\\nThat returns a list of tuples, but the OJ accepts it anyway. If needed, I could easily turn it into a list of lists:\\n\\n    def permute(self, nums):\\n        return map(list, itertools.permutations(nums))"
		},
		{
			"lc_ans_id":"18436",
			"view":"10625",
			"top":"5",
			"title":"Java Clean Code - Two recursive solutions",
			"vote":"42",
			"content":"**Bottom up? approach - 280ms**\\n\\n    public class Solution {\\n       public List<List<Integer>> permute(int[] nums) {\\n    \\t\\tList<List<Integer>> permutations = new ArrayList<>();\\n    \\t\\tif (nums.length == 0) {\\n    \\t\\t\\treturn permutations;\\n    \\t\\t}\\n    \\n    \\t\\tcollectPermutations(nums, 0, new ArrayList<>(), permutations);\\n    \\t\\treturn permutations;\\n        }\\n    \\n    \\tprivate void collectPermutations(int[] nums, int start, List<Integer> permutation,\\n     \\t\\t\\tList<List<Integer>>  permutations) {\\n    \\t\\t\\n    \\t\\tif (permutation.size() == nums.length) {\\n    \\t\\t\\tpermutations.add(permutation);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\n    \\t\\tfor (int i = 0; i <= permutation.size(); i++) {\\n    \\t\\t\\tList<Integer> newPermutation = new ArrayList<>(permutation);\\n    \\t\\t\\tnewPermutation.add(i, nums[start]);\\n    \\t\\t\\tcollectPermutations(nums, start + 1, newPermutation, permutations);\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n***Code flow***\\n\\n    nums = 1,2,3\\n\\n    start = 0, permutation = []\\n    i = 0, newPermutation = [1]\\n    \\tstart = 1, permutation = [1]\\n    \\ti = 0, newPermutation = [2, 1]\\n    \\t\\tstart = 2, permutation = [2, 1]\\n    \\t\\ti = 0, newPermutation = [3, 2, 1]\\n    \\t\\ti = 1, newPermutation = [2, 3, 1]\\n    \\t\\ti = 2, newPermutation = [2, 1, 3]\\n    \\ti = 1, newPermutation = [1, 2]\\n    \\t\\tstart = 2, permutation = [1, 2]\\n    \\t\\ti = 0, newPermutation = [3, 1, 2]\\n    \\t\\ti = 1, newPermutation = [1, 3, 2]\\n    \\t\\ti = 2, newPermutation = [1, 2, 3]\\n\\n**Base case and build approach - 524ms**\\n\\n    public class Solution {\\n       public List<List<Integer>> permute(int[] nums) {\\n    \\t\\treturn permute(Arrays.stream(nums).boxed().collect(Collectors.toList()));\\n       }\\n    \\n    \\tprivate List<List<Integer>> permute(List<Integer> nums) {\\n    \\t\\tList<List<Integer>> permutations = new ArrayList<>();\\n    \\t\\tif (nums.size() == 0) {\\n    \\t\\t\\treturn permutations;\\n    \\t\\t}\\n    \\t\\tif (nums.size() == 1) {\\n    \\t\\t\\tList<Integer> permutation = new ArrayList<>();\\n    \\t\\t\\tpermutation.add(nums.get(0));\\n    \\t\\t\\tpermutations.add(permutation);\\n    \\t\\t\\treturn permutations;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tList<List<Integer>> smallPermutations = permute(nums.subList(1, nums.size()));\\n    \\t\\tint first = nums.get(0);\\n    \\t\\tfor(List<Integer> permutation : smallPermutations) {\\n    \\t\\t\\tfor (int i = 0; i <= permutation.size(); i++) {\\n    \\t\\t\\t\\tList<Integer> newPermutation = new ArrayList<>(permutation);\\n    \\t\\t\\t\\tnewPermutation.add(i, first);\\n    \\t\\t\\t\\tpermutations.add(newPermutation);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn permutations;\\n    \\t}\\n    }\\n\\n***Code flow***\\n\\n    nums = 1,2,3\\n    \\n    smallPermutations(2, 3)\\n    \\tsmallPermutations(3)\\n    \\t\\treturn [[3]]\\n    \\tfirst = 2\\n     \\t\\tpermutation = [3]\\n    \\t\\t\\ti = 0, newPermutation = [2, 3]\\n    \\t\\t\\ti = 1, newPermutation = [3, 2]\\n    \\treturn [[2, 3], [3, 2]]\\n    first = 1\\n     \\tpermutation = [2, 3]\\n    \\t\\ti = 0, newPermutation = [1, 2, 3]\\n    \\t\\ti = 1, newPermutation = [2, 1, 3]\\n    \\t\\ti = 2, newPermutation = [2, 3, 1]\\n     \\tpermutation = [3, 2]\\n    \\t\\ti = 0, newPermutation = [1, 3, 2]\\n    \\t\\ti = 1, newPermutation = [3, 1, 2]\\n    \\t\\ti = 2, newPermutation = [3, 2, 1]"
		},
		{
			"lc_ans_id":"18296",
			"view":"5497",
			"top":"6",
			"title":"Simple Python solution (DFS).",
			"vote":"39",
			"content":"        \\n    # DFS\\n    def permute(self, nums):\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n        \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            # return # backtracking\\n        for i in xrange(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)"
		},
		{
			"lc_ans_id":"18462",
			"view":"6355",
			"top":"7",
			"title":"Share my three different solutions",
			"vote":"27",
			"content":"    // method 1: standard backtracing solution\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        permutation(num, 0, ans);\\n        return ans;\\n    }\\n    \\n    void permutation(vector<int> &num, int begin, vector<vector<int> > &ans) {\\n        if (begin >= num.size()) {\\n            ans.push_back(num);\\n            return;\\n        }\\n        \\n        // every number chosen to be the begin once\\n        for (int i = begin; i < num.size(); ++i) {\\n            swap(num[begin], num[i]);\\n            permutation(num, begin+1, ans);\\n            swap(num[begin], num[i]);\\n        }\\n    }\\n    \\n    // method 2: using next_permutation to iterate all the permutaions\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        sort(num.begin(), num.end());\\n        ans.push_back(num);\\n        \\n        while(next_permutation(num.begin(), num.end()))\\n            ans.push_back(num);\\n        return ans;\\n    }\\n    \\n    // method 3: recursive dfs\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        dfs(num, ans);\\n        return ans;\\n    }\\n    \\n    void dfs(vector<int> &num, vector<vector<int>> &ans) {\\n        if (num.size() == 1) {\\n            vector<int> tmp(num.begin(), num.end());\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        \\n        vector<vector<int> > ans1;\\n        vector<int> num1(num.begin()+1, num.end());\\n        dfs(num1, ans);\\n        \\n        for(int i = 0; i < ans.size(); ++i) {\\n            for(int j = 0; j <= ans[i].size(); ++j) {\\n                vector<int> tmp = ans[i];\\n                tmp.insert(tmp.begin()+j, num[0]);\\n                ans1.push_back(tmp);\\n            }\\n        }\\n        \\n        ans = ans1;\\n    }"
		},
		{
			"lc_ans_id":"18360",
			"view":"2425",
			"top":"8",
			"title":"Easy solution using code in nextPermutation (can be used in Permutations II without modification)",
			"vote":"15",
			"content":"Well, have you solved the [nextPermutation][1] problem? If so, your code can be used in this problem. The idea is fairly simple: \\n\\n 1. add `nums` to `res`; \\n 2. generate the next permutation of `nums` using `nextPermutation()`, and add it to `res`;\\n 3. repeat 2 until the next permutation of `nums` returns to the original configuration.\\n \\nThe code is as follows. \\n\\nA final note, the following code can be applied to the problem of [Permutations II][2] without any modification since the cases of duplicates have already been handled in `nextPermutation()`. If you want to learn more about `nextPermutation()`, please visit [this solution][3].\\n\\n        bool nextPermutation(vector<int>& nums) {\\n            int k = -1;\\n            for (int i = nums.size() - 2; i >= 0; i--) {\\n                if (nums[i] < nums[i + 1]) {\\n                    k = i;\\n                    break;\\n                }\\n            }\\n            if (k == -1) {\\n                reverse(nums.begin(), nums.end());\\n                return false;\\n            }\\n            int l = -1;\\n            for (int i = nums.size() - 1; i > k; i--) {\\n                if (nums[i] > nums[k]) {\\n                    l = i;\\n                    break;\\n                }\\n            }\\n            swap(nums[k], nums[l]);\\n            reverse(nums.begin() + k + 1, nums.end());\\n            return true;\\n        }\\n        vector<vector<int>> permute(vector<int>& nums) {\\n            vector<vector<int> > res;\\n            sort(nums.begin(), nums.end());\\n            res.push_back(nums);\\n            while (nextPermutation(nums))\\n                res.push_back(nums);\\n            return res;\\n        }\\n\\n\\n  [1]: https://leetcode.com/problems/next-permutation/\\n  [2]: https://leetcode.com/problems/permutations-ii/\\n  [3]: https://leetcode.com/discuss/38247/classic-simple-algorithm-from-wikipedia-implementation-12ms"
		},
		{
			"lc_ans_id":"18470",
			"view":"2862",
			"top":"9",
			"title":"My Java Accepted solution without additional space",
			"vote":"13",
			"content":"    public class Solution {\\n        public List<List<Integer>> permute(int[] num) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            permute(result, num, 0);\\n            return result;\\n        }\\n        \\n        private void permute(List<List<Integer>> result, int[] array, int start) {\\n    \\t\\tif (start >= array.length) {\\n    \\t\\t\\tList<Integer> current = new ArrayList<Integer>();\\n    \\t\\t\\tfor (int a : array) {\\n    \\t\\t\\t    current.add(a);\\n    \\t\\t\\t}\\n    \\t\\t\\tresult.add(current);\\n    \\t\\t} else {\\n    \\t\\t\\tfor (int i=start; i<array.length; i++) {\\n    \\t\\t\\t\\tswap(array, start, i);\\n    \\t\\t\\t\\tpermute(result, array, start+1);\\n    \\t\\t\\t\\tswap(array, start, i);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tprivate void swap(int[] array, int i, int j) {\\n    \\t\\tint temp = array[i];\\n    \\t\\tarray[i] = array[j];\\n    \\t\\tarray[j] = temp;\\n    \\t}\\n    }\\n\\nI enumerate all the permutations in a generative way, the idea is that, at each position, I specify the element by swapping with values with a larger index. The value at the first position can swap with position 1,2,...,n-1, after each swap, I will do a recursion for the rest of the array. \\n\\nThe problem is that with this approach, the permutations may be out of order."
		}
	],
	"id":"46",
	"title":"Permutations",
	"content":"<p>\r\nGiven a collection of <b>distinct</b> numbers, return all possible permutations.\r\n</p>\r\n\r\n<p>\r\nFor example,<br />\r\n<code>[1,2,3]</code> have the following permutations:<br />\r\n<pre>\r\n[\r\n  [1,2,3],\r\n  [1,3,2],\r\n  [2,1,3],\r\n  [2,3,1],\r\n  [3,1,2],\r\n  [3,2,1]\r\n]\r\n</pre>\r\n</p>",
	"frequency":"513",
	"ac_num":"212700"
}