{
	"difficulty":"3",
	"submit_num":"16831",
	"show_id":"471",
	"leetcode_id":"471",
	"answers":[
		{
			"lc_ans_id":"95599",
			"view":"11819",
			"top":"0",
			"title":"Accepted Solution in Java",
			"vote":"64",
			"content":"This is the first question I have answered in Leetcode. I hope you guys will like my solution. The approach here is simple. We will form 2-D array of Strings. \\ndp[i][j] = string from index i to index j in encoded form.\\n\\nWe can write the following formula as:-\\ndp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j]) or if we can find some pattern in string from i to j which will result in more less length.\\n\\nTime Complexity = O(n^3)\\n\\n\\npublic class Solution {\\n\\n     public String encode(String s) {\\n        String[][] dp = new String[s.length()][s.length()];\\n        \\n        for(int l=0;l<s.length();l++) {\\n            for(int i=0;i<s.length()-l;i++) {\\n                int j = i+l;\\n                String substr = s.substring(i, j+1);\\n                // Checking if string length < 5. In that case, we know that encoding will not help.\\n                if(j - i < 4) {\\n                    dp[i][j] = substr;\\n                } else {\\n                    dp[i][j] = substr;\\n                    // Loop for trying all results that we get after dividing the strings into 2 and combine the   results of 2 substrings\\n                    for(int k = i; k<j;k++) {\\n                        if((dp[i][k] + dp[k+1][j]).length() < dp[i][j].length()){\\n                            dp[i][j] = dp[i][k] + dp[k+1][j];\\n                        }\\n                    }\\n                    \\n                    // Loop for checking if string can itself found some pattern in it which could be repeated.\\n                    for(int k=0;k<substr.length();k++) {\\n                        String repeatStr = substr.substring(0, k+1);\\n                        if(repeatStr != null \\n                           && substr.length()%repeatStr.length() == 0 \\n                           && substr.replaceAll(repeatStr, \"\").length() == 0) {\\n                              String ss = substr.length()/repeatStr.length() + \"[\" + dp[i][i+k] + \"]\";\\n                              if(ss.length() < dp[i][j].length()) {\\n                                dp[i][j] = ss;\\n                              }\\n                         }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][s.length()-1];\\n    }\\n    }"
		},
		{
			"lc_ans_id":"95602",
			"view":"4046",
			"top":"1",
			"title":"Short Python",
			"vote":"20",
			"content":"Either don't encode `s` at all, or encode it as **one** part `k[...]` or encode it as **multiple** parts (in which case we can somewhere split it into two subproblems). Whatever is shortest. Uses @rsrs3's nice [trick](https://discuss.leetcode.com/topic/68206/easy-python-solution-with-explaination) of searching `s` in `s + s`.\\n\\n    def encode(self, s, memo={}):\\n        if s not in memo:\\n            n = len(s)\\n            i = (s + s).find(s, 1)\\n            one = '%d[%s]' % (n / i, self.encode(s[:i])) if i < n else s\\n            multi = [self.encode(s[:i]) + self.encode(s[i:]) for i in xrange(1, n)]\\n            memo[s] = min([s, one] + multi, key=len)\\n        return memo[s]"
		},
		{
			"lc_ans_id":"95605",
			"view":"4574",
			"top":"2",
			"title":"Easy to understand C++ O(n^3) solution",
			"vote":"14",
			"content":"3 for loop, so complexity O(n^3), bottom up DP with step goes from 1 to n, and for each step calculate all start and end locations. Use the collapse idea from [another solution](https://discuss.leetcode.com/topic/71442/short-python).\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<string>> dp;\\npublic:\\n\\tstring collapse(string& s, int i, int j) {\\n\\t    string temp = s.substr(i, j - i + 1);\\n\\t\\tauto pos = (temp+temp).find(temp, 1);\\n\\t\\tif (pos >= temp.size()) {\\n\\t\\t    return temp;\\n\\t\\t}\\n\\t\\treturn to_string(temp.size()/pos) + '['+ dp[i][i+pos-1]+']';\\n\\t}\\n\\n\\tstring encode(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tdp = vector<vector<string>>(n, vector<string>(n, \"\"));\\n\\t\\tfor (int step = 1; step <= n; step++) {\\n\\t\\t\\tfor (int i = 0; i + step - 1 < n; i++) {\\n\\t\\t\\t\\tint j = i + step - 1;\\n\\t\\t\\t\\tdp[i][j] = s.substr(i, step);\\n\\t\\t\\t\\tfor (int k = i; k < j; k++) {\\n\\t\\t\\t\\t\\tauto left = dp[i][k];\\n\\t\\t\\t\\t\\tauto right = dp[k + 1][j];\\n\\t\\t\\t\\t\\tif (left.size() + right.size() < dp[i][j].size()) {\\n\\t\\t\\t\\t\\t\\tdp[i][j] = left + right;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstring replace = collapse(s, i, j);\\n\\t\\t\\t\\tif (replace.size() < dp[i][j].size()) {\\n\\t\\t\\t\\t\\tdp[i][j] = replace;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[0][n - 1];\\n\\t}\\n};\\n```"
		},
		{
			"lc_ans_id":"95600",
			"view":"1371",
			"top":"3",
			"title":"Java hashmap O(n^2) solution beats 98%",
			"vote":"5",
			"content":"The basic idea is use an array of hashmap to record which substring repeated how many time up until current index, and another String array record the longest repeated substring up until current index. Then start from the end build the string and recursively do that for substring. Also, we have a global hashmap to record computed results for better performance. There are some edge cases need to be considered: \\n1. \"abab\" should not replace \"ab\" as the longest repeated substring\\n2. If there is an overlap for two different repeated substring, you should choose the longest one, for example \"abcdefabcdefffff\", you should let the middle 'f' belong to 'abcdef' instead of 'fffff'.\\n\\n```java\\n        int n = s.length();\\n        HashMap[] reps = new HashMap[n];\\n        String[] words = new String[n];\\n        int bound = -1;\\n        for (int i = 0; i < n; i++) {\\n            reps[i] = new HashMap<String, Integer>();\\n            words[i] = \"\";\\n            for (int j = i; j >= 0; j--) {\\n                String tmp = s.substring(j, i + 1);\\n                if (j > 0 && reps[j - 1].containsKey(tmp)) {\\n                    if (j - 1 > bound || tmp.length() >= words[bound].length()) {\\n                        reps[i].put(tmp, (int)reps[j - 1].get(tmp) + 1);\\n                    } else {\\n                        reps[i].put(tmp, 1);\\n                    }\\n                    if (tmp.split(words[i]).length > 0) {\\n                        words[i] = tmp;\\n                        bound = i;\\n                    }\\n                } else {\\n                    reps[i].put(tmp, 1);\\n                }               \\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (words[i].length() > 0 && words[i].length() * (int)reps[i].get(words[i]) > 4) {\\n                sb.insert(0, (int)reps[i].get(words[i]) + \"[\" + encode(words[i]) + \"]\");\\n                i = i - words[i].length() * (int)reps[i].get(words[i]) + 1;\\n            } else {\\n                sb.insert(0, s.charAt(i));\\n            }\\n        }\\n        \\n        return sb.toString();\\n```"
		},
		{
			"lc_ans_id":"95601",
			"view":"1292",
			"top":"4",
			"title":"Rigorous proof: Why condition \"(s+s).find(s,1) < s.size()\" is equivalent to substring repetition?",
			"vote":"5",
			"content":"Even though many of us use the following smart condition in code to check for substring repetition, I didn't see a rigorous proof. So here is one.\\n\\n**Why condition `(s+s).find(s,1) < s.size()` is equivalent to substring repetition?**\\n\\n**Proof:** Let `N = s.size()` and `L := (s+s).find(s,1)`, actually we can prove that **the following 2 statements are equivalent:**\\n1. `0 < L < N`;\\n2. `N%L == 0` and `s[i] == s[i%L]` is true for any `i` in `[0, N)`. (which means `s.substr(0,L)` is the repetitive substring)\\n\\nConsider function `char f(int i) { return s[i%N]; }`, obviously it has a period `N`.\\n\\n**\"1 => 2\"**: From condition 1, we have for any `i` in `[0,N)`\\n* `s[i] == (s+s)[i+L] == s[(i+L)%N]`, \\nwhich means `L` is also a positive period of function `f`. Note that `N == L*(N/L)+N%L`, so we have\\n* `f(i) == f(i+N) == f(i+L*(N/L)+N%L) == f(i+N%L)`,\\nwhich means `N%L` is also a period of `f`. Note that `N%L < L` but `L := (s+s).find(s,1)` is the minimum positive period of function `f`, so we must have `N%L == 0`. Note that `i == L*(i/L)+i%L`, so we have\\n* `s[i] == f(i) == f(L*(i/L)+i%L) == f(i%L) == s[i%L]`,\\nso condition 2 is obtained.\\n\\n**\"2=>1\"**: If condition 2 holds, for any `i` in `[0,N)`, note that `N%L == 0`, we have\\n* `(s+s)[i+L] == s[(i+L)%N] == s[((i+L)%N)%L] == s[(i+L)%L] == s[i]`,\\nwhich means `(s+s).substr(L,N) == s`, so condition 1 is obtained."
		},
		{
			"lc_ans_id":"95619",
			"view":"1484",
			"top":"5",
			"title":"C++ O(N^3)-time O(N^2)-space solution using memorized dynamic programming with detail explanations",
			"vote":"4",
			"content":"This solution is inspired by @amaximov and @70664914's threads.\\n\\n**General ideas:**\\n\\nWe use a 2-dimesion storage `dp[first][count]` to store the shortest encoded string of `s[first ... first+count-1]`. Therefore, our ultimate goal is to find `dp[0][N]`, where `N` is the length of `s`.\\n\\nFor any `first` and `count`, `dp[first][count]` must be one of the following two cases:\\n\\n\\n* *Case 1:* `dp[first][count]` is in the form of `k[***]`. In this case, `dp[first][count]` can be generated by repeating a substring.\\n\\n* *Case 2:* `dp[first][count]` is NOT in the form of `k[***]`. In this case, `dp[first][count]` can be generated by concatenating two substrings. Let the length of the two substrings be `count1` and `count - count1`, we have\\n\\n    dp[first][count] = dp[first][count1] + dp[first+count1][count - count1]\\n\\nDue to the analysis of Case 2, in order to calculate our ultimate goal `dp[0][N]`, we may need to use `dp[first][count]` (`0<=first<N`, `1<=count<=N-first`). When using these values, we use memorized dynamic programming.\\n\\n* If `dp[first][count]` has been not yet calculated before, it equals the default value (i.e. the empty string). In this case, we calculate `dp[first][count]` accordingly.\\n* If `dp[first][count]` has been calcuated before, it does not equal the default value. In this case, we do not need to calculate `dp[first][count]`.\\n\\n\\n**Complexity**\\n\\n*Time:* O(N^3)\\nupdate each value of `dp[first][count]` require at most O(N) time.\\nThere are O(N^2) such values.\\nSo overall time complexity is O(N^3).\\n\\n*Space:* O(N^2)\\nThe space of `dp[][]` is O(N^2).\\n\\n**Code (C++):**\\n\\n\\n\\tclass Solution {\\n\\n\\t\\tstring memorizedDynamicProgram(vector<vector<string>> & dp, \\n\\t\\t\\tconst string & s, int first, int count) {\\n\\n\\t\\t\\t// If dp[first][count] has been calculated,\\n\\t\\t\\t// we do not need to calculate any more.\\n\\t\\t\\tif (!dp[first][count].empty()) {\\n\\t\\t\\t\\treturn dp[first][count];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If dp[first][count] has not been calculated,\\n\\t\\t\\t// we calculate it now.\\n\\n\\t\\t\\t// default value: the raw string\\n\\t\\t\\tdp[first][count] = s.substr(first, count);\\n\\n\\t\\t\\t// test the repetitive pattern of length atomLength\\n\\t\\t\\tfor (int atomLength = 1; atomLength < count; ++atomLength){\\n\\t\\t\\t\\tif (count % atomLength == 0) {\\n\\t\\t\\t\\t\\tfor (int repeat = 1; repeat < count / atomLength; ++repeat) {\\n\\t\\t\\t\\t\\t\\tif (s.substr(first, atomLength) != s.substr(first + repeat*atomLength, atomLength)) {\\n\\t\\t\\t\\t\\t\\t\\tgoto UPDATE_COMPLETE;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Now we find the repetitive pattern\\n\\t\\t\\t\\t\\tint k = count / atomLength; // the occurance number of repetitive pattern\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Update its components (only dp once to avoid duplication)\\n\\t\\t\\t\\t\\tmemorizedDynamicProgram(dp, s, first, atomLength); // update[first][atomLength]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor (int repeat = 1; repeat < count / atomLength; ++repeat) {\\n\\t\\t\\t\\t\\t\\tdp[first + repeat * atomLength][atomLength] = dp[first][atomLength];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// try to update dp[first][count]\\n\\t\\t\\t\\t\\tif (dp[first][count].size() > to_string(k).size() + 2 + dp[first][atomLength].size()) {\\n\\t\\t\\t\\t\\t\\tdp[first][count] = to_string(k) + \"[\" + dp[first][atomLength] + \"]\";\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tUPDATE_COMPLETE:\\n\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// concatenate two strings, whose length are count1 and count-count1 respectively\\n\\t\\t\\tfor (int count1 = 1; count1 < count; ++count1) {\\n\\t\\t\\t\\tif (dp[first][count].size() > dp[first][count1].size() + dp[first + count1][count - count1].size()) {\\n\\t\\t\\t\\t\\tdp[first][count] = dp[first][count1] + dp[first + count1][count - count1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[first][count];\\n\\t\\t}\\n\\n\\tpublic:\\n\\t\\tstring encode(string s) {\\n\\t\\t\\tint n = s.size();\\n\\n\\t\\t\\tvector<vector<string>> dp(n, vector<string>(n + 1)); \\n\\t\\t\\t\\t\\t// (first, count) -> optimal string\\n\\n\\t\\t\\tmemorizedDynamicProgram(dp, s, 0, n);\\n\\t\\t\\treturn dp[0][n];\\n\\t\\t}\\n\\t};"
		},
		{
			"lc_ans_id":"95617",
			"view":"215",
			"top":"6",
			"title":"Short C++ DFS+MEMORIZATION 26ms",
			"vote":"3",
			"content":"```\\nclass Solution {\\n    int numRepetition(string &s, string &t) {\\n        int cnt=0,i=0;\\n        while(i<s.length()) {\\n            if(s.substr(i,t.length())!=t) break;\\n            cnt++;\\n            i+=t.length();\\n        }\\n        return cnt;\\n    }\\n    string dfs(string s, unordered_map<string,string> &m) {\\n        if(s.length()<5) return s;\\n        if(m.count(s)) return m[s];\\n        string res = s;\\n        for(int i=0;i<s.length();i++) {\\n            string s1 = s.substr(0,i+1);\\n            int cnt = numRepetition(s,s1);\\n            string t;\\n            for(int k=1;k<=cnt;k++) {\\n                if(k==1) t=s1+dfs(s.substr(i+1),m);\\n                else t = to_string(k)+\"[\"+dfs(s1,m)+\"]\"+dfs(s.substr(k*s1.length()),m);\\n                if(t.length()<res.length()) res=t;            \\n            }\\n        }\\n        m[s]=res;\\n        return res;        \\n    }\\npublic:\\n    string encode(string s) {\\n        unordered_map<string,string> m;\\n        return dfs(s,m);\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"95630",
			"view":"689",
			"top":"7",
			"title":"Easy dynamic programming solution with explained base case and recursion",
			"vote":"3",
			"content":"Inspired by a neat technique for finding self-repeating pattern (https://discuss.leetcode.com/topic/71442/short-python).\\n\\n1. DP for substring. For convenience, just use substring as key of memoization. strEncoding[str] = shortest encoding of str.\\n\\n2. Base case (in fact this 'base' is still recursive):\\nself-repeating: repeatingIdx = (s + s).find(s, 1), repeatingIdx < len(s). \\nFind index of s in s + s starting from index 1. \\nE.g., 'abbbabbbcabbbabbbc' return 9, return 2[strEncoding(abbbabbbc)].\\n\\n3. Recursion by Iterating string splitting point:\\nE.g., 'abbbabbbc' -> strEncoding(abbbabbb) + strEncoding(c)\\n\\n```\\nclass Solution(object):\\n    def encode(self, s):\\n        strEncoding = dict()\\n        return self.getEncoding(s, strEncoding)\\n\\n    def getEncoding(self, s, strEncoding):\\n        encoding = s\\n        # Base case: self-repeating, such as 'abbbabbbcabbbabbbc' -> 2[strEncoding(abbbabbbc)]\\n        # Find index of s in s + s starting from index 1. \\n        # E.g., 'abbbabbbcabbbabbbc' return 9. 'abcabcabcabc' return 3.\\n        repeatingIdx = (s + s).find(s, 1)\\n        if repeatingIdx < len(s):\\n            repeatingSubstr = s[: repeatingIdx]\\n            numRepeating = len(s) / len(repeatingSubstr)\\n            if repeatingSubstr not in strEncoding:\\n                strEncoding[repeatingSubstr] = self.getEncoding(repeatingSubstr, strEncoding)\\n            repeatingSubstrEncoding = strEncoding[repeatingSubstr]\\n            candidateEncoding = str(numRepeating) + '[' + repeatingSubstrEncoding + ']'\\n            if len(candidateEncoding) < len(encoding):\\n                encoding = candidateEncoding\\n        # If not self-repating, split string into substrings, \\n        # such as 'abbbabbbc' -> strEncoding(abbbabbb) + strEncoding(c)\\n        else:\\n            for i in range(1, len(s)):\\n                leftSubstr = s[: i]\\n                rightSubstr = s[i :]\\n                if leftSubstr not in strEncoding:\\n                    strEncoding[leftSubstr] = self.getEncoding(leftSubstr, strEncoding)\\n                leftSubstrEncoding = strEncoding[leftSubstr]\\n                if rightSubstr not in strEncoding:\\n                    strEncoding[rightSubstr] = self.getEncoding(rightSubstr, strEncoding)\\n                rightSubstrEncoding = strEncoding[rightSubstr]\\n                if len(leftSubstrEncoding) + len(rightSubstrEncoding) < len(encoding):\\n                    encoding = leftSubstrEncoding + rightSubstrEncoding\\n        return encoding\\n```"
		},
		{
			"lc_ans_id":"95609",
			"view":"1766",
			"top":"8",
			"title":"C++ 89ms DP memoization O(n^3.5)",
			"vote":"3",
			"content":"Inspired by @amaximov\\n```DP[i][j]``` best result that begins with index i of length j\\n```mDP(DP,s,i,j)``` memoization DP, calculate ```DP[i][j]```\\nIDEA: \\nEach optimal ```DP[i][j]``` is either: \\n1: totally divided by some substring; (first loop, ```O(n^(1.5))``` thanks to @yaopiupiupiu)\\n2: sum of optimals of two substrings. (second loop, ```O(n)```)\\nIn total, we will only call ```mDP``` ```n^2``` times, so complexity is ```O(n^3.5)```.\\n```\\nclass Solution {\\n\\n    void mDP(vector<vector<string> >& DP,string s,int i, int j){\\n        DP[i][j]=s.substr(i,j);\\n        //first loop\\n        for(int k=1;k<j;k++){\\n            if(j%k==0){\\n                int fine=true;\\n                for(int kk=1;kk<j/k;kk++){\\n                    if(!(s.substr(i,k)==s.substr(i+kk*k,k))){\\n                        fine=false;\\n                        break;\\n                    }\\n                }\\n                if(fine){\\n                    if(DP[i][k].size()==0)mDP(DP,s,i,k);\\n                    for(int kk=1;kk<j/k;kk++)DP[i+kk*k][k]=DP[i][k];\\n                    if(DP[i][j].size()>to_string(j/k).size()+2+DP[i][k].size()){\\n                        DP[i][j]=to_string(j/k)+\"[\"+DP[i][k]+\"]\";\\n                    }\\n                }\\n            }\\n        }\\n        //second loop\\n        for(int k=1;k<j;k++){\\n            if(DP[i][k].size()==0)mDP(DP,s,i,k);\\n            if(DP[i+k][j-k].size()==0)mDP(DP,s,i+k,j-k);\\n            if(DP[i][j].size()>DP[i][k].size()+DP[i+k][j-k].size()){\\n                DP[i][j]=DP[i][k]+DP[i+k][j-k];\\n            }\\n        }\\n    }\\n\\npublic:\\n    string encode(string s) {\\n        int l=s.size();\\n        vector<vector<string> > DP(l,*new vector<string>(l+1,\"\"));\\n        mDP(DP,s,0,l);\\n        return DP[0][l];\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"95610",
			"view":"363",
			"top":"9",
			"title":"Recursive Java solution with memoization, 45 msecs",
			"vote":"2",
			"content":"    static Map<String, String> prevResults = new HashMap<>();\\n    public String encode(String s) {\\n        if (s == null || s.length() < 5) {\\n            return s;\\n        }\\n        if (prevResults.containsKey(s)) {\\n            return prevResults.get(s);\\n        }\\n        int strlen = s.length();\\n        int minLength = Integer.MAX_VALUE;\\n        String choosenString = s;\\n        for (int i = 1; i < s.length() / 2 + 1; i++) {\\n            String encodedString = s;\\n            // split the string at index i into 2 strings\\n            String leftStr = s.substring(0, i);\\n            String rightStr = s.substring(i, strlen);\\n            int repeatCounter = findPrefixRepetitions(leftStr, rightStr);\\n            if (repeatCounter > 0) {\\n                encodedString = \"\" + (repeatCounter + 1) + '[' + encode(leftStr) + ']' + encode(rightStr.substring(repeatCounter * leftStr.length()));\\n            }\\n            String encodedString2 = encode(leftStr) + encode(rightStr);\\n            if (encodedString2.length() < encodedString.length()) {\\n                encodedString = encodedString2;\\n            }\\n            if (encodedString.length() < strlen) { \\n                if (minLength > encodedString.length()) {\\n                    choosenString = encodedString;\\n                    minLength = encodedString.length();\\n                }\\n            }\\n        }\\n        prevResults.put(s, choosenString);\\n        return choosenString;\\n    }\\n    \\n    private int findPrefixRepetitions(String prefix, String str) {\\n        int repeatCounter = 0;\\n        int startIndex = 0;\\n        do {\\n            int prefixIndex = str.indexOf(prefix, startIndex);\\n            if (prefixIndex != startIndex) {\\n                break;\\n            }\\n            repeatCounter++;\\n            startIndex = prefixIndex + prefix.length();\\n        } while (startIndex < str.length());\\n        return repeatCounter;\\n    }\\nThis solution's complexity is not clear to me (suspected to be exponential) but it passes all tests. It uses recursion with memoization instead of dynamic programming and surprisingly beats in time many dynamic programming solutions."
		}
	],
	"id":"464",
	"title":"Encode String with Shortest Length",
	"content":"<p>Given a <b>non-empty</b> string, encode the string such that its encoded length is the shortest.</p>\r\n\r\n<p>\r\nThe encoding rule is: <code>k[encoded_string]</code>, where the <i>encoded_string</i> inside the square brackets is being repeated exactly <i>k</i> times.</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><i>k</i> will be a positive integer and encoded string will not be empty or have extra space.</li>\r\n<li>You may assume that the input string contains only lowercase English letters. The string's length is at most 160.</li>\r\n<li>If an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them is fine.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Example 1:</b>\r\n<pre>\r\nInput: \"aaa\"\r\nOutput: \"aaa\"\r\nExplanation: There is no way to encode it such that it is shorter than the input string, so we do not encode it.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b>\r\n<pre>\r\nInput: \"aaaaa\"\r\nOutput: \"5[a]\"\r\nExplanation: \"5[a]\" is shorter than \"aaaaa\" by 1 character.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b>\r\n<pre>\r\nInput: \"aaaaaaaaaa\"\r\nOutput: \"10[a]\"\r\nExplanation: \"a9[a]\" or \"9[a]a\" are also valid solutions, both of them have the same length = 5, which is the same as \"10[a]\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 4:</b>\r\n<pre>\r\nInput: \"aabcaabcd\"\r\nOutput: \"2[aabc]d\"\r\nExplanation: \"aabc\" occurs twice, so one answer can be \"2[aabc]d\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 5:</b>\r\n<pre>\r\nInput: \"abbbabbbcabbbabbbc\"\r\nOutput: \"2[2[abbb]c]\"\r\nExplanation: \"abbbabbbc\" occurs twice, but \"abbbabbbc\" can also be encoded to \"2[abbb]c\", so one answer can be \"2[2[abbb]c]\".\r\n</pre>\r\n</p>",
	"frequency":"52",
	"ac_num":"7255"
}