{
	"difficulty":"2",
	"submit_num":"39373",
	"show_id":"473",
	"leetcode_id":"473",
	"answers":[
		{
			"lc_ans_id":"95729",
			"view":"13999",
			"top":"0",
			"title":"Java DFS Solution with Explanation",
			"vote":"43",
			"content":"According to https://en.wikipedia.org/wiki/Partition_problem, the partition problem (or number partitioning) is the task of deciding whether a given multiset ```S``` of positive integers can be partitioned into two subsets ```S1``` and ```S2``` such that the sum of the numbers in ```S1``` equals the sum of the numbers in ```S2```. The partition problem is ```NP-complete```.\\n\\nWhen I trying to think how to apply dynamic programming solution of above problem to this one (difference is divid ```S``` into 4 subsets), I took another look at the constraints of the problem:\\nThe length sum of the given matchsticks is in the range of ```0``` to ```10^9```.\\nThe length of the given matchstick array will not exceed ```15```.\\n\\nSounds like the input will not be very large... Then why not just do DFS? In fact, DFS solution passed judges.\\n\\nAnyone solved this problem by using DP? Please let me know :)\\n\\n```\\npublic class Solution {\\n    public boolean makesquare(int[] nums) {\\n    \\tif (nums == null || nums.length < 4) return false;\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        if (sum % 4 != 0) return false;\\n        \\n    \\treturn dfs(nums, new int[4], 0, sum / 4);\\n    }\\n    \\n    private boolean dfs(int[] nums, int[] sums, int index, int target) {\\n    \\tif (index == nums.length) {\\n    \\t    if (sums[0] == target && sums[1] == target && sums[2] == target) {\\n    \\t\\treturn true;\\n    \\t    }\\n    \\t    return false;\\n    \\t}\\n    \\t\\n    \\tfor (int i = 0; i < 4; i++) {\\n    \\t    if (sums[i] + nums[index] > target) continue;\\n    \\t    sums[i] += nums[index];\\n            if (dfs(nums, sums, index + 1, target)) return true;\\n    \\t    sums[i] -= nums[index];\\n    \\t}\\n    \\t\\n    \\treturn false;\\n    }\\n}\\n```\\n```Updates on 12/19/2016``` Thanks @benjamin19890721 for pointing out a very good optimization: Sorting the input array ```DESC``` will make the DFS process run much faster. Reason behind this is we always try to put the next matchstick in the first subset. If there is no solution, trying a longer matchstick first will get to negative conclusion earlier. Following is the updated code. Runtime is improved from more than 1000ms to around 40ms. A big improvement.\\n```\\npublic class Solution {\\n    public boolean makesquare(int[] nums) {\\n    \\tif (nums == null || nums.length < 4) return false;\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        if (sum % 4 != 0) return false;\\n        \\n        Arrays.sort(nums);\\n        reverse(nums);\\n        \\n    \\treturn dfs(nums, new int[4], 0, sum / 4);\\n    }\\n    \\n    private boolean dfs(int[] nums, int[] sums, int index, int target) {\\n    \\tif (index == nums.length) {\\n    \\t    if (sums[0] == target && sums[1] == target && sums[2] == target) {\\n    \\t\\treturn true;\\n    \\t    }\\n    \\t    return false;\\n    \\t}\\n    \\t\\n    \\tfor (int i = 0; i < 4; i++) {\\n    \\t    if (sums[i] + nums[index] > target) continue;\\n    \\t    sums[i] += nums[index];\\n            if (dfs(nums, sums, index + 1, target)) return true;\\n    \\t    sums[i] -= nums[index];\\n    \\t}\\n    \\t\\n    \\treturn false;\\n    }\\n    \\n    private void reverse(int[] nums) {\\n        int i = 0, j = nums.length - 1;\\n        while (i < j) {\\n            int temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n            i++; j--;\\n        }\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"95744",
			"view":"3951",
			"top":"1",
			"title":"cpp 6ms solution with DFS",
			"vote":"28",
			"content":"This is a NP problem. Time complexity should be O(4 ^ n), n is the length of array.\\n#### Trivial Solution:\\n```cpp\\nclass Solution {\\n    bool dfs(vector<int> &sidesLength,const vector<int> &matches, int index) {\\n        if (index == matches.size())\\n            return sidesLength[0] == sidesLength[1] && sidesLength[1] == sidesLength[2] && sidesLength[2] == sidesLength[3];\\n        for (int i = 0; i < 4; ++i) {\\n            sidesLength[i] += matches[index];\\n            if (dfs(sidesLength, matches, index + 1))\\n                return true;\\n            sidesLength[i] -= matches[index];\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        if (nums.empty()) return false;\\n        vector<int> sidesLength(4, 0);\\n        return dfs(sidesLength, nums, 0);\\n    }\\n};\\n```\\nWithout pruning, this solution TLEs at 11th test case.\\n#### First Optimization:\\n>each matchstick must be used exactly one time.\\n\\nThe description says we need to use every single match exactly **once**, so we can get the **length of each side of the square** if there is one.\\nif the current length is larger than target length, we don't need to go any further.\\n```if (sidesLength[i] + matches[index] > target) continue;``` by adding this line of code into dfs function, solution get TLE at 147th test case.\\n#### Second Optimization:\\nAfter reading the description again, I realize that the length of a single match can be very long. If they put long ones after short ones, it will take a long time before my algorithm return false.\\nSo I sort all the matches to avoid the worst case:```sort(nums.begin(), nums.end(), [](const int &l, const int &r){return l > r;});```. After putting this line before my algorithm, solution passed all cases and beats 50% solutions. I saw someone's algorithm is amazingly fast, they even make me reconsider wether the problem is NP or not.\\n#### Third Optimization:\\nBecause their solutions is so fast, I need think about if I can use DP to solve the problem. It turns out that it's still a NP problem, which makes happy again. But I can actually use the concept of DP in optimization: **if I have checked the same length before, why do I need to bother checking again?**\\nAlthough we only have 4 sides in a square, we can still check if we have encountered the same length with the current match. After I add this to my code:\\n```cpp\\nint j = i;\\nwhile (--j >= 0)\\n    if (sidesLength[i] == sidesLength[j]) \\n        break;\\nif (j != -1) continue;\\n```\\n\\nIt passed all test case in 6ms.\\n```cpp\\nclass Solution {\\n    bool dfs(vector<int> &sidesLength,const vector<int> &matches, int index, const int target) {\\n        if (index == matches.size())\\n            return sidesLength[0] == sidesLength[1] && sidesLength[1] == sidesLength[2] && sidesLength[2] == sidesLength[3];\\n        for (int i = 0; i < 4; ++i) {\\n            if (sidesLength[i] + matches[index] > target) // first\\n                continue;\\n            int j = i;\\n            while (--j >= 0) // third\\n                if (sidesLength[i] == sidesLength[j]) \\n                    break;\\n            if (j != -1) continue;\\n            sidesLength[i] += matches[index];\\n            if (dfs(sidesLength, matches, index + 1, target))\\n                return true;\\n            sidesLength[i] -= matches[index];\\n        }\\n        return false;\\n    }\\npublic:\\n    bool makesquare(vector<int>& nums) {\\n        if (nums.size() < 4) return false;\\n        int sum = 0;\\n        for (const int val: nums) {\\n            sum += val;\\n        }\\n        if (sum % 4 != 0) return false;\\n        sort(nums.begin(), nums.end(), [](const int &l, const int &r){return l > r;}); // second\\n        vector<int> sidesLength(4, 0);\\n        return dfs(sidesLength, nums, 0, sum / 4);\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"95752",
			"view":"2447",
			"top":"2",
			"title":"Java DFS solution with various optimizations (sorting, sequential-partition, DP)",
			"vote":"15",
			"content":"As others pointed out, after proper preprocessing, this problem boiled down to a number partitioning problem which is NP-hard. Nevertheless, if the total number of elements is small, a naive DFS solution is possible.\\n\\n---\\n**`I -- Naive DFS`**\\n\\nFor better description of the problem, let's reformulate it in the following symbolic way: \\n\\n**Given an array `nums` with `n` elements, let `T(i, s1, s2, s3, s4)` denote whether we can partition the subarray `nums[0, i]`(both inclusive) into four disjoint groups such that the sum of elements in the `j-th`  group is `sj`, with `j = 1, 2, 3, 4`.**\\n\\nWith this definition, our original problem will be `T(n - 1, side, side, side, side)` where `side` is the side length of the square.\\n\\nTo solve for `T(i, s1, s2, s3, s4)`, note that the last element of the subarray `nums[0, i]` (which is `nums[i]`) must belong to one of the disjoint groups, therefore we have the following recurrence relation:\\n```\\nT(i, s1, s2, s3, s4) = T(i - 1, s1 - nums[i], s2, s3, s4) ||\\n                       T(i - 1, s1, s2 - nums[i], s3, s4) ||\\n                       T(i - 1, s1, s2, s3 - nums[i], s4) ||\\n                       T(i - 1, s1, s2, s3, s4 - nums[i])\\n```\\nThe interpretation is as follows: if `nums[i]` belongs to the `j-th` group, we subtract it from `sj`, then recursively solve for the subproblem with reduced array size and modified group sum. However, we do not know which group it belongs to beforehand, therefore each of the groups will be examined until we either hit the right group or determine that no partition is possible. Also note that if all elements in the input array are positive, an element cannot fall into a group with a group sum smaller than the element itself, i.e., `nums[i]` cannot belong to the `j-th` group if `nums[i] > sj`.\\n\\nThe termination condition for the recursion is when the subarray is empty, i.e., `i = -1`, at which time we will check whether the sum of each group is zero. If so, a partition is found and return true; otherwise no partition is possible and return false.\\n\\nHere is the java program based on the above ideas:\\n\\n```\\npublic boolean makesquare(int[] nums) {\\n    if (nums.length < 4) return false;\\n        \\n    int perimeter = 0;\\n    for (int ele : nums) perimeter += ele;\\n    if (perimeter % 4 != 0) return false;\\n    \\n    int side = perimeter / 4;\\n\\n    return makesquareSub(nums, nums.length - 1, new int[] {side, side, side, side});\\n}\\n\\nprivate boolean makesquareSub(int[] nums, int i, int[] s) {\\n    if (i < 0) return s[0] == 0 && s[1] == 0 && s[2] == 0 && s[3] == 0;\\n        \\n    for (int j = 0; j < s.length; j++) {\\n        if (nums[i] > s[j]) continue;\\n        s[j] -= nums[i];\\n        if (makesquareSub(nums, i - 1, s)) return true;\\n        s[j] += nums[i];\\n    }\\n        \\n    return false;\\n}\\n```\\nWhile accepted, this solution runs rather slowly (~`450ms`). So let's see what optimizations can be done to enhance the time complexity.\\n\\n---\\n**`II -- DFS with sorting`**\\n\\nIn the recurrence relation above, we concluded that if `nums[i] > sj`, it cannot belong to the `j-th` group, which implies we needn't even bother to try that case. This condition is most likely to be met if we always choose the maximum element that is currently available in the subarray. Also note that the order of elements does not matter in the partition of the array. Therefore we can sort the input array in ascending order before rushing into DFS. This reduced the running time sharply to ~`40ms`.\\n```\\npublic boolean makesquare(int[] nums) {\\n    if (nums.length < 4) return false;\\n        \\n    int perimeter = 0;\\n    for (int ele : nums) perimeter += ele;\\n    if (perimeter % 4 != 0) return false;\\n        \\n    Arrays.sort(nums);\\n    int side = perimeter / 4;\\n\\n    return makesquareSub(nums, nums.length - 1, new int[] {side, side, side, side});\\n}\\n    \\nprivate boolean makesquareSub(int[] nums, int i, int[] s) {\\n    if (i < 0) return s[0] == 0 && s[1] == 0 && s[2] == 0 && s[3] == 0;\\n        \\n    for (int j = 0; j < s.length; j++) {\\n        if (nums[i] > s[j]) continue;\\n        s[j] -= nums[i];\\n        if (makesquareSub(nums, i - 1, s)) return true;\\n        s[j] += nums[i];\\n    }\\n        \\n    return false;\\n}\\n```\\n---\\n***Note: It looks like the following solutions based on sequential ideas are not correct. See [oliver_feng's](https://discuss.leetcode.com/topic/72569/java-dfs-solution-with-various-optimizations-sorting-sequential-partition-dp/3) comment below.***\\n\\n~~**`III -- DFS with sequential-partition`**~~\\n\\nSo far, the partitioning of the array is done simultaneously for the four disjoint groups. With the array sorted, it is also possible to break the partitioning process into four sequential parts such that each part will find each of the disjoint groups. (Note: sorting in ascending order is **necessary** now. We have to choose greedily (maximum element available) for each group,  otherwise the total number of valid groups may decrease. Check out the case `[3,3,3,3,1,1,1,1]`.)\\n\\nTo this end, let's define `T(i, sum)` which denotes whether `sum` can be written as the summation of some elements in the subarray `nums[0, i]`, with each element used at most once. If so, a group is found such that the sum of its elements will be `sum`. Without much efforts, we can obtain the following recurrence relation:\\n```\\nT(i, sum) = T(i - 1, sum - nums[i]) || T(i - 1, sum) \\n```\\nThe two cases on the right hand side correspond to whether we choose the last element `nums[i]` to form the sum or not. And again, it cannot be chosen if `nums[i] > sum`.\\n\\nThe termination condition is either `sum = 0` in which case a group is found or `i = -1` in which case no such group exists.\\n\\nSo far everything looks pretty similar to what we have discussed in part `I`. However, a key difference here is now we need to explicitly mark the elements that are chosen to form previous groups since they are no longer available. Some straightforward ways would be using a `boolean array` or an `integer`(and do bit manipulations). Since the elements in the input array are initially positive, it is also possible to mark visited elements by negating their values. \\n\\nHere is the java program for sequential partition, with running time further reduced to ~`15ms`.\\n\\n```\\npublic boolean makesquare(int[] nums) {\\n    if (nums.length < 4) return false;\\n        \\n    int perimeter = 0;\\n    for (int ele : nums) perimeter += ele;\\n    if (perimeter % 4 != 0) return false;\\n        \\n    Arrays.sort(nums);\\n    int side = perimeter / 4;\\n\\n    for (int i = 0; i < 3; i++) {\\n        if (!makesquareSub(nums, nums.length - 1, side)) return false;\\n    }\\n        \\n    return true;\\n}\\n    \\nprivate boolean makesquareSub(int[] nums, int i, int sum) {\\n    if (sum == 0) return true;\\n    if (i < 0) return false;\\n        \\n    if (nums[i] > 0 && nums[i] <= sum) {\\n        nums[i] = -nums[i];\\n        if (makesquareSub(nums, i - 1, sum + nums[i])) return true;\\n        nums[i] = -nums[i];\\n    }\\n        \\n    return makesquareSub(nums, i - 1, sum);\\n}\\n```\\n\\n---\\n~~**`IV -- DFS with DP`**~~\\n\\nFor all solutions above (`T(i, s1, s2, s3, s4)` or `T(i, sum)`), we did not take into account the possibility that there is overlapping among the subproblems.\\n\\nFor `T(i, s1, s2, s3, s4)`, each subproblem is characterized by **five** integers while for `T(i, sum)`, it is **two**. I would say the probability of overlapping subproblems for the former is relatively lower than the latter. So I only implemented DP for the sequential-partition case. However the running time (~`25ms`) did not get further improved, possibly due to the fact that the probability for overlapping subproblems is already rather low (if any) for this case with small number of elements. Not sure if DP will prevail for larger input size though.\\n\\nLast word about the following DP solution: naively we would use an array of HashMap (let's denote it as `map`) to memorize intermediate results, with `i` indexed into the array and `sum` as the key of the corresponding HashMap. However, due to our greedy strategy for finding each group, if two subproblems `T1(i1, sum1)` and `T2(i2, sum2)` have the same sum, i.e., `sum1 = sum2`, then the one with larger index `i` will always be solved before the other. Since `T(i, sum) = true` implies `T(j, sum) = true` with `j >= i`, and `T(i, sum) = false` implies `T(j, sum) = false` with `j <= i`, it is sufficient to use only the `sum` factor to characterize subproblems that yield `false` solution (if any of the subproblem yields true, the recursion will rewind and eventually terminate). Therefore you will see only a HashSet is used in the following implementation.\\n\\n```\\npublic boolean makesquare(int[] nums) {\\n    if (nums.length < 4) return false;\\n        \\n    int perimeter = 0;\\n    for (int ele : nums) perimeter += ele;\\n    if (perimeter % 4 != 0) return false;\\n        \\n    Arrays.sort(nums);\\n    int side = perimeter / 4;\\n        \\n    for (int i = 0; i < 3; i++) {\\n        if (!makesquareSub(nums, nums.length - 1, side, new HashSet<>())) return false;\\n    }\\n    \\n    return true;\\n}\\n    \\nprivate boolean makesquareSub(int[] nums, int i, int sum, Set<Integer> set) {\\n    if (sum == 0) return true;\\n    if (set.contains(sum) || i < 0) return false;\\n    \\n    if (nums[i] > 0 && nums[i] <= sum) {\\n        nums[i] = -nums[i];\\n        if (makesquareSub(nums, i - 1, sum + nums[i], set)) return true;\\n        nums[i] = -nums[i];\\n    }\\n        \\n    if (makesquareSub(nums, i - 1, sum, set)) return true;\\n        \\n    set.add(sum);\\n    return false;\\n}\\n```"
		},
		{
			"lc_ans_id":"95746",
			"view":"2768",
			"top":"3",
			"title":"C++ bit masking + DP solution with detailed comments",
			"vote":"9",
			"content":"This is a solution inspired by a friend who doesn't do leetcode. I am just posting his solution with the best explanation I can give. The bitmasking technique may look sophisticated but the idea is actually pretty straightforward because it uses brute force with some optimizations. A bitmask is used as a representation of a subset. For example if nums = {1,1,2,2,2}, then a bitmask = 01100 represents the subset {1,2}.\\n```\\nbool makesquare(vector<int>& nums) {\\n    int n = nums.size();\\n\\n    long sum = accumulate(nums.begin(), nums.end(), 0l);\\n    if (sum % 4)\\n        return false;\\n    long sideLen = sum / 4;\\n    // need to solve the problem of partitioning nums into four equal subsets each having\\n    // sum equal to sideLen\\n    vector<int> usedMasks;\\n    // validHalfSubsets[i] == true iff the subset represented by bitmask i\\n    // has sum == 2*sideLen, AND the subset represented by i can be further partitioned into\\n    // two equal subsets. See below for how it is used.\\n    vector<bool> validHalfSubsets(1<<n, false);\\n\\n    // E.g., if n = 5, (1 << 5 - 1) = 11111 represents the whole set\\n    int all = (1 << n) - 1;\\n    // go through all possible subsets each represented by a bitmask\\n    for (int mask = 0; mask <= all; mask++) {\\n        long subsetSum = 0;\\n        // calculate the sum of this subset\\n        for (int i = 0; i < 32; i++) {\\n\\t    if ((mask >> i) & 1)\\n\\t\\tsubsetSum += nums[i];\\n        }\\n\\t// if this subset has what we want\\n\\tif (subsetSum == sideLen) {\\n\\t    for (int usedMask : usedMasks) {\\n\\t    // if this mask and usedMask are mutually exclusive\\n\\t        if ((usedMask & mask) == 0) {\\n\\t\\t    // then they form a valid half subset whose sum is 2 * sideLen,\\n                    // that can be further partitioned into two equal subsets (usedMask and mask)\\n\\t\\t    int validHalf = usedMask | mask;\\n\\t\\t    validHalfSubsets[validHalf] = true;\\n\\t\\t    // if in the past we concluded that the other half is also a valid\\n\\t\\t    // half subset, DONE!\\n\\t\\t    if (validHalfSubsets[all ^ validHalf])\\n\\t\\t        return true;\\n\\t        }\\n            }\\n\\t    usedMasks.push_back(mask);\\n        }\\n    }\\n    return false;\\n}\\n```"
		},
		{
			"lc_ans_id":"95764",
			"view":"2455",
			"top":"4",
			"title":"Simple Recursion Java solution. 66ms",
			"vote":"6",
			"content":"Since it is square, the basic idea is get width of each side(total 4 sides) and use recursive way to figure out which group each matchstick belongs. \\n``````\\npublic boolean makesquare(int[] nums) {\\n        Long sum=0l;\\n        for(int x:nums){\\n            sum=sum+x;\\n        }\\n        if(sum%4!=0||nums.length<4) return false;\\n        long width=(sum/4);\\n        Arrays.sort(nums);\\n        long sum1=0,sum2=0,sum3=0,sum4=0;\\n        return helper(nums,nums.length-1,sum1,sum2,sum3,sum4,width);\\n        \\n    }\\n    public boolean helper(int[] a, int i,long sum1,long sum2,long sum3,long sum4, long width){\\n        if(sum1>width||sum2>width||sum3>width||sum4>width) return false;\\n        if(i==-1){\\n            if(sum1==width&&sum2==width&&sum3==width&&sum4==width) return true;\\n            else return false;\\n        }\\n//check a[i]  belonging to side1,side2,side3,side4\\n        return helper(a,i-1,sum1+a[i],sum2,sum3,sum4,width)||\\n        helper(a,i-1,sum1,sum2+a[i],sum3,sum4,width)||\\n        helper(a,i-1,sum1,sum2,sum3+a[i],sum4,width)||\\n        helper(a,i-1,sum1,sum2,sum3,sum4+a[i],width);\\n    }\\n````"
		},
		{
			"lc_ans_id":"95732",
			"view":"1175",
			"top":"5",
			"title":"Python DFS solution",
			"vote":"5",
			"content":"```\\nclass Solution(object):\\n    def makesquare(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(nums, pos, target):\\n            if pos == len(nums): return True\\n            for i in range(4):\\n                if target[i] >= nums[pos]:\\n                    target[i] -= nums[pos]\\n                    if dfs(nums, pos+1, target): return True\\n                    target[i] += nums[pos]\\n            return False\\n        if len(nums) < 4 : return False\\n        numSum = sum(nums)\\n        nums.sort(reverse=True)\\n        if numSum % 4 != 0: return False\\n        target = [numSum/4] * 4;\\n        return dfs(nums,0, target)\\n```"
		},
		{
			"lc_ans_id":"95778",
			"view":"993",
			"top":"6",
			"title":"9ms C++ DFS solution with smallest subsum check (detailed explanation)",
			"vote":"3",
			"content":"The problem is equivalent to ask if we can partition `nums` into 4 subsets such that their subsums will be `s = { sum/4, sum/4, sum/4, sum/4 }`.\\n\\nNote that for a generic subsum combo `s = { s[0], s[1], s[2], s[3] }` in ascending order, we can early terminate the DFS process if it violates the min subsum check:\\n* if `small[i] > s[i]` for any `0 <= i <= 3`, it is impossible to do such partition,\\n\\nwhere `small[i=0:3]` are the 4 smallest subsums of `nums`:\\n* `small[0] = nums[0]`,\\n* `small[1] = nums[1]`,\\n* `small[2] = min(nums[0] + nums[1], nums[2])`,\\n* `small[3] = min(max(nums[0] + nums[1], nums[2]), nums[3])`,\\n\\nwhere `nums[i=0:3]` are 4 smallest numbers in `nums`.\\n\\nFor example, for `nums = [99, 37, 37, 37, 37, 37, 37, 37, 37, 5]` whose `sum = 400`, it is obvious that there is no way to form a square with length `100` since no one can compensate `99` on a side. So after one DFS, we are trying to partition `nums` without `99` to subsums `s = {1, 100, 100, 100}` and this fails the min subsum check because smallest number `5 > 1`.\\n```\\npublic:    \\n    bool makesquare(vector<int>& nums) {\\n      int sum;\\n      if (nums.size() < 4 || (sum = accumulate(nums.begin(), nums.end(), 0))%4) return false;\\n      return sortSmall(nums), dfs(nums.begin(), vector<int>(4,sum/4));\\n    }\\nprivate: // helpers   \\n    // sort nums descendingly and calculate 4 smallest subsums\\n    void sortSmall(vector<int>& nums) {\\n      sort(nums.rbegin(), nums.rend());\\n      small = { *((e=nums.end())-1), *(e-2), min(*(e-1)+*(e-2),*(e-3)), \\n                min(max(*(e-1)+*(e-2),*(e-3)),*(e-4)) };\\n    }\\n\\n    // check if can partition into subsums {s[j]} starting at nums[i]\\n    bool dfs(vector<int>::iterator i, const vector<int>& s) {\\n      if (i == e) return true;\\n      // check min condition\\n      for (int j = 0; j < s.size(); ++j) if (small[j] > s[j]) return false; \\n      for (int j = 0; j < s.size(); ++j) {        \\n        if (s[j] < *i || j && s[j] == s[j-1]) continue;\\n        // build unique valid subsums\\n        vector<int> ss(s); if (!(ss[j] -= *i)) ss.erase(ss.begin()+j);\\n        if (sort(ss.begin(),ss.end()), dfs(i+1, ss)) return true;\\n      }\\n      return false;\\n    }\\n    \\n    vector<int>::iterator e; // end of nums sorted descendingly\\n    vector<int> small = vector<int>(4); // 4 smallest subsums\\n```"
		},
		{
			"lc_ans_id":"95743",
			"view":"762",
			"top":"7",
			"title":"JAVA DFS+DP solution",
			"vote":"3",
			"content":"```\\npublic class Solution {\\n\\tprivate Set<Integer> flags;\\n\\n\\tpublic boolean makesquare(int[] nums) {\\n\\t\\tif (nums.length == 0) return false;\\n\\t\\tint sum = 0;\\n\\t\\tfor (int num : nums) {\\n\\t\\t\\tsum += num;\\n\\t\\t}\\n\\t\\tif (sum % 4 != 0) return false;\\n\\t\\tflags = new HashSet<>();\\n\\n\\t\\tdfs(nums, 0, sum / 4);\\n\\n\\t\\tint len = (int) Math.pow(2, nums.length);\\n\\t\\tboolean[] dp = new boolean[len];\\n\\t\\tdp[0] = true;\\n\\t\\tfor (int num : flags) {\\n\\t\\t\\tfor (int i = dp.length - 1; i >= 0; i--) {\\n\\t\\t\\t\\tif (dp[i] && (num&i)==0) {\\n\\t\\t\\t\\t\\tdp[i | num] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[len - 1];\\n\\t}\\n\\n\\tpublic void dfs(int[] nums, int flag, int sum) {\\n\\t\\tif (sum == 0) {\\n\\t\\t\\tflags.add(flag);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (nums.length == 0) return;\\n\\n\\t\\tif (nums[0] <= sum) {\\n\\t\\t\\tdfs(Arrays.copyOfRange(nums, 1, nums.length), flag | (1 << nums.length - 1), sum - nums[0]);\\n\\t\\t}\\n\\t\\tdfs(Arrays.copyOfRange(nums, 1, nums.length), flag, sum);\\n\\t}\\n}\\n```"
		},
		{
			"lc_ans_id":"95787",
			"view":"1451",
			"top":"8",
			"title":"Python Explanation",
			"vote":"3",
			"content":"If the sum isn't divisible by 4, or if there are less than 4 matchsticks, or if one matchstick is greater than the expected sidelength, then it is impossible.\\n\\nOtherwise, let's see if it is possible to partition the set into 4 equal parts.  We do this by bitmask dp.  Let the i-th position of mask be 1 if we have not used A[i] yet, and let cur represent the length of an unfilled sidelength we have yet to fill.\\n\\nCode:\\n```\\nif len(A) < 4 or sum(A) % 4 or max(A) > sum(A) / 4:\\n  return False\\n\\nT = sum(A) / 4\\nN = len(A)\\nA.sort()\\n\\nmemo = {}\\ndef dp(mask, cur = T):\\n  if (mask, cur) in memo: return memo[mask, cur]\\n  if mask == 0: return cur == 0\\n  if cur == 0: return dp(mask, T)\\n\\n  ans = False\\n  for bit in xrange(N):\\n    if mask & (1 << bit):\\n      if A[bit] > cur:\\n        break\\n      if dp(mask ^ (1 << bit), cur - A[bit]):\\n        ans = True\\n        break\\n  memo[mask, cur] = ans\\n  return ans\\n\\nreturn dp(2**N - 1)\\n```"
		},
		{
			"lc_ans_id":"95730",
			"view":"16",
			"top":"9",
			"title":"c++ 6ms with promoted DFS+list",
			"vote":"1",
			"content":"```\\nbool makesquare(vector<int>& nums) {\\n    if(nums.size()<4)return false;\\n    list<int>remained;//fast insert and delete\\n    sort(nums.begin(),nums.end());//sorted list can improve efficiency\\n    int s=0,//length of each side\\n    for(int n:nums){\\n        s+=n;remained.push_back(n);\\n    }\\n    if(s%4)return false;\\n    s/=4;\\n    if(nums.back()>s)return false;\\n    return backtrack(remained,s,3,s,remained.begin(),0);\\n}\\nbool backtrack(list<int>&remained,int s,int k,int st,list<int>::iterator it,int n){//it is the current number of list; n is the number from current to end\\n    if(!st){st=s;k--;it=remained.begin();}//finish one side of square\\n    if(remained.size()-n<k+1)return false;//the number left is not enough to create square\\n    if(!k)return true;//can create a square\\n    for(;it!=remained.end();){\\n        int t=*it;\\n        if(t>st){it++;continue;}//current number can't create current side\\n        it=remained.erase(it);n--;\\n        if(backtrack(remained,s,k,st-t,it,n))return true;//backtrack\\n        it=remained.insert(it,t);n++;\\n        while(it!=remained.end()&&t==*it){it++;n--;}//this is why sorted list can improve efficiency\\n    }\\n    return false;\\n}\\n```"
		}
	],
	"id":"466",
	"title":"Matchsticks to Square",
	"content":"<p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used <b>exactly</b> one time.</P>\r\n\r\n<p> Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,1,2,2,2]\r\n<b>Output:</b> true\r\n\r\n<b>Explanation:</b> You can form a square with length 2, one side of the square came two sticks with length 1.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [3,3,3,3,4]\r\n<b>Output:</b> false\r\n\r\n<b>Explanation:</b> You cannot find a way to form a square with all the matchsticks.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length sum of the given matchsticks is in the range of <code>0</code> to <code>10^9</code>.\r\n<li>The length of the given matchstick array will not exceed <code>15</code>.</li>\r\n</ol>\r\n</p>",
	"frequency":"59",
	"ac_num":"13979"
}