{
	"difficulty":"2",
	"submit_num":"46056",
	"show_id":"474",
	"leetcode_id":"474",
	"answers":[
		{
			"lc_ans_id":"95814",
			"view":"13372",
			"top":"0",
			"title":"c++ DP solution with comments",
			"vote":"65",
			"content":"```\\nint findMaxForm(vector<string>& strs, int m, int n) {\\n  vector<vector<int>> memo(m+1, vector<int>(n+1, 0));\\n  int numZeroes, numOnes;\\n\\n  for (auto &s : strs) {\\n    numZeroes = numOnes = 0;\\n    // count number of zeroes and ones in current string\\n    for (auto c : s) {\\n      if (c == '0')\\n\\tnumZeroes++;\\n      else if (c == '1')\\n\\tnumOnes++;\\n    }\\n\\n    // memo[i][j] = the max number of strings that can be formed with i 0's and j 1's\\n    // from the first few strings up to the current string s\\n    // Catch: have to go from bottom right to top left\\n    // Why? If a cell in the memo is updated(because s is selected),\\n    // we should be adding 1 to memo[i][j] from the previous iteration (when we were not considering s)\\n    // If we go from top left to bottom right, we would be using results from this iteration => overcounting\\n    for (int i = m; i >= numZeroes; i--) {\\n\\tfor (int j = n; j >= numOnes; j--) {\\n          memo[i][j] = max(memo[i][j], memo[i - numZeroes][j - numOnes] + 1);\\n\\t}\\n    }\\n  }\\n  return memo[m][n];\\n}\\n```"
		},
		{
			"lc_ans_id":"95807",
			"view":"5778",
			"top":"1",
			"title":"0-1 knapsack detailed explanation.",
			"vote":"33",
			"content":"This problem is a typical 0-1 knapsack problem, we need to pick several strings in provided strings to get the maximum number of strings using limited number 0 and 1. We can create a three dimensional array, in which dp[i][j][k] means the maximum number of strings we can get from the first i argument strs using limited j number of '0's and k number of '1's.\\n\\nFor dp[i][j][k], we can get it by fetching the current string i or discarding the current string, which would result in dp[i][j][k] = dp[i-1][j-numOfZero(strs[i])][i-numOfOnes(strs[i])] and dp[i][j][k] = dp[i-1][j][k]; We only need to treat the larger one in it as the largest number for dp[i][j][k].\\n\\ntalking is cheap:\\n\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int l = strs.length;\\n        int[][][] dp = new int[l+1][m+1][n+1];\\n        \\n        for (int i = 0; i < l+1; i++) {\\n            int[] nums = new int[]{0,0};\\n            if (i > 0) {\\n                nums = calculate(strs[i-1]);\\n            }\\n            for (int j = 0; j < m+1; j++) {\\n                for (int k = 0; k < n+1; k++) {\\n                    if (i == 0) {\\n                        dp[i][j][k] = 0;\\n                    } else if (j>=nums[0] && k>=nums[1]) {\\n                        dp[i][j][k] = Math.max(dp[i-1][j][k], dp[i-1][j-nums[0]][k-nums[1]]+1);\\n                    } else {\\n                        dp[i][j][k] = dp[i-1][j][k];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[l][m][n];\\n    }\\n    \\n    private int[] calculate(String str) {\\n        int[] res = new int[2];\\n        Arrays.fill(res, 0);\\n        \\n        for (char ch : str.toCharArray()) {\\n            if (ch == '0') {\\n                res[0]++;\\n            } else if (ch == '1') {\\n                res[1]++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\nBy the way, 0-1 knapsack we cannot decrease the time complexity, but we can decrease the space complexity from i*j*k to j*k\\n\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int l = strs.length;\\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for (int i = 0; i < m+1; i++) {\\n            Arrays.fill(dp[i], 0);\\n        }\\n        \\n        int[] nums = new int[]{0,0};\\n        for (String str : strs) {\\n            nums = calculate(str);\\n            for (int j = m; j >= nums[0]; j--) {\\n                for (int k = n; k >= nums[1]; k--) {\\n                    if (j>=nums[0] && k>=nums[1]) {\\n                        dp[j][k] = Math.max(dp[j][k], dp[j-nums[0]][k-nums[1]]+1);\\n                    } else {\\n                        dp[j][k] = dp[j][k];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    \\n    private int[] calculate(String str) {\\n        int[] res = new int[2];\\n        Arrays.fill(res, 0);\\n        \\n        for (char ch : str.toCharArray()) {\\n            if (ch == '0') {\\n                res[0]++;\\n            } else if (ch == '1') {\\n                res[1]++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\nIf you know Chinese, http://love-oriented.com/pack/P01.html would help you a lot."
		},
		{
			"lc_ans_id":"95811",
			"view":"14093",
			"top":"2",
			"title":"Java Iterative DP Solution - O(mn) Space",
			"vote":"29",
			"content":"Time Complexity: O(kl + kmn), where k is the length of input string array and l is the average length of a string within the array.\\n\\n```\\npublic int findMaxForm(String[] strs, int m, int n) {\\n    int[][] dp = new int[m+1][n+1];\\n    for (String s : strs) {\\n        int[] count = count(s);\\n        for (int i=m;i>=count[0];i--) \\n            for (int j=n;j>=count[1];j--) \\n                dp[i][j] = Math.max(1 + dp[i-count[0]][j-count[1]], dp[i][j]);\\n    }\\n    return dp[m][n];\\n}\\n    \\npublic int[] count(String str) {\\n    int[] res = new int[2];\\n    for (int i=0;i<str.length();i++)\\n        res[str.charAt(i) - '0']++;\\n    return res;\\n }\\n```\\nThanks @shawngao for some ways to make this solution more concise."
		},
		{
			"lc_ans_id":"95808",
			"view":"3678",
			"top":"3",
			"title":"0-1 knapsack in python",
			"vote":"16",
			"content":"This question is very similar to a 0-1 knapsack, the transition function is\\n```\\ndp(k, x, y) = max(dp(k-1, x-z, y-o) + 1, dp(k-1, x, y))   (z is zeroes in strs[k], o is ones in strs[k])\\n```\\ndp(k, x, y) is the maximum strs we can include when we have x zeros, y ones and only the first k strs are considered.\\n\\ndp(len(strs), M, N) is the answer we are looking for\\n\\nI first implemented a dfs + memoization, which gets MLE, so I created a bottom up style dp.\\nWith bottom up, we can use something called \"rolling array\" to optimize space complexity from O(KMN) to O(MN)\\n\\n```\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        \\n        def count(s):\\n            return sum(1 for c in s if c == '0'), sum(1 for c in s if c == '1')\\n        \\n        for z, o in [count(s) for s in strs]:\\n            for x in range(m, -1, -1):\\n                for y in range(n, -1, -1):\\n                    if x >= z and y >= o:\\n                        dp[x][y] = max(1 + dp[x-z][y-o], dp[x][y])\\n                        \\n        return dp[m][n]\\n```"
		},
		{
			"lc_ans_id":"95815",
			"view":"2053",
			"top":"4",
			"title":"Have you graduated from primary school?",
			"vote":"14",
			"content":"Based on the description..."
		},
		{
			"lc_ans_id":"95860",
			"view":"2756",
			"top":"5",
			"title":"Java DP solution with explanation",
			"vote":"8",
			"content":"The idea is to build up the solution for 0..m zeros and 0..n ones, from only knowing 1 string, 2 strings, ..., up to n strings.\\n\\nFor example, for array = {\"10\", \"0\", \"1\"}, m = 1, n = 1.\\n\\n* for first string \"10\":\\n  * zero = 0, one = 0\\n  * zero = 1, one = 0\\n  * zero = 0, one = 1\\n  * zero = 1, one = 1, can form \"10\" [+1]\\n* continue on the second string \"0\", with previous knowledge of string \"10\":\\n  * zero = 0, one = 0\\n  * zero = 1, one = 0, can form \"0\" [+1]\\n  * zero = 0, one = 1\\n  * zero = 1, one = 1, can form \"0\" [+1] **or** 1 string (\"10\"), known from previous string\\n* continue on the last string \"1\", with previous knowledge of strings \"10\" and \"0\":\\n  * zero = 0, one = 0\\n  * zero = 1, one = 0, can't form \"1\", but we know it can form 1 string (\"0\") from previous set of strings\\n  * zero = 0, one = 1, can form \"1\" (+1)\\n  * zero = 1, one = 1, (can form \"1\" **and** 1 more string (\"0\") with zero = 1, one = 0, known from previous set of strings) or (1 string (\"10\"),  known from previous set of strings)\\n\\nHence, at the end, we know that with zero = 1, one = 1, with string \"10\", \"0\", and \"1\", the maximum number of strings we can form is 2.\\n\\n```\\npublic int findMaxForm(String[] strs, int m, int n) {\\n    int[][] max = new int[m + 1][n + 1];\\n    for (int i = 0; i < strs.length; i++) {\\n        String str = strs[i];\\n        \\n        int neededZero = 0;\\n        int neededOne = 0;\\n        for (int j = 0; j < str.length(); j++) {\\n            if (str.charAt(j) == '0') {\\n                neededZero++;\\n            } else {\\n                neededOne++;\\n            }\\n        }\\n        \\n        int[][] newMax = new int[m + 1][n + 1];\\n        \\n        for (int zero = 0; zero <= m; zero++) {\\n            for (int one = 0; one <= n; one++) {\\n                if (zero >= neededZero && one >= neededOne) {\\n                    int zeroLeft = zero - neededZero;\\n                    int oneLeft = one - neededOne;\\n                    newMax[zero][one] = Math.max(1 + max[zeroLeft][oneLeft], max[zero][one]);\\n                } else {\\n                    newMax[zero][one] = max[zero][one];\\n                }\\n            }\\n        }\\n        \\n        max = newMax;\\n    }\\n    return max[m][n];\\n}\\n```"
		},
		{
			"lc_ans_id":"95863",
			"view":"1686",
			"top":"6",
			"title":"Java memoization and accepted DP solutions with explanations",
			"vote":"4",
			"content":"Hi there! I am sharing explanation of my solution. In the problem what matters is the number of zeros and ones in each string. Therefore the first thing we have to do, is to turn the array of string into array of pairs. The ith pair contains number of zeros  and ones in ith string. Next step is to determine how many pairs from the array we can cover by m and n;\\n``` ```The strightforward idea is backtracking. So we can just try out covering strings starting from different positions and maximize the result. Implementation of this idea is written below:\\n\\n```\\npublic class Solution {\\n    Integer memo[][][];\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        if(strs == null || strs.length == 0 || (m == 0 && n == 0)) return 0;\\n        memo = new Integer[m+1][n+1][strs.length];\\n        int [][] pairs = new int[strs.length][2];\\n        for(int i = 0;i<strs.length;i++){\\n            for(int j = 0;j<strs[i].length();j++){\\n                char ch  = strs[i].charAt(j);\\n                if(ch == '0') pairs[i][0]++;\\n                else pairs[i][1]++;\\n            }\\n        }\\n        return go(pairs, 0, m, n);\\n    }\\n    \\n    public int go(int pairs[][], int s, int m, int n){\\n        if(s >= pairs.length) return 0;\\n        if(memo[m][n][s] != null) return memo[m][n][s];\\n        int count = 0;\\n        for(int i = s;i<pairs.length;i++){\\n            int dm = m - pairs[i][0];\\n            int dn = n - pairs[i][1];\\n            if(dm >= 0 && dn >=0) {\\n                count = Math.max(count, 1+go(pairs, i+1, dm, dn));\\n            }\\n        }\\n        memo[m][n][s] = count;\\n        return count;\\n    }\\n} \\n\\n```\\nThis top to down approach solution gets TLE at 51/56 test. But I think this approach could be accepted in an interview. \\n```  ```  My second solution uses bottom-up algorithm (DP). But pursues the same thinking approach. \\n```  ```  A state of my DP (int i, int numOfZeros, int numOfOnes) describes the maximum number of strings we can construct starting from index 'i' by having numOfZeros zeros and numOfOnes ones.\\n   There are two simple transition functions from upper state to lower state. \\n* First transition is skipping the ith string and just taking the maximum value we can construct starting from i-1 th string. \\n* Second transition is constructing current string (ith string) then adding maximum number of strings that can be constructed starting from i-1 th string by the rest of ones and zeros (numOfZeros - pair[i][0] and numOfOnes-pair[i][1]). \\n\\nThe value for the current state is the maximum of values of the two transaction. Finally the answer is the value of state that describes the number of strings that can be constructed starting from the last(or the first,actually does not matter) index of the input string by m zeros and n ones. In other words just return dp[strs.length-1][m][n];\\n\\n```\\npublic class Solution {\\n    \\n    public int findMaxForm(String[] strs, int m, int n) {\\n        if(strs == null || strs.length == 0 || (m == 0 && n == 0)) return 0;\\n        int dp [][][] = new int[strs.length][m+1][n+1];\\n        int [][] pairs = new int[strs.length][2];\\n        for(int i = 0;i<strs.length;i++){\\n            for(int j = 0;j<strs[i].length();j++){\\n                char ch  = strs[i].charAt(j);\\n                if(ch == '0') pairs[i][0]++;\\n                else pairs[i][1]++;\\n            }\\n        }\\n        for(int zeros =  pairs[0][0];zeros<=m;zeros++){\\n               for(int ones = pairs[0][1];ones<=n;ones++){\\n                   dp[0][zeros][ones] = 1;\\n               }\\n        } \\n        for(int i  = 1;i<strs.length;i++){\\n           for(int zeros =  0;zeros<=m;zeros++){\\n               for(int ones = 0;ones<=n;ones++){\\n                   dp[i][zeros][ones] = dp[i-1][zeros][ones];\\n               }\\n           }\\n           for(int zeros =  pairs[i][0];zeros<=m;zeros++){\\n               for(int ones = pairs[i][1];ones<=n;ones++){\\n                   dp[i][zeros][ones] = Math.max(dp[i-1][zeros][ones], 1+dp[i-1][zeros-pairs[i][0]][ones-pairs[i][1]]);\\n               }\\n           }\\n        }\\n        return dp[strs.length-1][m][n];\\n    }\\n    \\n   \\n}\\n\\n```\\nTime and space complexity of the solution is ```O(n*m*pairs.length)```"
		},
		{
			"lc_ans_id":"95845",
			"view":"297",
			"top":"7",
			"title":"Easy to understand Recursive Solutions in Java with Explanation",
			"vote":"3",
			"content":"\\nAs everyone told, this is a 0-1 Knapsack problem. In my solution, the focus is not time or memory efficiency. Instead, I would like to generate a code which is simple to understand and easy to maintain.\\n\\nSo, the main idea is, for each string, we will decide whether \\n\\n* use remaining 0s and 1s (if there are enough of them) and count that string or\\n* do not use any 0s and 1s and skip that string entirely\\n\\nHere is this solution:\\n\\n```\\npublic class Solution {\\n\\n  public int findMaxForm(String[] strs, int m, int n) {\\n    return findMaxFormStartingWith(strs, m, n, 0);\\n  }\\n\\t\\n  private int findMaxFormStartingWith(String[] strs, int m, int n, int begin) {\\n    if ((begin==strs.length) || (m+n==0)) {\\n      return 0;\\n    }\\n    int countByAddingString = 0;\\n    String current = strs[begin];\\n    int zeroes = countZeroesIn(current);\\n    int ones = current.length()-zeroes;\\n    if (m>=zeroes && n>=ones) {\\n      countByAddingString = 1 + findMaxFormStartingWith(strs, m-zeroes, n-ones, begin+1);\\n    }\\n    int countBySkippingString = findMaxFormStartingWith(strs, m, n, begin+1);\\n    if (countByAddingString > countBySkippingString) {\\n      return countByAddingString;\\n    }\\n    return countBySkippingString;\\n  }\\n\\t\\n  private int countZeroesIn(String str) {\\n    int count = 0;\\n    for (int i=0; i<str.length(); i++) {\\n      if (str.charAt(i) == '0') {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\\nWith this code, for each string, we count the zeroes in it by ```countZeroesIn(String str)``` and see if there are enough 0s and 1s for it. If so, we accumulate that string and proceed with the remaining strings, 0s and 1s by means of the following code:\\n\\n```countByAddingString = 1 + findMaxFormStartingWith(strs, m-zeroes, n-ones, begin+1);```\\n\\nWe also take the other route, which simply skips the string and does not use any 0s and 1s.\\n\\n```countBySkippingString = findMaxFormStartingWith(strs, m, n, begin+1);```\\n\\nWhichever is bigger, is that the result. \\n\\nThe main problem with this approach is, it is too slow. Why? Beacause, it does not take advantage of previously solved subproblems. The Dynamic Programming comes in to the scene. What we will add is a simple table, which holds the previous answers and return them whenever we need them.\\n\\n```findMaxFormStartingWith(strs, m, n, begin)``` is called by 4 parameters. The string array is provided for practical purposes. It can be simply left out by declaring a private field for the class. The actual parameters are the remaining 0s (```m```), 1s (```n```) and current string index ```begin```. I preferred to create a 3D integer array to store and retrieve the results of subproblems. Each dimension represents the respective values of the parameters.\\n\\n```\\n  private int[][][] dpTable;\\n\\n  public int findMaxForm(String[] strs, int m, int n) {\\n    dpTable = new int[m+1][n+1][strs.length];\\n    return findMaxFormStartingWith(strs, m, n, 0);\\n  }\\n```\\n\\nThe arrays in Java are 0-indexed, hence ```m+1``` and ```n+1``` make the array operations easier for us. With this array in our hands, we will have two extra operations:\\n\\n* return the result if we have solved for these parameters before\\n* store the result for further access\\n\\nThese are the steps that decrease the time required to solve the problem. And these are the steps that we can use as Dynamic Programming.\\n\\nThis modification can be seen in the final version below.\\n\\n```\\n  private int findMaxFormStartingWith(String[] strs, int m, int n, int begin) {\\n    if ((begin==strs.length) || (m+n==0)) {\\n      return 0;\\n    }\\n    // return the result if we have solved for these parameters before\\n    if (dpTable[m][n][begin] > 0) {\\n      return dpTable[m][n][begin];\\n    }\\n    int countByAddingString = 0;\\n    String current = strs[begin];\\n    int zeroes = countZeroesIn(current);\\n    int ones = current.length()-zeroes;\\n    if (m>=zeroes && n>=ones) {\\n      countByAddingString = findMaxFormStartingWith(strs, m-zeroes, n-ones, begin+1)+1;\\n    }\\n    int countBySkippingString = findMaxFormStartingWith(strs, m, n, begin+1);\\n    // store the result for further access\\n    if (countByAddingString > countBySkippingString) {\\n      dpTable[m][n][begin] = countByAddingString;\\n    } else {\\n      dpTable[m][n][begin] = countBySkippingString;\\n    }\\n    return dpTable[m][n][begin];\\n  }\\n```"
		},
		{
			"lc_ans_id":"95851",
			"view":"379",
			"top":"8",
			"title":"4 Python solution with detailed explanation",
			"vote":"3",
			"content":"**Solution**\\n\\n**Ones and Zeroes** https://leetcode.com/problems/ones-and-zeroes/\\n\\n**BruteForce**\\n* The recursion tree for this problem indicates that there are three states: i, m, and n. i refers to the start index for strs and m, n are the number of zeroes and ones allowed. The tree will perform a DFS like traversal for every possible start index i and record the number of strings that could be formed. The solution would be the maximum between all the initial start states.\\n* The helper method takes m, n, and i as the parameters for this problem. Note we do not have any explicit checks like m ==0 and n==0 for a solution. m could be 0 and n could be non zero and subsequent items might just have 1s. Once we pick a candidate, we just check if we have sufficient zeroes and ones to accomodate it. If yes, we include it and make the next call.\\n```\\nclass Solution(object):\\n    def helper(self, strs, m, n, i):\\n        max_so_far = 0\\n        for idx in range(i, len(strs)):\\n            zeroes, ones = strs[idx].count('0'), strs[idx].count('1') \\n            if m >= zeroes and n >= ones:\\n                max_so_far = max(max_so_far, self.helper(strs, m-zeroes, n-ones, idx+1)+1)\\n        return max_so_far\\n    \\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        cache = {}\\n        return self.helper(strs, m, n, 0)\\n```\\n\\n**Memoization: O(MNL). TLE error**\\n* Find the maximum strings which can be created using m zeroes and n ones starting from index i in strs and store the results in a three dimensional table. The answer to the problem is then table[m,n,0]\\n* The code is exactly like the brute force approach with an addition of a table.\\n* This gives a TLE.\\n```\\nclass Solution(object):\\n    def helper(self, strs, m, n, i, table):\\n        if m in table and n in table[m] and i in table[m][n]:\\n            return table[m][n][i]\\n        table.setdefault(m, {}).setdefault(n, {})[i] = 0\\n        for idx in range(i, len(strs)):\\n            zeroes, ones = strs[idx].count('0'), strs[idx].count('1') \\n            if m >= zeroes and n >= ones:\\n                table[m][n][i] = max(table[m][n][i], self.helper(strs, m-zeroes, n-ones, idx+1, table)+1)\\n        return table[m][n][i]\\n    \\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        return self.helper(strs, m, n, 0, {})\\n```\\n\\n**Dynamic Programming: Time and Space O(MNL). MLE error**\\n* Find the maximum strings which can be created using m zeroes and n ones using indices 0 to i in strs (strs[0:i+1]) and store the results in a three dimensional table. The answer to the problem is then table[m,n,i]\\n* For simplicity, we will parameterize i as the number of strings being used in strs so that we dont need to deal with negative indices.\\n* Iterate from index 1 to len(strs). For a given index, we test all possible pairs of m and n. \\n* If for a pair we find we have sufficient zeroes and ones to use str[i], we update table[i,j,k] as the max of table[i-1,j, k], 1+table[i-1,j-zeroes,k-ones]. This means that we are trying to find the maximum by either including it or not including it. For the case of inclusion, we need to find the maximum string we can until index i-1 with j-zeroes and k-ones.\\n* If for a pair we find we do not have sufficient zeroes and ones, we update table[i,j,k] as table[i-1,j,k].\\n```\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        table = {k:[[0]*(n+1) for _ in range(m+1)] for k in range(len(strs)+1)}\\n        for i in range(1, len(strs)+1):\\n            zeroes, ones = strs[i-1].count('0'), strs[i-1].count('1')\\n            for j in range(m+1):\\n                for k in range(n+1):\\n                    if j >= zeroes and k >= ones:\\n                        table[i][j][k] = max(table[i-1][j][k], 1+table[i-1][j-zeroes][k-ones])\\n                    else:\\n                        table[i][j][k] = table[i-1][j][k]\\n        return table[len(strs)][m][n]\\n```\\n\\n**Dynamic Programming: Time O(MNL) and Space O(MN). Accepted Solution*\\n \\n*  Do we really need a three dimensional table? Process index i only requires the table for index i-1.\\n*  We can therefore use a prev and current table and achieve space complexity of O(MN).\\n```\\nclass Solution(object):\\n    def findMaxForm(self, strs, m, n):\\n        \"\"\"\\n        :type strs: List[str]\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        prev, curr = [[0]*(n+1) for _ in range(m+1)], [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(1, len(strs)+1):\\n            zeroes, ones = strs[i-1].count('0'), strs[i-1].count('1')\\n            for j in range(m+1):\\n                for k in range(n+1):\\n                    curr[j][k] = 0\\n                    if j >= zeroes and k >= ones:\\n                        curr[j][k] = max(prev[j][k], 1+prev[j-zeroes][k-ones])\\n                    else:\\n                        curr[j][k] = prev[j][k]\\n            prev, curr = curr, prev\\n        return prev[m][n]\\n```"
		},
		{
			"lc_ans_id":"95842",
			"view":"1659",
			"top":"9",
			"title":"Accepted greedy algorithm.",
			"vote":"2",
			"content":"[UPDATE]:\\nThis is not a working solution as pointed out by @andhddn below. \\n\\nI have a greedy algorithm that is accepted. Can't prove the correctness though. Main idea is to use the shortest string first. We sort all the string based on the number of 1s it has once, and then based on the 0s second time. Each time we try to consume as much string as possible. Result is the bigger of the 2 iterations. \\n\\nAny counter example/ proof of correctness is appreciated\\n\\n```\\npublic class Solution {\\n    public int findMaxForm(String[] strs, int m, int n) {\\n        int result = 0;\\n        if(strs.length == 0) return 0;\\n        PriorityQueue<Element> oneQueue = new PriorityQueue<Element>(new oneComparator());\\n        PriorityQueue<Element> zeroQueue = new PriorityQueue<Element>(new zeroComparator());\\n        \\n        for(String s : strs){\\n            int ones = 0;\\n            int zeros = 0;\\n            for(char c : s.toCharArray()){\\n                if(c == '0') {\\n                    zeros++;\\n                }else{\\n                    ones++;\\n                }\\n            }\\n            Element e = new Element(ones, zeros);\\n            oneQueue.offer(e);\\n            zeroQueue.offer(e);\\n        }\\n        int numZero = m;\\n        int numOne = n;\\n        /*sort the string based on # of 0 each string has and try to consume as many string as possible*/\\n        while(!zeroQueue.isEmpty()){\\n            if(numZero >= zeroQueue.peek().zero && numOne >= zeroQueue.peek().one){\\n                result++;\\n                numZero -= zeroQueue.peek().zero;\\n                numOne -= zeroQueue.peek().one;\\n            }\\n\\n            zeroQueue.poll();\\n        }\\n        int secondResult = 0;\\n        numZero = m;\\n        numOne = n;\\n        /*sort the string based on # of 1 each string has and try to consume as many string as possible*/\\n        while(!oneQueue.isEmpty()){\\n            if(numOne >= oneQueue.peek().one && numZero >= oneQueue.peek().zero){\\n                secondResult++;\\n                numZero -= oneQueue.peek().zero;\\n                numOne -= oneQueue.peek().one;\\n            }\\n\\n            oneQueue.poll();\\n            \\n        }        \\n        return Math.max(result, secondResult);\\n        \\n    }\\n    \\n    class oneComparator implements Comparator<Element>{\\n        public int compare(Element e1, Element e2){\\n            if(e1.one == e2.one) return e1.zero - e2.zero;\\n            return e1.one - e2.one;\\n        }\\n    }\\n    \\n    class zeroComparator implements Comparator<Element>{\\n        public int compare(Element e1, Element e2){\\n            if(e1.zero == e2.zero) return e1.one - e2.one;\\n            return e1.zero - e2.zero;\\n        }\\n    }\\n    \\n    class Element{\\n        public int one;\\n        public int zero;\\n\\n        public Element(int one, int zero){\\n            this.one = one;\\n            this.zero = zero;\\n        }\\n        \\n    }\\n}```"
		}
	],
	"id":"467",
	"title":"Ones and Zeroes",
	"content":"<p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>\n<p>For now, suppose you are a dominator of <b>m</b> <code>0s</code> and <b>n</b> <code>1s</code> respectively. On the other hand, there is an array with strings consisting of only <code>0s</code> and <code>1s</code>.</p>\n\n<p>\nNow your task is to find the maximum number of strings that you can form with given <b>m</b> <code>0s</code> and <b>n</b> <code>1s</code>. Each <code>0</code> and <code>1</code> can be used at most <b>once</b>.\n</p>\n\n\n<p><b>Note:</b><br>\n<ol>\n<li>The given numbers of <code>0s</code> and <code>1s</code> will both not exceed <code>100</code></li>\n<li>The size of given string array won't exceed <code>600</code>.</li>\n</ol>\n</p>\n\n<p><b>Example 1:</b><br />\n<pre>\n<b>Input:</b> Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3\n<b>Output:</b> 4\n\n<b>Explanation:</b> This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”\n</pre>\n</p>\n\n<p><b>Example 2:</b><br />\n<pre>\n<b>Input:</b> Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1\n<b>Output:</b> 2\n\n<b>Explanation:</b> You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\".\n</pre>\n</p>",
	"frequency":"222",
	"ac_num":"18029"
}