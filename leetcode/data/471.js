{
	"difficulty":"1",
	"submit_num":"32743",
	"show_id":"479",
	"leetcode_id":"479",
	"answers":[
		{
			"lc_ans_id":"96290",
			"view":"13250",
			"top":"0",
			"title":"I don't feel like this is a easy question",
			"vote":"76",
			"content":"This question just doesn't sound like an easy one to me... \\u256e(\\u256f\\ufe4f\\u2570)\\u256d"
		},
		{
			"lc_ans_id":"96297",
			"view":"19886",
			"top":"1",
			"title":"Java Solution using assumed max palindrom",
			"vote":"35",
			"content":"```\\n        public int largestPalindrome(int n) {\\n        // if input is 1 then max is 9 \\n        if(n == 1){\\n            return 9;\\n        }\\n        \\n        // if n = 3 then upperBound = 999 and lowerBound = 99\\n        int upperBound = (int) Math.pow(10, n) - 1, lowerBound = upperBound / 10;\\n        long maxNumber = (long) upperBound * (long) upperBound;\\n        \\n        // represents the first half of the maximum assumed palindrom.\\n        // e.g. if n = 3 then maxNumber = 999 x 999 = 998001 so firstHalf = 998\\n        int firstHalf = (int)(maxNumber / (long) Math.pow(10, n));\\n        \\n        boolean palindromFound = false;\\n        long palindrom = 0;\\n        \\n        while (!palindromFound) {\\n            // creates maximum assumed palindrom\\n            // e.g. if n = 3 first time the maximum assumed palindrom will be 998 899\\n            palindrom = createPalindrom(firstHalf);\\n            \\n            // here i and palindrom/i forms the two factor of assumed palindrom\\n            for (long i = upperBound; upperBound > lowerBound; i--) {\\n                // if n= 3 none of the factor of palindrom  can be more than 999 or less than square root of assumed palindrom \\n                if (palindrom / i > maxNumber || i * i < palindrom) {\\n                    break;\\n                }\\n                \\n                // if two factors found, where both of them are n-digits,\\n                if (palindrom % i == 0) {\\n                    palindromFound = true;\\n                    break;\\n                }\\n            }\\n\\n            firstHalf--;\\n        }\\n\\n        return (int) (palindrom % 1337);\\n    }\\n\\n    private long createPalindrom(long num) {\\n        String str = num + new StringBuilder().append(num).reverse().toString();\\n        return Long.parseLong(str);\\n    }\\n```"
		},
		{
			"lc_ans_id":"96303",
			"view":"14144",
			"top":"2",
			"title":"Java Solution with explanation",
			"vote":"26",
			"content":"Hi there! I am sharing my solution. My idea is strightforward. First off, let's pay attention on some facts. Let's consider maximum number with n digits. Of course that is the number consisting only of digit 9 (999..9). Let's denote that number ```max```, and consider ```max*max```. \\n* It is  obvious that any number which is product of two n digit numbers is less than or equal to ```max*max```.\\n* Maximum possible length of the product is ```2*n```.\\n* If we partition palindrome number into two equal halves, then left half must be equals to the reverse of the right half.\\n\\nWell, how to find the largest possible palindrome number? Answer: If ```max*max``` is palindrome itself, then that is the largest possible palindrome. Otherwise partition it into two equal(by length) halves. If left half is less than, or equals to the right half, then the largest palindrome number is concatenation of left part and reversed left part. Otherwise decrement left part, then find the largest palindrome as concatenation of left and reverse of it. Can we find next palindrome? Answer: yes. It is enough to repeat the latter operation, to obtain next largest palindrome. For example for input n = 2, ```max*max``` = 99*99 = 9801. So left half (further just ```left```) is 98 and right half (further just ```right```) is 01. 98>1, it mean largest palindrome is 9779. But it is not answer for our problem. Because this number is not product of two numbers with 2 digits. Well, to get valid palindromic number, we need to traverse all the palindromic numbers and check whether that number is a product of two numbers with n digits. To get the largest palindromic number, we have to approach the palindromic numbers greedily. It means, we need to traverse them from the largest to the smallest. Once we have found a palindrome, which is product of two n digital numbers return that number by mod 1337. That's all with the idea. \\n```  ```Note the following points in implementation:\\n* To optimally validate a palindrome number, (i.e whether it is product of two n digital numbers) use greedy approach. In other words, start from largest possible number until the number is greater than its pair. Because it prevents you from considering duplicate pairs. For instance, if ```a>b and a*b = pal ```, then no need to consider ```b*a = pal```. It saves huge amount of time. Cope example:\\n ```   \\n        for(int i = max;i>pro/i;i--){\\n                if(pro%i == 0 ) {\\n                    return (int)(pro%m);\\n                }\\n         }\\n```\\n* Do not forget to assign palindrome number ( pro in my case, which stands for product) long datatype. Because maximum possible palindrome consists of 16 digits, which is greater than Integer.MAX_VALUE.\\n\\nTo sum up, I think this problem is NOT an EASY one. It would be better to tag it as MEDIUM.\\n\\nP.S: Sorry for dirty code.\\n\\n```\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n        if(n == 1) return 9;\\n        int m = 1337;\\n        int mod = (int)Math.pow(10, n);\\n        int max = (int)Math.pow(10, n)-1;\\n        long pro = (long)max*(long)max;\\n        int right = (int)(pro%mod);\\n        int left = (int)(pro/mod);\\n        if(left == reverse(right,n)) return (int)(pro%m);\\n        if(left > right) {left--;}\\n        pro = (long)left*(long)mod+(long)reverse(left,n);\\n        while(left != mod/10){\\n            for(int i = max;i>pro/i;i--){\\n                if(pro%i == 0 ) {\\n                    return (int)(pro%m);\\n                }\\n            }\\n            left--;\\n            pro = (long)left*(long)mod+(long)reverse(left,n);\\n        }\\n        \\n        return (int)(pro%m);\\n    }\\n    \\n    private int reverse(int n, int dig){\\n        int x = n;\\n        int res = 0;\\n        int ten = (int)Math.pow(10,dig-1);\\n        while(x != 0 ){\\n            int d = x%10;\\n            res+=ten*d;\\n            ten/=10;\\n            x/=10;\\n        }\\n        return res;\\n    }\\n   \\n}"
		},
		{
			"lc_ans_id":"96331",
			"view":"5756",
			"top":"3",
			"title":"Trickiness depending on language you use",
			"vote":"23",
			"content":"I've been going at this problem with similar approach as other people using an assumed max palindrome. However if you're using javascript you wwill encounter an issue where using an input of 8 would cause precision issues since javascript integers actually only have 53 bits of precision for a continuous integer. This means that in order to pass the test case for n = 8 you would need to manually handle the numbers (potentially using strings). That said, I think this should be labeled as at least a medium question, hardly an easy question based on my interview experience."
		},
		{
			"lc_ans_id":"96291",
			"view":"5945",
			"top":"4",
			"title":"An easy 9-line Java solution.",
			"vote":"18",
			"content":"``` java\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n        if (n==1) return 9;\\n        int max=(int)Math.pow(10, n)-1;\\n        for (int v=max-1;v>max/10;v--) {\\n            long u=Long.valueOf(v+new StringBuilder().append(v).reverse().toString());\\n            for (long x=max;x*x>=u;x--)\\n                if (u%x==0)\\n                    return (int)(u%1337);\\n        }\\n        return 0;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"96306",
			"view":"1900",
			"top":"5",
			"title":"Java solutions with two different approaches",
			"vote":"13",
			"content":"There are two directions for approaching the problem: one is to first construct the palindrome and then test whether it can be written as the product of two `n-digit` numbers; the other is to first obtain the product of the two `n-digit` number and then test whether the product is a palindrome.\\n\\n---\\n**`Part I -- From palindrome to product`**\\n\\nIt looks like most of the posts here took the first approach, so I will start from the first one also. For this approach, we need to consider the following two problems:\\n\\n1. How to construct the palindromes and arrange them in descending order (note we are interested in the maximum palindrome).\\n2. How to test if a given palindrome can be written as the product of two  `n-digit` numbers.\\n\\nFor the first problem, we need to know how many digits in each of the palindrome. Since the palindrome is meant to be the product of two  `n-digit` numbers, it can have either `2n` or `2n - 1` digits. And since we are interested in maximum palindrome, those with `2n` digits will be considered first. These palindromes can be divided into two parts with equal number of digits (`n` for each part): `left` and `right`. And `left` will be a mirror image of `right`, and vice versa. Therefore each palindrome will be fully determined by either its `left` or `right` part. \\n\\nNote the `left` part is an `n-digit` number and if we arrange it in descending order, the resulted palindrome will also be in descending order. Therefore we may start from the maximum `n-digit` number and go towards the minimum `n-digit` number. For each number, we can construct the palindrome by concatenating the number with its mirror image.\\n\\nNow we come to the second problem, i.e., how to check if the constructed palindrome can be written as the product of two `n-digit` numbers. This is essentially the \"integer factorization\" problem. One straightforward way would be the \"trial division\" algorithm, i.e., test each of the `n-digit` number to see if it is a factor of the palindrome and if so, the other factor is also an `n-digit` number. \\n\\nHere is the java problem for this approach. Note we only considered palindromes with `2n` digits. Fortunately for each case (`n = 1 to  8`), we are able to find at least one palindrome that can be decomposed into two `n-digit` numbers, therefore there is no need to check those with `2n - 1` digits (However if you are still concerned, refer to this [post](https://discuss.leetcode.com/topic/74533/java-solution-115ms)).\\n\\n```\\npublic int largestPalindrome(int n) {\\n    long max = (long)Math.pow(10, n) - 1;\\n    long min = max / 10;\\n        \\n    for (long h = max; h > min; h--) {\\n        long left = h, right = 0;\\n        for (long i = h; i != 0; right = right * 10 + i % 10, i /= 10, left *= 10);\\n        long palindrom = left + right;      // construct the palindrome\\n            \\n        for (long i = max; i > min; i--) {\\n            long j = palindrom / i;\\n            if (j > i || j <= min) break;     // terminate if the other number is greater than current number or is not an n-digit number\\n            if (palindrom % i == 0) return (int)(palindrom % 1337); // found if current number is a factor\\n        }\\n    }\\n\\n    return 9;    // account for case n = 1\\n}\\n```\\nApparently the algorithm goes exponentially: `O(10^n)`\\n\\n---\\n**`Part II -- Observations and optimizations`**\\n\\nBefore I continue to the other approach, I'd like to point out some observations and the corresponding optimizations.\\n\\nAs I mentioned, we are interested in the maximum palindrome, thus it's reasonable to first check palindromes starting with digit `9`. If not found, then those starting with digit `8, 7, 6,...`. If the palindrome is starting with digit `9`, it must also be ending with digit `9`. Now if the palindrome is the product of the two `n-digit` numbers, the two numbers must be ending with digits `1, 3, 7, or 9`. Similarly for other cases. \\n\\nIt looks like for each `n`, there exists at least one palindrome with `2n` digits and starting with digit `9` that can be written as the product of two `n-digit` numbers. I was able to prove for the case when `n` is even, but failed for the case when `n` is odd.\\n\\nIf `n` is even, let `n = 2k`. The two `n-digit` numbers can be `num1 = 10^n - 1` and `num2 = 10^n - 10^k + 1`. Their product will be `p = num1 * num2 = 10^(3k) * (10^k - 1) + (10^k - 1) = 9..0..9`, where `p` will have `k` leading and trailing digit of `9` and `2k` digit `0` in the middle. For `n <= 8`, this is also the maximum palindrome that is found (not sure if it holds true for higher `n`, but most likely it will do).\\n\\nIf `n` is odd, the above trick does not work (`p` will have unbalanced `9`'s). For this case, however, I would like to propose the following statement: let `n = 2k + 1`, there exists at least two `n-digit` numbers `num1` and `num2`, `10^n - 10^(k+1) <= num1, num2 <= 10^n - 1`, whose product will be a palindrome (verified for `n <= 8`). \\n\\nIn summary, we have the following conclusion: for each `n`, there exists at least two `n-digit` numbers `num1` and `num2`, `10^n - 10^m <= num1, num2 <= 10^n - 1 and m = [(n+1)/2]`, whose product will be a palindrome.\\n\\n---\\n**`Part III -- From product to palindrome`**\\n\\nSimilar to the first approach, we need to consider the following two problems:\\n\\n1. How to construct the products and arrange them in descending order.\\n2. How to test if a given product is a palindrome.\\n\\nThe second problem is easy, simply reverse the product and check if it is the same as the original product. The first problem, however, is a little tricky. Obtaining the product is a no-brainer. The hard part is how to arrange them in descending order. \\n\\nFirst we need to determine the candidate products. From `part II`, we will only consider products obtained with the two `n-digit` numbers in the range `[10^n - 10^m, 10^n - 1]`. Second we will use a PriorityQueue to extract these candidate products in descending order.\\n\\nHowever, the total number of candidates above still blows up the memory when `n = 8`. So we need further pruning. First again since the product ends with digit `9`, the two numbers must be ending with digits `1, 3, 7, or 9`. Second, to avoid repetition, the first number will be no less than the second. Third, for all products obtained with the first number fixed, there is no need to include them all at once but instead we can consider them once at a time with the second number going in decreasing order. So eventually we end up storing the two numbers in the PriorityQueue while extracting them according to their product.\\n\\nWith these optimizations, here is the java program for this approach:\\n\\n```\\npublic int largestPalindrome(int n) {\\n    int max = (int)Math.pow(10, n) - 1;\\n    int min = max - (int)Math.pow(10, (n + 1) >> 1);\\n    \\t\\n    Comparator<int[]> cmp = new Comparator<int[]>() {\\n    \\t@Override\\n\\tpublic int compare(int[] a, int[] b) {\\n    \\t    return Long.compare((long)b[0] * b[1], (long)a[0] * a[1]);\\n    \\t}\\n    };\\n    \\t\\n    PriorityQueue<int[]> pq = new PriorityQueue<>(max - min, cmp);\\n    \\t\\n    for (int i = max; i > min; i--) {\\n    \\tint r = i % 10;\\n    \\t\\t\\n    \\tif (r == 3 || r == 7) {\\n    \\t    pq.offer(new int[] {i, i});\\n    \\t} else if (r == 1) {\\n    \\t    pq.offer(new int[] {i, i - 2});\\n    \\t} else if (r == 9) {\\n    \\t    pq.offer(new int[] {i, i - 8});\\n    \\t}\\n    }\\n    \\t\\n    while (!pq.isEmpty()) {\\n    \\tint[] a = pq.poll();\\n    \\tlong p = (long)a[0] * a[1];\\n    \\t\\t\\n    \\tif (isPalindrome(p)) return (int)(p % 1337);\\n    \\t\\t\\n    \\tif (a[1] > min) {\\n    \\t    a[1] -= 10;\\n    \\t    pq.offer(a);\\n    \\t}\\n    }\\n    \\n    return 0;\\n}\\n    \\nprivate boolean isPalindrome(long z) {\\n    long r = 0;\\n    for (long x = z; x != 0; r = r * 10 + x % 10, x /= 10);\\n    return r == z;\\n}\\n```\\n\\nThis algorithm still goes exponentially with `n` while also requires extra space of the same order."
		},
		{
			"lc_ans_id":"96301",
			"view":"2162",
			"top":"6",
			"title":"Concise C++ solution",
			"vote":"11",
			"content":"Inspired by [@chiranjeeb2](https://discuss.leetcode.com/topic/74125/java-solution-using-assumed-max-palindrom) \\n\\n```\\nclass Solution {\\npublic:\\n    int largestPalindrome(int n) {\\n        if (n == 1) return 9;\\n        int upper = pow(10, n) - 1;\\n        int lower = pow(10, n-1);\\n        for (int i = upper; i >= lower; i--) {\\n            long cand = buildPalindrome(i);\\n            for (long j = upper; j*j >= cand; j--) {\\n                if (cand % j == 0 && cand / j <= upper) {\\n                    return cand % 1337;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    long buildPalindrome(int n) {\\n        string s = to_string(n);\\n        reverse(s.begin(), s.end());\\n        return stol(to_string(n) + s);\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"96305",
			"view":"768",
			"top":"7",
			"title":"Python Solution Using Math In 48ms",
			"vote":"5",
			"content":"Thanks to @nizametdinov 's reply in this [thread](https://discuss.leetcode.com/topic/78852/could-any-python-experts-share-their-codes-within-100ms/2), I came out below solution.\\nBecause `i^2 - a*i - lower = 0`\\nthus, `(i-a/2)^2 = (4*lower-a^2)/2`\\nthus, i.f.f. `(4*lower-a^2)/2` is some integer's square, can lower `i^2 - a*i - lower = 0` have integer result.\\nso I use `(a^2-4*lo)^.5 == int((a^2-4*lo)^.5)` to check.\\n```\\nclass Solution(object):\\n    def largestPalindrome(self, n):\\n        if n==1: return 9\\n        if n==2: return 987\\n        for a in xrange(2, 9*10**(n-1)):\\n            hi=(10**n)-a\\n            lo=int(str(hi)[::-1])\\n            if a**2-4*lo < 0: continue\\n            if (a**2-4*lo)**.5 == int((a**2-4*lo)**.5):\\n                return (lo+10**n*(10**n-a))%1337\\n```"
		},
		{
			"lc_ans_id":"96300",
			"view":"1171",
			"top":"8",
			"title":"java 1ms a stupid solution",
			"vote":"3",
			"content":"```\\npublic class Solution {\\n    public int largestPalindrome(int n) {\\n        int[] x = {9,99,993,9999,99979,999999,9998017,99999999};\\n        int[] y = {1,91,913,9901,99681,999001,9997647,99990001};\\n        \\n        return ((x[n-1]%1337)*(y[n-1]%1337))%1337;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"96336",
			"view":"1591",
			"top":"9",
			"title":"C++ solution with some comments",
			"vote":"3",
			"content":"rewrite @ZhassanB  solution into C++\\n\\n   \\n \\n   \\n    class Solution {\\n    public:\\n    int largestPalindrome(int n) {\\n           if(n == 1) {\\n            return 9;\\n        }\\n        \\n        long maxNum = pow(10, n) - 1;\\n        long possibleNum = maxNum * maxNum;\\n        \\n        long divider = pow(10,n);\\n        long left = possibleNum / divider;   //Find the left part\\n        long right = possibleNum % divider; //Find the right part\\n        \\n        if(left == reverts(right)) {  // if they are palindrome\\n            return possibleNum % 1337;\\n        }\\n        \\n        /* example: if number is 9869, then the possibleNum  can only be 9779, if number is 9379, then the possibleNum can be 9339, \\n       so the left part number is determined by the function below*/\\n        if(reverts(left) > right) {\\n            left --;\\n        }\\n        \\n        possibleNum = left * divider + reverts(left);\\n        \\n        while(left >= divider / 10) { // left should be no smaller than pow(10, n-1)\\n            for(long i = maxNum; i > possibleNum/i; i --) {\\n                if(possibleNum % i == 0) {\\n                    return possibleNum % 1337;\\n                }\\n            }\\n            left --;\\n            possibleNum = left * divider + reverts(left);\\n        }\\n        \\n        return possibleNum % 1337;\\n    }\\n    \\n    private:\\n        long reverts(long right) {\\n           long result = 0;\\n           while(right != 0) {\\n               result = 10* result + right%10;\\n               right /= 10;\\n          }\\n        return result;\\n        }\\n    };"
		}
	],
	"id":"471",
	"title":"Largest Palindrome Product",
	"content":"<p>Find the largest palindrome made from the product of two n-digit numbers.</p>\r\n<p> Since the result could be very large, you should return the largest palindrome mod 1337.</p>\r\n\r\n<p><b>Example:</b>\r\n<p>Input: 2</p>\r\n<p>Output: 987</p>\r\n<p>Explanation: 99 x 91 = 9009, 9009 % 1337 = 987\r\n</p>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b>\r\n<p>The range of n is [1,8].</p>\r\n</p>\r\n",
	"frequency":"528",
	"ac_num":"8214"
}