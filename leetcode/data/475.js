{
	"difficulty":"3",
	"submit_num":"18872",
	"show_id":"483",
	"leetcode_id":"483",
	"answers":[
		{
			"lc_ans_id":"96587",
			"view":"6542",
			"top":"0",
			"title":"Python solution with detailed mathematical explanation and derivation",
			"vote":"23",
			"content":"First things first. Let's see the math behind it.\\n\\nFrom given information, we can say one thing- Numbers will be of form-\\n\\nn = k^m + k^(m-1) + ... + k + 1\\n=> n-1 = k^m + k^(m-1) + ... + k\\n=> n-1 = k (k^(m-1) + k^(m-2) + ... + k + 1) ...... **[1]**\\n\\nAlso, from n = k^m + k^(m-1) + ... + k + 1, we can say,\\nn-k^m = k^(m-1) + k^(m-2) + ... + k + 1 ...... **[2]**\\n\\nfrom [1] and [2],\\n\\nn-1 = k (n - k^m)\\n=>k^(m+1) = nk - n + 1\\n\\nif you shuffle sides you will end up getting following form,\\n\\n**(k^(m+1) - 1)/(k - 1) = n** .... **[3]**\\n\\nAlso from [1] note that, (n - 1) must be divisible by k. \\n\\nWe know that, n = k^m + k^(m-1) + ... + k + 1\\n\\n=> n > k^m\\n=> m-th root of n > k .... **[4]**\\n\\n**[EDIT]** -->\\n\\nWith inputs from @StefanPochmann we can also say, from binomial thorem, **n = k^m + ... + 1 < (k+1)^m** .... **[5]**\\nTherefore, **k+1 > m-th root of n > k**.  .... from **[4]** and **[5]**\\nThus **\\u230am-th root of n\\u230b** is the only candidate that needs to be tested. **[6]**\\n\\n<--\\n\\nSo our number should satisfy this equation where **k** will be our base and **m** will be (number of 1s - 1)\\n\\nThis brings us to the search problem where we need to find k and m.\\n\\nLinear search from 1 to n does not work. it gives us TLE. So it leaves us with performing some optimization on search space.\\n\\nFrom **[6]** we know that the only candidate that needs to be tested is, **\\u230am-th root of n\\u230b**\\n\\nWe also know that the smallest base is 2 so we can find our m must be between 2 and log<sub>2</sub>n else m is (n-1) **[7]**\\n\\nThat brings me to the code:\\n**[EDIT]** -- >\\n```\\nimport math\\nclass Solution(object):\\n    def smallestGoodBase(self, n):\\n        \"\"\"\\n        :type n: str\\n        :rtype: str\\n        \"\"\"\\n        n = int(n)\\n        max_m = int(math.log(n,2)) # Refer [7]\\n        for m in range(max_m,1,-1):\\n            k = int(n**m**-1)  # Refer [6]\\n            if (k**(m+1)-1)//(k-1) == n:\\n                # Refer [3]\\n                return str(k)\\n        \\n        return str(n-1)  \\n```\\n<\\u2014-"
		},
		{
			"lc_ans_id":"96590",
			"view":"6447",
			"top":"1",
			"title":"3ms, AC, C++, long long int + binary search",
			"vote":"20",
			"content":"The input can be stored in a long long int, here I use unsigned long long int for a larger range. We need to find k, for 1+k^1+k^2+k^3+...+k^d=n. The smallest possible base is k=2, with has the longest possible representation, i.e., largest d. So, to find the smallest base means to find the longest possible representation \"11111....1\" based on k. As n<=10^18, so n<(1<<62). We iterate the length of the representation from 62 to 2 (2 can always be valid, with base=n-1), and check whether a given length can be valid.\\n\\nFor a given length d, we use binary search to check whether there is a base k which satisfies 1+k^1+k^2+...k^d=n. The left limit is 1, and the right limit is pow(n,1/d)+1, i.e., the d th square root of n. The code is shown below.\\n\\nP.S., I am going to graduate this semester, and need a JOB :)\\n```\\nclass Solution {\\npublic:\\n    string smallestGoodBase(string n) {\\n    unsigned long long tn=(unsigned long long)stoll(n);\\n    unsigned long long x=1;\\n    for (int i=62;i>=1;i--) {\\n        if ((x<<i)<tn) {\\n            unsigned long long cur=mysolve(tn,i);\\n            if (cur!=0) return to_string(cur);\\n        }\\n    }\\n    return to_string(tn-1);\\n    }\\n    \\nunsigned long long mysolve(unsigned long long n,int d) {\\n    double tn=(double) n;\\n    unsigned long long right=(unsigned long long)(pow(tn,1.0/d)+1);\\n    unsigned long long left=1;\\n    while (left<=right){\\n        unsigned long long mid=left+(right-left)/2;\\n        unsigned long long sum=1,cur=1;\\n        for (int i=1;i<=d;i++) {\\n            cur*=mid;\\n            sum+=cur;\\n        }\\n        if (sum==n) return mid;\\n        if (sum>n) right=mid-1;\\n        else left=mid+1;\\n    }\\n    return 0;\\n}\\n\\n};\\n```"
		},
		{
			"lc_ans_id":"96589",
			"view":"2062",
			"top":"2",
			"title":"Java solution with hand-writing explain",
			"vote":"14",
			"content":"n is the number, x is the base.\\n![alt text](https://raw.githubusercontent.com/hot13399/leetcode-graphic-answer/master/483.%20Smallest%20Good%20Base.jpg)\\n\\n    public String smallestGoodBase(String nn) {\\n      long n = Long.parseLong(nn);\\n      long res = 0;\\n      for(int k = 60; k >= 2; k--){\\n        long s = 2, e = n;\\n        while(s < e){\\n            long m = s + (e - s) / 2;   \\n            \\n            BigInteger left = BigInteger.valueOf(m);\\n            left = left.pow(k).subtract(BigInteger.ONE);\\n            BigInteger right = BigInteger.valueOf(n).multiply(BigInteger.valueOf(m).subtract(BigInteger.ONE));\\n            int cmr = left.compareTo(right);\\n            if(cmr == 0){\\n                res =  m;\\n                break;\\n            } else if(cmr < 0){\\n                s = m + 1;\\n            } else {\\n                e = m;\\n            }\\n        }\\n        \\n        if(res != 0) break;\\n      }\\n      \\n      return \"\" + res;\\n    }"
		},
		{
			"lc_ans_id":"96598",
			"view":"2526",
			"top":"3",
			"title":"Short Python O(log(N))",
			"vote":"7",
			"content":"```\\nclass Solution(object):\\n    def smallestGoodBase(self, N):\\n        n = int(N);\\n        \\n        for k in xrange(int(math.log(n, 2)), 1 , -1):\\n            a = int(n ** k ** -1)                  # kth-root of n\\n            if (1 - a ** (k + 1)) // (1 - a) == n: # [a^0 + a^1 + ... + a^k] == n\\n                return str(a)\\n        \\n        return str(n - 1)\\n```"
		},
		{
			"lc_ans_id":"96602",
			"view":"2824",
			"top":"4",
			"title":"Java/C# binary search solutions with detailed explanation",
			"vote":"6",
			"content":" The java solution is submitted by lixx2100 to contest.\\n1. n is equal to x^(k-1) + x^(k-2) + ... + x + 1, where k is from 2 to, say, 66\\n2. for each k from 2 to 66, we get \"x\", and the minimum of all \"x\"s is the answer\\n3. To get \"x\", we use binary search approach with left = 2, and right = Long.MAX_VALUE\\n4. to compare whether n is equal to x^(k-1) + x^(k-2) + ... + x + 1, we don't need to calculate x^(k-1) + x^(k-2) + ... + x + 1 from x.\\nif n = x^(k-1) + x^(k-2) + ... + x + 1, then n * (x - 1) = x^k -1.\\nin the source code, cb is x^k -1 and wb is n * (x - 1).\\n\\n```\\nimport java.math.*;\\n\\npublic class Solution {\\n\\n    public String smallestGoodBase(String n) {\\n        BigInteger N = new BigInteger(n);\\n        long base = Long.MAX_VALUE;\\n\\n        for (int k = 2; k < 66; k++) {\\n\\n            long l = 2, r = Long.MAX_VALUE - 5;\\n            while (l <= r) {\\n                long mid = l + (r - l) / 2;\\n\\n                BigInteger cb = BigInteger.valueOf(mid).pow(k).subtract(BigInteger.ONE);\\n                BigInteger wb = N.multiply(BigInteger.valueOf(mid).subtract(BigInteger.ONE));\\n\\n                int cmp = cb.compareTo(wb);\\n                if (cmp == 0) {\\n                    base = Math.min(base, mid);\\n                    break;\\n                } else if (cmp < 0) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n\\n        return \"\" + base;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"96599",
			"view":"2895",
			"top":"5",
			"title":"Java Binary Search solution, 9 ms",
			"vote":"5",
			"content":"```\\npublic class Solution {\\n    public String smallestGoodBase(String n) {\\n        long num = 0;\\n        for (char c : n.toCharArray()) num = num * 10 + c - '0';\\n        \\n        long x = 1;\\n        for (int p = 64; p >= 1; p--) {\\n            if ((x << p) < num) {\\n                long k = helper(num, p);\\n                if (k != -1) return String.valueOf(k);\\n            }\\n        }\\n        return String.valueOf(num - 1);\\n    }\\n    \\n    private long helper(long num, int p) {\\n        long l = 1, r = (long)(Math.pow(num, 1.0/p) + 1);\\n        while (l < r) {\\n            long mid = l + (r - l) / 2;\\n            long sum = 0, cur = 1;\\n            for (int i = 0; i <= p; i++) {\\n                sum += cur;\\n                cur *= mid;\\n            }\\n            if (sum == num) return mid;\\n            else if (sum > num) r = mid;\\n            else l = mid + 1;\\n        }\\n        return -1;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"96591",
			"view":"751",
			"top":"6",
			"title":"Java O((logn)^2) binary search solution",
			"vote":"3",
			"content":"To begin with, the whole problem is equivalent to solving the following equation with smallest `k`  (assuming `k >= 2` and `m >= 1`): \\n\\n  `f(k, m) = n`\\n\\nwhere `k` is the base of the numbers, `m` is the number of digit `1`'s in this base, `f(k, m) = 1 + k + k^2 + ... + k^(m-1) = (k^m - 1)/(k-1)` is the numeric value of the number in base `10`, and `n` is the numeric value of the given input string in base `10`. \\n\\nBefore we jump into solutions of the equation, let's first dig up some properties of the function `f(k, m) = (k^m - 1)/(k-1)`.\\n\\n1. If `m` is fixed, `f(k, m)` is monotonically increasing on `k`.\\n2. If `k` is fixed, `f(k, m)` is also monotonically increasing on `m`.\\n\\nNow suppose we have two different solutions for the above equation: `(k1, m1)` and `(k2, m2)`. Without loss of generality, let's assume `m1 > m2`, then we can show `k1 < k2` as follows: `n = f(k2, m2) = f(k1, m1) > f(k1, m2) ==> k2 > k1`. Similarly for the other case: `m1 < m2 ==> k1 > k2`. Therefore `k` and `m` will be inversely related provided the equation is held true.\\n\\nThe conclusion above suggests that if we can simply find a solution to the equation `f(k, m) = n` with the largest possible `m`, then the corresponding `k` is guaranteed to be the smallest. So now we need to figure out the upper and lower limit on `m` to impose constraint on our searching range. (Strictly speaking, we may also proceed in the other way round, i.e., to find the smallest `k` directly but that turns out to be `O(n)`.)\\n\\nNote that if the equation is held true, smaller `k` will correspond to larger `m`. Since the minimum of `k` is `2`, we know the maximum of `m` will be `log(n + 1)` (logarithm of `(n+1)` in base `2`). What about the lower limit? Note that `n >= 3`, therefore `m` cannot be `1` (otherwise the numeric value would be `1` and the equation will have no solutions). To summarize, we have: `2 <= m <= log(n + 1)`.\\n\\nSo our solution will go like this, starting from the upper limit of `m`, check if we can find a `k` so that the equation  `f(k, m) = n` is held true. If so, return the corresponding `k` as the solution. Otherwise decrease the value of `m` by `1` and repeat the process until either a solution is found or all values of `m` have been exhausted. Note that for any `n >= 3`, there is a trivial solution where `k = n - 1 and m = 2`, therefore our searching process above is guaranteed to find at least one solution.\\n\\nThe last part is how to find the solution to the equation with `m` fixed. A straightforward way would be doing binary search. One point worth noting here is the upper and lower limits for the searching range of `k`. For the upper limit, note that `n = f(k, m) = 1 + k + ... + k^(m-1) > k^(m-1) ==> k < n^(1/(m-1))`. For the lower limit, note that `n = f(k, m) = (k^m - 1)/(k-1) <= (k^m - 1) ==> k >= (n+1)^(1/m)`. To summarize:  `(n+1)^(1/m) <= k <= n^(1/(m-1))`.\\n\\nSo here comes our final solution based on the analyses above. Note that the range of the input `n` is `[3, 10^18]`, so `n` can fit into a `long` type variable. Also if for each `m`,  `k` is in the searching range specified above, we won't have overflow problem. As for the time complexity, in the worst case, we need to scan the whole range of `m`, which is O(logn); for each `m`, the binary search is O(logn) too; therefore our solution will run at O((logn)^2).  \\n\\n```\\npublic String smallestGoodBase(String n) {\\n    long num = Long.valueOf(n);\\n        \\n    for (int m = (int)(Math.log(num + 1) / Math.log(2)); m >= 2; m--) {\\n        long l = (long)(Math.pow(num + 1, 1.0 / m));\\n        long r = (long)(Math.pow(num, 1.0 / (m - 1)));\\n        \\t\\n        while (l <= r) {\\n            long k = l + ((r - l) >> 1);\\n            long f = 0L;\\n            for (int i = 0; i < m; i++, f = f * k + 1);\\n        \\t\\t\\n            if (num == f) {\\n        \\treturn String.valueOf(k);\\n            } else if (num < f) {\\n        \\tr = k - 1;\\n            } else {\\n        \\tl = k + 1;\\n            }\\n        }\\n    }\\n        \\n    return String.valueOf(num - 1);\\n}\\n```"
		},
		{
			"lc_ans_id":"96597",
			"view":"910",
			"top":"7",
			"title":"5-liner 3ms really TIGHT search bounds with time complexity analysis O((logN)^2) (detailed explanation)",
			"vote":"3",
			"content":"**Key Observation:** if `N` in base `k >= 2` has all digits as `1`'s, that means `n` has representation\\n* `n = ` &Sigma;<sub>p=0:d-1</sub> `k`<sup>p</sup>,\\n\\nwhere `d` is the number of digits in base `k`. So **the problem is equivalent to** \\n* find smallest `k >= 2` such that function `f(k,d)` := &Sigma;<sub>p=0:d-1</sub> `k`<sup>p</sup> - `N` = `0` for some integer `d`.\\n\\nAs many fellow coders have posted the popular binary search solution for root of `f(*, d)` with some fixed `d`, but I think the search bound for `d` and `k` should be tightened as much as possible to speed up the algorithm.\\n\\n**Range of d:** Note that `f(k,d)` is strictly increasing in `k`, which means `f(*,d)` has most one root for a fixed `d`. \\nNote that `f` can be rewritten as \\n* `f(k,d)` = (`k`<sup>d</sup>`-1`)/(`k-1`)`-N` &ge; `f(2,d)` = `2`<sup>d</sup>`-1-N`,\\n\\nso we must have `d` &le; `log2(N+1)` to be able to have a root for `f(*,d)`.\\n\\n**Range of k:** for a fixed `d`, we have\\n* `f(k,d)` = (`k`<sup>d</sup>`-1`)/(`k-1`)`-N` < `k`<sup>d</sup>`-N`,\\n\\nso we must have the root `k` > `N`<sup>1/d</sup>.\\nWe also have\\n* `f(k,d)` = &Sigma;<sub>p=0:d-1</sub> `k`<sup>p</sup> - `N` > `k`<sup>d-1</sup>`-N`,\\n\\nso we must have the root `k` < `N`<sup>1/(d-1)</sup>.\\n\\n**Summary:** we loop `d` only in range `[2, log2(N+1)]` reversely, and for each `d`, we binary search root for `f(*,d)` only in range `[N`<sup>1/d</sup>, `N`<sup>1/(d-1)</sup>`]`.\\n```\\n    int64_t N; // =stoll(n)\\n    \\n    string smallestGoodBase(string n) {\\n      for (int64_t k, d=log2((N=stoll(n))+1); d>1;) if (k = root(d--)) return to_string(k);\\n    }\\n    \\n    int64_t f(int64_t k, int64_t d) { // f(k,d) = sum k^i - N\\n      for (int64_t i=0, p=1, sum=1; i<d; sum += p*=k) if (++i == d) return sum-N;\\n    }\\n    \\n    int64_t root(int64_t d) { // binary search root for f(*,d) in range [N^1/d, N^1/(d-1)]\\n      int64_t m, v, L = pow(N, 1./d), R = pow(N, 1./(d-1));\\n      for (; L <= R; v<0? L = m+1 : R = m-1) if (!(v = f(m=(L+R)/2,d))) return m;\\n      return d>2? 0 : N-1;\\n    }\\n```\\n**Time Complexity:** \\n* The loop in `smallestGoodBase` has length `log N`.\\n* Apparently, function `f(k,d)` has `O(d)` complexity.\\n* In binary search `root`, we have `O(d*log(R-L)) = O(d*log R) = O(d*log N`<sup>1/(d-1)</sup>`) = O(log N)`.\\n\\nSo the overall time complexity is `O(log N)`<sup>2</sup>. (`N = stoll(n)`)\\n\\n**Improvement for Function `root`:** \\nActually, as @StefanPochmann pointed out in this [post](https://discuss.leetcode.com/topic/76368/python-solution-with-detailed-mathematical-explanation-and-derivation/4) with binomial theorem, only `int64_t k = pow(N, 1./(d-1))` could be the candidate for the root of `f(*,d)`. So method `root` can be simplified as following:\\n```\\n    int64_t root(int64_t d) { // only N^1/(d-1) could be root for f(*,d)\\n      int64_t k;\\n      return d>2? f(k = pow(N,1./(d-1)), d)? 0 : k : N-1;\\n    }\\n```\\nThe overall time complexity still stands as `O((log N)^2)`."
		},
		{
			"lc_ans_id":"96593",
			"view":"555",
			"top":"8",
			"title":"Concise C++ Binary Search solution",
			"vote":"2",
			"content":"The idea is similar to the other solutions\\n```\\nclass Solution {\\npublic:\\n    string smallestGoodBase(string n) {\\n        typedef unsigned long long ll;\\n        ll num = stol(n);\\n        for (ll p = log(num+1) / log(2); p >= 2; --p) {\\n            ll lk = 2, rk = pow(num, 1.0 / (p-1))+1;\\n            while (lk <= rk) {\\n                ll mk = lk + (rk - lk) / 2, sum = 0;\\n                for (ll i = 0, f = 1; i < p; ++i, f *= mk)\\n                    sum += f;\\n                if (sum < num) lk = mk+1;\\n                else if (sum > num) rk = mk-1;\\n                else return to_string(mk);\\n            }\\n        }\\n        return to_string(num-1);\\n    }\\n};"
		},
		{
			"lc_ans_id":"96604",
			"view":"1717",
			"top":"9",
			"title":"Java accepted answer, 11ms",
			"vote":"2",
			"content":"sum base r == 1111... means sum = 1+r+r^2+r^3+...+r^p\\nI tried two different search.\\n1. for r = 2-10, increase p until sum>= n\\n2. for p=2,3,4..., calculate r = sum^(1/p). then try a few numbers around r to see if the sum fits the above equation. In fact, I only tried r and got accepted by OJ.\\n\\n```\\n    public String smallestGoodBase(String n) {\\n        long nl = 0, cur = 1;\\n        for (int i=n.length()-1;i>=0;i--){\\n            nl+=(n.charAt(i)-'0')*cur;\\n            cur*=10;\\n        }\\n        for (long i=2;i<10;i++){\\n            long s = 0;\\n            cur = 1;\\n            for (int j=0;j<nl;j++){\\n                s+=cur;\\n                cur*=i;\\n                if (s == nl) return Long.toString(i);\\n                if (s > nl) break;\\n            }\\n        }\\n        long res = nl-1;\\n        for (int i=2;i<1000;i++){\\n        \\tint r = (int)Math.pow(nl,1.0/i);\\n        \\tif (r<5) break;\\n        \\tif (helper(r,i,nl)&&res>r)\\n        \\t\\tres = r;\\n        }\\n        return Long.toString(res);\\n    }\\n    boolean helper(int r, int i, long nl){\\n    \\tlong res = 0;\\n    \\tlong cur = 1; \\n    \\tfor(int j=0;j<=i;j++){\\n    \\t\\tres+=cur;\\n    \\t\\tcur*=r;\\n    \\t\\tif (cur>1000000000)\\n    \\t\\t\\tcur%=1000000000;\\n    \\t}\\n    \\tif (res%1000000000 == nl%1000000000) return true;\\n    \\telse return false;\\n    }\\n```"
		}
	],
	"id":"475",
	"title":"Smallest Good Base",
	"content":"<p>For an integer n, we call k>=2 a <i><b>good base</b></i> of n, if all digits of n base k are 1.</p>\r\n<p>Now given a string representing n, you should return the smallest good base of n in string format. <br/></p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"13\"\r\n<b>Output:</b> \"3\"\r\n<b>Explanation:</b> 13 base 3 is 111.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"4681\"\r\n<b>Output:</b> \"8\"\r\n<b>Explanation:</b> 4681 base 8 is 11111.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> \"1000000000000000000\"\r\n<b>Output:</b> \"999999999999999999\"\r\n<b>Explanation:</b> 1000000000000000000 base 999999999999999999 is 11.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The range of n is [3, 10^18].</li>\r\n<li>The string representing n is always valid and will not have leading zeros.</li>\r\n</ol>\r\n</p>",
	"frequency":"90",
	"ac_num":"6369"
}