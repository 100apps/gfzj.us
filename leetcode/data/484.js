{
	"difficulty":"3",
	"submit_num":"46181",
	"show_id":"493",
	"leetcode_id":"493",
	"answers":[
		{
			"lc_ans_id":"97268",
			"view":"13463",
			"top":"0",
			"title":"General principles behind problems similar to \"Reverse Pairs\"",
			"vote":"237",
			"content":"It looks like a host of solutions are out there (`BST`-based, `BIT`-based, `Merge-sort`-based). Here I'd like to focus on the general principles behind these solutions and its possible application to a number of similar problems.\\n\\nThe fundamental idea is very simple: **break down the array and solve for the subproblems**.\\n\\nA breakdown of an array naturally reminds us of subarrays. To smoothen our following discussion, let's assume the input array is `nums`, with a total of `n` elements. Let `nums[i, j]` denote the subarray starting from index `i` to index `j` (both inclusive), `T(i, j)` as the same problem applied to this subarray (for example, for [**Reverse Pairs**](https://leetcode.com/problems/reverse-pairs/?tab=Description),  `T(i, j)` will represent the total number of important reverse pairs for subarray `nums[i, j]`). \\n\\nWith the definition above, it's straightforward to identify our original problem as `T(0, n - 1)`. Now the key point is how to construct solutions to the original problem from its subproblems. This is essentially equivalent to building recurrence relations for `T(i, j)`. Since if we can find solutions to `T(i, j)` from its subproblems, we surely can build solutions to larger subarrays until eventually the whole array is spanned.\\n\\nWhile there may be many ways for establishing recurrence relations for `T(i, j)`, here I will only introduce the following two common ones:\\n\\n1. `T(i, j) = T(i, j - 1) + C`, i.e., elements will be processed sequentially and `C` denotes the subproblem for processing the last element of subarray `nums[i, j]`. We will call this sequential recurrence relation.\\n\\n2. `T(i, j) = T(i, m) + T(m + 1, j) + C` where `m = (i+j)/2`, i.e., subarray `nums[i, j]` will be further partitioned into two parts and `C` denotes the subproblem for combining the two parts. We will call this partition recurrence relation.\\n\\nFor either case, the nature of the subproblem `C` will depend on the problem under consideration, and it will determine the overall time complexity of the original problem. So usually it's crucial to find efficient algorithm for solving this subproblem in order to have better time performance. Also pay attention to possibilities of overlapping subproblems, in which case a dynamic programming (DP) approach would be preferred.\\n\\nNext, I will apply these two recurrence relations to this problem \"Reverse Pairs\" and list some solutions for your reference.\\n\\n---\\n**`I -- Sequential recurrence relation`**\\n\\nAgain we assume the input array is `nums` with `n` elements and `T(i, j)` denotes the total number of important reverse pairs for subarray `nums[i, j]`. For sequential recurrence relation, we can set `i = 0`, i.e., the subarray always starts from the beginning. Therefore we end up with:\\n\\n`T(0, j) = T(0, j - 1) + C`\\n\\nwhere the subproblem `C` now becomes **\"find the number of important reverse pairs with the first element of the pair coming from subarray `nums[0, j - 1]`  while the second element of the pair being `nums[j]`\"**.\\n\\nNote that for a pair `(p, q)` to be an important reverse pair, it has to satisfy the following two conditions:\\n1. `p < q`: the first element must come before the second element;\\n2. `nums[p] > 2 * nums[q]`: the first element has to be greater than twice of the second element.\\n\\nFor subproblem `C`, the first condition is met automatically; so we only need to consider the second condition, which is equivalent to searching for all elements within subarray `nums[0, j - 1]` that are greater than twice of `nums[j]`.\\n\\nThe straightforward way of searching would be a linear scan of the subarray, which runs at the order of `O(j)`. From the sequential recurrence relation, this leads to the naive `O(n^2)` solution.\\n\\nTo improve the searching efficiency, a key observation is that the order of elements in the subarray does not matter, since we are only interested in the total number of important reverse pairs. This suggests we may sort those elements and do a binary search instead of a plain linear scan.\\n\\nIf the searching space (formed by elements over which the search will be done) is \"static\" (it does not vary from run to run), placing the elements into an array would be perfect for us to do the binary search. However, this is not the case here. After the `j-th` element is processed, we need to add it to the searching space so that it becomes searchable for later elements, which renders the searching space expanding as more and more elements are processed.\\n\\nTherefore we'd like to strike a balance between searching and insertion operations. This is where data structures like binary search tree (`BST`) or binary indexed tree (`BIT`) prevail, which offers relatively fast performance for both operations.\\n\\n**1. `BST`-based solution**\\n\\nwe will define the tree node as follows, where `val` is the node value and `cnt` is the total number of elements in the subtree rooted at current node that are greater than or equal to `val`:\\n```\\nclass Node {\\n    int val, cnt;\\n    Node left, right;\\n        \\n    Node(int val) {\\n        this.val = val;\\n        this.cnt = 1;\\n    }\\n}\\n```\\nThe searching and insertion operations can be done as follows:\\n```\\nprivate int search(Node root, long val) {\\n    if (root == null) {\\n    \\treturn 0;\\n    } else if (val == root.val) {\\n    \\treturn root.cnt;\\n    } else if (val < root.val) {\\n    \\treturn root.cnt + search(root.left, val);\\n    } else {\\n    \\treturn search(root.right, val);\\n    }\\n}\\n\\nprivate Node insert(Node root, int val) {\\n    if (root == null) {\\n        root = new Node(val);\\n    } else if (val == root.val) {\\n        root.cnt++;\\n    } else if (val < root.val) {\\n        root.left = insert(root.left, val);\\n    } else {\\n        root.cnt++;\\n        root.right = insert(root.right, val);\\n    }\\n    \\n    return root;\\n}\\n```\\nAnd finally the main program, in which we will search for all elements no less than twice of current element plus `1` (converted to `long` type to avoid overflow) while insert the element itself into the BST. \\n\\n**Note:** this homemade BST is not self-balanced and the time complexity can go as bad as `O(n^2)` (in fact you will get `TLE` if you copy and paste the solution here). To guarantee `O(nlogn)` performance, use one of the self-balanced BST's (e.g. `Red-black` tree, `AVL` tree, etc.).\\n```\\npublic int reversePairs(int[] nums) {\\n    int res = 0;\\n    Node root = null;\\n    \\t\\n    for (int ele : nums) {\\n        res += search(root, 2L * ele + 1);\\n        root = insert(root, ele);\\n    }\\n    \\n    return res;\\n}\\n```\\n\\n**2. `BIT`-based solution**\\n\\nFor `BIT`, the searching and insertion operations are:\\n```\\nprivate int search(int[] bit, int i) {\\n    int sum = 0;\\n    \\n    while (i < bit.length) {\\n        sum += bit[i];\\n        i += i & -i;\\n    }\\n\\n    return sum;\\n}\\n\\nprivate void insert(int[] bit, int i) {\\n    while (i > 0) {\\n        bit[i] += 1;\\n        i -= i & -i;\\n    }\\n}\\n```\\nAnd the main program, where again we will search for all elements greater than twice of current element while insert the element itself into the BIT. For each element, the `\"index\"` function will return its index in the `BIT`. Unlike the BST-based solution, this is guaranteed to run at `O(nlogn)`.\\n```\\npublic int reversePairs(int[] nums) {\\n    int res = 0;\\n    int[] copy = Arrays.copyOf(nums, nums.length);\\n    int[] bit = new int[copy.length + 1];\\n    \\n    Arrays.sort(copy);\\n    \\n    for (int ele : nums) {\\n        res += search(bit, index(copy, 2L * ele + 1));\\n        insert(bit, index(copy, ele));\\n    }\\n    \\n    return res;\\n}\\n\\nprivate int index(int[] arr, long val) {\\n    int l = 0, r = arr.length - 1, m = 0;\\n    \\t\\n    while (l <= r) {\\n    \\tm = l + ((r - l) >> 1);\\n    \\t\\t\\n    \\tif (arr[m] >= val) {\\n    \\t    r = m - 1;\\n    \\t} else {\\n    \\t    l = m + 1;\\n    \\t}\\n    }\\n    \\n    return l + 1;\\n}\\n```\\n\\nMore explanation for the BIT-based solution:\\n1. We want the elements to be sorted so there is a sorted version of the input array which is `copy`.\\n\\n2. The `bit` is built upon this sorted array. Its length is one greater than that of the `copy` array to account for the root.\\n\\n3. Initially the `bit` is empty and we start doing a sequential scan of the input array. For each element being scanned, we first search the `bit` to find all elements greater than twice of it and add the result to `res`. We then insert the element itself into the `bit` for future search.\\n\\n4. Note that conventionally searching of the `bit` involves traversing towards the root from some index of the `bit`, which will yield a predefined running total of the `copy` array up to the corresponding index. For insertion, the traversing direction will be opposite and go from some index towards the end of the `bit` array.\\n\\n5. For each scanned element of the input array, its searching index will be given by the index of the first element in the `copy` array that is greater than twice of it (shifted up by `1` to account for the root), while its insertion index will be the index of the first element in the `copy` array that is no less than itself (again shifted up by `1`). This is what the `index` function is for.\\n\\n6. For our case, the running total is simply the number of elements encountered during the traversal process. If we stick to the convention above, the running total will be the number of elements smaller than the one at the given index, since the `copy` array is sorted in ascending order. However, we'd actually like to find the number of elements greater than some value (i.e., twice of the element being scanned), therefore we need to flip the convention. This is what you see inside the `search` and `insert` functions: the former traversing towards the end of the `bit` while the latter towards the root.\\n\\n---\\n**`II -- Partition recurrence relation`**\\n\\nFor partition recurrence relation, setting `i = 0, j = n - 1, m = (n-1)/2`, we have:\\n\\n`T(0, n - 1) = T(0, m) + T(m + 1, n - 1) + C`\\n\\nwhere the subproblem `C` now reads **\"find the number of important reverse pairs with the first element of the pair coming from the left subarray `nums[0, m]`  while the second element of the pair coming from the right subarray `nums[m + 1, n - 1]`\"**.\\n\\nAgain for this subproblem, the first of the two aforementioned conditions is met automatically. As for the second condition, we have as usual this plain linear scan algorithm, applied for each element in the left (or right) subarray. This, to no surprise, leads to the `O(n^2)` naive solution.\\n\\nFortunately the observation holds true here that the order of elements in the left or right subarray does not matter, which prompts sorting of elements in both subarrays. With both subarrays sorted, the number of important reverse pairs can be found in linear time by employing the so-called two-pointer technique: one pointing to elements in the left subarray while the other to those in the right subarray and both pointers will go only in one direction due to the ordering of the elements.\\n\\nThe last question is which algorithm is best here to sort the subarrays. Since we need to partition the array into halves anyway, it is most natural to adapt it into a `Merge-sort`. Another point in favor of `Merge-sort` is that the searching process above can be embedded seamlessly into its merging stage.\\n\\nSo here is the `Merge-sort`-based solution, where the function `\"reversePairsSub\"` will return the total number of important reverse pairs within subarray `nums[l, r]`. The two-pointer searching process is represented by the nested `while` loop involving variable `p`, while the rest is the standard merging algorithm.\\n```\\npublic int reversePairs(int[] nums) {\\n    return reversePairsSub(nums, 0, nums.length - 1);\\n}\\n    \\nprivate int reversePairsSub(int[] nums, int l, int r) {\\n    if (l >= r) return 0;\\n        \\n    int m = l + ((r - l) >> 1);\\n    int res = reversePairsSub(nums, l, m) + reversePairsSub(nums, m + 1, r);\\n        \\n    int i = l, j = m + 1, k = 0, p = m + 1;\\n    int[] merge = new int[r - l + 1];\\n        \\n    while (i <= m) {\\n        while (p <= r && nums[i] > 2L * nums[p]) p++;\\n        res += p - (m + 1);\\n        \\t\\n        while (j <= r && nums[i] >= nums[j]) merge[k++] = nums[j++];\\n        merge[k++] = nums[i++];\\n    }\\n        \\n    while (j <= r) merge[k++] = nums[j++];\\n        \\n    System.arraycopy(merge, 0, nums, l, merge.length);\\n        \\n    return res;\\n}\\n```\\n\\n---\\n**`III -- Summary`**\\n\\nMany problems involving arrays can be solved by breaking down the problem into subproblems applied on subarrays and then link the solution to the original problem with those of the subproblems, to which we have sequential recurrence relation and partition recurrence relation. For either case, it's crucial to identify the subproblem `C` and find efficient algorithm for approaching it.\\n\\nIf the subproblem `C` involves searching on \"dynamic searching space\", try to consider data structures that support relatively fast operations on both searching and updating (such as `self-balanced BST`, `BIT`, `Segment tree`, `...`).\\n\\nIf the subproblem `C` of partition recurrence relation involves sorting, `Merge-sort` would be a nice sorting algorithm to use. Also, the code could be made more elegant if the solution to the subproblem can be embedded into the merging process.\\n\\nIf there are overlapping among the subproblems `T(i, j)`, it's preferable to cache the intermediate results for future lookup.\\n\\nLastly let me name a few leetcode problems that fall into the patterns described above and thus can be solved with similar ideas.\\n\\n[315. Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)\\n[327. Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/)\\n\\nFor `leetcode 315`, applying the sequential recurrence relation (with `j` fixed), the subproblem `C` reads: **find the number of elements out of visited ones that are smaller than current element**, which involves searching on \"dynamic searching space\"; applying the partition recurrence relation, we have a subproblem `C`: **for each element in the left half, find the number of elements in the right half that are smaller than it**, which can be embedded into the merging process by noting that these elements are exactly those swapped to its left during the merging process.\\n\\nFor `leetcode 327`, applying the sequential recurrence relation (with `j` fixed) on the pre-sum array, the subproblem `C` reads: **find the number of elements out of visited ones that are within the given range**, which again involves searching on \"dynamic searching space\"; applying the partition recurrence relation, we have a subproblem `C`: **for each element in the left half, find the number of elements in the right half that are within the given range**, which can be embedded into the merging process using the two-pointer technique.\\n\\nAnyway, hope these ideas can sharpen your skills for solving array-related problems."
		},
		{
			"lc_ans_id":"97280",
			"view":"8093",
			"top":"1",
			"title":"Very Short and Clear MergeSort & BST Java Solutions",
			"vote":"41",
			"content":"**MergeSort**\\n\\n**Explanation:**  In each round, we divide our array into two parts and sort them. So after \"int cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid+1, e); \", the left part and the right part are sorted and now our only job is to count how many pairs of number (leftPart[i], rightPart[j]) satisfies leftPart[i] <= 2*rightPart[j]. \\nFor example, \\nleft: 4 6 8   right: 1 2 3\\nso we use two pointers to travel left and right parts. For each leftPart[i], if j<=e && nums[i]/2.0 > nums[j], we just continue to move j to the end, to increase rightPart[j], until it is valid. Like in our example, left's 4 can match 1 and 2; left's 6 can match 1, 2, 3, and left's 8 can match 1, 2, 3. So in this particular round, there are 8 pairs found, so we increases our total by 8. \\n\\n```\\npublic class Solution {\\n    public int reversePairs(int[] nums) {\\n        return mergeSort(nums, 0, nums.length-1);\\n    }\\n    private int mergeSort(int[] nums, int s, int e){\\n        if(s>=e) return 0; \\n        int mid = s + (e-s)/2; \\n        int cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid+1, e); \\n        for(int i = s, j = mid+1; i<=mid; i++){\\n            while(j<=e && nums[i]/2.0 > nums[j]) j++; \\n            cnt += j-(mid+1); \\n        }\\n        Arrays.sort(nums, s, e+1); \\n        return cnt; \\n    }\\n}\\n```\\n**Or:** \\nBecause left part and right part are sorted, you can replace the Arrays.sort() part with a actual merge sort process. The previous version is easy to write, while this one is faster. \\n\\n```\\npublic class Solution {\\n    int[] helper;\\n    public int reversePairs(int[] nums) {\\n        this.helper = new int[nums.length];\\n        return mergeSort(nums, 0, nums.length-1);\\n    }\\n    private int mergeSort(int[] nums, int s, int e){\\n        if(s>=e) return 0; \\n        int mid = s + (e-s)/2; \\n        int cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid+1, e); \\n        for(int i = s, j = mid+1; i<=mid; i++){\\n            while(j<=e && nums[i]/2.0 > nums[j]) j++; \\n            cnt += j-(mid+1); \\n        }\\n        //Arrays.sort(nums, s, e+1); \\n        myMerge(nums, s, mid, e);\\n        return cnt; \\n    }\\n    \\n    private void myMerge(int[] nums, int s, int mid, int e){\\n        for(int i = s; i<=e; i++) helper[i] = nums[i];\\n        int p1 = s;//pointer for left part\\n        int p2 = mid+1;//pointer for rigth part\\n        int i = s;//pointer for sorted array\\n        while(p1<=mid || p2<=e){\\n            if(p1>mid || (p2<=e && helper[p1] >= helper[p2])){\\n                nums[i++] = helper[p2++];\\n            }else{\\n                nums[i++] = helper[p1++];\\n            }\\n        }\\n    }\\n}\\n```\\n\\n\\n------------------------------------------------------------------------\\n\\n**BST**\\nBST solution is no longer acceptable, because it's performance can be very bad, O(n^2) actually, for extreme cases like [1,2,3,4......49999], due to the its unbalance, but I am still providing it below just FYI. \\nWe build the Binary Search Tree from right to left, and at the same time, search the partially built tree with nums[i]/2.0. The code below should be clear enough. \\n```\\npublic class Solution {\\n    public int reversePairs(int[] nums) {\\n        Node root = null;\\n        int[] cnt = new int[1];\\n        for(int i = nums.length-1; i>=0; i--){\\n            search(cnt, root, nums[i]/2.0);//search and count the partially built tree\\n            root = build(nums[i], root);//add nums[i] to BST\\n        }\\n        return cnt[0];\\n    }\\n    \\n    private void search(int[] cnt, Node node, double target){\\n        if(node==null) return; \\n        else if(target == node.val) cnt[0] += node.less;\\n        else if(target < node.val) search(cnt, node.left, target);\\n        else{\\n            cnt[0]+=node.less + node.same; \\n            search(cnt, node.right, target);\\n        }\\n    }\\n    \\n    private Node build(int val, Node n){\\n        if(n==null) return new Node(val);\\n        else if(val == n.val) n.same+=1;\\n        else if(val > n.val) n.right = build(val, n.right);\\n        else{\\n            n.less += 1;\\n            n.left = build(val, n.left);\\n        }\\n        return n;\\n    }\\n    \\n    class Node{\\n        int val, less = 0, same = 1;//less: number of nodes that less than this node.val\\n        Node left, right;\\n        public Node(int v){\\n            this.val = v;\\n        }\\n    }\\n}\\n```\\nSimilar to this https://leetcode.com/problems/count-of-smaller-numbers-after-self/. But the main difference is: here, the number to add and the number to search are different (add nums[i], but search nums[i]/2.0), so not a good idea to combine build and search together."
		},
		{
			"lc_ans_id":"97287",
			"view":"2941",
			"top":"2",
			"title":"C++ with iterators",
			"vote":"14",
			"content":"Just a mergesort solution, but using iterators (instead of indexes) and `inplace_merge`.\\n\\n```\\nclass Solution {\\npublic:\\n    int sort_and_count(vector<int>::iterator begin, vector<int>::iterator end) {\\n        if (end - begin <= 1)\\n            return 0;\\n        auto mid = begin + (end - begin) / 2;\\n        int count = sort_and_count(begin, mid) + sort_and_count(mid, end);\\n        for (auto i = begin, j = mid; i != mid; ++i) {\\n            while (j != end and *i > 2L * *j)\\n                ++j;\\n            count += j - mid;\\n        }\\n        inplace_merge(begin, mid, end);\\n        return count;\\n    }\\n\\n    int reversePairs(vector<int>& nums) {\\n        return sort_and_count(nums.begin(), nums.end());\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"97272",
			"view":"2807",
			"top":"3",
			"title":"Clean Java Solution using Enhanced Binary Search Tree",
			"vote":"13",
			"content":"This is literally the same problem with [315. Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/).\\nThe only difference is to find count of numbers smaller than ```half``` of the current number after itself. \\nTo efficiently search for count of numbers smaller than a target, we can use a Binary Search Tree. There is a little change of the TreeNode to include count of numbers ```smaller or equal``` to it. This will make the query even faster because we don't need to traverse all its left sub-tree to get the count.\\n\\nOverall Algorithm:\\n1. Scan the numbers from right to left.\\n2. First search the tree to get ```count``` of numbers smaller than ```nums[i] / 2.0```, sum to the final result.\\n3. Insert ```nums[i]``` to the tree.\\n\\nInsert logic:\\n1. Recursively try to find a place to insert this number. When root is ```null```, its time to create a new node. If meet the ```same``` number, just increase the ```count```.\\n2. When try to insert the number to left sub-tree, increase ```count``` of current node.\\n\\nQuery logic:\\n1. If target value is greater than the current value, meaning current node and all left sub-tree are ```smaller``` than target, return ```count``` (remember it stands for count of numbers ```smaller or equal``` to current number) of current node ```plus``` any possible smaller number than target in ```right``` sub-tree.\\n2. Otherwise, only search ```left``` sub-tree.\\n\\n```\\npublic class Solution {\\n    class Node {\\n\\tint value, count;\\n\\tNode left, right;\\n\\tNode (int v) {\\n\\t    value = v; count = 1;\\n\\t}\\n    }\\n\\t\\n    public int reversePairs(int[] nums) {\\n        int result = 0;\\n        if (nums == null || nums.length <= 1) return result;\\n        \\n        int len = nums.length;\\n\\tNode root = new Node(nums[len - 1]);\\n\\t    \\n\\tfor(int i = len - 2; i >= 0; i--) {\\n\\t    result += query(root, nums[i] / 2.0);\\n\\t    insert(root, nums[i]);\\n\\t}\\n\\n\\treturn result;\\n    }\\n    \\n    private Node insert(Node root, int value) {\\n\\tif (root == null) return new Node(value);\\n\\t\\t\\n\\tif (root.value == value) {\\n\\t    root.count++;\\n\\t}\\n\\telse if (root.value > value) {\\n\\t    root.count++;\\n\\t    root.left = insert(root.left, value);\\n\\t}\\n\\telse {\\n\\t    root.right = insert(root.right, value);\\n\\t}\\n\\t\\t\\n\\treturn root;\\n    }\\n\\t\\n    private int query(Node root, double value) {\\n\\tif (root == null) return 0;\\n\\t\\t\\n\\tif (value > root.value) {\\n\\t    return root.count + query(root.right, value);\\n\\t}\\n\\telse {\\n\\t    return query(root.left, value);\\n\\t}\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"97315",
			"view":"2507",
			"top":"4",
			"title":"Java merge sort solution, O(nlog(n))",
			"vote":"10",
			"content":"Similar with count smaller after self, just scan the array before merge\\n```\\npublic class Solution {\\n        \\n    public int ret;\\n    public int reversePairs(int[] nums) {\\n        ret = 0;\\n        mergeSort(nums, 0, nums.length-1);\\n        return ret;\\n    }\\n\\n    public void mergeSort(int[] nums, int left, int right) {\\n        if (right <= left) {\\n            return;\\n        }\\n        int middle = left + (right - left)/2;\\n        mergeSort(nums, left, middle);\\n        mergeSort(nums,middle+1, right);\\n\\n        //count elements\\n        int count = 0;\\n        for (int l = left, r = middle+1; l <= middle;) {\\n            if (r > right || (long)nums[l] <= 2*(long)nums[r]) {\\n                l++;\\n                ret += count;\\n            } else {\\n                r++;\\n                count++;\\n            }\\n        }\\n        \\n        //merge sort\\n        int[] temp = new int[right - left + 1];\\n        for (int l = left, r = middle+1, k = 0; l <= middle || r <= right;) {\\n            if (l <= middle && ((r > right) || nums[l] < nums[r])) {\\n                temp[k++] = nums[l++];\\n            } else {\\n                temp[k++] = nums[r++];\\n            }\\n        }\\n        for (int i = 0; i < temp.length; i++) {\\n            nums[left + i] = temp[i];\\n        }\\n    }\\n}\\n```\\nClearer and simpler version, but slower, got the idea by [another solution](https://discuss.leetcode.com/topic/78953/c-solution-using-merge-sort) \\n\\n```\\npublic class Solution {\\n        \\n    public int ret;\\n    public int reversePairs(int[] nums) {\\n        ret = 0;\\n        mergeSort(nums, 0, nums.length-1);\\n        return ret;\\n    }\\n\\n    public void mergeSort(int[] nums, int left, int right) {\\n        if (right <= left) {\\n            return;\\n        }\\n        int middle = left + (right - left)/2;\\n        mergeSort(nums, left, middle);\\n        mergeSort(nums,middle+1, right);\\n\\n        //count elements\\n        int count = 0;\\n        for (int l = left, r = middle+1; l <= middle;) {\\n            if (r > right || (long)nums[l] <= 2*(long)nums[r]) {\\n                l++;\\n                ret += count;\\n            } else {\\n                r++;\\n                count++;\\n            }\\n        }\\n        \\n        //sort\\n        Arrays.sort(nums, left, right + 1);   \\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"97323",
			"view":"804",
			"top":"5",
			"title":"Well explained O(nlogn) Python Solution based on mergesort",
			"vote":"7",
			"content":"Count \"important reverse pairs\" while doing mergesort:\\nWhen we're doing mergesort, original index of elements in left part (smaller side), i, must less than those in right part, j.\\nSimply compare nums[i] and 2*nums[j] and sum them up.\\n\\nNote that those partial lists induced during mergesort here are generated by sorted(), instead of building it one by one.\\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.cnt = 0\\n    def reversePairs(self, nums):\\n        def msort(lst):\\n            # merge sort body\\n            L = len(lst)\\n            if L <= 1:                          # base case\\n                return lst\\n            else:                               # recursive case\\n                return merger(msort(lst[:int(L/2)]), msort(lst[int(L/2):]))\\n        def merger(left, right):\\n            # merger\\n            l, r = 0, 0                         # increase l and r iteratively\\n            while l < len(left) and r < len(right):\\n                if left[l] <= 2*right[r]:\\n                    l += 1\\n                else:\\n                    self.cnt += len(left)-l     # add here\\n                    r += 1\\n            return sorted(left+right)           # I can't avoid TLE without timsort...\\n\\n        msort(nums)\\n        return self.cnt\\n```"
		},
		{
			"lc_ans_id":"97319",
			"view":"1101",
			"top":"6",
			"title":"C++ Solution using merge sort",
			"vote":"5",
			"content":"\\n```\\nclass Solution {\\nprivate:\\n    int count;\\n   \\n    void checkCount(vector<int>& nums, int start, int mid, int end){\\n\\n        // two pointers;\\n        int l = start, r = mid + 1;\\n        while(l <= mid && r <= end){\\n            if((long)nums[l] > (long) 2 * nums[r]){\\n                count += (mid - l + 1);\\n                r++;\\n            }else{\\n                l++;\\n            }\\n        }\\n       // worst case might be nlog(n) \\n        sort(nums.begin() + start, nums.begin() + end + 1);\\n        return;\\n        \\n        \\n        \\n        //every step sort\\n    }\\n    void mergeSort(vector<int>& nums, int start, int end){\\n        if(start == end) return;\\n        \\n        int mid = (start + end)/2;\\n        mergeSort(nums,start, mid);\\n        mergeSort(nums,mid+1,end);\\n        \\n        checkCount(nums,start,mid,end);\\n        return;\\n        \\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        if(!nums.size())return 0;\\n        count = 0;\\n        mergeSort(nums,0,nums.size()-1);\\n        return count;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"97312",
			"view":"392",
			"top":"7",
			"title":"C++ solution using balanced binary search tree O(nlgn)",
			"vote":"4",
			"content":"Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].\\n\\nScanning the number from left to right, for each number nums[j]\\n1. Search the  tree to find all the numbers nums[i] where nums[i] > 2*nums[j].\\n2. Insert nums[j] to the tree and balance the tree.\\n\\nReference: https://www.cpp.edu/~ftang/courses/CS241/notes/self%20balance%20bst.htm\\n\\n```\\nclass Solution {\\npublic:\\n    struct node{\\n        //count:number of nodes from root itself;  \\n        //self:number of nodes sharing the same val;\\n        //height: tree height\\n        int val,count,height,self;\\n        node* left;\\n        node* right;\\n        node(int k):val(k),count(1),self(1),height(1),left(0),right(0){};\\n        void fix_count_height() { //update count and height\\n            count = self + (left?left->count:0) + (right?right->count:0);\\n            height = 1 + max((left?left->height:0),(right?right->height:0));\\n        }\\n    };\\n    \\n    /*           p                              q            node: p,q\\n               /   \\\\     right rotation       /   \\\\          Tree: A,B,C\\n              q     C    -------------->     A     p\\n            /   \\\\        <--------------         /   \\\\\\n           A     B       left rotation          B     C\\n    */\\n    node* right_rotation(node* p){ // O(1) time complexity\\n        node* q = p->left;       \\n        p->left = q->right;    \\n        q->right = p;          \\n        p->fix_count_height();\\n        q->fix_count_height();\\n        return q; //return new root q after rotation\\n    }\\n    node* left_rotation(node* q){ // O(1) time complexity\\n        node* p = q->right;\\n        q->right = p->left;\\n        p->left = q;\\n        q->fix_count_height();\\n        p->fix_count_height(); \\n        return p; //return new root p after rotation\\n    }\\n    \\n    int bfactor(node* p){ //balance factor = 1,0,-1 are considered balanced from root p \\n        int hr = (p->right) ? p->right->height : 0;\\n        int hl = (p->left) ? p->left->height : 0;\\n        return hr-hl;\\n    }\\n    \\n    //insert k key in a tree from root r, return the new root after insertion\\n    node* insert(node* r, int k){ // O(log(n)) time complexity\\n        if(!r) return new node(k);\\n        if(k < r->val)\\n            r->left = insert(r->left,k);\\n        else if(k > r->val)\\n            r->right = insert(r->right,k);\\n        else{\\n            r->self++;\\n            r->count++;\\n            return r;\\n        }\\n        \\n        //balance the tree if one child's height is greater by 2 than the other child\\n        if(bfactor(r) >= 2){\\n            if(bfactor(r->right) < 0)\\n                r->right = right_rotation(r->right);\\n            return left_rotation(r);\\n        }\\n        else if(bfactor(r) <= -2){\\n            if(bfactor(r->left) > 0)\\n                r->left = left_rotation(r->left);\\n            return right_rotation(r);\\n        }\\n        else{ //no need to rotate the tree, just update the node's count and height \\n            r->fix_count_height();\\n            return r;\\n        }\\n    }\\n    \\n    //search the tree from root, count the nodes n where n->val > key .\\n    int search(const long long key, node* root){ // O(lg(n)) time complexity\\n        if(!root) return 0;\\n        if(root->val < key)\\n            return search(key,root->right);\\n        else if(root->val > key)\\n            return ( root->self + (root->right ? root->right->count : 0) ) + search(key,root->left);\\n        else //root->val == key\\n            return (root->right) ? root->right->count : 0;\\n    }\\n    \\n    int reversePairs(vector<int>& nums) {\\n        int size = nums.size();\\n        if(size<2)  return 0;\\n        \\n        //Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].\\n        node* root = 0;\\n        root = insert(root,nums[0]);\\n        int count = 0;\\n        for(int j=1; j<size; j++){\\n            int numsj = nums[j];\\n            count += search(2*(long long)numsj,root);\\n            root = insert(root, numsj);\\n        }\\n        return count;\\n    }\\n}; \\n```"
		},
		{
			"lc_ans_id":"97306",
			"view":"708",
			"top":"8",
			"title":"<= 20 lines Java code. Beats 100%!!",
			"vote":"4",
			"content":"Thanks to @Pepsi's solution of [327. Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/?tab=Description). My code below is so similar with the one Pepsi posted [here](https://discuss.leetcode.com/topic/33738/share-my-solution). \\n\\n@Chidong's solution with BST is really impressive, but I think because it *may not be a balanced tree*, his solution maybe not *strictly* O(nlogn), but **merge sort** can do it with **worst case time complexity** in **O(nlogn)**, so that my solution could beat 100%. That's just my guess. please let me know if I am wrong.\\n\\n```\\npublic class Solution {\\n    public int reversePairs(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        return mergeSort(nums, 0, nums.length - 1);\\n    }\\n    private int mergeSort(int[] nums, int l, int r) {\\n        if (l >= r) return 0;\\n        int mid = l + (r - l)/2;\\n        int count = mergeSort(nums, l, mid) + mergeSort(nums, mid + 1, r);\\n        int[] cache = new int[r - l + 1];\\n        int i = l, t = l, c = 0;\\n        for (int j = mid + 1; j <= r; j++, c++) {\\n            while (i <= mid && nums[i] <= 2 * (long)nums[j]) i++;\\n            while (t <= mid && nums[t] < nums[j]) cache[c++] = nums[t++];\\n            cache[c] = nums[j];\\n            count += mid - i + 1;\\n        }\\n        while (t <= mid) cache[c++] = nums[t++];\\n        System.arraycopy(cache, 0, nums, l, r - l + 1);\\n        return count;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"97303",
			"view":"495",
			"top":"9",
			"title":"C++ solution using binary search + Fenwick tree",
			"vote":"3",
			"content":"\\n\\nThis is obviously not a fast or short solution at all. But if you want to review the usage of Fenwick tree I wish this could be helpful. The basic idea is similar to LC315, but binary search is used to maintain another map so we know where to \"count\" the numbers. A detailed implementation of Fenwick tree is also given for the purpose of reviewing old knowledge...\\n\\n      class Fenwick {\\n      private:\\n      \\t// tree is one unit shiftd from a virtual vector arr[]\\n      \\tvector<long> tree;\\n      \\tlong lsb(long i) { return i & (-i); }\\n      public:\\n      \\tFenwick(long size) {\\n      \\t\\ttree = vector<long>(size + 1, 0);\\n      \\t}\\n      \\n      \\t// the following function sums up arr[0..id]\\n      \\tlong sum(long id) {\\n      \\t\\tid++;\\n      \\t\\tlong ret = 0;\\n      \\t\\twhile(id > 0) {\\n      \\t\\t\\tret += tree[id];\\n      \\t\\t\\tid -= lsb(id);\\n      \\t\\t}\\n      \\t\\treturn ret;\\n      \\t}\\n      \\n      \\t// the following function increases arr[id]\\n      \\tvoid add(long id, long val) {\\n      \\t\\tlong n = tree.size();\\n      \\t\\tid++;\\n      \\t\\twhile(id < n) {\\n      \\t\\t\\ttree[id] += val;\\n      \\t\\t\\tid += lsb(id);\\n      \\t\\t}\\n      \\t}\\n      \\n      };\\n      \\n      \\n      \\n      class Solution {\\n      public:\\n      \\tlong reversePairs(vector<int>& nums) {\\n      \\t\\tvector<long> nums2;\\n      \\t\\tfor(long i : nums) {\\n      \\t\\t\\tnums2.push_back(2*i);\\n      \\t\\t}\\n      \\n      \\t\\tsort(nums2.begin(), nums2.end());\\n      \\t\\t// order maps the original order to sorted order, it doesn't matter if duplicated is present\\n      \\t\\tunordered_map<long, long> order;\\n      \\t\\t\\n      \\t\\t// binary search result, notice that this is index<->index map \\n      \\t\\tunordered_map<long, long> biorder;\\n      \\t\\tlong ret = 0;\\n      \\t\\tlong n = nums.size();\\n      \\t\\tfor(long i = 0; i < n; ++i) {\\n      \\t\\t\\tbiorder[i] = lower_bound(nums2.begin(), nums2.end(), nums[i]) - nums2.begin();\\n      \\t\\t\\torder[nums2[i]/2] = i;\\n      \\t\\t}\\n      \\n      \\t\\tFenwick fw(n);\\n      \\t\\tfor(long i = n-1; i>=0; --i) {\\n      \\t\\t\\tret += fw.sum(biorder[i]-1);\\n      \\t\\t\\tfw.add(order[nums[i]], 1);\\n      \\t\\t}\\n      \\t\\treturn ret;\\n      \\t}\\n      };"
		}
	],
	"id":"484",
	"title":"Reverse Pairs",
	"content":"<p>Given an array <code>nums</code>, we call <code>(i, j)</code> an <b><i>important reverse pair</i></b> if <code>i &lt; j</code> and <code>nums[i] &gt; 2*nums[j]</code>.</p>\r\n\r\n<p>You need to return the number of important reverse pairs in the given array.</p>\r\n\r\n<p><b>Example1:</b>\r\n<pre>\r\n<b>Input</b>: [1,3,2,3,1]\r\n<b>Output</b>: 2\r\n</pre></p>\r\n\r\n<p><b>Example2:</b>\r\n<pre>\r\n<b>Input</b>: [2,4,3,5,1]\r\n<b>Output</b>: 3\r\n</pre></p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the given array will not exceed <code>50,000</code>.</li>\r\n<li>All the numbers in the input array are in the range of 32-bit integer.</li>\r\n</ol>\r\n</p>",
	"frequency":"129",
	"ac_num":"9734"
}