{
	"difficulty":"3",
	"submit_num":"13483",
	"show_id":"499",
	"leetcode_id":"499",
	"answers":[
		{
			"lc_ans_id":"97797",
			"view":"4171",
			"top":"0",
			"title":"Similar to The Maze II. Easy-understanding Java bfs solution.",
			"vote":"16",
			"content":"Solution of *The Maze*: https://discuss.leetcode.com/topic/77471/easy-understanding-java-bfs-solution\\nSolution of *The Maze II*: https://discuss.leetcode.com/topic/77472/similar-to-the-maze-easy-understanding-java-bfs-solution\\n\\nWe just need to implement `Comparable` of `Point`, and record the route of every point.\\n``` java\\npublic class Solution {\\n    class Point implements Comparable<Point> {\\n        int x,y,l;\\n        String s;\\n        public Point(int _x, int _y) {x=_x;y=_y;l=Integer.MAX_VALUE;s=\"\";}\\n        public Point(int _x, int _y, int _l,String _s) {x=_x;y=_y;l=_l;s=_s;}\\n        public int compareTo(Point p) {return l==p.l?s.compareTo(p.s):l-p.l;}\\n    }\\n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\\n        int m=maze.length, n=maze[0].length;\\n        Point[][] points=new Point[m][n];\\n        for (int i=0;i<m*n;i++) points[i/n][i%n]=new Point(i/n, i%n);\\n        int[][] dir=new int[][] {{-1,0},{0,1},{1,0},{0,-1}};\\n        String[] ds=new String[] {\"u\",\"r\",\"d\",\"l\"};\\n        PriorityQueue<Point> list=new PriorityQueue<>(); // using priority queue\\n        list.offer(new Point(ball[0], ball[1], 0, \"\"));\\n        while (!list.isEmpty()) {\\n            Point p=list.poll();\\n            if (points[p.x][p.y].compareTo(p)<=0) continue; // if we have already found a route shorter\\n            points[p.x][p.y]=p;\\n            for (int i=0;i<4;i++) {\\n                int xx=p.x, yy=p.y, l=p.l;\\n                while (xx>=0 && xx<m && yy>=0 && yy<n && maze[xx][yy]==0 && (xx!=hole[0] || yy!=hole[1])) {\\n                    xx+=dir[i][0];\\n                    yy+=dir[i][1];\\n                    l++;\\n                }\\n                if (xx!=hole[0] || yy!=hole[1]) { // check the hole\\n                    xx-=dir[i][0];\\n                    yy-=dir[i][1];\\n                    l--;\\n                }\\n                list.offer(new Point(xx, yy, l, p.s+ds[i]));\\n            }\\n        }\\n        return points[hole[0]][hole[1]].l==Integer.MAX_VALUE?\"impossible\":points[hole[0]][hole[1]].s;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"97832",
			"view":"2575",
			"top":"1",
			"title":"Clear Java Accepted DFS Solution with Explanation",
			"vote":"12",
			"content":"```\\npublic class Solution {\\n    int min; //min distance to hole\\n    String minS; //min distance's path string\\n    int[] hole;\\n    int[][] maze; \\n    int[][] map; //shortest distant traveling from ball to this point\\n    int[][] dirs = {{0,1},{-1,0},{1,0},{0,-1}}; //r, u, d, l\\n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\\n        this.min = Integer.MAX_VALUE; \\n        this.minS = null;\\n        this.hole = hole; \\n        this.maze = maze; \\n        this.map = new int[maze.length][maze[0].length];\\n        for(int i = 0; i<map.length; i++) Arrays.fill(map[i], Integer.MAX_VALUE); \\n        \\n        move(ball[0], ball[1], 0, \"\", -1);\\n        return (minS==null) ? \"impossible\" : minS;\\n    }\\n    \\n    private void move(int r, int c, int cnt, String path, int dir){//dir is a index of dirs \\n        if(cnt > min || cnt > map[r][c]) return; //not a shortest route for sure \\n        if(dir!=-1){//if not from start point \\n            //add path \\n            if(dir==0) path+='r';\\n            else if(dir==1) path+='u';\\n            else if(dir==2) path+='d';\\n            else path+='l';\\n    \\n            //roll along dir \\n            while(r>=0 && r<maze.length && c>=0 && c<maze[0].length && maze[r][c]==0){\\n                map[r][c] = Math.min(map[r][c], cnt); \\n                if(r==hole[0] && c==hole[1]){//check hole\\n                    if(cnt==min && path.compareTo(minS)<0){\\n                        minS=path;\\n                    }else if(cnt<min){\\n                        min = cnt; \\n                        minS = path; \\n                    }\\n                    return; \\n                }\\n                r += dirs[dir][0];\\n                c += dirs[dir][1];\\n                cnt++;\\n            }\\n            r -= dirs[dir][0];//[r,c] is wall, need to walk back 1 step\\n            c -= dirs[dir][1];\\n            cnt--;\\n        }\\n        \\n        //hit wall (or start) -> try to turn\\n        for(int i = 0; i<dirs.length; i++){\\n            if(dir == i) continue;//dont keep going\\n            if(dir == (3-i)) continue;//dont go back\\n            int newR = r + dirs[i][0];\\n            int newC = c + dirs[i][1];\\n            if(newR>=0 && newR<maze.length && newC>=0 && newC<maze[0].length && maze[newR][newC]==0){//can go\\n                move(r, c, cnt, path, i);\\n            }\\n        }\\n    }\\n}\\n```\\nEach time, first add the direction to the path, and then go with that direction, checking for hole along the way. When hit a wall, try to turn, and go with the new direction. For the starting point, don't \"go\", jump directly to \"turn\" part."
		},
		{
			"lc_ans_id":"97808",
			"view":"963",
			"top":"2",
			"title":"Simple Python Explanation",
			"vote":"9",
			"content":"We can use Dijkstra's algorithm to find the shortest distance from the ball to the hole.  If you are unfamiliar with this algorithm, how it works is that we process events in priority order, where the priority is (distance, path_string).  When an event is processed, it adds neighboring nodes with respective distance.  To repeatedly find the highest priority node to process, we use a heap (priority queue or 'pq'), where we can add nodes with logarithmic time complexity, and maintains the invariant that pq[0] is always the smallest (highest priority.)  When we reach the hole for the first time (if we do), we are guaranteed to have the right answer in terms of having the shortest distance and the lexicographically smallest path-string.\\n\\nWhen we look for the neighbors of a location in the matrix, we simulate walking up/left/right/down as long as we are inside the bounds of the matrix and the path is clear.  If during this simulation we reach the hole prematurely, we should also stop.  If after searching with our algorithm it is the case that we never reached the hole, then the task is impossible.\\n```\\ndef findShortestWay(self, A, ball, hole):\\n    ball, hole = tuple(ball), tuple(hole)\\n    R, C = len(A), len(A[0])\\n    \\n    def neighbors(r, c):\\n        for dr, dc, di in [(-1, 0, 'u'), (0, 1, 'r'), \\n                           (0, -1, 'l'), (1, 0, 'd')]:\\n            cr, cc, dist = r, c, 0\\n            while (0 <= cr + dr < R and \\n                    0 <= cc + dc < C and\\n                    not A[cr+dr][cc+dc]):\\n                cr += dr\\n                cc += dc\\n                dist += 1\\n                if (cr, cc) == hole:\\n                    break\\n            yield (cr, cc), di, dist\\n    \\n    pq = [(0, '', ball)]\\n    seen = set()\\n    while pq:\\n        dist, path, node = heapq.heappop(pq)\\n        if node in seen: continue\\n        if node == hole: return path\\n        seen.add(node)\\n        for nei, di, nei_dist in neighbors(*node):\\n            heapq.heappush(pq, (dist+nei_dist, path+di, nei) )\\n        \\n    return \"impossible\"\\n```"
		},
		{
			"lc_ans_id":"97831",
			"view":"317",
			"top":"3",
			"title":"Short,clean and straight forward BFS solution with PriorityQueue",
			"vote":"5",
			"content":"The idea is just using BFS with a PriorityQueue(dijkstra's algorithm), PriorityQueue polls out the Coordinate with the minimum distance, if there are two with same distance, we compare their lexicographical order, by this way, we can ensure that we get the lexicographically smallest way in the end.\\n\\n```\\npublic class Solution {\\n    class Coordinate implements Comparable<Coordinate> {\\n        int x, y, dist;\\n        String moves;\\n\\n        public Coordinate(int x, int y, int dist, String moves) {\\n            this.x = x;\\n            this.y = y;\\n            this.dist = dist;\\n            this.moves = moves;\\n        }\\n        \\n        public int compareTo(Coordinate that) {\\n            if (this.dist != that.dist)     return this.dist - that.dist;\\n            return this.moves.compareTo(that.moves);\\n        }\\n    }\\n    \\n    int[][] dirs = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};\\n    char[] dirc = {'d', 'l', 'r', 'u'};\\n    \\n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\\n        int m = maze.length, n = maze[0].length;\\n\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        PriorityQueue<Coordinate> pq = new PriorityQueue<>();\\n        pq.add(new Coordinate(ball[0], ball[1], 0, \"\"));\\n        \\n        while(!pq.isEmpty()) {\\n            Coordinate curr = pq.poll();\\n            \\n            if (curr.x == hole[0] && curr.y == hole[1]) {\\n                return curr.moves;\\n            }\\n            \\n            if (!visited[curr.x][curr.y]) {\\n                visited[curr.x][curr.y] = true;\\n                for (int direction = 0; direction < 4; direction++) {\\n                    Coordinate next = moveForward(maze, curr, direction, hole);\\n                    pq.add(new Coordinate(next.x, next.y, next.dist, next.moves + dirc[direction]));\\n                }\\n            }\\n        }\\n        return \"impossible\";\\n    }\\n    \\n/*\\n    Start from current position move forward in one direction until hit the wall, return the last position before hitting the wall\\n*/\\n    private Coordinate moveForward(int[][] maze, Coordinate curr, int direction, int[] hole) {\\n        int m = maze.length, n = maze[0].length;\\n        int nx = curr.x, ny = curr.y, dis = curr.dist;\\n        while (nx >= 0 && nx < m && ny >= 0 && ny < n && maze[nx][ny] == 0) {\\n            nx += dirs[direction][0];\\n            ny += dirs[direction][1];\\n            dis++;\\n            if (nx == hole[0] && ny == hole[1]) {\\n                return new Coordinate(nx, ny, dis, curr.moves);\\n            }\\n        }\\n        // back up one step from wall\\n        nx -= dirs[direction][0];\\n        ny -= dirs[direction][1];\\n        dis--;\\n        return new Coordinate(nx, ny, dis, curr.moves);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"97813",
			"view":"1038",
			"top":"4",
			"title":"C++ DFS 9ms 14 lines",
			"vote":"5",
			"content":"I am rolling the ball from the stopping point recursively in the down-left-right-up order, and keeping track of the path with the shortest distance. That way, the first discovered path will be lexicographically smallest (if distance is the same). Except the very first roll, the ball is rolled only vertically (down and up) or horizontally (left and right), alternating.\\n\\nWhen the ball stops, I am using the existing maze vector to store the current distance. If the ball was there before, I only continue the search if the current distance is smaller.\\n```\\nstring roll(vector<vector<int>>& maze, int rowBall, int colBall, const vector<int>& hole, \\n    int d_row, int d_col, int steps, const string& path, pair<string, int>& res)\\n{\\n    if (steps < res.second) {\\n        if (d_row != 0 || d_col != 0) { // both are zero for the initial ball position.\\n            while ((rowBall + d_row) >= 0 && (colBall + d_col) >= 0 && (rowBall + d_row) <  maze.size() \\n                && (colBall + d_col) < maze[0].size() && maze[rowBall + d_row][colBall + d_col] != 1) \\n            {\\n                rowBall += d_row;\\n                colBall += d_col;\\n                ++steps;\\n                if (rowBall == hole[0] && colBall == hole[1] && steps < res.second) res = {path, steps};\\n            }\\n        }\\n        if (maze[rowBall][colBall] == 0 || steps + 2 < maze[rowBall][colBall]) {\\n            maze[rowBall][colBall] = steps + 2; // '1' is for the walls.\\n            if (d_row == 0) roll(maze, rowBall, colBall, hole, 1, 0, steps, path + \"d\", res);\\n            if (d_col == 0) roll(maze, rowBall, colBall, hole, 0, -1, steps, path + \"l\", res);\\n            if (d_col == 0) roll(maze, rowBall, colBall, hole, 0, 1, steps, path + \"r\", res);\\n            if (d_row == 0) roll(maze, rowBall, colBall, hole, -1, 0, steps, path + \"u\", res);\\n        }\\n    }\\n    return res.first;\\n}\\nstring findShortestWay(vector<vector<int>>& maze, vector<int>& ball, vector<int>& hole) \\n{\\n    return roll(maze, ball[0], ball[1], hole, 0, 0, 0, \"\", pair<string, int>() = {\"impossible\", INT_MAX});\\n}\\n```"
		},
		{
			"lc_ans_id":"97826",
			"view":"1031",
			"top":"5",
			"title":"Java BFS solution with Queue, standard BFS 15ms(beats 85.71%)",
			"vote":"4",
			"content":"```\\npublic class Solution {\\n  public class Element {\\n    int direction;\\n    int row, col;\\n    String moves;\\n\\n    Element(int row, int col, String moves, int direction) {\\n      this.row = row;\\n      this.col = col;\\n      this.moves = moves;\\n      this.direction = direction;\\n    }\\n  }\\n\\n  public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\\n    //initialization\\n    int m = maze.length, n = maze[0].length;\\n    Queue<Element> path = new LinkedList<>();\\n    char[] directions = {'d', 'l', 'r', 'u'};\\n    int[] deltaRow = {1, 0, 0, -1};\\n    int[] deltaCol = {0, -1, 1, 0};\\n    boolean[][][] visited = new boolean[m][n][4];\\n\\n    //add start point\\n    for (int i = 0; i < 4; i++) {\\n      int row = ball[0] + deltaRow[i], col = ball[1] + deltaCol[i];\\n      if (row >= 0 && row < m && col >= 0 && col < n && maze[row][col] == 0) {\\n        path.add(new Element(row, col, String.valueOf(directions[i]), i));\\n      }\\n    }\\n\\n    while (!path.isEmpty()) {\\n      Element top = path.poll();\\n      visited[top.row][top.col][top.direction] = true;\\n      if (top.row == hole[0] && top.col == hole[1]) {\\n        return top.moves;\\n      }\\n      //go with same direction\\n      int nextRow = top.row + deltaRow[top.direction];\\n      int nextCol = top.col + deltaCol[top.direction];\\n      if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && maze[nextRow][nextCol] == 0) {\\n        //no hit wall\\n        if (!visited[nextRow][nextCol][top.direction]) {\\n          path.offer(new Element(nextRow, nextCol, top.moves, top.direction));\\n        }\\n      } else {\\n        //hit the wall, change direction\\n        for (int direction = 0; direction < 4; direction++) {\\n          if (direction != top.direction) {\\n            nextRow = top.row + deltaRow[direction];\\n            nextCol = top.col + deltaCol[direction];\\n            if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && maze[nextRow][nextCol] == 0\\n                && !visited[nextRow][nextCol][direction]) {\\n              path.offer(new Element(nextRow, nextCol, top.moves + directions[direction], direction));\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return \"impossible\";\\n  }\\n}\\n```"
		},
		{
			"lc_ans_id":"97840",
			"view":"373",
			"top":"6",
			"title":"[Java] [DFS] [Memoization] [Beats 85.71%] [15ms]",
			"vote":"2",
			"content":"Consider rolling down, then left,right & up. One with the minimum steps is chosen. If multiple such exist, then choose the first of the ones considered in the above mentioned order. If no route exist, return -1. \\n\\nStay away from infinite loops by marking starting locations.\\n```\\npublic class Solution {\\n\\tprivate  String[][] directionsToHole;\\n\\tprivate  int[][] shortestDistanceToHole;\\n\\tpublic  String findShortestWay(int[][] maze, int[] ball, int[] hole) {\\n\\t\\tdirectionsToHole = new String[maze.length][maze[0].length];\\n\\t\\tshortestDistanceToHole = new int[maze.length][maze[0].length];\\n\\t\\tif(rollTheBall(maze,ball[0],ball[1],hole[0],hole[1])<0)\\n\\t\\t\\treturn \"impossible\";\\n\\t\\treturn directionsToHole[ball[0]][ball[1]];\\n\\t}\\n    \\n \\tprivate int rollTheBall(int[][] maze, int ballRow, int ballColumn, int holeRow, int holeColumn){\\n\\t\\t// memoization step (i.e. if we have directions to reach hole from this point)\\n\\t\\tif(directionsToHole[ballRow][ballColumn]!=null)\\n\\t\\t\\treturn shortestDistanceToHole[ballRow][ballColumn];\\n\\n\\t\\tmaze[ballRow][ballColumn] = -2;\\t// Indicates that ball has been rolled from this point\\n\\n\\t\\tint ro,co,steps,tr;\\n\\t\\tint rows = maze.length;\\n\\t\\tint cols = maze[0].length;\\n\\t\\tint[] dir = new int[4];\\n\\t\\tString[] path = new String[4];\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\n\\t\\tro = ballRow;\\n\\t\\tco = ballColumn;\\n\\t\\tsteps = 0;\\t\\t\\t// for counting the steps till a wall/boundary/hole is hit/found.\\n\\n\\t\\t// Order of Rolling: down, left, right , up (lexicographically ordered).\\n\\n\\t\\twhile(ro<=rows-2){ // keep rolling down till boundary\\n\\t\\t\\tif(ro+1 == holeRow && co == holeColumn){ // hole found\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsteps++;\\n\\t\\t\\t\\tdirectionsToHole[ballRow][ballColumn] = \"d\";\\n\\t\\t\\t\\t// because we had set it as -2 in the starting, so reset it back\\n\\t\\t\\t\\tmaze[ballRow][ballColumn] = 0;\\n\\t\\t\\t\\t// store the steps to the hole from starting point\\n\\t\\t\\t\\tshortestDistanceToHole[ballRow][ballColumn] = steps;\\n\\t\\t\\t\\treturn steps;\\n\\t\\t\\t}\\n\\t\\t\\tif(maze[ro+1][co]==0){\\n\\t\\t\\t\\tro++;\\n\\t\\t\\t\\tsteps++;\\n\\t\\t\\t}\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// if ball was rolled in the down direction and it was stopped by a\\n\\t\\t// boundary and by not any other starting point\\n\\t\\tif(ro>ballRow && !(ro<=rows-2 && maze[ro+1][co]==-2)){\\n\\t\\t\\ttr = rollTheBall(maze,ro,co,holeRow,holeColumn);\\n\\t\\t\\tif(tr>-1){\\n\\t\\t\\t\\tdir[0] = steps + tr;\\n\\t\\t\\t\\tmin = Math.min(min, dir[0]);\\n\\t\\t\\t\\tpath[0] = \"d\"+directionsToHole[ro][co];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Similarly for other three directions\\n\\t\\tsteps=0;\\n\\t\\tro = ballRow;\\n\\t\\tco = ballColumn;\\n\\t\\twhile(co>=1){\\n\\t\\t\\tif(ro == holeRow && co-1 == holeColumn){// hole found\\n\\t\\t\\t\\tsteps++;\\n\\t\\t\\t\\tdirectionsToHole[ballRow][ballColumn] = \"l\";\\n\\t\\t\\t\\tmaze[ballRow][ballColumn] = 0;\\n\\t\\t\\t\\tshortestDistanceToHole[ballRow][ballColumn] = steps;\\n\\t\\t\\t\\treturn steps;\\n\\t\\t\\t}\\n\\t\\t\\tif(maze[ro][co-1]==0){\\n\\t\\t\\t\\tco--;\\n\\t\\t\\t\\tsteps++;\\n\\t\\t\\t}\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tif(co<ballColumn && !(co>=1 && maze[ro][co-1]==-2)){\\n\\t\\t\\ttr = rollTheBall(maze,ro,co,holeRow,holeColumn);\\n\\t\\t\\tif(tr>-1){\\n\\t\\t\\t\\tdir[1] = steps + tr;\\n\\t\\t\\t\\tmin = Math.min(min, dir[1]);\\n\\t\\t\\t\\tpath[1] = \"l\"+directionsToHole[ro][co];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsteps=0;\\n\\t\\tro = ballRow;\\n\\t\\tco = ballColumn;\\n\\t\\twhile(co<=cols-2){\\n\\t\\t\\tif(ro == holeRow && co+1 == holeColumn){// hole found\\n\\t\\t\\t\\tsteps++;\\n\\t\\t\\t\\tdirectionsToHole[ballRow][ballColumn] = \"r\";\\n\\t\\t\\t\\tmaze[ballRow][ballColumn] = 0;\\n\\t\\t\\t\\tshortestDistanceToHole[ballRow][ballColumn] = steps;\\n\\t\\t\\t\\treturn steps;\\n\\t\\t\\t}\\n\\t\\t\\tif(maze[ro][co+1]==0){\\n\\t\\t\\t\\tco++;\\n\\t\\t\\t\\tsteps++;}\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tif(co>ballColumn && !(co<=cols-2 && maze[ro][co+1]==-2)){\\n\\t\\t\\ttr = rollTheBall(maze,ro,co,holeRow,holeColumn);\\n\\t\\t\\tif(tr>-1){\\n\\t\\t\\t\\tdir[2] = steps + tr;\\n\\t\\t\\t\\tmin = Math.min(min, dir[2]);\\n\\t\\t\\t\\tpath[2] = \"r\"+directionsToHole[ro][co];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsteps=0;\\n\\t\\tro = ballRow;\\n\\t\\tco = ballColumn;\\n\\t\\twhile(ro>=1){\\n\\t\\t\\tif(ro-1 == holeRow && co == holeColumn){ // hole found\\n\\t\\t\\t\\tsteps++;\\n\\t\\t\\t\\tdirectionsToHole[ballRow][ballColumn] = \"u\";\\n\\t\\t\\t\\tmaze[ballRow][ballColumn] = 0;\\n\\t\\t\\t\\tshortestDistanceToHole[ballRow][ballColumn] = steps;\\n\\t\\t\\t\\treturn steps;\\n\\t\\t\\t}\\n\\t\\t\\tif(maze[ro-1][co]==0){\\n\\t\\t\\t\\tro--;\\n\\t\\t\\t\\tsteps++;\\n\\t\\t\\t}\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tif(ro<ballRow && !(ro>=1 && maze[ro-1][co]==-2)){\\n\\t\\t\\ttr = rollTheBall(maze,ro,co,holeRow,holeColumn);\\n\\t\\t\\tif(tr>-1){\\n\\t\\t\\t\\tdir[3] = steps + tr;\\n\\t\\t\\t\\tmin = Math.min(min, dir[3]);\\n\\t\\t\\t\\tpath[3] = \"u\"+directionsToHole[ro][co];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t// if no path was found\\n\\t\\tif(min == Integer.MAX_VALUE){\\n\\t\\t\\tmaze[ballRow][ballColumn] = 0;\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// the first of the entries which have the smallest path\\n\\t\\tfor(int i=0;i<4;i++)\\n\\t\\t\\tif(dir[i]==min){\\n\\t\\t\\t\\tdirectionsToHole[ballRow][ballColumn] = path[i];\\n\\t\\t\\t\\tmaze[ballRow][ballColumn] = 0;\\n\\t\\t\\t\\tshortestDistanceToHole[ballRow][ballColumn] = dir[i];\\n\\t\\t\\t\\treturn dir[i];\\n\\t\\t\\t}\\n\\t\\tshortestDistanceToHole[ballRow][ballColumn] = -1;\\n\\t\\treturn -1;\\n\\t}\\n}\\n```"
		},
		{
			"lc_ans_id":"97851",
			"view":"345",
			"top":"7",
			"title":"C++ DFS solution",
			"vote":"2",
			"content":"The idea is that each time hit a wall, turn to only two directions not the whole four directions. For example if the current move is up, then next move cannot be up or down, because it will move back. \\n\\n```\\nclass Solution {\\npublic:\\n    string findShortestWay(vector<vector<int>>& maze, vector<int>& ball, vector<int>& hole) {\\n        maze[hole[0]][hole[1]] = 2; // tag the hole as 2\\n\\n        // walk through all the maze needs this much distance\\n        int minDis = maze.size() * maze[0].size(); \\n        string res;\\n        vector<char> movements;\\n        for (char dir : \"dlru\") {\\n            helper(ball, maze, dir, movements, 0, minDis, res);\\n        }\\n\\n        if (res.empty())\\n            return \"impossible\";\\n        return res;\\n    }\\n\\n    struct MoveStatus {\\n        int dis;\\n        bool reachHole;\\n    };\\n\\n    void helper(vector<int> ball, vector<vector<int>> &maze, char dir, vector<char> &movements, int preDis, int &minDis, string &res) {\\n        // since move() changes ball position, need save the original position\\n        // not tag the ball position as visited because this move can be invalid\\n        int oriX = ball[0], oriY = ball[1];\\n\\n        MoveStatus ms = move(ball, maze, dir);\\n        if (ms.dis == 0) // invalid move\\n            return;\\n\\n        int distance = ms.dis + preDis;\\n        if (distance > minDis)\\n            return;\\n\\n        movements.push_back(dir);\\n        if (ms.reachHole) {\\n            if (distance < minDis) {\\n                minDis = distance;\\n                res = string(movements.begin(), movements.end());\\n            }\\n            movements.pop_back();\\n            return;\\n        }\\n\\n        // now tag the start point of the ball as visited\\n        maze[oriX][oriY] = -1;\\n        for (char newDir : getDir(dir)) {\\n            helper(ball, maze, newDir, movements, distance, minDis, res);\\n        }\\n        movements.pop_back();\\n        maze[oriX][oriY] = 0;\\n    }\\n\\n    MoveStatus move(vector<int> &ball, vector<vector<int>> &maze, char dir) {\\n        int xInc = 0, yInc = 0;\\n        if (dir == 'u') {\\n            xInc = -1;\\n        } else if (dir == 'd') {\\n            xInc = 1;\\n        } else if (dir == 'l') {\\n            yInc = -1;\\n        } else {\\n            yInc = 1;\\n        }\\n\\n        int &x = ball[0], &y = ball[1];\\n        int dis = 0;\\n        while (x >= 0 && x < (int)maze.size() && y >= 0 && y < (int)maze[0].size() && maze[x][y] == 0) {\\n            ++dis;\\n            x += xInc;\\n            y += yInc;\\n        }\\n\\n        if (x >= 0 && x < (int)maze.size() && y >= 0 && y < (int)maze[0].size()) {\\n            if (maze[x][y] == -1)\\n                return {0, false}; // cycle detected\\n            if (maze[x][y] == 2)\\n                return {dis, true}; // reach hole\\n        }\\n\\n        // touch board or wall, need go back a cell\\n        --dis;\\n        x -= xInc;\\n        y -= yInc;\\n        return {dis, false};\\n    }\\n\\n    string getDir(char dir) {\\n        if (dir == 'u' || dir == 'd')\\n            return \"lr\";\\n        return \"du\";\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"97801",
			"view":"102",
			"top":"8",
			"title":"Easy understanding BFS Java solution",
			"vote":"1",
			"content":"```\\npublic class Solution {\\n    private int[][] dir = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};\\n    private char[] alph = {'d', 'l', 'r', 'u'};\\n    // dlru {1, 0}, {0, -1}, {0, 1}, {-1, 0}\\n    \\n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\\n        if (maze == null || maze.length == 0 || maze[0].length == 0) {\\n            return \"\";\\n        }\\n        int n = maze.length, m = maze[0].length;\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.offer(ball);\\n        String[][] path = new String[n][m];\\n        int[][] step = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                step[i][j] = Integer.MAX_VALUE;\\n                path[i][j] = \"\";   //!!!\\n            }\\n        }\\n        step[ball[0]][ball[1]] = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int[] point = queue.poll();\\n            for (int i = 0; i < 4; i++) {\\n                int[] d = dir[i];\\n                int x = point[0];\\n                int y = point[1];\\n                if (x == hole[0] && y == hole[1]) {\\n                    break;\\n                }\\n                while (x + d[0] >= 0 && x + d[0] < n && y + d[1] >= 0 && y + d[1] < m && maze[x + d[0]][y + d[1]] == 0) {\\n                    x += d[0];\\n                    y += d[1];\\n                    if (x == hole[0] && y == hole[1]) {\\n                        break;\\n                    }\\n                }\\n                int curStep = Math.abs(x - point[0]) + Math.abs(y - point[1]);\\n                if (curStep == 0) {\\n                    continue;\\n                }\\n                if (step[x][y] > curStep + step[point[0]][point[1]]) {\\n                    // update step & path, and put point into queue\\n                    step[x][y] = curStep + step[point[0]][point[1]];\\n                    path[x][y] = path[point[0]][point[1]] + alph[i];\\n                    queue.offer(new int[]{x, y});\\n                } else if (step[x][y] == curStep + step[point[0]][point[1]]) {\\n                    // compare path and update path\\n                    String curPath = path[point[0]][point[1]] + alph[i];\\n                    path[x][y] = comparePath(curPath, path[x][y]);\\n                    queue.offer(new int[]{x, y});\\n                }\\n            }\\n        }\\n        return step[hole[0]][hole[1]] == Integer.MAX_VALUE? \"impossible\" : path[hole[0]][hole[1]];\\n    }\\n    \\n    private String comparePath(String s1, String s2) {\\n        char[] c1 = s1.toCharArray();\\n        char[] c2 = s2.toCharArray();\\n        int len = Math.min(c1.length, c2.length);\\n        for (int i = 0; i < len; i++) {\\n            if (c1[i] < c2[i]) {\\n                return s1;\\n            }\\n            if (c1[i] > c2[i]) {\\n                return s2;\\n            }\\n        }\\n        return len == c1.length ? s1 : s2;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"97803",
			"view":"118",
			"top":"9",
			"title":"C++, BFS, 6 ms concise solution",
			"vote":"1",
			"content":"I have tried BFS, DFS, and Dijkstra with priority_queue. And it came out BFS is fastest, at least in C++. Possible reason is that BFS is better than DFS for shortest path problem, and DFS results in many useless travel through the graph. And it seems that the priority_queue grows quickly for Dijkstra algorithm, because the same point with different distance was all put in the queue. \\n\\nSimilar to other two Maze problems, I use 1 matrix to save minimum distance from starting points (initially INT_MAX), and 1 matrix to save the path to current point. I use a queue to perform BFS. A new point will be added into the queue, if the new distance is less than saved or the distance is the same but the new path is lexicographically smaller. When the hole is encountered, update the distance and path of the hole, and go to next iteration.\\n\\nThe time complexity is hard to analyze. The worst case could be O(mn*mn), m and n is the size of maze.\\n```\\nclass Solution {\\npublic:\\n    string findShortestWay(vector<vector<int>>& maze, vector<int>& ball, vector<int>& hole) {\\n        int m = maze.size(), n = maze[0].size();\\n        vector<vector<int>> dis(m, vector<int>(n, INT_MAX));\\n        vector<vector<string>> path(m, vector<string>(n));\\n        // distance of starting point is 0\\n        dis[ball[0]][ball[1]] = 0;\\n        queue<vector<int>> myq;\\n        myq.push(ball);\\n       // the order of ball move direction is lexicographically smallest, i.e. dlru\\n        vector<int> d1({1, 0, 0, -1}), d2({0, -1, 1, 0});\\n        string dirs = \"dlru\";\\n        while (!myq.empty()) {\\n            int row = myq.front()[0], col = myq.front()[1];\\n            myq.pop();\\n            for (int i = 0; i < 4; ++i) {\\n                int r = row+d1[i], c = col+d2[i], len = 0;\\n                while (r >= 0 && r < m && c >= 0 && c < n && maze[r][c] == 0) {\\n                    r += d1[i];\\n                    c += d2[i];\\n                    len++;\\n                }\\n                r -= d1[i];\\n                c -= d2[i];\\n                // if the current move goes across the hole\\n                if ((hole[0]-row)*(hole[0]-r) <= 0 && (hole[1]-col)*(hole[1]-c) <= 0) {\\n                    int k = abs(hole[0]-row)+abs(hole[1]-col);\\n                    if (dis[hole[0]][hole[1]] > dis[row][col]+k || (dis[hole[0]][hole[1]] == dis[row][col]+k && path[hole[0]][hole[1]] > path[row][col]+dirs[i])) {\\n                        dis[hole[0]][hole[1]] = dis[row][col]+k;\\n                        path[hole[0]][hole[1]] = path[row][col]+dirs[i];\\n                    }\\n                    continue;\\n                }\\n                // check whether the end point should be a new starting point\\n                if (dis[r][c] > dis[row][col]+len || (dis[r][c] == dis[row][col]+len && path[r][c] > path[row][col]+dirs[i])) {\\n                    dis[r][c] = dis[row][col]+len;\\n                    path[r][c] = path[row][col]+dirs[i];\\n                    myq.push({r, c});\\n                }\\n            }\\n        }\\n        return path[hole[0]][hole[1]] == \"\"? \"impossible\":path[hole[0]][hole[1]];\\n    }\\n};\\n```"
		}
	],
	"id":"489",
	"title":"The Maze III",
	"content":"<p>There is a <b>ball</b> in a maze with empty spaces and walls. The ball can go through empty spaces by rolling <b>up</b> (u), <b>down</b> (d), <b>left</b> (l) or <b>right</b> (r), but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a <b>hole</b> in this maze. The ball will drop into the hole if it rolls on to the hole.</p>\r\n\r\n<p> Given the <b>ball position</b>, the <b>hole position</b> and the <b>maze</b>, find out how the ball could drop into the hole by moving the <b>shortest distance</b>. The distance is defined by the number of <b>empty spaces</b> traveled by the ball from the start position (excluded) to the hole (included). Output the moving <b>directions</b> by using 'u', 'd', 'l' and 'r'. Since there could be several different shortest ways, you should output the <b>lexicographically smallest</b> way. If the ball cannot reach the hole, output \"impossible\".</p>\r\n\r\n<p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The ball and the hole coordinates are represented by row and column indexes.</p>\r\n\r\n<p>\r\n<b>Example 1</b>\r\n<pre>\r\n<b>Input 1:</b> a maze represented by a 2D array\r\n\r\n0 0 0 0 0\r\n1 1 0 0 1\r\n0 0 0 0 0\r\n0 1 0 0 1\r\n0 1 0 0 0\r\n\r\n<b>Input 2:</b> ball coordinate (rowBall, colBall) = (4, 3)\r\n<b>Input 3:</b> hole coordinate (rowHole, colHole) = (0, 1)\r\n\r\n<b>Output:</b> \"lul\"\r\n<b>Explanation:</b> There are two shortest ways for the ball to drop into the hole.\r\nThe first way is left -> up -> left, represented by \"lul\".\r\nThe second way is up -> left, represented by 'ul'.\r\nBoth ways have shortest distance 6, but the first way is lexicographically smaller because 'l' < 'u'. So the output is \"lul\".\r\n<img src=\"https://leetcode.com/static/images/problemset/maze_2_example_1.png\" width = \"30%\" />\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Example 2</b>\r\n<pre>\r\n<b>Input 1:</b> a maze represented by a 2D array\r\n\r\n0 0 0 0 0\r\n1 1 0 0 1\r\n0 0 0 0 0\r\n0 1 0 0 1\r\n0 1 0 0 0\r\n\r\n<b>Input 2:</b> ball coordinate (rowBall, colBall) = (4, 3)\r\n<b>Input 3:</b> hole coordinate (rowHole, colHole) = (3, 0)\r\n<b>Output:</b> \"impossible\"\r\n<b>Explanation:</b> The ball cannot reach the hole.\r\n<img src=\"https://leetcode.com/static/images/problemset/maze_2_example_2.png\" width = \"30%\" />\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>There is only one ball and one hole in the maze.</li>\r\n<li>Both the ball and hole exist on an empty space, and they will not be at the same position initially.</li>\r\n<li>The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.</li>\r\n<li>The maze contains at least 2 empty spaces, and the width and the height of the maze won't exceed 30.</li>\r\n</ol>\r\n</p>",
	"frequency":"28",
	"ac_num":"4515"
}