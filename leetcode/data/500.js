{
	"difficulty":"3",
	"submit_num":"18687",
	"show_id":"514",
	"leetcode_id":"514",
	"answers":[
		{
			"lc_ans_id":"98902",
			"view":"7730",
			"top":"0",
			"title":"Concise Java DP Solution",
			"vote":"41",
			"content":"```\\npublic class Solution {\\n    public int findRotateSteps(String ring, String key) {\\n        int n = ring.length();\\n        int m = key.length();\\n        int[][] dp = new int[m + 1][n];\\n        \\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < n; k++) {\\n                    if (ring.charAt(k) == key.charAt(i)) {\\n                        int diff = Math.abs(j - k);\\n                        int step = Math.min(diff, n - diff);\\n                        dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0] + m;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"98920",
			"view":"2821",
			"top":"1",
			"title":"Shared my C++ dp solution ,19ms",
			"vote":"10",
			"content":"Simple dp idea\\n1. recording each index of characters in ring,beacuse each characters we have search in this time would be starting index in the next search \\n2. How could we solve the problem that rotate the ring to the left or right ?   My idea is **min((tmp[j] + size -it)%size,(it + size - tmp[j])%size)**\\n\\n * Suppose you want to rotate the ring to the right and search 'k', and the size is 5.\\nWe could calculate it by **this + size -k(index)%size** \\n\\n```\\nthis -  -  -  -  k\\n```\\n\\n * If we want to rotate the ring to the left\\uff0cwhat should we do? It is the same problem  with above problem,move **this** to its right,and reach **k**\\n```\\nk -  -  -  -   this\\n```\\n * So we could calculate it by **k(index) + size -this%size**\\n* There are many people use **abs()** instead of **%size**,I think it's faster than mine :)\\n\\n\\n\\n\\n\\n````\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int size = ring.size();\\n        int ksize = key.size();\\n        unordered_map<char,vector<int>> mp;//stored index of each characters in ring,pay attention to duplcate characters.\\n        for(int i=0;i<size;++i){\\n            mp[ring[i]].push_back(i);\\n        }\\n        \\n        vector<vector<int>> dp(ksize+1,vector<int> (size,INT_MAX));// initializing dp vector \\n        fill(dp[0].begin(),dp[0].end(),0);\\n        \\n        vector<int> tmp(1,0);// starting index\\n        \\n        int res = INT_MAX;\\n        for(int i=1;i<=ksize;++i){\\n            for(auto it:mp[key[i-1]]){  //\\n                for(int j=0;j<tmp.size();++j){  //Search The shortest distance key[i-1] in ring\\n                    int minDist = min((tmp[j] + size -it)%size,(it + size - tmp[j])%size) + dp[i-1][tmp[j]];// Look at the above explanation\\n                    dp[i][it] =min(dp[i][it],minDist);\\n                    res = (i!=ksize?res:min(res,dp[i][it])); //Can we optimize it?\\n                }\\n            }\\n            tmp = mp[key[i-1]]; //next start is the characters we search in this time\\n        }\\n        return res + ksize;\\n    }\\n};\\n````\\n\\n**update (optimazed space complexity)**\\n\\n````\\nclass Solution {\\npublic:\\n    int findRotateSteps(string ring, string key) {\\n        int size = ring.size();\\n        int ksize = key.size();\\n        vector<vector<int>> mp(26);   //Optimazed_1 use vector instead of unordered_map\\n            //stored index of each ,pay attention to duplcate characters.\\n        for(int i=0;i<size;++i){\\n            mp[ring[i]-'a'].push_back(i);\\n        }\\n        \\n        vector<int> dp (size,INT_MAX);   //Optimazed_2,use less space \\n        dp[0] = 0;\\n        \\n        vector<int> startIndex(1,0);// starting index\\n\\n        for(int i=1;i<=ksize;++i){\\n            vector<int> nextDp(size,INT_MAX);\\n            for(auto it:mp[key[i-1]-'a']){\\n                for(int j=0;j<startIndex.size();++j){\\n                    int minDist = min((startIndex[j] + size -it)%size,(it + size - startIndex[j])%size) + dp[startIndex[j]];// Look at the above explanation\\n                    nextDp[it] =min(nextDp[it],minDist);\\n                }\\n            }\\n            startIndex = mp[key[i-1]-'a'];\\n            dp = nextDp;\\n        }\\n        \\n        int res = INT_MAX;\\n        for(int i=0;i<size;++i){\\n            res = min(res,dp[i]);\\n        }  // get the smallest value(step)\\n        \\n        return res + ksize;\\n    }\\n};\\n\\n````"
		},
		{
			"lc_ans_id":"98897",
			"view":"2775",
			"top":"2",
			"title":"Java Clear Solution, dfs+memoization",
			"vote":"8",
			"content":"Hi There! The key point in the problem is to make decision whether to move clockwise or anticlockwise. Actually to get optimal answer, we have to move clockwise for some characters of ```key``` and anti-clockwise for others. If apply brute force, then for each position in ```key``` we have two options,\\n  * Search for the character clockwise\\n  * Search for the character anti-clockwise\\n\\nTo find optimal answer we need to try both options and get minimum of them. Thus, we obtain ```dfs solution``` for the problem. But, there are duplicate calculation for some positions. Therefore, we need to memorize ```states```. The ```state``` is defined by position of the```ring``` and the index of character in the ```key```. This way, we can avoid calculating number of steps for the same state. Code will clarify the idea more.\\n```\\npublic class Solution {\\n    Map<String, Map<Integer, Integer>> memo;\\n    public int findRotateSteps(String ring, String key) {\\n        memo = new HashMap<>();\\n        return dfs(ring, key, 0);\\n    }\\n    \\n    private int findPos(String ring, char ch){ // find first occurrence clockwise\\n        return ring.indexOf(ch);\\n    }\\n    \\n    private int findBackPos(String ring, char ch){ //find first occurrence  anti-clockwise\\n        if(ring.charAt(0) == ch) return 0;\\n        for(int i = ring.length()-1;i>0;i--){\\n            if(ring.charAt(i) == ch) return i;\\n        }\\n        return 0;\\n    }\\n    \\n    private int dfs(String ring, String key, int i){\\n        if(i == key.length()) return 0;\\n        int res = 0;\\n        char ch = key.charAt(i);\\n        if(memo.containsKey(ring) && memo.get(ring).containsKey(i)) return memo.get(ring).get(i);\\n        int f = findPos(ring, ch);\\n        int b = findBackPos(ring, ch);\\n        int forward = 1+f+dfs(ring.substring(f)+ring.substring(0, f), key, i+1);\\n        int back = 1+ring.length()-b + dfs(ring.substring(b)+ring.substring(0, b),key, i+1);\\n        res = Math.min(forward, back);\\n        Map<Integer, Integer> ans = memo.getOrDefault(ring, new HashMap<>());\\n        ans.put(i, res);\\n        memo.put(ring, ans);\\n        return res;\\n    }\\n}"
		},
		{
			"lc_ans_id":"98900",
			"view":"1291",
			"top":"3",
			"title":"O(RK)-time DP solution",
			"vote":"7",
			"content":"We can further improve the runtime of [this DP Solution](https://discuss.leetcode.com/topic/81684/concise-java-dp-solution) from `O(R * R * K)` to `O(R * (26 + K)) = O(RK)`, where `R = |Ring|` and `K = |Key|`. Basically, we can do the inner-most loop in `O(1)` time. The idea is that if we are currently at position `i` and require the previous char equal to some letter `ch`, we just need to check the position (with letter `ch`) that is closest to `i` from its left or right. Thus, at most two positions need to be checked, instead of the entire ring.\\n\\n**Update:** The preprocessing of the following code takes `O(R^2 * 26) = O(R^2)` time. But I believe there must exist a faster way, and ~~I was just too lazy to do that~~...\\n**Update:** Okay, the preprocessing can be done in `O(26 * R) = O(R)` time.\\n\\n```\\npublic int findRotateSteps(String ring, String key) {\\n    int R = ring.length(), K = key.length();\\n    int[][] prev = new int[R][26], next = new int[R][26];\\n    for (int i = 0; i < R; i++) {\\n        Arrays.fill(prev[i], -1);\\n        Arrays.fill(next[i], -1);\\n        for (int j = (i + 1) % R; j != i; j = (j + 1) % R) {\\n            int ch = ring.charAt(j) - 'a';\\n            if (next[i][ch] == -1) next[i][ch] = j;\\n        }\\n        for (int j = (i - 1 + R) % R; j != i; j = (j - 1 + R) % R) {\\n            int ch = ring.charAt(j) - 'a';\\n            if (prev[i][ch] == -1) prev[i][ch] = j;\\n        }\\n        prev[i][ring.charAt(i) - 'a'] = next[i][ring.charAt(i) - 'a'] = i;\\n    }\\n\\n    int[][] f = new int[K][R];\\n    int ans = Integer.MAX_VALUE;\\n    for (int i = 0; i < K; i++) {\\n        for (int j = 0; j < R; j++) {\\n            f[i][j] = Integer.MAX_VALUE / 2;\\n\\n            if (key.charAt(i) == ring.charAt(j)) {\\n                if (i == 0) f[i][j] = Math.min(f[i][j], dist(0, j, ring.length()));\\n                else {\\n                    int preKey = key.charAt(i - 1) - 'a';\\n                    f[i][j] = Math.min(f[i][j], f[i - 1][prev[j][preKey]] + dist(prev[j][preKey], j, ring.length()));\\n                    f[i][j] = Math.min(f[i][j], f[i - 1][next[j][preKey]] + dist(next[j][preKey], j, ring.length()));\\n                }\\n            }\\n            if (i == K - 1) ans = Math.min(ans, f[i][j]);\\n        }\\n    }\\n    return ans + K;\\n}\\n```\\n\\nAn `O(26R) = O(R)`-time preprocessing.\\n```java\\nint R = ring.length(), K = key.length();\\nint[][] prev = new int[R][26], next = new int[R][26];\\nMap<Character, List<Integer>> map = new HashMap<>();\\nfor (int i = 0; i < ring.length(); i++) {\\n    char ch = ring.charAt(i);\\n    map.putIfAbsent(ch, new ArrayList<>());\\n    map.get(ch).add(i);\\n}\\nfor (char ch : map.keySet()) {\\n    List<Integer> list = map.get(ch);\\n    for (int i = 0, ptr = 0; i < ring.length(); i++) {\\n        next[i][ch - 'a'] = list.get(ptr);\\n        prev[i][ch - 'a'] = list.get((ptr - 1 + list.size()) % list.size());\\n        if (ring.charAt(i) == ch) ptr = (ptr + 1) % list.size();\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"98929",
			"view":"709",
			"top":"4",
			"title":"Evolve from brute force to dp",
			"vote":"5",
			"content":"1. brute force, try all next steps.\\n```\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> pos[26];\\n        for(int i=0;i<ring.size();i++) pos[ring[i]-'a'].push_back(i);\\n        return findSteps(0, 0, ring, key, pos);    \\n    }\\n    int findSteps(int p1, int p2, string &ring, string &key, vector<int> pos[26]) {\\n        if(p2==key.size()) return 0;\\n        int r = ring.size(), ms=INT_MAX;\\n        for(int nxt:pos[key[p2]-'a']) {\\n            int dist = abs(p1-nxt);\\n            ms = min(ms,min(dist, r-dist)+findSteps(nxt,p2+1,ring,key,pos));    \\n        }\\n        return ms+1;\\n    }\\n```\\n2. O(kr^2) Memoization. There are overlapping sub-problems in #1. We only need to process a substring of key once.\\n```\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> pos[26];\\n        int r = ring.size();\\n        for(int i=0;i<r;i++) pos[ring[i]-'a'].push_back(i);\\n        vector<vector<int>> mem(r,vector<int>(key.size()));\\n        return findSteps(0, 0, ring, key, pos,mem);    \\n    }\\n    int findSteps(int p1, int p2, string &ring, string &key, vector<int> pos[26],vector<vector<int>>& mem) {\\n        if(p2==key.size()) return 0;\\n        if(mem[p1][p2]) return mem[p1][p2];\\n        int r = ring.size(), ms=INT_MAX;\\n        for(int nxt:pos[key[p2]-'a']) {\\n            int dist = abs(p1-nxt);\\n            ms = min(ms,min(dist, r-dist)+findSteps(nxt,p2+1,ring,key,pos,mem));    \\n        }\\n        return mem[p1][p2]=ms+1;\\n    }\\n```\\n3. O(kr^2) dp\\n```\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> pos[26];\\n        int r = ring.size(), k = key.size();\\n        for(int i=0;i<r;i++) pos[ring[i]-'a'].push_back(i);\\n        vector<vector<int>> dp(k+1,vector<int>(r,INT_MAX));\\n        dp[k].assign(r,0);\\n        for(int i=k-1;i>=0;i--) \\n            for(int j=0;j<r;j++)\\n                for(int nxt:pos[key[i]-'a']) {\\n                    int dist = abs(j-nxt);\\n                    dp[i][j]=min(dp[i][j],min(dist,r-dist)+dp[i+1][nxt]);\\n                }\\n        return dp[0][0]+k;\\n    }\\n```\\n4. linear space dp\\n```\\n    int findRotateSteps(string ring, string key) {\\n        vector<int> pos[26];\\n        int r = ring.size(), k = key.size();\\n        for(int i=0;i<r;i++) pos[ring[i]-'a'].push_back(i);\\n        vector<int> pre(r), cur(r,INT_MAX), *p_pre = &pre, *p_cur = &cur;\\n        for(int i=k-1;i>=0;i--) {\\n            for(int j=0;j<r;j++)\\n                for(int nxt:pos[key[i]-'a']) {\\n                    int dist = abs(j-nxt);\\n                    (*p_cur)[j]=min((*p_cur)[j],min(dist,r-dist)+(*p_pre)[nxt]);\\n                }\\n            swap(p_pre,p_cur);\\n            p_cur->assign(r,INT_MAX);\\n        }\\n        return (*p_pre)[0]+k;\\n    }\\n```"
		},
		{
			"lc_ans_id":"98953",
			"view":"732",
			"top":"5",
			"title":"JAVA DP with explanation",
			"vote":"5",
			"content":"The dp is a 2D integer array, with height = the length of **ring**, with width = the length of **key**. So DP[i][j] represents that if we want to spell the next character key[**j**], and at the same time the 12:00 aligns with the ring[**i**], then what is the minimum steps to spell the **whole key start at key[j]**. If we finish the DP array, then the answer is just DP[0][0], which means the minimum steps to spell the **whole key** start at key[0], if currently 12:00 aligns with the ring[0], and this is exactly the original problem. And don't forget to plus the length of key, which is the steps we need to push the button.\\n\\n\\n```\\n// by fallcreek\\npublic class Solution {\\n    public int findRotateSteps(String ring, String key) {        \\n        int[][] dp = new int[ring.length()][key.length()];\\n        for(int[] line : dp)    Arrays.fill(line, -1);\\n        \\n        return helper(ring, 0, key, 0, dp) + key.length();\\n    }\\n    \\n    public int helper(String ring, int rIndex, String key, int kIndex, int[][] dp){\\n        if(kIndex == key.length()) return 0;\\n        if(dp[rIndex][kIndex] != -1) return dp[rIndex][kIndex];\\n        \\n        char dest = key.charAt(kIndex);\\n        \\n        int nextIndex = ring.indexOf(dest);\\n        int sol = Integer.MAX_VALUE;\\n        do{\\n            int move = Math.min(Math.abs(rIndex - nextIndex), ring.length() - Math.abs(rIndex - nextIndex));\\n            int remain = helper(ring, nextIndex, key, kIndex + 1, dp);\\n            sol = Math.min(sol, move + remain);\\n            nextIndex = ring.indexOf(dest, nextIndex + 1);\\n        }while(nextIndex != -1);\\n        dp[rIndex][kIndex] = sol;\\n        return sol;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"98923",
			"view":"591",
			"top":"6",
			"title":"please modify the tag from \"Dynamic Programming\" to Dynamic Programming",
			"vote":"3",
			"content":"otherwise there will be a tag named \"Dynamic Programming\" with only this problem, rather than merged with other Dynamic Programming problems."
		},
		{
			"lc_ans_id":"98937",
			"view":"621",
			"top":"7",
			"title":"Python Solution (222 ms)",
			"vote":"3",
			"content":"First, the distance between two positions (i, j) can be defined as \\n```\\ndist(i, j) = min(|i - j|, n - |i - j|)\\n```\\nSecond, we need a dictionary, h, which tells us the characters on the ring and its possible positions of the ring (a list of positions). \\n\\nThe ring starts with one possible status: pcl_pre = [[position, cost]] = [[0, 0]]. For each next character, ch, on the key, we can have several choices of positions, h[ch]. Since we don't know which route will give the minimum total cost later, we need to compute and store the minimum cost for each possible next positions, h[ch], from all possible current positions, pcl_pre. In the end, we return the minimum total cost for the last character on the key.\\n \\n```\\nclass Solution(object):\\n    def findRotateSteps(self, ring, key):\\n        n = len(ring)\\n        #the distance between two points (i, j) on the ring\\n        def dist(i, j):\\n            return min(abs(i - j), n - abs(i - j))\\n        #build the position list for each character in ring    \\n        h = {}\\n        for i in xrange(n):\\n            a = ring[i]\\n            if a in h: h[a].append(i)\\n            else: h[a] = [i]\\n        \\n        pcl_pre = [[0,0]] #list of possible previous position of the ring and the cost\\n        for k in key:\\n            pl_k = h[k] #obtain the location list of character k\\n            pcl_next = [[p, 0] for p in pl_k] #list of possible next position of the ring and the cost\\n            \\n            for pc_next in pcl_next:\\n                p_next = pc_next[0] #next possible position\\n                #Find minimum cost to p_next\\n                cmin = dist(p_next, pcl_pre[0][0]) + pcl_pre[0][1]\\n                for pc_pre in pcl_pre:\\n                    cmin = min(cmin, dist(p_next, pc_pre[0]) + pc_pre[1])\\n                pc_next[1] = cmin\\n            \\n            pcl_pre = pcl_next\\n        \\n        #Find the min cost for all possible end positions\\n        cmin = pcl_pre[0][1]\\n        for pc in pcl_pre:\\n            cmin = min(cmin, pc[1])\\n        return len(key) + cmin\\n```\\nOne can actually improve this method by doing it backward. In this way, we can just return the cost to position = 0 instead of searching over all possible end positions."
		},
		{
			"lc_ans_id":"98916",
			"view":"138",
			"top":"8",
			"title":"Super clear DFS + memorization solution",
			"vote":"2",
			"content":"\\n```\\npublic class Solution {\\n    public int findRotateSteps(String ring, String key) {\\n           Map<String,Integer> map = new HashMap();\\n           return dfs(ring, key, 0, map);\\n    }\\n    \\n    public int dfs(String ring, String key, int index, Map<String,Integer> map){\\n        if(index == key.length()){\\n            return 0;\\n        }\\n    \\n        char c = key.charAt(index);\\n        String hashKey = ring + index;\\n        if(map.containsKey(hashKey)) return map.get(hashKey);\\n        \\n        int minSteps = Integer.MAX_VALUE;\\n        for(int i = 0; i < ring.length(); i ++){\\n            if(ring.charAt(i) == c){\\n                String s = ring.substring(i, ring.length()) + ring.substring(0, i);\\n                int steps = 1 + Math.min(i, ring.length() - i);\\n                steps += dfs(s, key, index + 1, map);\\n                minSteps = Math.min(minSteps, steps);\\n            }\\n        }\\n        \\n        map.put(hashKey, minSteps);\\n        \\n        return minSteps;\\n    }\\n}\\n````"
		},
		{
			"lc_ans_id":"98918",
			"view":"738",
			"top":"9",
			"title":"Java Easy understanding solution! Recursion + memorization",
			"vote":"2",
			"content":"The state is represented by the 12:00 direction of index p and the current index of key to spell.\\nInitially, p = 0. Rotate both direction to find the character to match the character in key to spell. there are two cases:\\n1. left rotation and right rotation end up with same index (i==j) then there is only one branch\\n2. they end up with different index then there are two branch\\nBelow is the code please feel free to advise\\n\\n```\\n    public int findRotateSteps(String ring, String key) {\\n        if(ring.length()==0 || key.length()==0) return 0;\\n        return findShortest(ring.toCharArray(), 0, key.toCharArray(), 0, new int[ring.length()][key.length()]);\\n    }\\n    private int findShortest(char[] arr, int p,  char[] key, int idx, int[][] mem) {\\n        if(idx==key.length) return 0;\\n        if(mem[p][idx]>0) return mem[p][idx];\\n        int c1 = 0, c2=0,i=p, j=p;\\n        for(; arr[i]!=key[idx]; c1++) {\\n            i=(i+1)%arr.length;\\n        }\\n        for(; arr[j]!=key[idx];c2++) {\\n            j=(j-1+arr.length)%arr.length;\\n        }\\n        if(i==j) { //rotate to same location then use the less count one\\n            mem[p][idx]= Math.min(c1,c2)+1 + findShortest(arr, i, key, idx+1, mem);\\n        } else {\\n            int r1 = findShortest(arr, i, key, idx+1, mem) + c1 + 1;\\n            int r2 = findShortest(arr, j, key, idx+1, mem) + c2 + 1;\\n            mem[p][idx] = Math.min(r1,r2);\\n        }\\n        return mem[p][idx];\\n    }"
		}
	],
	"id":"500",
	"title":"Freedom Trail",
	"content":"<p>\r\nIn the video game Fallout 4, the quest \"Road to Freedom\" requires players to reach a metal dial called the \"Freedom Trail Ring\", and use the dial to spell a specific keyword in order to open the door. \r\n</p>\r\n\r\n<p>\r\nGiven a string <b>ring</b>, which represents the code engraved on the outer ring and another string <b>key</b>, which represents the keyword needs to be spelled. You need to find the <b>minimum</b> number of steps in order to spell all the characters in the keyword.\r\n</p>\r\nInitially, the first character of the <b>ring</b> is aligned at 12:00 direction. You need to spell all the characters in the string <b>key</b> one by one by rotating the ring clockwise or anticlockwise to make each character of the string <b>key</b> aligned at 12:00 direction and then by pressing the center button.\r\n<br>\r\n\r\nAt the stage of rotating the ring to spell the key character <b>key[i]</b>:\r\n<ol>\r\n<li>You can rotate the <b>ring</b> clockwise or anticlockwise <b>one place</b>, which counts as 1 step. The final purpose of the rotation is to align one of the string <b>ring's</b> characters at the 12:00 direction, where this character must equal to the character <b>key[i]</b>.\r\n\r\n<li>If the character <b>key[i]</b> has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.</li>\r\n</ol>\r\n\r\n</p>\r\n\r\n<p><b>Example:</b><br />\r\n<center>\r\n<img src=\"/static/images/problemset/ring.jpg\" width = \"26%\" />\r\n</center>\r\n</br>\r\n<pre>\r\n<b>Input:</b> ring = \"godding\", key = \"gd\"\r\n<b>Output:</b> 4\r\n<b>Explanation:</b></br> For the first key character 'g', since it is already in place, we just need 1 step to spell this character. </br> For the second key character 'd', we need to rotate the ring \"godding\" anticlockwise by two steps to make it become \"ddinggo\".</br> Also, we need 1 more step for spelling.</br> So the final output is 4.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>Length of both ring and <b>key</b> will be in range 1 to 100.</li>\r\n<li>There are only lowercase letters in both strings and might be some duplcate characters in both strings.</li>\r\n<li>It's guaranteed that string <b>key</b> could always be spelled by rotating the string <b>ring</b>.</li>\r\n</ol>\r\n</p>",
	"frequency":"66",
	"ac_num":"7351"
}