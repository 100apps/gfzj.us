{
	"difficulty":"3",
	"submit_num":"286168",
	"show_id":"51",
	"leetcode_id":"51",
	"answers":[
		{
			"lc_ans_id":"19808",
			"view":"25618",
			"top":"0",
			"title":"Accepted 4ms c++ solution use backtracking and bitmask, easy understand.",
			"vote":"120",
			"content":"In this problem, we can go row by row, and in each position, we need to check if the `column`, the `45\\xb0 diagonal` and the `135\\xb0 diagonal` had a queen before.\\n\\n**Solution A:** Directly check the validity of each position, *12ms*:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<std::string> > solveNQueens(int n) {\\n            std::vector<std::vector<std::string> > res;\\n            std::vector<std::string> nQueens(n, std::string(n, '.'));\\n            solveNQueens(res, nQueens, 0, n);\\n            return res;\\n        }\\n    private:\\n        void solveNQueens(std::vector<std::vector<std::string> > &res, std::vector<std::string> &nQueens, int row, int &n) {\\n            if (row == n) {\\n                res.push_back(nQueens);\\n                return;\\n            }\\n            for (int col = 0; col != n; ++col)\\n                if (isValid(nQueens, row, col, n)) {\\n                    nQueens[row][col] = 'Q';\\n                    solveNQueens(res, nQueens, row + 1, n);\\n                    nQueens[row][col] = '.';\\n                }\\n        }\\n        bool isValid(std::vector<std::string> &nQueens, int row, int col, int &n) {\\n            //check if the column had a queen before.\\n            for (int i = 0; i != row; ++i)\\n                if (nQueens[i][col] == 'Q')\\n                    return false;\\n            //check if the 45\\xb0 diagonal had a queen before.\\n            for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j)\\n                if (nQueens[i][j] == 'Q')\\n                    return false;\\n            //check if the 135\\xb0 diagonal had a queen before.\\n            for (int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j)\\n                if (nQueens[i][j] == 'Q')\\n                    return false;\\n            return true;\\n        }\\n    };\\n\\n**Solution B:** Use flag vectors as bitmask, *4ms*:\\n\\nThe number of columns is `n`,  the number of 45\\xb0 diagonals is `2 * n - 1`,  the number of 135\\xb0 diagonals is also `2 * n - 1`. When reach `[row, col]`, the column No. is `col`, the 45\\xb0 diagonal No. is `row + col` and the 135\\xb0 diagonal No. is `n - 1 + col - row`. We can use three arrays to indicate if the column or the diagonal had a queen before, if not, we can put a queen in this position and continue. \\n\\n**NOTE:** Please don't use `vector<bool> flag` to replace `vector<int> flag` in the following C++ code. In fact, `vector<bool>` is not a STL container. You should avoid to use it. You can also get the knowledge from [here](http://stackoverflow.com/questions/17794569/why-is-vectorbool-not-a-stl-container) and [here](http://stackoverflow.com/questions/670308/alternative-to-vectorbool).\\n\\n    /**    | | |                / / /             \\\\ \\\\ \\\\\\n      *    O O O               O O O               O O O\\n      *    | | |              / / / /             \\\\ \\\\ \\\\ \\\\\\n      *    O O O               O O O               O O O\\n      *    | | |              / / / /             \\\\ \\\\ \\\\ \\\\ \\n      *    O O O               O O O               O O O\\n      *    | | |              / / /                 \\\\ \\\\ \\\\\\n      *   3 columns        5 45\\xb0 diagonals     5 135\\xb0 diagonals    (when n is 3)\\n      */\\n    class Solution {\\n    public:\\n        std::vector<std::vector<std::string> > solveNQueens(int n) {\\n            std::vector<std::vector<std::string> > res;\\n            std::vector<std::string> nQueens(n, std::string(n, '.'));\\n            std::vector<int> flag_col(n, 1), flag_45(2 * n - 1, 1), flag_135(2 * n - 1, 1);\\n            solveNQueens(res, nQueens, flag_col, flag_45, flag_135, 0, n);\\n            return res;\\n        }\\n    private:\\n        void solveNQueens(std::vector<std::vector<std::string> > &res, std::vector<std::string> &nQueens, std::vector<int> &flag_col, std::vector<int> &flag_45, std::vector<int> &flag_135, int row, int &n) {\\n            if (row == n) {\\n                res.push_back(nQueens);\\n                return;\\n            }\\n            for (int col = 0; col != n; ++col)\\n                if (flag_col[col] && flag_45[row + col] && flag_135[n - 1 + col - row]) {\\n                    flag_col[col] = flag_45[row + col] = flag_135[n - 1 + col - row] = 0;\\n                    nQueens[row][col] = 'Q';\\n                    solveNQueens(res, nQueens, flag_col, flag_45, flag_135, row + 1, n);\\n                    nQueens[row][col] = '.';\\n                    flag_col[col] = flag_45[row + col] = flag_135[n - 1 + col - row] = 1;\\n                }\\n        }\\n    };\\n\\nBut we actually do not need to use three arrays, we just need one. Now, when reach `[row, col]`, the subscript of column is `col`, the subscript of 45\\xb0 diagonal is `n + row + col` and the subscript of 135\\xb0 diagonal  is `n + 2 * n - 1 + n - 1 + col - row`.\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<std::string> > solveNQueens(int n) {\\n            std::vector<std::vector<std::string> > res;\\n            std::vector<std::string> nQueens(n, std::string(n, '.'));\\n            /*\\n            flag[0] to flag[n - 1] to indicate if the column had a queen before.\\n            flag[n] to flag[3 * n - 2] to indicate if the 45\\xb0 diagonal had a queen before.\\n            flag[3 * n - 1] to flag[5 * n - 3] to indicate if the 135\\xb0 diagonal had a queen before.\\n            */\\n            std::vector<int> flag(5 * n - 2, 1);\\n            solveNQueens(res, nQueens, flag, 0, n);\\n            return res;\\n        }\\n    private:\\n        void solveNQueens(std::vector<std::vector<std::string> > &res, std::vector<std::string> &nQueens, std::vector<int> &flag, int row, int &n) {\\n            if (row == n) {\\n                res.push_back(nQueens);\\n                return;\\n            }\\n            for (int col = 0; col != n; ++col)\\n                if (flag[col] && flag[n + row + col] && flag[4 * n - 2 + col - row]) {\\n                    flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 0;\\n                    nQueens[row][col] = 'Q';\\n                    solveNQueens(res, nQueens, flag, row + 1, n);\\n                    nQueens[row][col] = '.';\\n                    flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 1;\\n                }\\n        }\\n    };"
		},
		{
			"lc_ans_id":"19805",
			"view":"13667",
			"top":"1",
			"title":"My easy understanding Java Solution",
			"vote":"48",
			"content":"    public class Solution {\\n        public List<List<String>> solveNQueens(int n) {\\n            char[][] board = new char[n][n];\\n            for(int i = 0; i < n; i++)\\n                for(int j = 0; j < n; j++)\\n                    board[i][j] = '.';\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            dfs(board, 0, res);\\n            return res;\\n        }\\n        \\n        private void dfs(char[][] board, int colIndex, List<List<String>> res) {\\n            if(colIndex == board.length) {\\n                res.add(construct(board));\\n                return;\\n            }\\n            \\n            for(int i = 0; i < board.length; i++) {\\n                if(validate(board, i, colIndex)) {\\n                    board[i][colIndex] = 'Q';\\n                    dfs(board, colIndex + 1, res);\\n                    board[i][colIndex] = '.';\\n                }\\n            }\\n        }\\n        \\n        private boolean validate(char[][] board, int x, int y) {\\n            for(int i = 0; i < board.length; i++) {\\n                for(int j = 0; j < y; j++) {\\n                    if(board[i][j] == 'Q' && (x + j == y + i || x + y == i + j || x == i))\\n                        return false;\\n                }\\n            }\\n            \\n            return true;\\n        }\\n        \\n        private List<String> construct(char[][] board) {\\n            List<String> res = new LinkedList<String>();\\n            for(int i = 0; i < board.length; i++) {\\n                String s = new String(board[i]);\\n                res.add(s);\\n            }\\n            return res;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"19810",
			"view":"9874",
			"top":"2",
			"title":"Fast, short, and easy-to-understand python solution, 11 lines, 76ms",
			"vote":"44",
			"content":"ideas: <br>\\nUse the `DFS` helper function to find solutions recursively. A solution will be found when the length of    `queens` is equal to `n` ( `queens` is a list of the indices of the queens).<br><br>\\nIn this problem, whenever a location `(x, y`) is occupied, any other locations `(p, q )` where `p + q == x + y` or `p - q == x - y` would be  invalid. We can use this information to keep track of the indicators (`xy_dif` and  `xy_sum` ) of the invalid positions and then call DFS recursively with valid positions only. <br><br>\\n\\nAt the end, we convert the result (a list of lists; each sublist is the indices of the queens) into the desire format.\\n\\n\\n    def solveNQueens(self, n):\\n        def DFS(queens, xy_dif, xy_sum):\\n            p = len(queens)\\n            if p==n:\\n                result.append(queens)\\n                return None\\n            for q in range(n):\\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum: \\n                    DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q])  \\n        result = []\\n        DFS([],[],[])\\n        return [ [\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]"
		},
		{
			"lc_ans_id":"19812",
			"view":"10219",
			"top":"3",
			"title":"The description should give a clear explanation of the problem of \"n-queens\"",
			"vote":"41",
			"content":"queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
		},
		{
			"lc_ans_id":"19828",
			"view":"13319",
			"top":"4",
			"title":"Comparably concise Java code",
			"vote":"34",
			"content":"Hi guys!\\n\\nI didn't invent a wheel here. We just remember the busy columns and diagonals and recursively try to put the queen into the next row. But I think the code below is short enough to be reproduced in the interview.\\n\\nHope it helps!\\n\\n----------\\n\\n    public class Solution {\\n        \\n        private void helper(int r, boolean[] cols, boolean[] d1, boolean[] d2, \\n                            String[] board, List<String[]> res) {\\n            if (r == board.length) res.add(board.clone());\\n            else {\\n                for (int c = 0; c < board.length; c++) {\\n                    int id1 = r - c + board.length, id2 = 2*board.length - r - c - 1;\\n                    if (!cols[c] && !d1[id1] && !d2[id2]) {\\n                        char[] row = new char[board.length];\\n                        Arrays.fill(row, '.'); row[c] = 'Q';\\n                        board[r] = new String(row);\\n                        cols[c] = true; d1[id1] = true; d2[id2] = true;\\n                        helper(r+1, cols, d1, d2, board, res);\\n                        cols[c] = false; d1[id1] = false; d2[id2] = false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        public List<String[]> solveNQueens(int n) {\\n            List<String[]> res = new ArrayList<>();\\n            helper(0, new boolean[n], new boolean[2*n], new boolean[2*n], \\n                new String[n], res);\\n            return res;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"19975",
			"view":"4842",
			"top":"5",
			"title":"Accepted : auxillary space O(n) , using dfs , cpp",
			"vote":"24",
			"content":"Space complexity :  Instead of using a 2D array to represent the chess board, i am using a 1D array , the index of which would represent the row number and the value of arr at row index will be the column number for the correct position of the queen.\\n \\ni.e\\n         \\n\\n           Instead of doing  arr[row][col]=1\\n           i am using arr[row]=col ;               where queen is positioned at (row,col);\\n\\nLogic :  DFS for every column number ,ranging from 0 to n-1, for all the rows from 0 to n-1 and check the validity of queen position for every row,col combination(using isSafe function)\\n\\nisSafe function : It checks whether the queen in current position(r,c) is being attacked by any of the r-1 queens positioned in row numbers 0 through r-1. \\n\\n\\n \\n\\n     class Solution {\\n        public:\\n            vector < vector <string> > sol;\\n            int limit;\\n            \\n            vector<string> toChessString(vector<int> arr) \\n              {\\n                string s(arr.size(),'.');\\n                vector<string> ans(arr.size(),s);\\n        \\n                for(int i=0 ; i<arr.size() ; i++)\\n                  ans[i][arr[i]]='Q';\\n        \\n                  return ans;\\n              }\\n        \\n        \\n            bool isSafe(vector<int> arr, int r , int c )\\n             {\\n                int check;\\n                for(int row=r-1,ldia=c-1,rdia=c+1 ; row>=0 ; row--,ldia--,rdia++)\\n                {\\n                    check=arr[row];\\n        \\n                    if(check==c || check==ldia || check==rdia)\\n                     return false;\\n                }\\n                return true;\\n             }\\n        \\n            void solveNqueen(vector<int> arr , int r , int c)\\n            {\\n                if(r==limit)\\n                 sol.push_back(toChessString(arr));\\n                    \\n                else\\n                 {\\n                     for(int col=c ; col<limit ; col++)\\n                     {\\n                        arr[r]=col;\\n        \\n                        if(isSafe(arr,r,col))\\n                          solveNqueen(arr,r+1,0);\\n                     }\\n                 }\\n            }\\n        \\n        \\n            vector<vector<string> > solveNQueens(int n) {\\n                vector<int> arr(n,0);\\n                limit=n;\\n                solveNqueen(arr,0,0);\\n              \\n                return sol;\\n            }\\n        };"
		},
		{
			"lc_ans_id":"19866",
			"view":"2285",
			"top":"6",
			"title":"C++ 6ms solution use bitmask",
			"vote":"18",
			"content":"    class Solution \\n    {\\n        int n;\\n        string getNq(int p)\\n        {\\n            string s(n, '.');\\n            s[p] = 'Q';\\n            return s;\\n        }\\n        void nQueens(int p, int l, int m, int r, vector<vector<string>> &res)\\n        {\\n            static vector<string> ans;\\n            if (p >= n)\\n            {\\n                res.push_back(ans);\\n                return ;\\n            }\\n            int mask = l | m | r;\\n            for (int i = 0, b = 1; i < n; ++ i, b <<= 1)\\n                if (!(mask & b))\\n                {\\n                    ans.push_back(getNq(i));\\n                    nQueens(p + 1, (l | b) >> 1, m | b, (r | b) << 1, res);\\n                    ans.pop_back();\\n                }\\n        }\\n    public:\\n        vector<vector<string> > solveNQueens(int n) \\n        {\\n            this->n = n;\\n            vector<vector<string>> res;\\n            nQueens(0, 0, 0, 0, res);\\n            return res;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"19804",
			"view":"2625",
			"top":"7",
			"title":"Share my JAVA DFS solution very easy to understand",
			"vote":"15",
			"content":"    public class Solution {\\n        private Set<Integer> col = new HashSet<Integer>();\\n        private Set<Integer> diag1 = new HashSet<Integer>();\\n        private Set<Integer> diag2 = new HashSet<Integer>();\\n        \\n        public List<List<String>> solveNQueens(int n) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            dfs(res,new ArrayList<String>(), 0, n);\\n            return res;\\n        }\\n        private void dfs(List<List<String>> res, List<String> list, int row, int n){\\n            if (row == n){\\n                res.add(new ArrayList<String>(list));\\n                return;\\n            }\\n            for (int i = 0; i < n; i++){\\n                if (col.contains(i) || diag1.contains(row + i) || diag2.contains(row - i)) continue;\\n                \\n                char[] charArray = new char[n];\\n                Arrays.fill(charArray, '.');\\n                charArray[i] = 'Q';\\n                String rowString = new String(charArray);\\n                \\n                list.add(rowString);\\n                col.add(i);\\n                diag1.add(row + i);\\n                diag2.add(row - i);\\n                \\n                dfs(res, list, row + 1, n);\\n                \\n                list.remove(list.size() - 1);\\n                col.remove(i);\\n                diag1.remove(row + i);\\n                diag2.remove(row - i);\\n            }\\n        }\\n    }"
		},
		{
			"lc_ans_id":"19971",
			"view":"1117",
			"top":"8",
			"title":"Python recursive dfs solution with comments.",
			"vote":"11",
			"content":"   \\n   \\n    def solveNQueens(self, n):\\n        res = []\\n        self.dfs([-1]*n, 0, [], res)\\n        return res\\n     \\n    # nums is a one-dimension array, like [1, 3, 0, 2] means\\n    # first queen is placed in column 1, second queen is placed\\n    # in column 3, etc.\\n    def dfs(self, nums, index, path, res):\\n        if index == len(nums):\\n            res.append(path)\\n            return  # backtracking\\n        for i in xrange(len(nums)):\\n            nums[index] = i\\n            if self.valid(nums, index):  # pruning\\n                tmp = \".\"*len(nums)\\n                self.dfs(nums, index+1, path+[tmp[:i]+\"Q\"+tmp[i+1:]], res)\\n    \\n    # check whether nth queen can be placed in that column\\n    def valid(self, nums, n):\\n        for i in xrange(n):\\n            if abs(nums[i]-nums[n]) == n -i or nums[i] == nums[n]:\\n                return False\\n        return True"
		},
		{
			"lc_ans_id":"19860",
			"view":"1430",
			"top":"9",
			"title":"93% concise, fast, and clear java solution",
			"vote":"9",
			"content":"The code has comment.\\n\\n    public class Solution {\\n        public List<List<String>> solveNQueens(int n) {\\n            boolean[] \\n                //ocp0 = new boolean[n], //whether there's a queen ocupying nth row, I don't need it\\n                ocp90 = new boolean[n], //whether there's a queen ocupying nth column\\n                ocp45 = new boolean[2 * n - 1], // mark 45 degree occupation\\n                ocp135 = new boolean[2 * n - 1]; // mark 135 degree occupation\\n            List<List<String>> ans = new ArrayList<List<String>>();\\n            char[][] map = new char[n][n];\\n            for (char[] tmp : map) Arrays.fill(tmp, '.'); //init\\n            \\n            solve(0, n, map, ans, ocp45, ocp90, ocp135);\\n            return ans;\\n        }\\n        \\n        private void solve(int depth, int n, char[][] map, List<List<String>> ans, \\n        boolean[] ocp45, boolean[] ocp90, boolean[] ocp135) {\\n            if (depth == n) {\\n                addSolution(ans, map);\\n                return;\\n            }\\n            \\n            for (int j = 0; j < n; j++)\\n                if (!ocp90[j] && !ocp45[depth + j] && !ocp135[j - depth + n - 1]) {\\n                    ocp90[j] = true;\\n                    ocp45[depth + j] = true;\\n                    ocp135[j - depth + n - 1] = true;\\n                    map[depth][j] = 'Q';\\n                    solve(depth + 1, n, map, ans, ocp45, ocp90, ocp135);\\n                    ocp90[j] = false;\\n                    ocp45[depth + j] = false;\\n                    ocp135[j - depth + n - 1] = false;\\n                    map[depth][j] = '.';\\n                }\\n        }\\n        \\n        private void addSolution(List<List<String>> ans, char[][] map) {\\n            List<String> cur = new ArrayList<String>();\\n            for (char[] i : map) cur.add(String.valueOf(i));\\n            ans.add(cur);\\n        }\\n    }"
		}
	],
	"id":"51",
	"title":"N-Queens",
	"content":"<p>The <i>n</i>-queens puzzle is the problem of placing <i>n</i> queens on an <i>n</i>×<i>n</i> chessboard such that no two queens attack each other.</p>\r\n\r\n<p><img src=\"https://leetcode.com/static/images/problemset/8-queens.png\" /></p>\r\n\r\n<p>Given an integer <i>n</i>, return all distinct solutions to the <i>n</i>-queens puzzle.</p>\r\n\r\n<p>Each solution contains a distinct board configuration of the <i>n</i>-queens' placement, where <code>'Q'</code> and <code>'.'</code> both indicate a queen and an empty space respectively.</p>\r\n\r\n<p>For example,<br />\r\nThere exist two distinct solutions to the 4-queens puzzle:</p>\r\n<pre>\r\n[\r\n [\".Q..\",  // Solution 1\r\n  \"...Q\",\r\n  \"Q...\",\r\n  \"..Q.\"],\r\n\r\n [\"..Q.\",  // Solution 2\r\n  \"Q...\",\r\n  \"...Q\",\r\n  \".Q..\"]\r\n]\r\n</pre>",
	"frequency":"418",
	"ac_num":"93400"
}