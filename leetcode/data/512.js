{
	"difficulty":"3",
	"submit_num":"10132",
	"show_id":"527",
	"leetcode_id":"527",
	"answers":[
		{
			"lc_ans_id":"99782",
			"view":"5475",
			"top":"0",
			"title":"Really simple and straightforward Java solution",
			"vote":"33",
			"content":"Make abbreviation for each word.\\nThen, check each word, if there are some strings which have same abbreviation with it, increase the prefix.\\n\\n``` java\\n    public List<String> wordsAbbreviation(List<String> dict) {\\n        int len=dict.size();\\n        String[] ans=new String[len];\\n        int[] prefix=new int[len];\\n        for (int i=0;i<len;i++) {\\n            prefix[i]=1;\\n            ans[i]=makeAbbr(dict.get(i), 1); // make abbreviation for each string\\n        }\\n        for (int i=0;i<len;i++) {\\n            while (true) {\\n                HashSet<Integer> set=new HashSet<>();\\n                for (int j=i+1;j<len;j++) {\\n                    if (ans[j].equals(ans[i])) set.add(j); // check all strings with the same abbreviation\\n                }\\n                if (set.isEmpty()) break;\\n                set.add(i);\\n                for (int k: set) \\n                    ans[k]=makeAbbr(dict.get(k), ++prefix[k]); // increase the prefix\\n            }\\n        }\\n        return Arrays.asList(ans);\\n    }\\n\\n    private String makeAbbr(String s, int k) {\\n        if (k>=s.length()-2) return s;\\n        StringBuilder builder=new StringBuilder();\\n        builder.append(s.substring(0, k));\\n        builder.append(s.length()-1-k);\\n        builder.append(s.charAt(s.length()-1));\\n        return builder.toString();\\n    }\\n```"
		},
		{
			"lc_ans_id":"99785",
			"view":"835",
			"top":"1",
			"title":"Visualization",
			"vote":"9",
			"content":"https://www.youtube.com/watch?v=yAQMcGY4c90\\n\\nInspired by @ckcz123's [solution](https://discuss.leetcode.com/topic/82613/really-simple-and-straightforward-java-solution)"
		},
		{
			"lc_ans_id":"99792",
			"view":"1874",
			"top":"2",
			"title":"HashMap + Trie => O(nL) solution",
			"vote":"7",
			"content":"The basic idea is to group all conflicted words, and then resolve the conflicts using Trie. The time complexity will be O(nL) for building trie, O(nL) to resolve conflicts, O(n) to group words. So the time complexity will be O(n(2L + 1). n is the number of words, and L is the average length of each words. \\n\\nI added the comments in code, so you can directly see the code. Please correct me if I make some mistakes and welcome to make my code concise.\\n```java\\npublic class Solution {\\n    \\n    public List<String> wordsAbbreviation(List<String> dict) {\\n        Map<String, List<Integer>> abbrMap = new HashMap<>();\\n        // 1) create result set\\n        List<String> res = new ArrayList<>(Collections.nCopies(dict.size(), null));\\n        // 2) Group all words with the same shortest abbreviation. For example:\\n        // \"internal\", \"interval\" => grouped by \"i6l\"\\n        // \"intension\", \"intrusion\" => grouped by \"i7n\"\\n        // \"god\" => grouped by \"god\"\\n        // we can notice that only words with the same length and the same start\\n        // and end letter could be grouped together\\n        for (int i = 0; i < dict.size(); i ++) {\\n            String word = dict.get(i);\\n            String st = getShortestAbbr(word);\\n            List<Integer> pos = abbrMap.get(st);\\n            if (pos == null) {\\n                pos = new ArrayList<>();\\n                abbrMap.put(st, pos);\\n            }\\n            pos.add(i);\\n        }\\n        // 3) Resolve conflicts in each group\\n        for (Map.Entry<String, List<Integer>> entry : abbrMap.entrySet()) {\\n            String abbr = entry.getKey();\\n            List<Integer> pos = entry.getValue();\\n            resolve(dict, res, abbr, pos);\\n        }\\n        return res;\\n    }\\n    \\n    /**\\n     * To resolve conflicts in a group, we could build a trie for all the words\\n     * in the group. The trie node will contain the count of words that has the\\n     * same prefix. Then we could use this trie to determine when we could resolve\\n     * a conflict by identifying that the count of words in that trie node will only\\n     * have one word has the prefix.\\n     */\\n    private void resolve(List<String> dict, List<String> res, String abbr, List<Integer> pos) {\\n        if (pos.size() == 1) {\\n            res.set(pos.get(0), abbr);\\n        } else {\\n            Trie trie = buildTrie(dict, pos);\\n            for (int p : pos) {\\n                String w = dict.get(p);\\n                Trie cur = trie;\\n                int i = 0;\\n                int n = w.length();\\n                // while loop to find the trie node which only has the 1 word which has\\n                // the prefix. That means in that position, only current word has that\\n                // specific character.\\n                while (i < n && cur.next.get(w.charAt(i)).cnt > 1) {\\n                    cur = cur.next.get(w.charAt(i));\\n                    i ++;\\n                }\\n                if (i >= n - 3) {\\n                    res.set(p, w);\\n                } else {\\n                    String pre = w.substring(0, i+1);\\n                    String st = pre + (n - i - 2) + \"\" + w.charAt(n - 1);\\n                    res.set(p, st);\\n                }\\n            }\\n        }\\n    }\\n    \\n    /**\\n     * Get the shortest abbreviation for a word\\n     */ \\n    private String getShortestAbbr(String s) {\\n        if (s.length() <= 3) {\\n            return s;\\n        } else {\\n            return s.charAt(0) + \"\" + (s.length() - 2) + \"\" + s.charAt(s.length() - 1);\\n        }\\n    }\\n    \\n    /**\\n     * Standard way to build the trie, but we record each trie node with the information\\n     * of the count of words with the same prefix.\\n     */\\n    private Trie buildTrie(List<String> dict, List<Integer> pos) {\\n        Trie root = new Trie();\\n        for (int p : pos) {\\n            String w = dict.get(p);\\n            Trie cur = root;\\n            for (int i = 0; i < w.length(); i ++) {\\n                char c = w.charAt(i);\\n                if (cur.next.containsKey(c)) {\\n                    cur = cur.next.get(c);\\n                } else {\\n                    Trie next = new Trie();\\n                    cur.next.put(c, next);\\n                    cur = next;\\n                }\\n                cur.cnt ++;\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    private class Trie {\\n        int cnt = 0;\\n        Map<Character, Trie> next = new HashMap<>();\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"99797",
			"view":"2432",
			"top":"3",
			"title":"Verbose Java Solution, HashMap(s)",
			"vote":"7",
			"content":"It's 10:30 PM now. Try to add some comments in-line. Will add more explanation later...\\n```\\npublic class Solution {\\n    public List<String> wordsAbbreviation(List<String> dict) {\\n        Map<String, String> wordToAbbr = new HashMap<>();\\n        Map<Integer, List<String>> groups = new HashMap<>();\\n        \\n        // Try to group words by their length. Because no point to compare words with different length.\\n        // Also no point to look at words with length < 4.\\n        for (String word : dict) {\\n            int len = word.length();\\n            if (len < 4) {\\n                wordToAbbr.put(word, word);\\n            }\\n            else {\\n                List<String> g = groups.getOrDefault(len, new ArrayList<String>());\\n                g.add(word);\\n                groups.put(len, g);\\n            }\\n        }\\n        \\n        // For each group of words with same length, generate a result HashMap.\\n        for (int len : groups.keySet()) {\\n            Map<String, String> res = getAbbr(groups.get(len));\\n            for (String word : res.keySet()) {\\n                wordToAbbr.put(word, res.get(word));\\n            }\\n        }\\n        \\n        // Generate the result list\\n        List<String> result = new ArrayList<>();\\n        for (String word : dict) {\\n            result.add(wordToAbbr.get(word));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private Map<String, String> getAbbr(List<String> words) {\\n        Map<String, String> res = new HashMap<>();\\n        int len = words.get(0).length();\\n        \\n        // Try to abbreviate a word from index 1 to len - 2 \\n        for (int i = 1; i < len - 2; i++) {\\n            Map<String, String> abbrToWord = new HashMap<>();\\n            for (String s : words) {\\n                if (res.containsKey(s)) continue;\\n                // Generate the current abbreviation\\n                String abbr = s.substring(0, i) + (len - 1 - i) + s.charAt(len - 1);\\n                // Tick: use reversed abbreviation to word map to check if there is any duplicated abbreviation\\n                if (!abbrToWord.containsKey(abbr)) {\\n                    abbrToWord.put(abbr, s);\\n                }\\n                else {\\n                    abbrToWord.put(abbr, \"\");\\n                }\\n            }\\n\\n            // Add unique abbreviations find during this round to result HashMap\\n            for (String abbr : abbrToWord.keySet()) {\\n                String s = abbrToWord.get(abbr);\\n                // Not a unique abbreviation\\n                if (s.length() == 0) continue;\\n                res.put(s, abbr);\\n            }\\n        }\\n        \\n        // Add all words that can't be shortened.\\n        for (String s : words) {\\n            if (!res.containsKey(s)) {\\n                res.put(s, s);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"99781",
			"view":"911",
			"top":"4",
			"title":"Python, Straightforward with Explanation",
			"vote":"6",
			"content":"Call two words similar if they have the same first letter, last letter, and length.  Only words that are similar are eligible to have the same abbreviation.  This motivates us to group words by similarity (it is an equivalence relation.)\\n\\nFor each group G of similar words, consider a word W.  If it has a longest common prefix P with any other word X in G, then our abbreviation must contain a prefix of more than |P| characters.  Sort G.  It must be the case that the longest common prefix of W with any other word X in G must occur with words adjacent to W, so we only need to check those.\\n\\n```\\ndef wordsAbbreviation(self, A):\\n    def longest_common_prefix(a, b):\\n        i = 0\\n        while i < len(a) and i < len(b) and a[i] == b[i]:\\n            i += 1\\n        return i\\n    \\n    ans = [None for _ in A]\\n    \\n    groups = collections.defaultdict(list)\\n    for index, word in enumerate(A):\\n        groups[len(word), word[0], word[-1]].append((word, index))\\n    \\n    for (size, first, last), enum_words in groups.iteritems():\\n        enum_words.sort()\\n        lcp = [0] * len(enum_words)\\n        for i, (word, _) in enumerate(enum_words):\\n            if i:\\n                word2, _ = enum_words[i-1]\\n                p = longest_common_prefix(word, word2)\\n                lcp[i] = max(lcp[i], p)\\n                lcp[i-1] = max(lcp[i-1], p)\\n                \\n        for (word, index), p in zip(enum_words, lcp):\\n            delta = size - 2 - p\\n            if delta <= max(1, len(str(delta)) - 1):\\n                ans[index] = word\\n            else:\\n                ans[index] = word[:p+1] + str(delta) + last\\n    \\n    return ans\\n```"
		},
		{
			"lc_ans_id":"99786",
			"view":"765",
			"top":"5",
			"title":"Any Explanations for the Problem?",
			"vote":"5",
			"content":"I am not quite understand the problem. If I just follow the description from the problem, here is the result I got for the example :[\"l2e\", \"god\", \"i6l\", \"me\", \"i6t\", \"in5l\", \"i7n\", \"f2e\", \"in6n\"] which is different from the answer of problem.\\nCan anyone explain to me why this kind of abbreviation is wrong? Thanks ahead."
		},
		{
			"lc_ans_id":"99784",
			"view":"123",
			"top":"6",
			"title":"Java HashMap & Trie with explanation, beat 100%, 25ms",
			"vote":"4",
			"content":"For searching word problems, the first thing comes to my mind is always trie.\\nIn this problem, we actually check if this word has prefix with other words that has same length, start and end;\\nThe naive way is build the whole trie for all words, which require large space if there are many long words.\\nSo my approach is,\\n\\n1. Build a map, abbr->Trie, where abbr=s[0]+len+s[len-1]\\n\\n2. For a new word, if abbr is not in the map, create a new Trie for this abbr, but only push further to the 1st char, and then memorize the idx of the word at this trie node;\\n\\n3. For a new word, if abbr is in the map, continue search in the trie till the current char can not be matched. And here we have 2 situation:\\n    (1) the idx memorized under this trie node is -1, which means that the word that has same prefix with current word has longer prefix with other words, then we just create a new trie node for the current word and memorize the current idx;\\n    (2) the idx memorized under this trie node is not -1, which means that the word memorized here has same prefix with current word and currently they share the longest prefix in this abbr. Thus, we need to push further for both words until the 1st different char. And also, we need to set the idx memorized before to -1. \\n\\nSince we do not build the suffix of the word in the trie until there is another word has same prefix, the space complexity for the trie with abbr is O(n*longestSamePrefixLength).\\n\\nCode:\\n\\n    class Solution {\\n    public List<String> wordsAbbreviation(List<String> dict) {\\n        abbr2trie = new HashMap<>();\\n        endIdx = new int[dict.size()];\\n        for(int i = 0; i<dict.size(); ++i){\\n            String cur = dict.get(i);\\n            if(cur.length()<=3) endIdx[i] = cur.length();\\n            else{\\n                addWord(cur, str2abbr(cur), i, dict);\\n            }\\n        }\\n        List<String> res = new LinkedList<>();\\n        for(int i = 0; i<dict.size(); ++i){\\n            String cur = dict.get(i);\\n            if(cur.length()-endIdx[i]-1<=1) res.add(cur);\\n            else{\\n                res.add(cur.substring(0, endIdx[i])+(cur.length()-endIdx[i]-1)+cur.charAt(cur.length()-1));\\n            }\\n        }\\n        return res;\\n    }\\n    private Map<String, TrieNode> abbr2trie;\\n    private int[] endIdx;\\n    class TrieNode{\\n        int stringIndex;\\n        TrieNode[] next;\\n        public TrieNode(){\\n            stringIndex = -1;\\n            next = new TrieNode[26];\\n        }\\n        public TrieNode(int i){\\n            stringIndex = i;\\n            next = new TrieNode[26];\\n        }\\n    }\\n    private String str2abbr(String s){\\n        return s.charAt(0)+String.valueOf(s.length())+s.charAt(s.length()-1);\\n    }\\n    private void addWord(String s, String abbr, int sidx, List<String> dict){\\n        if(!abbr2trie.containsKey(abbr)){\\n            // 1st word with this abbr\\n            // Only create 1st char of the string in the trie\\n            TrieNode head = new TrieNode();\\n            abbr2trie.put(abbr, head);\\n            head.next[s.charAt(0)-'a'] = new TrieNode(sidx);\\n            endIdx[sidx] = 1;\\n        }\\n        else{\\n            TrieNode node = abbr2trie.get(abbr);\\n            int idx = 0;\\n            while(node.next[s.charAt(idx)-'a']!=null){\\n                // Go through same preffix in the trie\\n                node = node.next[s.charAt(idx++)-'a'];\\n            }\\n            int sidx2 = node.stringIndex;\\n            if(sidx2==-1){\\n                // This means that other words with this prefix have been pushed further, they have longer same prefix\\n                // And this word could stop here and create next char to distinguish it\\n                node.next[s.charAt(idx)-'a'] = new TrieNode(sidx);\\n                endIdx[sidx] = idx+1;\\n                return;\\n            }\\n            // Push further sidx2\\n            node.stringIndex = -1;\\n            \\n            String s2 = dict.get(sidx2);\\n            while(s.charAt(idx)==s2.charAt(idx)){\\n                node.next[s.charAt(idx) - 'a'] = new TrieNode();\\n                node = node.next[s.charAt(idx++) -'a'];\\n            }\\n            endIdx[sidx]  = idx+1;\\n            endIdx[sidx2] = idx+1;\\n            node.next[s.charAt(idx)-'a'] = new TrieNode(sidx);\\n            node.next[s2.charAt(idx)-'a'] = new TrieNode(sidx2);\\n        }\\n    }\\n    }"
		},
		{
			"lc_ans_id":"99790",
			"view":"245",
			"top":"7",
			"title":"C++ clear solution, sorting, O(mnlogn) time",
			"vote":"3",
			"content":"The idea is to sort the dict first, by comparing 3 things:\\n1) a.size( ) == b.size( ) \\n2) first and last character \\n3) the remaining characters\\nAfter sorting, we only need compare a certain word to its previous and next word for longest common prefix, in order to decide its abbreviation. \\nn is the size of dict, and m is the average length of word in dict. Sorting complexity is O(mnlogn), and the procedure after sorting is O(mn). \\n```\\nclass Solution {\\npublic:\\n    vector<string> wordsAbbreviation(vector<string>& dict) {\\n        int n = dict.size();\\n        vector<string> ans = dict;\\n        // sort the dict\\n        sort(dict.begin(), dict.end(), mycompare);\\n        unordered_map<string, string> mp;\\n        // prefix is the longest common prefix between dict[i] and dict[i-1]\\n        int prefix = 0; \\n        for (int i = 0; i < n; ++i) {\\n            int j = 0;\\n            // j is the longest prefix length between dict[i] and dict[i+1]\\n           // if dict[i] is last word, or the length is different, or the last character is different, j = 0;\\n            if (i < n-1 && dict[i].size() == dict[i+1].size() && dict[i].back() == dict[i+1].back()) {\\n                while (j < dict[i].size() && dict[i][j] == dict[i+1][j])\\n                    j++;\\n            }\\n            if (j > prefix) prefix = j;\\n            // build abbreviation if it is shorter than word, and put it in a map\\n            if (dict[i].size() > prefix+3) {\\n                string s = dict[i].substr(0, prefix+1)+to_string(dict[i].size()-prefix-2)+dict[i].back();\\n                mp[dict[i]] = s;\\n            }\\n            // update prefix to be longest prefix with previous word\\n            prefix = j;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            if (mp.count(ans[i])) ans[i] = mp[ans[i]];\\n        }\\n        return ans;\\n    }\\nprivate:\\n    static bool mycompare(string& a, string& b) {\\n        if (a.size() == b.size()) {\\n            if (a.back() < b.back()) \\n                return true;\\n            else if (a.back() > b.back()) \\n                return false;\\n            for (int i = 0; i < a.size()-1; ++i) {\\n                if (a[i] < b[i]) \\n                    return true;\\n                else if (a[i] > b[i])\\n                    return false;\\n            }\\n        }\\n        return a.size() < b.size();\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"99822",
			"view":"152",
			"top":"8",
			"title":"Python short & clear solution",
			"vote":"2",
			"content":"Simple idea, have not applied optimization for simplicity\\n1) group abbreviations into different groups, group name is abbreviation, values are all the words with same abbreviation. For the example case \"intrusion' and \"intension\" goes to the same group \"i7n\"\\n2) for each group, resolve conflicts. For each conflicting word, try to search for prefix that makes it unique, from 1 to word length. For example, \"intrusion\", \"intention\", \"intentian\" in the same group, for \"intrusion\", try is \"in\" unique? no, then try \"int\"? no, then try \"intr\", yes. so got the abbreviation for \"intrusion\".\\n```\\nclass Solution(object):\\n    def wordsAbbreviation(self, dict):\\n        \"\"\"\\n        :type dict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        abbr2word = collections.defaultdict(set)\\n        word2abbr = {}\\n\\n        # group words into abbreivations\\n        for word in dict:\\n            abbr = self.getAbbreviation(word)\\n            abbr2word[abbr].add(word)\\n\\n        #resolve conflicts in each group\\n        for abbr, words in abbr2word.items():\\n            if len(words) > 1:\\n                for word in words:\\n                    for i in range(2, len(word)):\\n                        prefix = word[:i]\\n                        if self.checkUnique(prefix, words):\\n                            nabbr = self.getAbbr(word, prefix)\\n                            word2abbr[word] = nabbr\\n                            break\\n            else:\\n                word2abbr[words.pop()] = abbr\\n        return [word2abbr[word] for word in dict]\\n        \\n    def checkUnique(self, prefix, words):\\n        return sum(word.startswith(prefix) for word in words) == 1\\n                    \\n    def getAbbr(self, word, prefix):\\n        abbr = prefix + str(len(word) - 1 - len(prefix)) + word[-1]\\n        return abbr if len(abbr) < len(word) else word\\n        \\n    def getAbbreviation(self, word):\\n        abbr = word[0] + str(len(word) - 2) + word[-1]\\n        return abbr if len(abbr) < len(word) else word\\n```"
		},
		{
			"lc_ans_id":"99800",
			"view":"157",
			"top":"9",
			"title":"[C++] map & queue",
			"vote":"1",
			"content":"```\\nclass Solution {\\npublic:\\n    vector<string> wordsAbbreviation(vector<string>& dict) {\\n        vector<string> res;\\n        map<string, string> abbrs;\\n        map<string, set<string>> origins;\\n        queue<string> q;\\n        for (string w : dict) {\\n            q.push(w);\\n        }\\n\\n        for (int i = 1; !q.empty(); i++) {\\n            set<string> ambiguous;\\n            while (!q.empty()) {\\n                string w = q.front();\\n                q.pop();\\n                string ab = abbr(w, i);\\n                origins[ab].insert(w);\\n                abbrs[w] = ab;\\n                if (origins[ab].size() > 1) {\\n                    ambiguous.insert(ab);\\n                }\\n            }\\n\\n            for (string ab : ambiguous) {\\n                for (string word : origins[ab]) {\\n                    q.push(word);\\n                }\\n                origins.erase(ab);\\n            }\\n        }\\n\\n        for (string word : dict) {\\n            res.push_back(abbrs[word]);\\n        }\\n        return res;\\n    }\\n\\nprivate:\\n    string abbr(string s, int i) {\\n        return i + 2 >= s.size() ? s : s.substr(0, i) + to_string(s.size() - i - 1) + s[s.size() - 1];\\n    }\\n};\\n```"
		}
	],
	"id":"512",
	"title":"Word Abbreviation",
	"content":"<p>Given an array of n distinct non-empty strings, you need to generate <b>minimal</b> possible abbreviations for every word following rules below.</p>\r\n\r\n<ol>\r\n<li>Begin with the first character and then the number of characters abbreviated, which followed by the last character.</li>\r\n<li>If there are any conflict, that is more than one words share the same abbreviation, a longer prefix is used instead of only the first character until making the map from word to abbreviation become unique. In other words, a final abbreviation cannot map to more than one original words.</li>\r\n<li> If the abbreviation doesn't make the word shorter, then keep it as original.</li>\r\n</ol>\r\n\r\n<p><b>Example:</b><br />\r\n<pre>\r\n<b>Input:</b> [\"like\", \"god\", \"internal\", \"me\", \"internet\", \"interval\", \"intension\", \"face\", \"intrusion\"]\r\n<b>Output:</b> [\"l2e\",\"god\",\"internal\",\"me\",\"i6t\",\"interval\",\"inte4n\",\"f2e\",\"intr4n\"]\r\n</pre>\r\n</p>\r\n\r\n\r\n<b>Note:</b> \r\n<ol>\r\n<li> Both n and the length of each word will not exceed 400.</li>\r\n<li> The length of each word is greater than 1.</li>\r\n<li> The words consist of lowercase English letters only.</li>\r\n<li> The return answers should be <b>in the same order</b> as the original array.</li>\r\n</ol>",
	"frequency":"1",
	"ac_num":"4468"
}