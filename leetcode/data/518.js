{
	"difficulty":"2",
	"submit_num":"134",
	"show_id":"534",
	"leetcode_id":"534",
	"answers":[
		{
			"lc_ans_id":"100258",
			"view":"27026",
			"top":"0",
			"title":"A \"complete\" solution for TinyURL (Leetcode System Design)",
			"vote":"74",
			"content":"Note: The solution is translated from the Segmentfault post over [here](https://segmentfault.com/a/1190000006140476). Thanks for liuqi627.\\n\\n# Question Description\\n\\nOver [here](https://leetcode.com/problems/design-tinyurl/#/description)\\n\\n# S: Scenario\\n\\nLong URL to short URL and reversed.\\n\\n# N: Need (Assume the system is not massive if you are not sure)\\n\\n## QPS (queries per second)\\n\\n* Daily User: 100M\\n* Daily usage per person: (Write) long2short 0.1, (Read) short2long 1\\n* Daily request: Write 10M, Read 100M\\n* QPS: Since a day is 86400s approximately 100K.\\n\\nWrite 100, Read 1K\\n\\n* Peak QPS: Write 200, Read 2K\\n\\n(Thousand level can be handled by a single SSD MySQL Machine)\\n\\n## Storage\\n\\n* 10M new mappings (long URL to short URL) per day\\n* assume each mapping takes 100B in average\\n* 1GB every day. 1 TB hard drive could stand for 3 years.\\n\\nStorage is not the problem for this kind of system. Service like Netflix may have storage issues.\\n\\nThrough SN analysis, we could have a big picture of the system. In general, this system is not hard and could be handled by a single SSD Machine. \\n\\n# A: API\\n\\nOnly one service: URLService\\n\\n* Core (Business Logic) Layer:\\n* Class: URLService\\n* Interface:\\n* URLService.encode(String long_url)\\n* URLService.decode(String short_url)\\n* Web Layer: \\n* REST API:\\n* GET: /{short_url}, return a http redirect response(301)\\n* POST: goo.gl method - [google shorten URL](https://developers.google.com/url-shortener/v1/getting_started#actions)\\n\\nRequest Body: {url=longUrl} e.g. {\"longUrl\": \"http://www.google.com/\"}\\nReturn OK(200), short_url is included in the data\\n\\n# K: Data Access\\n\\n## Step 1: Pick a storage structure\\n\\n### SQL vs NoSQL?\\n\\n1. Does it need to support transactions? NoSQL does not support transaction.\\n2. Do we need rich SQL query? NoSQL does not support as many queries as SQL.\\n3. Pursue development efficiency? Most Web Framework supports SQL database very well (with ORM). It means fewer codes for the system.\\n4. Do we need to use AUTO_INCREMENT ID? NoSQL couldn't do this. It only has a global unique Object\\\\_id.\\n5. Does the system has a high requirement for QPS? NoSQL has high performance. For example, Memcached's QPS could reach million level, MondoDB does 10K level, MySQL only supports K level.\\n6. How high is the system's scalability? SQL requires developers write their codes to scale, while NoSQL comes with them (sharding, replica).\\n\\n### Answer:\\n\\n1. No -> NoSQL\\n2. No -> NoSQL\\n3. Doesn't matter because there are only a few codes. -> NoSQL\\n4. Our algorithm needs AUTO_INCREMENT ID. -> SQL\\n5. Write 200, Read 2K. Not high. -> SQL\\n6. Not high. -> SQL\\n\\n### System Algorithm\\n\\nOK, let's talk about the system algorithm. There are following solutions:\\n\\n1. Hash function:\\n\\n   long_url -> md5/sha1\\n\\n   * md5 convert a string into 128 binary bits, generally represented as 16 bytes hex:\\n\\n   http://site.douban.com/chuan -> c93a360dc7f3eb093ab6e304db516653\\n\\n   * sha1 convert a string into 160 binary bits, generally represented as 20 bytes hex:\\n\\n   http://site.douban.com/chuan -> dff85871a72c73c3eae09e39ffe97aea63047094\\n\\nThese two algorithms could make sure hash values are randomly distributed, but the conflicts are inevitable. Any hash algorithm could have inevitable conflicts.\\n\\n* Pros: Simple. We could take the first 6 chars of the converted string.\\n\\n* Cons: Conflicts.\\n\\n  Solutions: 1. use (long_url + timestamp) as the hash function key. 2. When conflicts, regenerates the hash value(it's different because timestamp changes).\\n\\n  Overall, when urls are over 1 billion, there would be a lot of conflicts and the efficiency could be very low.\\n\\n1. base62\\n   Take short_url as a 62 base notation. 6 bits could represent 62^6=57 billion.\\n\\nEach short_url represent a decimal digit. It could be the auto\\\\_increment\\\\_id in SQL database.\\n\\n```Java\\npublic class URLService {\\n    HashMap<String, Integer> ltos;\\n    HashMap<Integer, String> stol;\\n    static int COUNTER;\\n    String elements;\\n    URLService() {\\n        ltos = new HashMap<String, Integer>();\\n        stol = new HashMap<Integer, String>();\\n        COUNTER = 1;\\n        elements = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    }\\n    public String longToShort(String url) {\\n        String shorturl = base10ToBase62(COUNTER);\\n        ltos.put(url, COUNTER);\\n        stol.put(COUNTER, url);\\n        COUNTER++;\\n        return \"http://tiny.url/\" + shorturl;\\n    }\\n    public String shortToLong(String url) {\\n        url = url.substring(\"http://tiny.url/\".length());\\n        int n = base62ToBase10(url);\\n        return stol.get(n);\\n    }\\n    \\n    public int base62ToBase10(String s) {\\n        int n = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            n = n * 62 + convert(s.charAt(i));\\n        }\\n        return n;\\n        \\n    }\\n    public int convert(char c) {\\n        if (c >= '0' && c <= '9')\\n            return c - '0';\\n        if (c >= 'a' && c <= 'z') {\\n            return c - 'a' + 10;\\n        }\\n        if (c >= 'A' && c <= 'Z') {\\n            return c - 'A' + 36;\\n        }\\n        return -1;\\n    }\\n    public String base10ToBase62(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while (n != 0) {\\n            sb.insert(0, elements.charAt(n % 62));\\n            n /= 62;\\n        }\\n        while (sb.length() != 6) {\\n            sb.insert(0, '0');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n## Step 2: Database Schema\\n\\nOne table (id, long\\\\_url). id is the primary key, ordered by long\\\\_url\\n\\nThe basic system architecture:\\n\\nBrowser <-> Web <-> Core <-> DB\\n\\n# O: optimize\\n\\n## How to improve the response speed?\\n\\n### Improve the response speed between web server and database\\n\\nUse Memcached to improve response speed. When getting long_url, search in the cache first, then database. We could put 90% read request on the cache.\\n\\n### Improve the response speed between web server and user's browser\\n\\nDifferent locations use different web server and cache server. All the areas share a DB used to match the users to the closest web server (through DNS) when they have a miss on the cache.\\n\\n## What if we need one more MySQL machine?\\n\\n### Issues:\\n\\n* running out of cache\\n* More and more write requests\\n* More and more cache misses\\n\\n### Solutions:\\n\\n**Database Partitioning**\\n\\n1. Vertical sharding 2. Horizontal sharding\\n\\nThe best way is horizontal sharding.\\n\\nCurrently table structure is (id, long_url). So, which column should be sharding key?\\n\\nAn easy way is id modulo sharding.\\n\\nHere comes another question: How could multiple machines share a global auto\\\\_increment\\\\_id?\\n\\nTwo ways: 1. use one more machine to maintain the id. 2. use zookeeper. Both suck.\\n\\nSo, we do not use global auto\\\\_increment\\\\_id.\\n\\nThe pro way is put the sharding key as the first byte of the short_url.\\n\\nAnother way is to use consistent hashing to break the cycle into 62 pieces. It doesn't matter how many pieces because there probably would not be over 62 machines (it could be 360 or whatever). Each machine is responsible for the service in the part of the cycle.\\n\\nwrite long\\\\_url -> hash(long_url)%62 -> put long\\\\_url to the specific machine according to hash value -> generate short\\\\_url on this machine -> return short\\\\_url\\n\\nshort\\\\_url request -> get the sharding key (first byte of the short\\\\_url) -> search in the corresponding machine based on sharding key -> return long\\\\_url\\n\\nEach time we add a new machine, put half of the range of the most used machine to the new machine.\\n\\n# More Optimization\\n\\nPut Chinese DB in China, American DB in the United States. Use geographical information as the sharding key, e.g. 0 for Chinese websites, 1 for American websites."
		},
		{
			"lc_ans_id":"100261",
			"view":"1481",
			"top":"1",
			"title":"How do I make this problem as solved?",
			"vote":"10",
			"content":"This is only problem in my TODO list.\\nThat makes me feel not good."
		},
		{
			"lc_ans_id":"100266",
			"view":"9692",
			"top":"2",
			"title":"Question on Caching",
			"vote":"10",
			"content":"This is really a good problem and makes us think more than just coding!\\n\\nSuggestion to add questions to the problem:\\n\\n* If you can enable caching, what would you cache and what's the expiry time? Explain!"
		},
		{
			"lc_ans_id":"100263",
			"view":"17842",
			"top":"3",
			"title":"Suggestion on extra questions",
			"vote":"9",
			"content":"This is a great problem! Reminds that a programming interview is not only a coding interview :)\\n\\nI'd like to suggest a couple of extra questions:\\n* Keep URLs forever or prune, pros/cons? How we do pruning? \\n* What API would you provide to a third-party developer?"
		},
		{
			"lc_ans_id":"100265",
			"view":"1621",
			"top":"4",
			"title":"Should we design a class and name methods encode and decode for completing this question? My solutions isnt getting picked up when i run code",
			"vote":"1",
			"content":"```\\npublic class Codec {\\n    String alphabet = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    HashMap<String, String> map = new HashMap<>();\\n    Random rand = new Random();\\n    String key = getRand();\\n    public String getRand() {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 6; i++) {\\n            sb.append(alphabet.charAt(rand.nextInt(62)));\\n        }\\n        return sb.toString();\\n    }\\n\\n    public String encode(String longUrl) {\\n        while (map.containsKey(key)) {\\n            key = getRand();\\n        }\\n        map.put(key, longUrl);\\n        return \"http://tinyurl.com/\" + key;\\n    }\\n\\n    public String decode(String shortUrl) {\\n        return map.get(shortUrl.replace(\"http://tinyurl.com/\", \"\"));\\n    }\\n}\\n\\nclass Main {\\n    public static void main(String[] args) {     \\n        Codec codec = new Codec();\\n        String res = codec.encode(\"https://leetcode.com/problems/design-tinyurl\");\\n        codec.decode(res);        \\n    }\\n}\\n\\n```"
		},
		{
			"lc_ans_id":"100260",
			"view":"34",
			"top":"5",
			"title":"Feedback on this code",
			"vote":"0",
			"content":"I need feedback on how well this code works:\\n```\\n# Solution with SQL:\\nimport hashlib\\nimport sqlite3\\nimport time\\n\\n# setup\\ndatabase = \"tiny.sqlite3\" \\nconn = sqlite3.connect(database)\\nc = conn.cursor()\\nc.execute(\"create table if not exists urls (long_url string, short string)\")\\nconn.commit()\\nconn.close()\\n\\ndef new_url(long_url, short):\\n    conn = sqlite3.connect(database)\\n    c = conn.cursor()\\n    c.execute(\"insert into urls values(?, ?)\", long_url, short)\\n    conn.commit()\\n    conn.close()\\n\\ndef query(short_url):\\n    conn = sqlite3.connect(database)\\n    c = conn.cursor()\\n    u=c.execute(\"select * from urls where short = ?\", short_url)\\n    conn.commit()\\n    conn.close()\\n    return u[0]\\n\\n# reuse important functions\\ndef gen_url(url):\\n    h = hashlib.sha1()\\n    h.update(b\"%s\"%url)\\n    h.update(bytes(int(time.time())))\\n    return \"http://tinyurl.com/%s\"%h.hexdigest()[:5]\\n\\nclass URLService:\\n    def encode(url):\\n        tiny = gen_url(url)\\n        # we have found a conflict!\\n        if query(tiny):\\n            URLService.encode(url)\\n        new_url(url, tiny)\\n        return tiny\\n    def decode(tiny):\\n        url = query(tiny)\\n        return url\\n```\\nvs. this code:\\n```\\n# Dramatically simple solution using NoSQL:\\nimport hashlib\\nimport json\\nimport time\\ndb = \"tiny.json\"\\n\\n# use a bytes + timestamp\\n# conflict-proof\\ndef gen_url(url):\\n    h = hashlib.sha1()\\n    h.update(b\"%s\"%url)\\n    h.update(bytes(int(time.time())))\\n    return \"http://tinyurl.com/%s\"%h.hexdigest()[:5]\\n\\nclass URLService:\\n    urls = None\\n    with open(db, \"wr\") as d:\\n        urls = json.loads(d.read())\\n        \\n    def encode(url):\\n        t = gen_url(url)\\n        # we have found a conflict!\\n        if urls[t]:\\n            URLService.encode(url)\\n        else:\\n            urls[t] = url\\n        with open(db, \"w+\") as d:\\n            d.write(json.dumps(url))\\n        return t\\n    \\n    def decode(url):\\n        with open(db, \"r+\") as d:\\n            urls = json.loads(d.read())\\n        return urls[url]\\n```\\nI have a feeling that the NoSQL solution is a lot less complex and easier to understand.\\nAlso, what do I have to implement after this?\\n\\n**EDIT**: Both solutions will lag when there are more than a million URLs in the database, because in both of\\nthe solutions, they recursively check if the url is in the database. It will become harder to recalculate as the amount\\nof URLs increases. If this was on a distributed system, it would take atleast 5 min to make space for a new URL, and the time keeps increasing. Soon it will have to increase the length of the tiny URLs, thereby defeating the original purpose\\n\\ntl;dr: my solutions don't scale"
		},
		{
			"lc_ans_id":"100264",
			"view":"1768",
			"top":"6",
			"title":"Hierarchy and Duplicate TinyURLs",
			"vote":"0",
			"content":"\\n1. Should you allow the user to create a TinyURL of an existing TinyURL?\\nExample: `https://leetcode.com/problems/design-tinyurl` is shortened to `http://tinyurl.com/4e9iAk`.\\nWhat should be done to shorten `http://tinyurl.com/4e9iAk` to say, for example, `http://tinyurl.com/4f0jBl`?\\n\\n2. Should you allow the user to force shortening of a long URL to multiple tiny URLs?\\n\\nWhat could be the advantages/disadvantages?\\n\\nSome of the points I feel-\\n****Advantages****: User can get a sense of encrypting/customizing a commonly available TinyURL.\\n\\n****Disadvantages****: There can be a loop between the redirection of URL, similar to a loop in LinkedList. This might cause the system to hang forever. \\nIncreased time and space complexity."
		},
		{
			"lc_ans_id":"100259",
			"view":"959",
			"top":"7",
			"title":"extra Q",
			"vote":"0",
			"content":"I would consider supporting custom URLs - like tinyurl.com/golangrocks pointing to some longer URL."
		},
		{
			"lc_ans_id":"100267",
			"view":"4783",
			"top":"8",
			"title":"Need feedback on this code for the tinyUrl.",
			"vote":"0",
			"content":"```\\n// You can type code here and execute it.\\nimport java.lang.*;\\nimport java.util.*;\\n\\n\\nclass Main {\\n    public static void main(String[] args) {\\n        String s = \"https://leetcode.com/problems/design-tinyurl\";\\n        // HashTable<String, String> tiny = new HashTable<String, String>();\\n        Hashtable<Integer,String> tiny = new Hashtable<Integer, String>();\\n        int id = generateId(tiny, s);\\n        System.out.println(generateTinyUrl(id));\\n    }\\n    \\n    private static String generateTinyUrl(int id){\\n        char[] set = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u',\\n            'v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'\\n        };\\n        StringBuilder st = new StringBuilder();\\n        while(id > 0){\\n            char ch = set[id % 62];\\n            st.append(ch);\\n            id = id / 62;\\n        }\\n        int size = st.length();\\n        // for(int i=size; i < 6;i++){\\n        //     st.append(set[randomWithRange(0,61)]);\\n        // }\\n        \\n        System.out.println(st);\\n        return new String(st);\\n    }\\n    \\n    private static int randomWithRange(int min, int max)\\n    {\\n        int range = (max - min) + 1;     \\n        return (int)(Math.random() * range) + min;\\n    }\\n    \\n    private static int generateId(Hashtable<Integer, String> tiny, String longUrl){\\n        if(tiny.containsValue(longUrl)){\\n            for(int key: tiny.keySet()){\\n                if(tiny.get(key) == longUrl){\\n                    return key;\\n                }\\n            }\\n        }\\n        \\n        int size = tiny.size();\\n        return size+1;\\n    }\\n}\\n```"
		}
	],
	"id":"518",
	"title":"Design TinyURL",
	"content":"<blockquote>Note: For the coding companion problem, please see: <a href=\"https://leetcode.com/problems/encode-and-decode-tinyurl/\">Encode and Decode TinyURL</a>.</blockquote>\r\n\r\n<p>How would you design a URL shortening service that is similar to <a href=\"https://en.wikipedia.org/wiki/TinyURL\" target=\"_blank\">TinyURL</a>?</p>\r\n\r\n<p><b>Background:</b><br />\r\nTinyURL is a URL shortening service where you enter a URL such as <code>https://leetcode.com/problems/design-tinyurl</code> and it returns a short URL such as <code>http://tinyurl.com/4e9iAk</code>.\r\n</p>\r\n\r\n<p><b>Requirements:</b><br />\r\n<ol>\r\n<li>For instance, \"http://tinyurl.com/<span class=\"hilight\">4e9iAk</span>\" is the tiny url for the page <code>\"https://leetcode.com/problems/design-tinyurl\"</code>. The <b>identifier</b> (<span class=\"hilight\">the highlighted part</span>) can be any string with 6 alphanumeric characters containing <code>0-9</code>, <code>a-z</code>, <code>A-Z</code>.</li>\r\n\r\n<li>Each shortened URL must be unique; that is, no two different URLs can be shortened to the same URL.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Note about Questions:</b><br />Below are just a small subset of questions to get you started. In real world, there could be many follow ups and questions possible and the discussion is open-ended (No one true or correct way to solve a problem). If you have more ideas or questions, please ask in Discuss and we may compile it here!</p>\r\n\r\n<p><b>Questions:</b><br />\r\n<ol>\r\n<li>How many unique identifiers possible? Will you run out of unique URLs?</li>\r\n<li>Should the identifier be increment or not? Which is easier to design? Pros and cons?</li>\r\n<li>Mapping an identifier to an URL and its reversal - Does this problem ring a bell to you?</li>\r\n<li>How do you store the URLs? Does a simple flat file database work?</li>\r\n<li>What is the bottleneck of the system? Is it <b>read-heavy</b> or <b>write-heavy</b>?</li>\r\n<li>Estimate the maximum number of URLs a single machine can store.</li>\r\n<li>Estimate the maximum number of queries per second (QPS) for decoding a shortened URL in a single machine.</li>\r\n<li>How would you scale the service? For example, a viral link which is shared in social media could result in a peak QPS at a moment's notice.</li>\r\n<li>How could you handle redundancy? i,e, if a server is down, how could you ensure the service is still operational?</li>\r\n<li>Keep URLs forever or prune, pros/cons? How we do pruning? (Contributed by @alex_svetkin)</li>\r\n<li>What API would you provide to a third-party developer? (Contributed by @alex_svetkin)</li>\r\n<li>If you can enable caching, what would you cache and what's the expiry time? (Contributed by @Humandroid)</li>\r\n</ol>\r\n</p>\r\n\r\n<style>\r\n.hilight {\r\n  color: #d14;\r\n  background-color: #f7f7f9;\r\n  padding: 1px 3px;\r\n  border: 1px solid #e1e1e8\"\r\n}\r\n</style>",
	"frequency":"615",
	"ac_num":"0"
}