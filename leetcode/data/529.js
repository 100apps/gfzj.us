{
	"difficulty":"2",
	"submit_num":"24785",
	"show_id":"545",
	"leetcode_id":"545",
	"answers":[
		{
			"lc_ans_id":"101280",
			"view":"6450",
			"top":"0",
			"title":"Java(12ms) - left boundary, left leaves, right leaves, right boundary",
			"vote":"57",
			"content":"\\n\\n\\n    List<Integer> nodes = new ArrayList<>(1000);\\n    public List<Integer> boundaryOfBinaryTree(TreeNode root) {\\n        \\n        if(root == null) return nodes;\\n\\n        nodes.add(root.val);\\n        leftBoundary(root.left);\\n        leaves(root.left);\\n        leaves(root.right);\\n        rightBoundary(root.right);\\n        \\n        return nodes;\\n    }\\n    public void leftBoundary(TreeNode root) {\\n        if(root == null || (root.left == null && root.right == null)) return;\\n        nodes.add(root.val);\\n        if(root.left == null) leftBoundary(root.right);\\n        else leftBoundary(root.left);\\n    }\\n    public void rightBoundary(TreeNode root) {\\n        if(root == null || (root.right == null && root.left == null)) return;\\n        if(root.right == null)rightBoundary(root.left);\\n        else rightBoundary(root.right);\\n        nodes.add(root.val); // add after child visit(reverse)\\n    }\\n    public void leaves(TreeNode root) {\\n        if(root == null) return;\\n        if(root.left == null && root.right == null) {\\n            nodes.add(root.val);\\n            return;\\n        }\\n        leaves(root.left);\\n        leaves(root.right);\\n    }"
		},
		{
			"lc_ans_id":"101294",
			"view":"1593",
			"top":"1",
			"title":"[Java] [C++] Clean Code  (1 Pass perorder postorder hybrid)",
			"vote":"16",
			"content":"1. node.left is left bound if node is left bound;\\n    node.right could also be left bound if node is left bound && node has no right child;\\n2. Same applys for right bound;\\n3. if node is left bound, add it before 2 child - pre order;\\n    if node is right bound, add it after 2 child - post order;\\n4. A leaf node that is neither left or right bound belongs to the bottom line;\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> boundaryOfBinaryTree(TreeNode* root) {\\n        vector<int> bounds;\\n        if (root) {\\n            bounds.push_back(root->val);\\n            getBounds(root->left, bounds, true, false);\\n            getBounds(root->right, bounds, false, true);\\n        }\\n        return bounds;\\n    }\\n\\nprivate:\\n    void getBounds(TreeNode* node, vector<int>& res, bool lb, bool rb) {\\n        if (!node)  return;\\n        if (lb) res.push_back(node->val);\\n        if (!lb && !rb && !node->left && !node->right)  res.push_back(node->val);\\n        getBounds(node->left, res, lb, rb && !node->right);\\n        getBounds(node->right, res, lb && !node->left, rb);\\n        if (rb) res.push_back(node->val);\\n    }\\n};\\n```\\n**Java**\\n```\\npublic class Solution {\\n    public List<Integer> boundaryOfBinaryTree(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (root != null) {\\n            res.add(root.val);\\n            getBounds(root.left, res, true, false);\\n            getBounds(root.right, res, false, true);\\n        }\\n        return res;\\n    }\\n\\n    private void getBounds(TreeNode node, List<Integer> res, boolean lb, boolean rb) {\\n        if (node == null) return;\\n        if (lb) res.add(node.val);\\n        if (!lb && !rb && node.left == null && node.right == null) res.add(node.val);\\n        getBounds(node.left, res, lb, rb && node.right == null);\\n        getBounds(node.right, res, lb && node.left == null, rb);\\n        if (rb) res.add(node.val);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"101285",
			"view":"2868",
			"top":"2",
			"title":"Java Preorder Single Pass O(n) Solution",
			"vote":"12",
			"content":"We perform a single preorder traversal of the tree, keeping tracking of the left boundary and middle leaf nodes and the right boundary nodes in the process. A single flag is used to designate the type of node during the preorder traversal. Its values are: \\n                                         0 - root, 1 - left boundary node, 2 - right boundary node, 3 - middle node.\\n\\n```\\npublic List<Integer> boundaryOfBinaryTree(TreeNode root) {\\n    List<Integer> left = new LinkedList<>(), right = new LinkedList<>();\\n    preorder(root, left, right, 0);\\n    left.addAll(right);\\n    return left;\\n}\\n\\npublic void preorder(TreeNode cur, List<Integer> left, List<Integer> right, int flag) {\\n    if (cur == null) return;\\n    if (flag == 2) right.add(0, cur.val);\\n    else if (flag <= 1 || cur.left == null && cur.right == null) left.add(cur.val);\\n    preorder(cur.left, left, right, flag <= 1 ? 1 : (flag == 2 && cur.right == null) ? 2 : 3);\\n    preorder(cur.right, left, right, flag % 2 == 0 ? 2 : (flag == 1 && cur.left == null) ? 1 : 3);\\n}\\n```"
		},
		{
			"lc_ans_id":"101308",
			"view":"598",
			"top":"3",
			"title":"python dfs solution",
			"vote":"4",
			"content":"```\\nclass Solution(object):\\n    def boundaryOfBinaryTree(self, root):\\n        def dfs_leftmost(node):\\n            if not node or not node.left and not node.right:\\n                return\\n            boundary.append(node.val)\\n            if node.left:\\n                dfs_leftmost(node.left)\\n            else:\\n                dfs_leftmost(node.right)\\n\\n        def dfs_leaves(node):\\n            if not node:\\n                return\\n            dfs_leaves(node.left)\\n            if node != root and not node.left and not node.right:\\n                boundary.append(node.val)\\n            dfs_leaves(node.right)\\n\\n        def dfs_rightmost(node):\\n            if not node or not node.left and not node.right:\\n                return\\n            if node.right:\\n                dfs_rightmost(node.right)\\n            else:\\n                dfs_rightmost(node.left)\\n            boundary.append(node.val)\\n\\n        if not root:\\n            return []\\n        boundary = [root.val]\\n        dfs_leftmost(root.left)\\n        dfs_leaves(root)\\n        dfs_rightmost(root.right)\\n        return boundary\\n```"
		},
		{
			"lc_ans_id":"101309",
			"view":"383",
			"top":"4",
			"title":"Python, Straightforward with Explanation",
			"vote":"3",
			"content":"Let's merely get the nodes from the left boundary, the right boundary, and the leaves, in counter-clockwise order.\\n\\nTo get nodes from the left boundary, we start from root.left and move left if we can, else right, until we can't move anymore.  The right boundary is similar.\\n\\nTo get nodes from the leaves, we DFS until we hit a leaf (until node.left and node.right are both None).  We should take care to add to our stack in the order (right, left) so that they are popped in the order (left, right).\\n\\nNow armed with all the nodes we could visit, let's visit them in order.  As we visit a node, we should skip over ones we've seen before (comparing node objects by pointer, not node.val), and otherwise add node.val to our answer.\\n\\nWe could also rewrite this answer by calling visit(cur) directly instead of appending to left_bd_nodes, etc. to save a little space.\\n\\n```\\nif not root: return []\\n\\nleft_bd_nodes = [root]\\ncur = root.left\\nwhile cur:\\n  left_bd_nodes.append(cur)\\n  cur = cur.left or cur.right\\n\\nright_bd_nodes = [root]\\ncur = root.right\\nwhile cur:\\n  right_bd_nodes.append(cur)\\n  cur = cur.right or cur.left\\n\\nleaf_nodes = []\\nstack = [root]\\nwhile stack:\\n  node = stack.pop()\\n  if node.right:\\n    stack.append(node.right)\\n  if node.left:\\n    stack.append(node.left)\\n  if not node.left and not node.right:\\n    leaf_nodes.append(node)\\n\\nans = []\\nseen = set()\\ndef visit(node):\\n  if node not in seen:\\n    seen.add(node)\\n    ans.append(node.val)\\n\\nfor node in left_bd_nodes: visit(node)\\nfor node in leaf_nodes: visit(node)\\nfor node in reversed(right_bd_nodes): visit(node)\\n\\nreturn ans\\n```\\n\\n*Note: I try to focus my editorials on the most repeatable and instructive solutions, not the most clever or short.*"
		},
		{
			"lc_ans_id":"101307",
			"view":"161",
			"top":"5",
			"title":"Python solution, recursive dfs ~20 lines.",
			"vote":"2",
			"content":"\\n    def boundaryOfBinaryTree(self, root):\\n        # The main idea is to carry the flag isleft and isight\\n        # in the dfs steps to help decide when to add node\\n        # values to the boundary array.\\n        if not root: return []\\n        boundary = [root.val]\\n        def dfs(root, isleft, isright):\\n            if root:\\n                # append when going down from the left or at leaf node\\n                if (not root.left and not root.right) or isleft:\\n                    boundary.append(root.val)\\n                \\n                if root.left and root.right:\\n                    dfs(root.left, isleft, False)\\n                    dfs(root.right, False, isright)\\n                else:\\n                    dfs(root.left,  isleft, isright)\\n                    dfs(root.right, isleft, isright)\\n                \\n                # append to boundary when coming up from the right\\n                if (root.left or root.right) and isright:\\n                    boundary.append(root.val)\\n        \\n        dfs(root.left, True, False)\\n        dfs(root.right, False, True)\\n        return boundary"
		},
		{
			"lc_ans_id":"101279",
			"view":"124",
			"top":"6",
			"title":"One pass preorder-postorder hybrid algorithm in Java.",
			"vote":"1",
			"content":"```java\\npublic class Solution {\\n    public List<Integer> boundaryOfBinaryTree(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        result.add(root.val);\\n        preorder(root.left, true, result);\\n        postorder(root.right, true, result);\\n        \\n        return result;\\n    }\\n    \\n    private void preorder(TreeNode node, boolean isBoundary, List<Integer> visitor) {\\n        if (node == null) {\\n            return;\\n        }\\n        if (isBoundary || isLeaf(node)) {\\n            visitor.add(node.val);\\n        } \\n        \\n        if (node.left != null) {\\n            preorder(node.left, isBoundary, visitor);\\n            preorder(node.right, false, visitor);\\n        } else {\\n            preorder(node.right, isBoundary, visitor);\\n        }\\n\\n        \\n    }\\n    \\n    private void postorder(TreeNode node, boolean isBoundary, List<Integer> visitor) {\\n        if (node == null) {\\n            return;\\n        }\\n        if (node.right != null) {\\n            postorder(node.left, false, visitor);\\n            postorder(node.right, isBoundary, visitor);\\n        } else {\\n            postorder(node.left, isBoundary, visitor);\\n        }\\n       \\n        \\n        if (isBoundary || isLeaf(node)) {\\n            visitor.add(node.val);\\n        } \\n        \\n    }\\n    \\n    private boolean isLeaf(TreeNode node) {\\n        return node.left == null && node.right == null;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"101288",
			"view":"551",
			"top":"7",
			"title":"Java Recursive Solution - Beats 94%",
			"vote":"1",
			"content":"I came up with this recursive solution. I saw some iterative solutions by others but felt the same tree is iterated 3 times to find left boundary, right boundary and leaves. This one does it in one iteration and is self explanatory and finishes in 11ms. I am giving all three solutions to understand how I compressed the code in each round but they all works fine and accepted by OJ.\\n\\n**First hand solution**\\n```\\npublic class Solution {\\n    public List<Integer> boundaryOfBinaryTree(TreeNode root) {\\n        List<Integer> ls = new ArrayList<Integer>();\\n        if(root!=null){\\n            ls.add(root.val);\\n            lookupElems(root.left,ls,true,false);      \\n            lookupElems(root.right,ls,false,true);\\n        }\\n        return ls;\\n    }\\n    \\n    private void lookupElems(TreeNode root,List<Integer> ls,boolean isLeftBoundary,boolean isRightBoundary){\\n        if (root==null) return;\\n        if (root.left==null && root.right==null) {\\n            ls.add(root.val);\\n            return;\\n        }        \\n        if (isLeftBoundary) {\\n            ls.add(root.val);\\n            if(root.left!=null) {\\n                lookupElems(root.left,ls,true,false);\\n                lookupElems(root.right,ls,false,false);\\n            }\\n            else if (root.right!=null){\\n                lookupElems(root.right,ls,true,false);\\n            } \\n            return;\\n        }\\n        if(!isLeftBoundary && !isRightBoundary){\\n            lookupElems(root.left,ls,false,false);\\n            lookupElems(root.right,ls,false,false);\\n            return;\\n        }\\n        if (isRightBoundary) {\\n            if(root.right!=null) {\\n                lookupElems(root.left,ls,false,false);\\n                lookupElems(root.right,ls,false,true);\\n            }\\n            else if (root.left!=null){\\n                lookupElems(root.left,ls,false,true);\\n            }\\n            ls.add(root.val);\\n        }        \\n    }\\n}\\n```\\n**Second Round Compression**\\n```\\npublic class Solution {\\n    public List<Integer> boundaryOfBinaryTree(TreeNode root) {\\n        List<Integer> ls = new ArrayList<Integer>();\\n        if(root!=null){\\n            ls.add(root.val);\\n            lookupElems(root.left,ls,true,false);      \\n            lookupElems(root.right,ls,false,true);\\n        }\\n        return ls;\\n    }\\n    \\n    private void lookupElems(TreeNode root,List<Integer> ls,boolean isLeftBoundary,boolean isRightBoundary){\\n        if (root==null) return;\\n        if (root.left==null && root.right==null) {\\n            ls.add(root.val);\\n            return;\\n        }        \\n        if (isLeftBoundary) {\\n            ls.add(root.val);\\n            lookupElems(root.left,ls,root.left!=null,false);\\n            lookupElems(root.right,ls,root.left==null,false);\\n            return;\\n        }\\n        if (!isLeftBoundary && !isRightBoundary){\\n            lookupElems(root.left,ls,false,false);\\n            lookupElems(root.right,ls,false,false);\\n            return;\\n        }\\n        if (isRightBoundary) {\\n            lookupElems(root.left,ls,false,root.right==null);\\n            lookupElems(root.right,ls,false,root.right!=null);\\n            ls.add(root.val);\\n        }        \\n    }\\n}\\n```\\n**Final Compression to look more elegant but it looks little complex :D**\\n```\\npublic class Solution {\\n    public List<Integer> boundaryOfBinaryTree(TreeNode root) {\\n        List<Integer> ls = new ArrayList<Integer>();\\n        if(root!=null){\\n            ls.add(root.val);\\n            lookupElems(root.left,ls,true,false);      \\n            lookupElems(root.right,ls,false,true);\\n        }\\n        return ls;\\n    }\\n    \\n    private void lookupElems(TreeNode root,List<Integer> ls,boolean isLeftBoundary,boolean isRightBoundary){\\n        if (root==null) {\\n            return;\\n        }\\n        if (root.left==null && root.right==null) {\\n            ls.add(root.val);\\n            return;\\n        }        \\n        if (isLeftBoundary) {\\n            ls.add(root.val);\\n        } \\n        lookupElems(root.left,ls,root.left!=null && isLeftBoundary,root.right==null && isRightBoundary);\\n        lookupElems(root.right,ls,root.left==null && isLeftBoundary,root.right!=null && isRightBoundary);\\n        if (isRightBoundary) {\\n            ls.add(root.val);\\n        }\\n    }\\n}\\n```\\nHope you like it! :-)"
		},
		{
			"lc_ans_id":"101306",
			"view":"398",
			"top":"8",
			"title":"Verbose java solution. easy to understand",
			"vote":"1",
			"content":"public class Solution {\\n\\n    private List<Integer> bound = new ArrayList<>();\\n    \\n    public List<Integer> boundaryOfBinaryTree(TreeNode root) {\\n        if (root == null) return bound;\\n        if (!(root.left == null && root.right == null)) {\\n            bound.add(root.val);\\n        }\\n        TreeNode l = root.left;\\n        TreeNode r = root.right;\\n        \\n        while (l != null && !(l.left == null && l.right == null)) {\\n            bound.add(l.val);\\n            if (l.left != null) l = l.left;\\n            else l = l.right;\\n        }\\n        \\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        \\n        while (p != null || stack.size() != 0) {\\n            if (p != null) {\\n                stack.add(p);\\n                if (p.left == null && p.right == null) bound.add(p.val);\\n                p = p.left;\\n            }\\n            else {\\n                TreeNode tmp = stack.pollLast();\\n                p = tmp.right;\\n            }\\n        }\\n        \\n        List<Integer> right = new ArrayList<>();\\n        while (r != null && !(r.left == null && r.right == null)) {\\n            right.add(r.val);\\n            if (r.right != null) r = r.right;\\n            else r = r.left;\\n        }\\n        for (int i = right.size() - 1; i >= 0; i--) {\\n            bound.add(right.get(i));\\n        }\\n        return bound;\\n    }\\n}"
		},
		{
			"lc_ans_id":"101282",
			"view":"584",
			"top":"9",
			"title":"Java naive solution, just check left boundary leaves and right boundary in order",
			"vote":"1",
			"content":"    public List<Integer> boundaryOfBinaryTree(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        if(root==null) return ret;\\n        Set<TreeNode> visited = new HashSet<>();\\n        getLeftBound(root,ret,visited);\\n        getLeaves(root,ret,visited);\\n        getRightBound(root,ret,visited);\\n        return ret;\\n    }\\n    \\n    private void getLeftBound(TreeNode root, List<Integer> ret, Set<TreeNode> visited){\\n        if(root.left==null){\\n            ret.add(root.val);\\n            visited.add(root);\\n            return;\\n        }\\n        TreeNode curr = root;\\n        while(curr!=null){\\n            ret.add(curr.val);\\n            visited.add(curr);\\n            if(curr.left!=null){\\n                curr = curr.left;\\n            }\\n            else if(curr.right!=null){\\n                curr = curr.right;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return;\\n    }\\n    \\n    private void getLeaves(TreeNode root, List<Integer> ret, Set<TreeNode> visited){\\n        if(root.left==null&&root.right==null){\\n            if(!visited.contains(root)){\\n                ret.add(root.val);\\n                visited.add(root);\\n            }\\n            return;\\n        }\\n        if(root.left!=null){\\n            getLeaves(root.left,ret,visited);\\n        }\\n        if(root.right!=null){\\n            getLeaves(root.right,ret,visited);\\n        }\\n    }\\n    \\n    private void getRightBound(TreeNode root, List<Integer> ret,Set<TreeNode> visited){\\n        int pos = ret.size();\\n        if(root.right==null){\\n            return;\\n        }\\n        TreeNode curr = root.right;\\n        while(curr!=null){\\n            if(visited.contains(curr)) break;\\n            ret.add(pos,curr.val);\\n            visited.add(curr);\\n            if(curr.right!=null){\\n                curr = curr.right;\\n            }\\n            else if(curr.left!=null){\\n                curr = curr.left;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return;\\n    }"
		}
	],
	"id":"529",
	"title":"Boundary of Binary Tree",
	"content":"<p>Given a binary tree, return the values of its boundary in <b>anti-clockwise</b> direction starting from root.\r\nBoundary includes left boundary, leaves, and right boundary in order without duplicate nodes. </p>\r\n\r\n<p><b>Left boundary</b> is defined as the path from root to the <b>left-most</b> node. <b>Right boundary</b> is defined as the path from root to the <b>right-most</b> node. If the root doesn't have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.</p>\r\n\r\n<p>The <b>left-most</b> node is defined as a <b>leaf</b> node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.</p>\r\n\r\n<p>The <b>right-most</b> node is also defined by the same way with left and right exchanged.</p>\r\n\r\n<p>\r\n<b>Example 1</b><br>\r\n<pre>\r\n<b>Input:</b>\r\n  1\r\n   \\\r\n    2\r\n   / \\\r\n  3   4\r\n\r\n<b>Ouput:</b>\r\n[1, 3, 4, 2]\r\n\r\n<b>Explanation:</b>\r\nThe root doesn't have left subtree, so the root itself is left boundary.\r\nThe leaves are node 3 and 4.\r\nThe right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary.\r\nSo order them in anti-clockwise without duplicates and we have [1,3,4,2].\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Example 2</b><br>\r\n<pre>\r\n<b>Input:</b>\r\n    ____1_____\r\n   /          \\\r\n  2            3\r\n / \\          / \r\n4   5        6   \r\n   / \\      / \\\r\n  7   8    9  10  \r\n       \r\n<b>Ouput:</b>\r\n[1,2,4,7,8,9,10,6,3]\r\n\r\n<b>Explanation:</b>\r\nThe left boundary are node 1,2,4. (4 is the left-most node according to definition)\r\nThe leaves are node 4,7,8,9,10.\r\nThe right boundary are node 1,3,6,10. (10 is the right-most node).\r\nSo order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3].\r\n</pre>\r\n</p>",
	"frequency":"98",
	"ac_num":"7997"
}