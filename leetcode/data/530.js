{
	"difficulty":"3",
	"submit_num":"14036",
	"show_id":"546",
	"leetcode_id":"546",
	"answers":[
		{
			"lc_ans_id":"101310",
			"view":"9171",
			"top":"0",
			"title":"Java top-down and bottom-up DP solutions",
			"vote":"88",
			"content":"Since the input is an array, let's begin with the usual approach by breaking it down with the original problem applied to each of the subarrays. \\n\\nLet the input array be `boxes` with length `n`. Define `T(i, j)` as the maximum points one can get by removing boxes of the subarray `boxes[i, j]` (both inclusive). The original problem is identified as `T(0, n - 1)` and the termination condition is as follows:\\n1. `T(i, i - 1) = 0`: no boxes so no points.\\n2. `T(i, i) = 1`: only one box left so the maximum point is `1`.\\n\\nNext let's try to work out the recurrence relation for `T(i, j)`. Take the first box `boxes[i]`(i.e., the box at index `i`) as an example. What are the possible ways of removing it? (Note: we can also look at the last box and the analyses turn out to be the same.)\\n\\nIf it happens to have a color that you dislike, you'll probably say \"I don't like this box so let's get rid of it now\". In this case, you will first get `1` point for removing this poor box. But still you want maximum points for the remaining boxes, which by definition is `T(i + 1, j)`. In total your points will be `1 + T(i + 1, j)`.\\n\\nBut later after reading the rules more carefully, you realize that you might get more points if this box (`boxes[i]`) can be removed together with other boxes of the same color. For example, if there are two such boxes, you get `4` points by removing them simultaneously, instead of `2` by removing them one by one. So you decide to let it stick around a little bit longer until there is another box of the same color (whose index is `m`) becomes its neighbor. Note up to this moment all boxes from index `i + 1` to index `m - 1` would have been removed. So if we again aim for maximum points, the points gathered so far will be `T(i + 1, m - 1)`.  What about the remaining boxes?\\n\\nAt this moment, the boxes we left behind consist of two parts: the one at index `i` (`boxes[i]`) and those of the subarray `boxes[m, j]`, with the former bordering the latter from the left. Apparently there is no way applying the definition of the subproblem to the subarray `boxes[m, j]`, since we have some extra piece of information that is not included in the definition. **In this case, I shall call that the definition of the subproblem is not self-contained and its solution relies on information external to the subproblem itself**.\\n\\nAnother example of problem that does not have self-contained subproblems is [leetcode 312. Burst Balloons](https://leetcode.com/problems/burst-balloons/#/description), where the maximum coins of subarray `nums[i, j]` depend on the two numbers adjacent to `nums[i]` on the left and to `nums[j]` on the right. So you may find some similarities between these two problems. \\n\\nProblems without self-contained subproblems usually don't have well-defined recurrence relations, which renders it impossible to be solved recursively. The cure to this issue can sound simple and straightforward: **modify the definition of the problem to absorb the external information so that the new one is self-contained**.\\n\\nSo let's see how we can redefine `T(i, j)` to make it self-contained. First let's identify the external information. On the one hand, from the point of view of the subarray `boxes[m, j]`, it knows nothing about the number (denoted by `k`) of boxes of the same color as `boxes[m]`to its left. On the other hand, given this number `k`, the maximum points can be obtained from removing all these boxes is fixed. Therefore the external information to `T(i, j)` is this `k`. Next let's absorb this extra piece of information into the definition of `T(i, j)` and redefine it as `T(i, j, k)` which denotes the maximum points possible by removing the boxes of subarray `boxes[i, j]` with `k` boxes attached to its left of the same color as `boxes[i]`. Lastly let's reexamine some of the statements above:\\n\\n1. Our original problem now becomes `T(0, n - 1, 0)`, since there is no boxes attached to the left of the input array at the beginning.\\n\\n2. The termination conditions now will be:\\n**a**. `T(i, i - 1, k) = 0`: no boxes so no points, and this is true for any `k` (you can interpret it as nowhere to attach the boxes).\\n**b**. `T(i, i, k) = (k + 1) * (k + 1)`: only one box left in the subarray but we've already got `k` boxes of the same color attached to its left, so the total number of boxes of the same color is `(k + 1)` and the maximum point is `(k + 1) * (k + 1)`.\\n\\n3. The recurrence relation is as follows and the maximum points will be the larger of the two cases:\\n**a**. If we remove `boxes[i]` first, we get `(k + 1) * (k + 1) + T(i + 1, j, 0)` points, where for the first term, instead of `1` we again get `(k + 1) * (k + 1)` points for removing `boxes[i]` due to the attached boxes to its left; and for the second term there will be no attached boxes so we have the `0` in this term.\\n**b**. If we decide to attach `boxes[i]` to some other box of the same color, say `boxes[m]`, then from our analyses above, the total points will be `T(i + 1, m - 1, 0) + T(m, j, k + 1)`, where for the first term, since there is no attached boxes for subarray `boxes[i + 1, m - 1]`, we have `k = 0` for this part; while for the second term, the total number of attached boxes for subarray `boxes[m, j]` will increase by `1` because apart from the original `k` boxes, we have to account for `boxes[i]`now, so we have `k + 1` for this term. But we are not done yet. What if there are multiple boxes of the same color as `boxes[i]` within subarray `boxes[i + 1, j]`? We have to try each of them and choose the one that yields the maximum points. Therefore the final answer for this case will be: `max(T(i + 1, m - 1, 0) + T(m, j, k + 1))` where `i < m <= j && boxes[i] == boxes[m]`.\\n\\nBefore we get to the actual code, it's not hard to discover that there is overlapping among the subproblems `T(i, j, k)`, therefore it's qualified as a DP problem and its intermediate results should be cached for future lookup. Here each subproblem is characterized by three integers `(i, j, k)`, all of which are bounded, i.e, `0 <= i, j, k < n`, so a three-dimensional array (`n` by `n` by `n`) will be good enough for the cache.\\n\\nFinally here are the two solutions, one for top-down DP and the other for bottom-up DP. From the bottom-up solution, the time complexity will be `O(n^4)` and the space complexity will be `O(n^3)`.\\n\\n**`Top-down DP:`**\\n\\n```\\npublic int removeBoxes(int[] boxes) {\\n    int n = boxes.length;\\n    int[][][] dp = new int[n][n][n];\\n    return removeBoxesSub(boxes, 0, n - 1, 0, dp);\\n}\\n    \\nprivate int removeBoxesSub(int[] boxes, int i, int j, int k, int[][][] dp) {\\n    if (i > j) return 0;\\n    if (dp[i][j][k] > 0) return dp[i][j][k];\\n    \\n    for (; i + 1 <= j && boxes[i + 1] == boxes[i]; i++, k++); // optimization: all boxes of the same color counted continuously from the first box should be grouped together\\n    int res = (k + 1) * (k + 1) + removeBoxesSub(boxes, i + 1, j, 0, dp);\\n    \\n    for (int m = i + 1; m <= j; m++) {\\n        if (boxes[i] == boxes[m]) {\\n            res = Math.max(res, removeBoxesSub(boxes, i + 1, m - 1, 0, dp) + removeBoxesSub(boxes, m, j, k + 1, dp));\\n        }\\n    }\\n        \\n    dp[i][j][k] = res;\\n    return res;\\n}\\n```\\n\\n**`Bottom-up DP:`**\\n\\n```\\npublic int removeBoxes(int[] boxes) {\\n    int n = boxes.length;\\n    int[][][] dp = new int[n][n][n];\\n    \\t\\n    for (int j = 0; j < n; j++) {\\n    \\tfor (int k = 0; k <= j; k++) {\\n    \\t    dp[j][j][k] = (k + 1) * (k + 1);\\n    \\t}\\n    }\\n    \\t\\n    for (int l = 1; l < n; l++) {\\n    \\tfor (int j = l; j < n; j++) {\\n    \\t    int i = j - l;\\n    \\t        \\n    \\t    for (int k = 0; k <= i; k++) {\\n    \\t        int res = (k + 1) * (k + 1) + dp[i + 1][j][0];\\n    \\t            \\n    \\t        for (int m = i + 1; m <= j; m++) {\\n    \\t            if (boxes[m] == boxes[i]) {\\n    \\t                res = Math.max(res, dp[i + 1][m - 1][0] + dp[m][j][k + 1]);\\n    \\t            }\\n    \\t        }\\n    \\t            \\n    \\t        dp[i][j][k] = res;\\n    \\t    }\\n    \\t}\\n    }\\n    \\n    return (n == 0 ? 0 : dp[0][n - 1][0]);\\n}\\n```\\n\\n**`Side notes`**: In case you are curious, for the problem \"**leetcode 312. Burst Balloons**\", the external information to subarray `nums[i, j]` is the two numbers (denoted as `left` and `right`) adjacent to `nums[i]` and `nums[j]`, respectively. If we absorb this extra piece of information into the definition of `T(i, j)`, we have `T(i, j, left, right)` which represents the maximum coins obtained by bursting balloons of subarray `nums[i, j]` whose two adjacent numbers are `left` and `right`. The original problem will be `T(0, n - 1, 1, 1)` and the termination condition is `T(i, i, left, right) = left * right * nums[i]`. The recurrence relations will be: `T(i, j, left, right) = max(left * nums[k] * right + T(i, k - 1, left, nums[k]) + T(k + 1, j, nums[k], right))` where `i <= k <= j` (here we interpret it as that the balloon at index `k` is the last to be burst. Since all balloons can be the last one so we try each case and choose one that yields the maximum coins). For more details, refer to [dietpepsi 's post](https://discuss.leetcode.com/topic/30746/share-some-analysis-and-explanations)."
		},
		{
			"lc_ans_id":"101312",
			"view":"7221",
			"top":"1",
			"title":"Memoization DFS C++",
			"vote":"37",
			"content":"Getting memory limit errors for the last input, so sad. I read some of the top submissions and found out the reason: I was using STL vector instead of a C array....\\n\\nThanks to one of the top submission, which used the same idea as me, I have cleaned my code.\\n\\n=======================  Explanation ===========================\\n**First Attempt**\\nThe initial thought is straightforward, try every possible removal and recursively search the rest. No doubt it will be a TLE answer. Obviously there are a lot of recomputations involved here. Memoization is the key then. But how to design the memory is tricky. I tried to use a string of 0s and 1s to indicate whether the box is removed or not, but still getting TLE. \\n\\n**One step further**\\nI think the problem of the approach above is that there are a lot of *unnecessary* computations (not recomputations). For example, if there is a formation of `ABCDAA`, we know the optimal way is `B->C->D->AAA`. On the other hand, if the formation is `BCDAA`, meaning that we couldn't find an `A` before `D`, we will simply remove `AA`, which will be the optimal solution for removing them. Note this is true only if `AA` is at the end of the array. With naive memoization approach, the program will search a lot of unnecessary paths, such as `C->B->D->AA`, `D->B->C->AA`.\\n\\nTherefore, I designed the memoization matrix to be `memo[l][r][k]`, the largest number we can get using `l`th to `r`th (inclusive) boxes with k same colored boxes as `r`th box appended at the end. Example, `memo[l][r][3]` represents the solution for this setting: `[b_l, ..., b_r, A,A,A]` with `b_r==A`.\\n\\nThe transition function is to find the maximum among all `b_i==b_r` for `i=l,...,r-1`:\\n\\n`memo[l][r][k] = max(memo[l][r][k], memo[l][i][k+1] + memo[i+1][r-1][0])`\\n\\nBasically, if there is one `i` such that `b_i==b_r`, we partition the array into two: `[b_l, ..., b_i, b_r, A, ..., A]`, and `[b_{i+1}, ..., b_{r-1}]`. The solution for first one will be `memo[l][i][k+1]`, and the second will be `memo[i+1][r-1][0]`. Otherwise, we just remove the last k+1 boxes (including `b_r`) and search the best solution for `l`th to `r-1`th boxes. (One optimization here: make `r` as left as possible, this improved the running time from **250ms** to **35ms**)\\n\\nThe final solution is stored in `memo[0][n-1][0]` for sure. \\n\\nI didn't think about this question for a long time in the contest because the time is up. There will be a lot of room for time and space optimization as well. Thus, if you find any flaws or any improvements, please correct me.\\n\\n```\\nclass Solution {\\npublic:\\n    int removeBoxes(vector<int>& boxes) {\\n        int n=boxes.size();\\n        int memo[100][100][100] = {0};\\n        return dfs(boxes,memo,0,n-1,0);\\n    }\\n    \\n    int dfs(vector<int>& boxes,int memo[100][100][100], int l,int r,int k){\\n        if (l>r) return 0;\\n        if (memo[l][r][k]!=0) return memo[l][r][k];\\n\\n        while (r>l && boxes[r]==boxes[r-1]) {r--;k++;}\\n        memo[l][r][k] = dfs(boxes,memo,l,r-1,0) + (k+1)*(k+1);\\n        for (int i=l; i<r; i++){\\n            if (boxes[i]==boxes[r]){\\n                memo[l][r][k] = max(memo[l][r][k], dfs(boxes,memo,l,i,k+1) + dfs(boxes,memo,i+1,r-1,0));\\n            }\\n        }\\n        return memo[l][r][k];\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"101325",
			"view":"3971",
			"top":"2",
			"title":"Java DP + Memorization 60ms",
			"vote":"15",
			"content":"When facing this problem, I am keeping thinking how to simulate the case when `boxes[i] == boxes[j]` when `i` and `j` are not consecutive. It turns out that the dp matrix needs one more dimension to store such state. So we are going to define the state as \\n\\n```\\ndp[i][j][k] represents the max points from box[i] to box[j] with k boxes whose values equal to box[i]\\n```\\n\\nThe transformation function is as below\\n\\n```\\ndp[i][j][k] = max(dp[i+1][m-1][1] + dp[m][j][k+1]) when box[i] = box[m]\\n```\\n\\nSo the Java code with memorization is as below. Kindly ask me any questions.\\n\\n```\\n  public int removeBoxes(int[] boxes) {\\n        if (boxes == null || boxes.length == 0) {\\n            return 0;\\n        }\\n\\n        int size = boxes.length;\\n        int[][][] dp = new int[size][size][size];\\n\\n        return get(dp, boxes, 0, size-1, 1);\\n    }\\n\\n    private int get(int[][][] dp, int[] boxes, int i, int j, int k) {\\n        if (i > j) {\\n            return 0;\\n        } else if (i == j) {\\n            return k * k;\\n        } else if (dp[i][j][k] != 0) {\\n            return dp[i][j][k];\\n        } else {\\n            int temp = get(dp, boxes, i + 1, j, 1) + k * k;\\n\\n            for (int m = i + 1; m <= j; m++) {\\n                if (boxes[i] == boxes[m]) {\\n                    temp = Math.max(temp, get(dp, boxes, i + 1, m - 1, 1) + get(dp, boxes, m, j, k + 1));\\n                }\\n            }\\n\\n            dp[i][j][k] = temp;\\n            return temp;\\n        }\\n\\n\\n    }\\n```"
		},
		{
			"lc_ans_id":"101311",
			"view":"1847",
			"top":"3",
			"title":"Python, Fast DP with Explanation",
			"vote":"8",
			"content":"Let **A** be the array of boxes.  \\n\\nOne natural approach is to consider dp(i, j) = the answer for A[i: j+1].  But this isn't flexible enough for divide and conquer style strategies.  For example, with [1,2,2,2,1], we don't have enough information when investigating things like [1,2,2,2] and [1] separately.\\n\\nLet dp(i, j, k) = the maximum value of removing boxes if we have k extra boxes of color A[i] to the left of A[i: j+1].  (We would have at most k < len(A) extra boxes.)  Let m <= j be the largest value so that A[i], A[i+1], ... A[m] are all the same color.  Because a^2 + b^2 < (a+b)^2, any block of contiguous boxes of the same color must be removed at the same time, so in fact dp(i, j, k) = dp(m, j, k+(m-i)).\\n\\nNow, we could remove the k boxes we were carrying plus box A[i] (value: (k+1)**2), then remove the rest (value: dp(i+1, j, 0)).  Or, for any point m in [i+1, j] with A[i] == A[m], we could remove dp(i+1, m-1) first, then [m, j] would have k+1 extra boxes of color A[m] behind, which has value dp(m, j, k+1).\\n\\nThe \"i, k = m, k + m - i\" part skips order (m-i)*(j-i) calls to dp, and is necessary to get this kind of solution to pass in Python.\\n```\\ndef removeBoxes(self, A):\\n    N = len(A)\\n    memo = [[[0]*N for _ in xrange(N) ] for _ in xrange(N) ]\\n    \\n    def dp(i, j, k):\\n        if i > j: return 0\\n        if not memo[i][j][k]:\\n            m = i\\n            while m+1 <= j and A[m+1] == A[i]:\\n                m += 1\\n            i, k = m, k + m - i\\n            ans = dp(i+1, j, 0) + (k+1) ** 2\\n            for m in xrange(i+1, j+1):\\n                if A[i] == A[m]:\\n                    ans = max(ans, dp(i+1, m-1, 0) + dp(m, j, k+1))\\n            memo[i][j][k] = ans\\n        return memo[i][j][k]\\n    \\n    return dp(0, N-1, 0)\\n```"
		},
		{
			"lc_ans_id":"101314",
			"view":"608",
			"top":"4",
			"title":"C++ 29ms dp solution!",
			"vote":"5",
			"content":"We use danymic programming to solve this problem.\\n**step 1**\\nFirst, we merge the blocks with same color to one segment. \\nfor example, if we have `1 2 3 3 2 2 2 1`, then we got `1 2 3 2 1`. and at the same time ,we use `c[i]` and `len[i]` to maintain the `color` and `number` of blocks of the i_th segment.\\nIn the previous example, `c[]` is: `1 2 3 2 1`, `len[]` is `1 1 2 3 1`\\n**step 2**\\ndanymic programming, and this step is based on step1.\\nwe use `d[i, j, k]` to show that: in `[i, j]`, we got `k` blocks with same color of segment `j` after `j`.\\nand we have 2 ways to do next:\\n1. merge segment j and the k blocks after j because the have the same color:\\n`d[i, j, k] = d[i, j - 1, 0] + (len[j] + k) * (len[j] + k)`\\n2. we accumulate segment `j` and the `k` blocks to segment `pos`(pos is before j) if segment `j` and segment `pos` has the same color:\\n`if (c[pos] == c[j]): d[i, j, k] = d[i, pos,len[j] + k] + d[pos + 1, j - 1, 0]  (i <= pos < j)`\\n\\n**time complexity**: `O(n^4)`\\n**code**:\\n```cpp\\nconst int maxn = 105;\\nint d[maxn][maxn][maxn];\\n\\nclass Solution {\\nprivate:\\n    int c[maxn], len[maxn];\\npublic:\\n    int dfs(int i, int j, int k) {\\n        if (d[i][j][k] != -1) return d[i][j][k];\\n        if (i > j) return 0;\\n        d[i][j][k] = dfs(i, j - 1, 0) + (len[j] + k) * (len[j] + k);\\n        for (int pos = i; pos < j; pos++) {\\n            if (c[pos] == c[j]) d[i][j][k] = max(d[i][j][k], dfs(i, pos, len[j] + k) + dfs(pos + 1, j - 1, 0));\\n        }\\n        return d[i][j][k];\\n    }\\n\\n    int removeBoxes(vector<int>& boxes) {\\n        int n = 0;\\n        memset(c, 0, sizeof(c));\\n        memset(len, 0, sizeof(len));\\n        memset(d, -1, sizeof(d));\\n        for (int i = 0; i < boxes.size(); i++) {\\n            if (i == 0 || boxes[i] != boxes[i - 1]) c[++n] = boxes[i], len[n] = 1;\\n            else len[n]++;\\n        }\\n        return dfs(1, n, 0);\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"101329",
			"view":"1311",
			"top":"5",
			"title":"10-line Memorization DFS C++ with explanation",
			"vote":"5",
			"content":"```\\nclass Solution {\\npublic:\\n    int mem[100][100][100]; // initialized to 0, mem[left][right][k] means value from boxes[left]~boxes[right] followed by \\n    // k same color boxes. Follow does not mean strictly consecutive boxes, for example, [1, 3, 2, 3, 4], 3 can be \\n    // followed by the other 3 because we can remove 2 first\\n    \\n    int removeBoxes(vector<int>& boxes) {\\n        return DFS(boxes,0,boxes.size()-1,0);\\n    }\\n    \\n    int DFS(vector<int>& boxes, int l,int r,int k){\\n        if (l>r) return 0; \\n        if (mem[l][r][k]) return mem[l][r][k]; // if we have calculated this DFS result, return it\\n        \\n        mem[l][r][k] = DFS(boxes,l,r-1,0) + (k+1)*(k+1); // box[l][r] result is box[l][r-1]+(k+1)^2\\n        for (int i=l; i<r; i++) // go through each box from left\\n            if (boxes[i]==boxes[r]) // check for same color box as boxes[r]\\n                mem[l][r][k] = max(mem[l][r][k], DFS(boxes,l,i,k+1) + DFS(boxes,i+1,r-1,0)); // if we found same color box,\\n                // then we have a chance to get a higher value by group boxes[l]~boxes[i] and boxes[r] together, plus the \\n                // value from boxes[i+1]~boxes[r-1]\\n        return mem[l][r][k];\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"101324",
			"view":"1866",
			"top":"6",
			"title":"I found the problem in other OnlineJudge",
			"vote":"4",
			"content":"http://poj.org/problem?id=1390"
		},
		{
			"lc_ans_id":"101328",
			"view":"610",
			"top":"7",
			"title":"Java Preprocessing DFS + Memoization, less space needed",
			"vote":"3",
			"content":"Inspired by @waterbucket and @supersj  [c++ DFS Solution with Explanation.](https://discuss.leetcode.com/topic/84333/c-dfs-solution-with-explanation). Add some comments in the code.\\n\\n```\\npublic class Solution {\\n    public int removeBoxes(int[] boxes) {\\n        List<Integer> colors = new ArrayList<>();\\n        List<Integer> lens = new ArrayList<>();\\n        // preprocessing\\n        // [1,1,1,3,3,2,3,3,3,1,1] would become\\n        // colors : [1,3,2,3,1]\\n        // lens :   [3,2,1,3,2]\\n        for (int box : boxes) {\\n            if (!colors.isEmpty() && colors.get(colors.size() - 1) == box) {\\n                // continuous, increase length count by 1\\n                lens.set(lens.size() - 1, lens.get(lens.size() - 1) + 1);\\n            } else {\\n                // new color\\n                colors.add(box);\\n                lens.add(1);\\n            }\\n        }\\n        int N = boxes.length;\\n        int M = colors.size();\\n        // dp[i][j][k] means the maximal score for colors[i:j] with k boxes of same color merged after j\\n        // i and j are inclusive, so dp[0][M - 1][0] will be the final answer\\n        int[][][] dp = new int[M][M][N];\\n        return dfs(colors, lens, 0, M - 1, 0, dp);\\n    }\\n    \\n    // top-down dfs search with memoization\\n    private int dfs(List<Integer> colors, List<Integer> lens, int l, int r, int k, int[][][] dp) {\\n        if (l > r) return 0;\\n        if (dp[l][r][k] > 0) return dp[l][r][k];\\n        // merging boxes with colors[r]\\n        int score = dfs(colors, lens, l, r - 1, 0, dp) + (lens.get(r) + k) * (lens.get(r) + k);\\n        // merge boxes with colors[l:i] and colors[l + 1:r - 1] where i from l to r - 1\\n        for (int i = l; i < r; i++) {\\n            if (colors.get(i) == colors.get(r)) {\\n                // notice here : since we use top-down approach, colors[i + 1:r - 1] has already been merged, so k = 0;\\n                // so color[i] is adjacent to color[r] now\\n                score = Math.max(score, \\n                    dfs(colors, lens, l, i, lens.get(r) + k, dp) + dfs(colors, lens, i + 1, r - 1, 0, dp));\\n            }\\n        }\\n        dp[l][r][k] = score;\\n        return score;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"101331",
			"view":"705",
			"top":"8",
			"title":"Python, Straightforward [but slow] with Explanation",
			"vote":"3",
			"content":"Let **A** be the array of boxes.  A natural approach is to consider dp(i, j) to be the value of A[i: j+1].  Let's use a top-down dp and investigate this line of thinking.\\n\\nSay we want to evaluate **dp(i, j)**.  When we want to remove box A[i], we will do so with any subset of boxes of the same color within A[i: j+1].  Then our candidate answer will be (num_boxes_chosen)**2 + sum( dp(a, b) for [a,b] maximum size ranges not touching chosen boxes in [i,j] ).  Since [a, b] has smaller size than [i, j], our dp function won't loop.\\n\\nBecause in general a^2 + b^2 < (a+b)^2, we can consider contiguous ranges of \"good\" boxes (boxes that have the same color as A[i]) as one entity that we either include or don't include.  Now we are ready for our algorithm:\\n\\nFirst, find the ranges of every good box.  For example if A[1: 13] = [2, 2, 2, 3, 5, 6, 2, 2, 3, 2, 4, 5], our good ranges will be **good** = [[1, 3], [7, 8], [10]].  Then, for every subset of these good ranges, let's suppose we removed all the boxes represented by these subsets in one move.  If for example we remove [1,3] + [10], then we've removed 4 boxes, and our candidate answer will be 4**2 + dp(1, 0) + dp(4,9) + dp(11,12).  Our actual answer must be one of the candidate answers, so we'll take a running maximum. \\n\\nThis approach is worst case exponential, so it's not the best approach but it passes the test cases.\\n```\\ndef removeBoxes(self, A):\\n    def outside_ranges(ranges, i, j):\\n        prev = i\\n        for r1, r2 in ranges:\\n            yield prev, r1 - 1\\n            prev = r2 + 1\\n        yield prev, j\\n        \\n    memo = {}\\n    def dp(i, j):\\n        if i >= j: return +(i==j)\\n        if (i,j) not in memo:\\n            good = []\\n            for k, v in itertools.groupby(range(i, j+1),\\n                    key = lambda x: A[x] == A[i]):\\n                if k:\\n                    w = list(v)\\n                    good.append((w[0], w[-1]))\\n            \\n            ans = 0\\n            for size in xrange(1, len(good) + 1):\\n                for subset in itertools.combinations(good, size):\\n                    cand = sum( g[-1] - g[0] + 1 for g in subset ) ** 2\\n                    cand += sum( dp(L, R) for L, R in outside_ranges(subset, i, j) )\\n                    ans = max(ans, cand)\\n            \\n            memo[i, j] = ans\\n        return memo[i, j]\\n    return dp(0, len(A)-1)\\n```"
		},
		{
			"lc_ans_id":"101320",
			"view":"150",
			"top":"9",
			"title":"A DP Solution & An Extra Thought of Using Dancing Links",
			"vote":"2",
			"content":"Suppose we have an array **A : [8, 6, 2, 6, 6, 3, 2, 3, 2, 2]**; (length is 10)\\nTry to express the problem that \\n          **Calculating the biggest sum of removing boxes in A starting from index i up to j(i<=j)**   as ***G(i,j)***\\nThen we may consider ***G(i,j+1)*** based on the solution of ***G(i,j)***.\\nLet ***G(i,j).V***  be the solution of problem ***G(i,j)***'s biggest sum, and ***G(i,j).L*** be its continuous number of the last element(e.g **A[j]**) when getting ***G(i,j).V*** ,  for example, **A[0~3] = [8 6 2 6]** , we can easily get the biggest sum by removing elements as the following : **8, 2, 6 6**,  thus ***G(0,3).V = 1^2 + 1^2 + 2^2 = 6***, and ***G(0,3).L = the continuous number of A [3] 's count when removing. = 2*** \\nNow let's consider ***G(i,j+1)***'s solution, \\n\\n* If **A[j+1]=A[j]**, then we can easily get that, ***G(i,j+1).V = G(i,j).V - G(i,j).L^2 + (G(i,j).L + 1)^2 = G(i,j).V + 2\\\\*G(i,j).L + 1***, and respectively, ***G(i,j+1).L = G(i,j).L + 1***.\\nThis is not very hard to prove.Say we'll calculate ***G(0,4)***, we find that **A[4]=6=A[3]**, so just append **A[4]** to the last of **A[3]** in ***G(i,j)***'s solution,we get ***G(0,4)***'s solution :**8,2,6 6 6**.Thus ***G(0,4) = G(0,3).V + 2\\\\*G(0,3).L + 1 = 6 + 2\\\\*2 + 1 = 11***,and ***G(0,4).L = G(0,3).L + 1 = 3***.\\n\\n* If **A[j+1]!=A[j]**, then there are two conditions of removing **A[j+1]**:\\n    \\n\\n                    1.removing A[j+1] alone\\n                          Under this condition, A[i+1] does not have to  be removed with any other element.Simply let S as its solution,then S.V = G(i,j).V + 1, and S.L = 1.\\n                    2.removing A[j+1] with an element in A[i~j] so that we can get a bigger count of A[j+1] to calculate the square of the count.Let r>=0 && r<=j-i-1 and A[i+r] = A[j+1],(e.g.  r is offset from i such that  A[i+r] = A[j+1],and i+r <= j -1 , because A[j+1]!=A[j])\\n                          Under this condition, A[j+1] has to be removed with A[i+r],so elements in range from i+r+1 to j must be removed before A[j+1].Let F(i,j,r) be the problem that \"Calculating the biggest sum of removing boxes in A starting from index i up to j(i<=j) &&  A[j]==A[i+r] && A[j] is removed together with A[i+r]\"\\n\\nFor instance, consider ***G(0,8)***.If we already have solved ***G(0,7)***, then **A[8]=2 A[7]=3, A[8]!=A[7] , and A[8]=A[6]=A[2]=2**. We can \\n\\n* 1 remove **A[8]** alone\\n   or\\n* 2.remove **A[8]** together with **A[6]**, raising new problem ***F(0,8,6)*** \\n* 3.remove **A[8]** together with **A[2]**, raising new problem ***F(0,8,2)***\\n\\nSo we know ***G(0,8).V = max  { G(0,7).V + 1,F(0,8,6).V,  F(0,8,2).V }***\\nGenerally, if **A[j+1]!=A[j]**, then ***G(i,j+1).V = max {G(i,j).V + 1, max{ F(i,j+1,r) where A[i+r]==A[j+1] && r>=0 && r<=j -i-1} }***\\nNow let's consider ***F(i,j,r)***.In this type of problem, **A[i+r+1 ~  j-1]** must be removed before **A[i+r]** and **A[j]** , so it is the problem of ***G(i+r-1,j-1)***,and then if we solved ***G(i,i+r)***, then by adding 1 to ***G(i,i+r).V*** we get the solution of removing **A[j]** together with **A[i+r]**,\\nSo\\n***F(i,j,r).V = G(i+r+1,j-1).V + G(i,i+r).V + 2\\\\*G(i,i+r).L + 1***,  and\\n***F(i,j,r).L = G(i,i+r).L + 1***\\n\\nTo conclude,we get formula:\\n***G(i,j+1).V = max {G(i,j).V + 1, max{ F(i,j+1,r) where A[i+r]==A[j+1] && r>=0 && r<=j -i-1} }*** \\n***G(i,j+1).L = 1 if G(i,j+1).V = G(i,j).V + 1 else   G(i,j+1).L=F(i,j+1,r).L where G(i,j+1),V=F(i,j,r).V***\\n***F(i,j,r).V = G(i+r+1,j-1).V + G(i,i+r).V + 2\\\\*G(i,i+r).L + 1***,\\n***F(i,j,r).L = G(i,i+r).L + 1***\\n\\n<DP solution ended>\\n\\n\\n**An Extra Thought**\\nI've solved the sudoku problem by using Knuth's Dancing Links Algorithm, it is a very smart data structure used in backtracing problem. So what if I express array **A** as a Double-Linked List like\\n**8 --> 6 -->  2 --> 6 --> 6 --> 3 --> 2 --> 3 --> 2 --> 2**\\neach time I remove a range of the same number from **A**.for example , I remove **6 6**,then **A** becomes\\n**8 --> 6 -->  2 --> 3 --> 2 --> 3 --> 2 --> 2**, \\nWhy I selected **6 6** instead of **2 6**?Because there is a **truth** that builds up what I thought, each time we can only remove a single number or numbers with the same value in a continuous range.\\nNow **A** is reduced and can be recovered using Knuth's Dancing Links later.\\nBy continuously removing and recovering **A**,we can finally traverse all possible removing orders and get the maximum result.\\n\\n\\n**Here is my accepted code, nearly 25ms time cost.**\\n```\\nstruct Node{\\n\\tNode *next,*previous;\\n\\tint val;\\n\\tint num;\\n\\tNode(Node* next=NULL,Node* previous=NULL):next(next),previous(previous){}\\n\\tNode(int val,int num,Node* next=NULL,Node* previous=NULL):next(next),previous(previous),val(val),num(num){}\\n\\n\\tvoid insertNext(int val,int num)\\n\\t{\\n\\t\\tNode *newnode=new Node(val,num,this->next,this);\\n\\t\\tif(newnode->next)\\n\\t\\t\\tnewnode->next->previous = newnode;\\n\\t\\tthis->next = newnode;\\n\\t}\\n\\t//remove all node after thisnode such that the count of number can not exceed biggestnum\\n\\tstatic void eliminate(Node *thisnode,int biggestnum)\\n\\t{\\n\\t\\tNode *p=thisnode->next;\\n\\t\\twhile(p && biggestnum >= p->num) p = p->next;\\n\\t\\t/**\\n\\t\\t * We should free those nodes here,but I did not.\\n\\t\\t * make a note to mark this problem\\n\\t\\t */\\n\\t\\tthisnode->next = p;\\n\\t\\tif(p)p->previous = thisnode;\\n\\t}\\n\\n\\tstatic void update(Node* thisnode,int newval,int newnum)\\n\\t{\\n\\t\\twhile(true)\\n\\t\\t{\\n\\t\\t\\tif(newval > thisnode->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(newnum >= thisnode->num)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthisnode->val = newval;\\n\\t\\t\\t\\t\\tthisnode->num = newnum;\\n\\t\\t\\t\\t\\teliminate(thisnode,newnum);\\n\\t\\t\\t\\t}else{//insert this to next\\n\\t\\t\\t\\t\\tNode *newnode = new Node(newval,newnum,thisnode,thisnode->previous);\\n\\t\\t\\t\\t\\tthisnode->previous = newnode;\\n\\t\\t\\t\\t\\tif(newnode->previous)\\n\\t\\t\\t\\t\\t\\tnewnode->previous->next = newnode;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;//ended\\n\\t\\t\\t}else if(newval == thisnode->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(newnum > thisnode->num) {thisnode->num = newnum;eliminate(thisnode,newnum);}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tif(newnum <= thisnode->num)return;\\n\\t\\t\\t\\telse if(thisnode->next == NULL)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tNode *newnode = new Node(newval,newnum,NULL,thisnode);\\n\\t\\t\\t\\t\\tthisnode->next = newnode;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tthisnode = thisnode->next;//continue to next\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution\\n{\\npublic:\\n\\tint removeBoxes(vector<int>& boxes)\\n\\t{\\n\\t\\trow = (int) boxes.size();\\n\\t\\tcol = row;\\n\\t\\tC = new std::map<int,Node>[row * col]; //C[i][j][k]\\n\\t\\tfor(int i=0;i<row;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0;j<col;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint base = i*col + j;\\n\\t\\t\\t\\tif(i > j)continue;\\n\\t\\t\\t\\telse if( i == j)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tC[base].insert({0,Node()});\\n\\t\\t\\t\\t\\tC[base][0].insertNext(1, 1);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tC[base].insert({j-i,Node()});\\n\\t\\t\\t\\t\\tC[base][j-i].insertNext(-1, -1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis->boxes = &boxes;\\n\\t\\tsolveRangeg(0,row-1);\\n\\t\\tint val = C[row-1][row - 1].next->val;\\n\\t\\treturn val;//C[0][row-1][row-1][VAL]\\n\\t}\\n\\t/**\\n         * formula for F(i,j,k)\\n\\t * i<j &&  0<=k<=j-i-2  && A[i+k]==A[j], A[j]!=A[j-1]\\n\\t */\\n\\tvoid solveRangef(int i,int j,int k)\\n\\t{\\n\\t\\tint base=i*col + j;\\n\\t\\tif(C[base].find(k)!=C[base].end())return; //already has i,j,k solved\\n\\t\\tif(i<0 || i>=row || j<0 || j>=col || i>=j)return;\\n\\n\\t\\tC[base].insert({k,Node()});\\n\\t\\tC[base][k].insertNext(-1, -1);\\n\\n\\t\\tsolveRangeg(i,i+k);\\n\\t\\tsolveRangeg(i+k+1,j-1);\\n\\n\\t\\tint diff = j -i -k-2;\\n\\t\\tint base2=(i+k+1)*col + (j-1);\\n\\t\\tint isolateVal=diff>=0?C[base2][diff].next->val:0;\\n\\n\\t\\tint base1=i*col + (i+k);\\n\\t\\tNode *n=C[base1][k].next;\\n\\t\\tNode *basenode=C[base][k].next;\\n\\t\\twhile(n)\\n\\t\\t{\\n\\t\\t\\tNode::update(basenode,n->val + 2*n->num + 1 + isolateVal,n->num + 1);\\n\\t\\t\\tn=n->next;\\n\\t\\t}\\n\\t}\\n\\t/**\\n         * formula for G(i,j)\\n\\t */\\n\\tvoid solveRangeg(int i,int j)\\n\\t{\\n\\t\\tint base=i*col+j;\\n  \\t\\tif(i<0 || i>=row || j<0 || j>=col || i>=j || C[base][j-i].next->val!=-1)return;\\n\\n\\n\\t\\tsolveRangeg(i,j-1);\\n\\n\\t\\tstd::vector<int> &A = *boxes;\\n\\t\\tNode *basenode=C[base][j-i].next;\\n\\t\\tint base1 = i*col + (j-1);\\n\\t\\tNode *base1node=C[base1][j-i-1].next;\\n\\t\\tif(A[j]==A[j-1])\\n\\t\\t{\\n\\t\\t\\tNode *n=base1node;\\n\\t\\t\\twhile(n)\\n\\t\\t\\t{\\n\\t\\t\\t\\tNode::update(basenode, n->val + 2*n->num + 1, n->num + 1);\\n\\t\\t\\t\\tn=n->next;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tNode::update(basenode,base1node->val + 1,1);\\n\\t\\tfor(int r=j-i-2;r>=0;r--)\\n\\t\\t{\\n\\t\\t\\tif(A[r+i]!=A[j])continue;\\n\\t\\t\\tsolveRangef(i,j,r);\\n\\t\\t\\tNode *n=C[base][r].next;\\n\\t\\t\\twhile(n)\\n\\t\\t\\t{\\n\\t\\t\\t\\tNode::update(basenode,n->val,n->num);\\n\\t\\t\\t\\tn = n->next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\n\\tstd::map<int,Node> *C;\\n\\tstd::vector<int> *boxes;\\n\\tint row;\\n\\tint col;\\n};\\n```"
		}
	],
	"id":"530",
	"title":"Remove Boxes",
	"content":"<p>Given several boxes with different colors represented by different positive numbers. <br />\r\nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get <code>k*k</code> points.<br />\r\nFind the maximum points you can get.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br>\r\nInput: \r\n<pre>\r\n[1, 3, 2, 2, 2, 3, 4, 3, 1]\r\n</pre>\r\nOutput:\r\n<pre>\r\n23\r\n</pre>\r\nExplanation: \r\n<pre>\r\n[1, 3, 2, 2, 2, 3, 4, 3, 1] \r\n----> [1, 3, 3, 4, 3, 1] (3*3=9 points) \r\n----> [1, 3, 3, 3, 1] (1*1=1 points) \r\n----> [1, 1] (3*3=9 points) \r\n----> [] (2*2=4 points)\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe number of boxes <code>n</code> would not exceed 100.\r\n</p>\r\n",
	"frequency":"234",
	"ac_num":"4945"
}