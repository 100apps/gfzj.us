{
	"difficulty":"2",
	"submit_num":"15207",
	"show_id":"549",
	"leetcode_id":"549",
	"answers":[
		{
			"lc_ans_id":"101519",
			"view":"5088",
			"top":"0",
			"title":"Neat Java Solution Single pass O(n)",
			"vote":"29",
			"content":"```\\npublic class Solution {\\n    int maxval = 0;\\n    public int longestConsecutive(TreeNode root) {\\n        longestPath(root);\\n        return maxval;\\n    }\\n    public int[] longestPath(TreeNode root) {\\n        if (root == null)\\n            return new int[] {0,0};\\n        int inr = 1, dcr = 1;\\n        if (root.left != null) {\\n            int[] l = longestPath(root.left);\\n            if (root.val == root.left.val + 1)\\n                dcr = l[1] + 1;\\n            else if (root.val == root.left.val - 1)\\n                inr = l[0] + 1;\\n        }\\n        if (root.right != null) {\\n            int[] r = longestPath(root.right);\\n            if (root.val == root.right.val + 1)\\n                dcr = Math.max(dcr, r[1] + 1);\\n            else if (root.val == root.right.val - 1)\\n                inr = Math.max(inr, r[0] + 1);\\n        }\\n        maxval = Math.max(maxval, dcr + inr - 1);\\n        return new int[] {inr, dcr};\\n    }\\n}"
		},
		{
			"lc_ans_id":"101510",
			"view":"2551",
			"top":"1",
			"title":"Java solution, Binary Tree Post Order Traversal",
			"vote":"14",
			"content":"```\\npublic class Solution {\\n    int max = 0;\\n    \\n    class Result {\\n        TreeNode node;\\n        int inc;\\n        int des;\\n    }\\n    \\n    public int longestConsecutive(TreeNode root) {\\n        traverse(root);\\n        return max;\\n    }\\n    \\n    private Result traverse(TreeNode node) {\\n        if (node == null) return null;\\n        \\n        Result left = traverse(node.left);\\n        Result right = traverse(node.right);\\n        \\n        Result curr = new Result();\\n        curr.node = node;\\n        curr.inc = 1;\\n        curr.des = 1;\\n        \\n        if (left != null) {\\n            if (node.val - left.node.val == 1) {\\n                curr.inc = Math.max(curr.inc, left.inc + 1);\\n            }\\n            else if (node.val - left.node.val == -1) {\\n                curr.des = Math.max(curr.des, left.des + 1);\\n            }\\n        }\\n        \\n        if (right != null) {\\n            if (node.val - right.node.val == 1) {\\n                curr.inc = Math.max(curr.inc, right.inc + 1);\\n            }\\n            else if (node.val - right.node.val == -1) {\\n                curr.des = Math.max(curr.des, right.des + 1);\\n            }\\n        }\\n        \\n        max = Math.max(max, curr.inc + curr.des - 1);\\n        \\n        return curr;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"101520",
			"view":"1395",
			"top":"2",
			"title":"DFS C++, Python solutions",
			"vote":"10",
			"content":"c++ solution:\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(TreeNode* root) {\\n        int longest = 0;\\n        dfs(root, root, longest);\\n        return longest;\\n    }\\n\\n    pair<int, int> dfs(TreeNode * node, TreeNode * parent, int & longest) {\\n        if ( NULL == node ) {\\n            return make_pair(0, 0);\\n        }\\n        auto left = dfs(node->left, node, longest);\\n        auto right = dfs(node->right, node, longest);\\n        longest = max(longest, left.first + right.second + 1);\\n        longest = max(longest, left.second + right.first + 1);\\n        int inc = 0, dec = 0;\\n        if ( node->val == parent->val + 1 ) {\\n            inc = max(left.first, right.first) + 1;\\n        }\\n        if ( node->val == parent->val - 1 ) {\\n            dec = max(left.second, right.second) + 1;\\n        }\\n        return make_pair(inc, dec);\\n    }\\n};\\n```\\npython solution\\n```\\nclass Solution(object):\\n    def longestConsecutive(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(node, parent):\\n            if not node:\\n                return 0, 0\\n            li, ld = dfs(node.left, node)\\n            ri, rd = dfs(node.right, node)\\n            l[0] = max(l[0], li + rd + 1, ld + ri + 1)\\n            if node.val == parent.val + 1:\\n                return max(li, ri) + 1, 0\\n            if node.val == parent.val - 1:\\n                return 0, max(ld, rd) + 1\\n            return 0, 0\\n        l = [0]\\n        dfs(root, root)\\n        return l[0]\\n```"
		},
		{
			"lc_ans_id":"101509",
			"view":"730",
			"top":"3",
			"title":"Java recursively compute ascending and descending sequence",
			"vote":"7",
			"content":"For each subtree we recursively compute the length of longest ascending and descending path starting from the subtree root. Then we can efficiently check if we could join the two subtree together to get a longer child-parent-child path. In another word, for each subtree, the longest child-parent-child consecutive (with root being the parent) is dec+inc-1 since both the ascending and descending path start from root.\\n```\\n    private int maxlen = 0;\\n    private int[] helper(TreeNode root) {\\n        if (root == null) return new int[]{0, 0};\\n        int inc = 1, dec = 1;\\n        int[] left = helper(root.left), right = helper(root.right);\\n        if (root.left != null) {\\n            if (root.left.val == root.val+1) inc += left[0];\\n            if (root.left.val == root.val-1) dec += left[1];\\n        }\\n        if (root.right != null) {\\n            if (root.right.val == root.val+1) inc = Math.max(inc, 1+right[0]);\\n            if (root.right.val == root.val-1) dec = Math.max(dec, 1+right[1]);\\n        }\\n        maxlen = Math.max(inc+dec-1, maxlen);\\n        return new int[]{inc, dec};\\n    }\\n    public int longestConsecutive(TreeNode root) {\\n        helper(root);\\n        return maxlen;\\n    }\\n```"
		},
		{
			"lc_ans_id":"101511",
			"view":"293",
			"top":"4",
			"title":"c++ Short Beautiful Code",
			"vote":"3",
			"content":"```\\nint longestConsecutive(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        int childMax = 0, cur = 0, l1 = 0, l2 = 0;\\n\\n        l1 = findPath(root->left, root->val, -1) + findPath(root->right, root->val, 1) + 1;\\n        l2 = findPath(root->left, root->val, 1) + findPath(root->right, root->val, -1) + 1;\\n        cur = max(l1, l2);\\n        childMax = max(longestConsecutive(root->left), longestConsecutive(root->right));\\n        \\n        return max(cur, childMax);\\n    }\\n    \\n    int findPath(TreeNode* root, int prevVal, int diff){\\n        if(root == NULL) return 0;\\n        \\n        if(root->val == (prevVal + diff)) \\n            return max(findPath(root->left, root->val, diff), findPath(root->right, root->val, diff)) + 1;\\n        else\\n            return 0;\\n    }"
		},
		{
			"lc_ans_id":"101523",
			"view":"235",
			"top":"5",
			"title":"Easy O(n) Java Solution for 2 problems",
			"vote":"1",
			"content":"The main idea is to record each node's LCS, which is the value returned by helper function. At each helper function, we need to update max LCS.\\nBinary Tree Longest Consecutive Sequence\\n```\\npublic class Solution {\\n    int res;\\n    public int longestConsecutive(TreeNode root) {\\n        res = 0;\\n        helper(root);\\n        return res;\\n    }\\n    public int helper(TreeNode root){\\n        int cur = 0;\\n        if(root == null) return cur;\\n        int left = helper(root.left);\\n        int right = helper(root.right);\\n        if(root.left != null && root.left.val != root.val + 1) left = 0;\\n        if(root.right != null && root.right.val != root.val + 1) right = 0;\\n        cur = Math.max(left, right) + 1;\\n        res = Math.max(cur, res);\\n        return cur;\\n    }\\n}\\n```\\nSame idea, but the helper function need to return the 2 LCS value, one is upward, the other is downward.\\nBinary Tree Longest Consecutive Sequence II\\n```\\npublic class Solution {\\n    int res;\\n    public int longestConsecutive(TreeNode root) {\\n        res = 0;\\n        helper(root);\\n        return res;\\n    }\\n    public int[] helper(TreeNode root){\\n        int[] cur = new int[2];\\n        if(root == null) return cur;\\n        int[] left = helper(root.left);\\n        int[] right = helper(root.right);\\n        \\n        if(root.left != null){\\n            if(root.left.val != root.val - 1) left[0] = 0;\\n            if(root.left.val != root.val + 1) left[1] = 0;\\n        }\\n        if(root.right != null){\\n            if(root.right.val != root.val - 1) right[0] = 0;\\n            if(root.right.val != root.val + 1) right[1] = 0;\\n        }\\n        \\n        cur[0] = Math.max(left[0], right[0]) + 1;\\n        cur[1] = Math.max(left[1], right[1]) + 1;\\n        \\n        res = Math.max(res, cur[0] + cur[1] - 1);\\n        return cur;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"101539",
			"view":"165",
			"top":"6",
			"title":"[549. Binary Tree Longest Consecutive Sequence II] C++_AC_DFS_with brief explanation",
			"vote":"1",
			"content":"For each node, we have two choices: go left or go right, and the value might be increase or decrease. So, we use **pair<int,int> p** to store the information: **p.first** stores the consecutive number of decreasing nodes from this root, **p.second** stores the consecutive number of increasing nodes from this root. Then we will apply DFS for left child and right child of this root.\\n\\nLet's consider the base case: if we reach the leaf node, then the DFS function will return {1,1}, this means that we only have 1 node from this leaf if it is increasing sequence, and we only have 1 node from this leaf if it is decreasing sequence. Now, our max length is 1 + 1 - 1 = 1.(decreasing + increasing - 1)\\nLet's look at the following code:\\n\\n        pair<int,int> l(0,0);\\n        pair<int,int> r(0,0);\\n        if(root->left){\\n            l = dfs(root->left, {1,1});\\nWe apply DFS to the left child of this root, and get the result **l**.\\n\\n            if(root->left->val + 1 == root->val){\\n                cur.first += l.first;\\n            }\\nif left child value is 1 less than root->val, then we can see that this child can be a decreasing consecutive node from this root, so we can add the number of decreasing node of this child to our root result.\\n\\n            if(root->left->val - 1 == root->val){\\n                cur.second += l.second;\\n            }\\n        }\\nIt is the same for the increasing part.\\n\\n        if(root->right){\\n            r = dfs(root->right, {1,1});\\n            if(root->right->val + 1 == root->val){\\n                cur.first = max(cur.first, r.first + 1);\\n            }\\n            if(root->right->val - 1 == root->val){\\n                cur.second = max(cur.second, r.second + 1);\\n            }\\n        }\\nSimilar method for the right child of this root, however, we should notice:  **cur.first = max(cur.first, r.first + 1);**, why? Because we can only choose one path from left and right paths when both of them are all eligible as the decreasing sequence or increasing sequence. So we will choose the largest one as our result.\\n\\nSo each time when we finish our recursive, we update our final result **maxVal**.\\n\\n**Comprehensive code:**\\n\\n    class Solution {\\n    public:\\n    int maxVal = 0;\\n    int longestConsecutive(TreeNode* root) {\\n        if(root == nullptr) return 0;\\n        dfs(root, {1,1});\\n        return maxVal;\\n    }\\n    \\n    pair<int,int> dfs(TreeNode* root, pair<int, int> cur){\\n        pair<int,int> l(0,0);\\n        pair<int,int> r(0,0);\\n        if(root->left){\\n            l = dfs(root->left, {1,1});\\n            if(root->left->val + 1 == root->val){\\n                cur.first += l.first;\\n            }\\n            if(root->left->val - 1 == root->val){\\n                cur.second += l.second;\\n            }\\n        }\\n        if(root->right){\\n            r = dfs(root->right, {1,1});\\n            if(root->right->val + 1 == root->val){\\n                cur.first = max(cur.first, r.first + 1);\\n            }\\n            if(root->right->val - 1 == root->val){\\n                cur.second = max(cur.second, r.second + 1);\\n            }\\n        }\\n        maxVal = max(maxVal, cur.first + cur.second - 1);\\n        return cur;\\n    }\\n    };"
		},
		{
			"lc_ans_id":"101547",
			"view":"213",
			"top":"7",
			"title":"[C++] Clean Code - 2 Solution - return vector or struct",
			"vote":"1",
			"content":"**Return vector**\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(TreeNode* root) {\\n        int maxlen = 0;\\n        dfs(root, maxlen);\\n        return maxlen;\\n    }\\n\\nprivate:\\n    vector<int> dfs(TreeNode* node, int& maxlen) {\\n        if (!node) {\\n            return {0,0};\\n        }\\n\\n        vector<int> p(2, 1);\\n        int l2r = 1;\\n        int r2l = 1;\\n\\n        if (node->left) {\\n            vector<int> l = dfs(node->left, maxlen);\\n            int lv = node->left->val;\\n            if (node->val + 1 == lv) {\\n                p[0] = max(p[0], 1 + l[0]);\\n                r2l += l[0];\\n            }\\n            if (node->val - 1 == lv) {\\n                p[1] = max(p[1], 1 + l[1]);\\n                l2r += l[1];\\n            }\\n        }\\n\\n        if (node->right) {\\n            vector<int> r = dfs(node->right, maxlen);\\n            int rv = node->right->val;\\n            if (node->val + 1 == rv) {\\n                p[0] = max(p[0], 1 + r[0]);\\n                l2r += r[0];\\n            }\\n            if (node->val - 1 == rv) {\\n                p[1] = max(p[1], 1 + r[1]);\\n                r2l += r[1];\\n            }\\n        }\\n        maxlen = max(maxlen, max(max(l2r, r2l), max(p[0], p[1])));\\n        return p;\\n    }\\n};\\n```\\n\\n\\n**Return Struct**\\n```\\nclass Solution {\\npublic:\\n    int longestConsecutive(TreeNode* root) {\\n        int maxlen = 0;\\n        dfs(root, maxlen);\\n        return maxlen;\\n    }\\n\\nprivate:\\n    struct RetnInfo {\\n        int inc;\\n        int desc;\\n        RetnInfo(int inc, int desc) : inc(inc), desc(desc) {};\\n    };\\n\\n    RetnInfo dfs(TreeNode* node, int& maxlen) {\\n        if (!node) {\\n            return RetnInfo(0, 0);\\n        }\\n\\n        RetnInfo p(1, 1);   // return info for parent\\n        int lr = 1, rl = 1; // lr - left to right; rl - right to left;\\n        RetnInfo l = dfs(node->left, maxlen);\\n        RetnInfo r = dfs(node->right, maxlen);\\n\\n        if (node->left && node->left->val == node->val + 1) {\\n            p.inc = max(p.inc, 1 + l.inc);\\n            rl += l.inc;\\n        }\\n        if (node->left && node->left->val == node->val - 1) {\\n            p.desc = max(p.desc, 1 + l.desc);\\n            lr += l.desc;\\n        }\\n\\n        if (node->right && node->right->val == node->val + 1) {\\n            p.inc = max(p.inc, 1 + r.inc);\\n            lr += r.inc;\\n        }\\n        if (node->right && node->right->val == node->val - 1) {\\n            p.desc = max(p.desc, 1 + r.desc);\\n            rl += r.desc;\\n        }\\n\\n        maxlen = max(maxlen, max(max(lr, rl), max(p.inc, p.desc)));\\n        return p;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"101548",
			"view":"393",
			"top":"8",
			"title":"20-line C++ DFS Solution",
			"vote":"1",
			"content":"```\\nclass Solution {\\npublic:\\n    int res;\\n    int longestConsecutive(TreeNode* root) {\\n        if(root) \\n            DFS(root);\\n        return res;\\n    }\\n    pair<int, int> DFS(TreeNode *node)\\n    {\\n        pair<int, int> leftRes, rightRes;\\n        if(node->left)\\n            leftRes = DFS(node->left);\\n        if(node->right)\\n            rightRes = DFS(node->right);\\n        int inc = 1, des = 1;\\n        if(node->left && node->val == node->left->val + 1)\\n            inc = max(inc, 1 + leftRes.first);\\n        if(node->right && node->val == node->right->val + 1)\\n            inc = max(inc, 1 + rightRes.first);\\n        if(node->left && node->val == node->left->val - 1)\\n            des = max(des, 1 + leftRes.second);\\n        if(node->right && node->val == node->right->val - 1)\\n            des = max(des, 1 + rightRes.second);\\n        res = max(res, inc + des - 1);\\n        return pair<int, int>(inc, des);\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"101534",
			"view":"868",
			"top":"9",
			"title":"Java Recursive Solution with some comments.",
			"vote":"1",
			"content":"    int maxlen;\\n    public int longestConsecutive(TreeNode root) {\\n        maxlen = 0;\\n        if(root==null) return maxlen;\\n        incdecPath(root);\\n        return maxlen;\\n    }\\n    private int[] incdecPath(TreeNode curr){\\n        int[] ret = {1,1,1,1}; // index 0 and 1 used to record from current node to left node. index 0 used to record the length pointing from current node to current.left.  \\n       //Of course, you can use a 2D array here using positive and negative numbers to mark the \"flow\" direction.\\n        if(curr.left!=null){\\n            int[] leftchild = incdecPath(curr.left);\\n            if(curr.val - curr.left.val == 1){\\n                ret[0] += Math.max(leftchild[0], leftchild[2]);\\n            }\\n            if(curr.val - curr.left.val == -1){\\n                ret[1] += Math.max(leftchild[1], leftchild[3]);\\n            }\\n        }\\n        if(curr.right!=null){\\n            int[] rightchild = incdecPath(curr.right);\\n            if(curr.val - curr.right.val == 1){\\n                ret[2] += Math.max(rightchild[0], rightchild[2]);\\n            }\\n            if(curr.val - curr.right.val == -1){\\n                ret[3] += Math.max(rightchild[1], rightchild[3]);\\n            }\\n        }\\n        maxlen = Math.max(maxlen,Math.max(ret[0] + ret[3], ret[1] + ret[2]) - 1);\\n        return ret;\\n    }"
		}
	],
	"id":"533",
	"title":"Binary Tree Longest Consecutive Sequence II",
	"content":"<p>Given a binary tree, you need to find the length of Longest Consecutive Path in Binary Tree. </p>\r\n\r\n<p>Especially, this path can be either increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n        1\r\n       / \\\r\n      2   3\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> The longest consecutive path is [1, 2] or [2, 1].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n        2\r\n       / \\\r\n      1   3\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> The longest consecutive path is [1, 2, 3] or [3, 2, 1].\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nAll the values of tree nodes are in the range of [-1e7, 1e7].\r\n</p> \r\n\r\n",
	"frequency":"34",
	"ac_num":"6539"
}