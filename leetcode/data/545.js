{
	"difficulty":"3",
	"submit_num":"27731",
	"show_id":"564",
	"leetcode_id":"564",
	"answers":[
		{
			"lc_ans_id":"102391",
			"view":"6646",
			"top":"0",
			"title":"Python, Simple with Explanation",
			"vote":"37",
			"content":"Let's build a list of candidate answers for which the final answer must be one of those candidates.  Afterwards, choosing from these candidates is straightforward.\\n\\nIf the final answer has the same number of digits as the input string ```S```, then the answer must be the middle digits + (-1, 0, or 1) flipped into a palindrome.  For example, ```23456``` had middle part ```234```, and ```233, 234, 235``` flipped into a palindrome yields ```23332, 23432, 23532```.  Given that we know the number of digits, the prefix ```235``` (for example) uniquely determines the corresponding palindrome ```23532```, so all palindromes with larger prefix like ```23732``` are strictly farther away from S than ```23532 >= S```.\\n\\nIf the final answer has a different number of digits, it must be of the form ```999....999``` or ```1000...0001```, as any palindrome smaller than ```99....99``` or bigger than ```100....001``` will be farther away from S.\\n \\n```\\ndef nearestPalindromic(self, S):\\n    K = len(S)\\n    candidates = [str(10**k + d) for k in (K-1, K) for d in (-1, 1)]\\n    prefix = S[:(K+1)/2]\\n    P = int(prefix)\\n    for start in map(str, (P-1, P, P+1)):\\n        candidates.append(start + (start[:-1] if K%2 else start)[::-1])\\n    \\n    def delta(x):\\n        return abs(int(S) - int(x))\\n    \\n    ans = None\\n    for cand in candidates:\\n        if cand != S and not cand.startswith('00'):\\n            if (ans is None or delta(cand) < delta(ans) or\\n                    delta(cand) == delta(ans) and int(cand) < int(ans)):\\n                ans = cand\\n    return ans\\n```"
		},
		{
			"lc_ans_id":"102390",
			"view":"5612",
			"top":"1",
			"title":"Java solution with full explaination",
			"vote":"11",
			"content":"My solution take @uwi 's solution as reference, and add my understanding to it.\\nWe first need to find the higher palindrome and lower palidrome respectively. and return the one who has the least different with the input number.\\n\\nFor the higher palindrome, the low limit is number + 1 while for the lower palindrome, the high limit is number - 1.\\n\\nOne global solution to find a palindrome is to copy first half part of the array to the last half part, we regards this as standard palindrome.\\nWe need to detect this standard palindrome belongs to higher one or the lower one. And other solutions will be based on this standard one. \\n\\nFor the higher palindrome, if the standard one belongs to higher, we just simply return it. Or we need to change it.\\nFor example, String n is 1343, and the standard palindrome is 1331. to get the higher one from the standard palidrome, we start from the \\nfirst 3, which is (n.length - 1) / 2. Add the number by 1, (---> 1431)if the added result is not higher than 9, the changing process is finished,\\notherwise, continuously changing the number of previous index by i. After the changing process, we re-palidrome the string. (1431 -- > 1441)\\n\\nFor the lower palindrome, similar idea.But we need to notice that when we decrease a number, and if the first character of the string is '0',\\nwe need to resize the array of n.length - 1, and fill in with '9'. (for example, n is '1000', the standard palidrome is '1001'(higher one) ,the lower one '0000'-->'999'.)\\n```java\\npublic class Solution {\\n    public String nearestPalindromic(String n) {\\n        Long number = Long.parseLong(n);\\n        Long big = findHigherPalindrome(number + 1);\\n        Long small = findLowerPalindrome(number - 1);\\n        return Math.abs(number - small) > Math.abs(big - number) ? String.valueOf(big) : String.valueOf(small);\\n    }\\n    public Long findHigherPalindrome(Long limit) {\\n        String n = Long.toString(limit);\\n        char[] s = n.toCharArray(); // limit\\n        int m = s.length;\\n        char[] t = Arrays.copyOf(s, m); // target\\n        for (int i = 0; i < m / 2; i++) {\\n            t[m - 1 - i] = t[i];\\n        }\\n        for (int i = 0; i < m; i++) {\\n            if (s[i] < t[i]) {\\n                return Long.parseLong(String.valueOf(t)); \\n            } else if (s[i] > t[i]) { \\n                for (int j = (m - 1) / 2; j >= 0; j--) {\\n                    if (++t[j] > '9') {\\n                        t[j] = '0';\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                // make it palindrome again\\n                for (int k = 0; k < m / 2; k++) {\\n                    t[m - 1 - k] = t[k];\\n                }\\n                return Long.parseLong(String.valueOf(t)); \\n            }\\n        }\\n        return Long.parseLong(String.valueOf(t));    \\n    }\\n    public Long findLowerPalindrome(Long limit) {\\n        String n = Long.toString(limit);\\n        char[] s = n.toCharArray();\\n        int m = s.length;\\n        char[] t = Arrays.copyOf(s, m);\\n        for (int i = 0; i < m / 2; i++) {\\n            t[m - 1 - i] = t[i];\\n        }\\n        for (int i = 0; i < m; i++) {\\n            if (s[i] > t[i]) {\\n                return Long.parseLong(String.valueOf(t)); \\n            } else if (s[i] < t[i]) {\\n                for (int j = (m - 1) / 2; j >= 0; j--) {\\n                    if (--t[j] < '0') {\\n                        t[j] = '9';\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if (t[0] == '0') {\\n                    char[] a = new char[m - 1];\\n                    Arrays.fill(a, '9');\\n                    return Long.parseLong(String.valueOf(a)); \\n                }\\n                // make it palindrome again\\n                for (int k = 0; k < m / 2; k++) {\\n                    t[m - 1 - k] = t[k];\\n                }\\n                return Long.parseLong(String.valueOf(t)); \\n            }\\n        }\\n         return Long.parseLong(String.valueOf(t));  \\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"102389",
			"view":"1986",
			"top":"2",
			"title":"Java solution with detailed proof",
			"vote":"10",
			"content":"The basic idea for this problem is summarized in other posts (see [awice's post](https://discuss.leetcode.com/topic/87220/python-simple-with-explanation)), in which we will find a couple of candidate palindromes and choose the one that is closest to the given number. Here I will elaborate on this idea and show the theoretical proof behind the scene wherever possible.\\n\\n---\\n**`I -- The given number itself is a palindrome`**\\n\\nSince we are asked to find the closest palindrome, let's begin with the simple case when the given number itself is a palindrome.\\n\\nAssume `n` is the string representation of the given number with length `m` (i.e., the number has `m` digits), `num` is the **numerical** value of `n`.  Because `n` is a palindrome, we can break it into two parts from the middle: left part consisting of the first `p` digits and right part consisting of the remaining `k` digits, where `k = m/2` (integer division) and `p = m - k`. Note that in this definition, we have `p >= k`: the number of digits in the left part is no less than that in the right. Let `l` and `r` be the **numerical** values of the left and right parts, respectively. Then `num = l * 10^k + r`. To get a more concrete idea, let's work out an example. Suppose `n = \"14241\"`, then `m = 5`, `num = 14241`,  `p = 3`, `k = 2`, `l = 142`, `r = 41` and apparently `num = l * 10^2 + r = 142 * 100 + 41 = 14241`.\\n\\nNow assume we have another palindrome `n1` with length `m1` and **numerical** value `num1`. And again we will divide it into two parts, but instead breaking from the middle, we will break it such that the right part has `k1 = k` digits while the left part contains the remaining `p1 = m1 - k` digits. The corresponding **numerical** values of the left and right parts are `l1` and `r1` (if `m1 <= k`, all the digits go to the right part and we have `l1 = 0`). Similarly `num1 = l1 * 10^k + r1`. Again we take an example with  `n1 = \"131\"`, then `m1 = 3`, `num1 = 131`,  `p1 = 1`, `k1 = 2`, `l1 = 1`, `r1 = 31` and apparently `num1 = l1* 10^2 + r1 = 1 * 100 + 31 = 131`.\\n\\nNext we will show that `l > l1 ==> num > num1`, that is if `l` is greater than `l1`, then the numerical value of `n` is greater than that of `n1`, i.e., `num > num1`. The proof is as follows. **First** note that `0 < r, r1 < 10^k`, which implies `|r - r1| < 10^k`. **Second** note that if `l > l1`, we have `l - l1 >= 1` since both of them are integers. **Then** `num - num1 = (l * 10^k + r) - (l1 * 10^k + r1) = (l - l1) * 10^k + (r - r1) >= 10^k + (r - r1) > 0`, that is `num > num1`. Similarly we can show that `l < l1 ==> num < num1`.\\n\\nNow we will introduce a third palindrome `n2` with length `m2` and **numerical** value `num2`. Similar to `n1`, `n2` has left and right parts with **numerical** values `l2` and `r2`. We then can show that `l > l1 > l2 ==> d1 < d2`, where `d1 = abs(num - num1)` and `d2 = abs(num - num2)` denote the distances from `n1` and `n2` to `n`, respectively (`abs` means absolute values). The proof is rather straightforward. **First** from the conclusion above, we have `num > num1` and `num > num2`. **Second** by the same reasoning with `l`, `num` replaced by `l2`, `num2`, we conclude `l1 > l2 ==> num1 > num2`. **Then** `d1 - d2 = abs(num - num1) - abs(num - num2) = (num - num1) - (num - num2) = num2 - num1 < 0`. This is to say if we have two palindromes whose left part values are smaller than that of the given palindrome, then the one with larger left part value is closer to the given palindrome. Similarly we may show that `l < l1 < l2 ==> d1 < d2`, i.e., if we have two palindromes whose left part values are greater than that of the given palindrome, then the one with smaller left part value is closer to the given palindrome.\\n\\nSince we are only concerned with the closest palindrome to `n`, our analyses above suggest we need to minimize the difference of the left part values between the candidate palindromes and `n`. Apparently the **minimum** difference we can get is `1` (it cannot be `0` otherwise the candidate palindrome is the same as `n`), and we end up with two candidate palindromes, one smaller than `n` and the other larger than `n`, both with left part values differ by `1` from that of `n`. We will denote these two candidate palindromes as `cn1` and `cn2`, with numerical values `cnum1` and `cnum2`, left part values `cl1` and `cl2`, and right part values `cr1` and `cr2`. We assume `cnum1 < num < cnum2`. Then `cl1` and `cl2` will be related to `l` by `cl1 = l - 1` and `cl2 = l + 1`.\\n\\nBecause `n` is given, `l` will be known to us. So the left parts of the two candidate palindromes will also be fixed. Then our task is equivalent to determining the whole palindrome from information of its left part. We will postpone this to the end of the post and move to the next part where the given number is not a palindrome.\\n\\n---\\n**`II -- The given number is a not palindrome`**\\n\\nWe have shown how to find the candidate palindromes in part I, under the assumption that the given number `n` itself is a palindrome. But what if it is not?\\n\\nWell, the answer to that is very simple: why don't we just go ahead and construct a palindrome from `n` by ourselves?\\n\\nThere are two ways of constructing a palindrome from `n`. First we divide it into two parts from the middle. Then we can either replace the left part with the reverse of the right, or replace the right part with the reverse of the left. If we replace the left part, the distance between the constructed palindrome to `n` is given by `abs(l - l') * 10^k`, where `l` and `l'` are the numerical values of the left parts of `n` and the constructed palindrome, respectively, since they share the right parts. However if we replace the right part, the distance will be `abs(r - r')`, where `r` and `r'` are the numerical values of the right parts of `n` and the constructed palindrome, respectively, as now they share the left parts. Apparently the former is greater than the latter, therefore the palindrome should be constructed by replacing the right part with the reverse of the left part.\\n\\nLet `curP` be the palindrome constructed above, with numerical value `cur`. The two candidate palindromes built from `curP` as shown in part **`I`** are `preP` and `nextP`, with numerical values `pre` and `next`, respectively. Assuming `pre < cur < next`, we will show that `pre < num < next`, i.e., the numerical value of `n` itself is also in between `pre` and `next`.\\n\\nThe proof goes as follows. Let's assume the numerical values of the left and right parts of `n`, `preP`, `curP` and `nextP` are `l` and `r`, `l1` and `r1`, `l2` and `r2`, `l3` and `r3`, respectively. Since `curP` is constructed by replacing the right part only, we have `l2 = l`. Also from part **`I`**, we have `l1 = l2 - 1` and `l3 = l2 + 1`. Then `num - pre = (l * 10^k + r) - (l1 * 10^k + r1) = (l - l1) * 10^k + (r - r1) = 10^k + (r - r1) > 0` and `next - num = (l3 * 10^k + r3) - (l * 10^k + r) = (l3 - l) * 10^k + (r3 - r) = 10^k + (r3 - r) > 0`. Therefore `pre < num < next`.\\n\\nLet `d1 = abs(num - pre)`, `d2 = abs(num - cur)` and `d3 = abs(num - next)`. The conclusion above means any palindrome smaller than `pre` or larger than `next` will have greater distance from `num` than at least one of `d1`, `d2` and `d3`, and thus cannot be the closest palindrome. Eventually the closest palindromes can only be one of `preP`, `curP` and `nextP`.\\n\\n---\\n**`III -- Construct the whole palindrome from its left part`**\\n\\nWe have shown that the candidate palindromes can only be `preP`, `curP` and `nextP`. Obtaining `curP` is straightforward, by simply replacing the right part of `n` with the reverse of its left part. Obtaining `preP` and `nextP` requires some efforts since we only know the left parts for them.\\n\\nTo streamline our explanations below, let's first spell out the various notations for `preP`, `curP` and `nextP`: the number of digits are `m1`, `m2` and `m3`; the numerical values are `pre`, `cur` and `next`; the number of digits in the left part are `p1`, `p2` and `p3`; in the right part are `k1`, `k2` and `k3`; the numerical values of the left parts are `l1`, `l2` and `l3`; of the right parts are `r1`, `r2` and `r3`; respectively. Note the partition of the three palindromes are chosen such that `k2 = k/2, p2 = k - k2` where `k` is the number of digits in `n`, and `k1 = k2 = k3`, i.e., the three palindromes have the same number of digits in the right parts.\\n\\nNext let's see how to work out `nextP`. From the analyses above, we have `l3 = l2 + 1`. If there is no **carry** beyond the most significant digit (MSD) of `l2`, then `p3 = p2`, which means `k3 = k/2, p3 = k - k3`. This implies `nextP` is also partitioned from the same middle position as `curP`. Therefore, the right part of `nextP` can be obtained by taking the last `k3` digits of the reverse of `l3`. If there is carry going on beyond MSD of `l2`, then `p3 = p2 + 1`. But this is only possible if all digits in `l2` is `9` and therefore `l3` will be of the form with a leading one followed by `p3` zeros. In this case, the right part of `nextP` can still be obtained by taking the last `k3` digits of the reverse of `l3`. So in either case, `nextP` can be obtained by attaching to its left part the string consisting of the last `k3` digits of the reverse of `l3`.\\n\\nLastly for `preP`, we have `l1 = l2 - 1`. Again, if there is no **borrow** from the MSD of `l2`, the right part of `preP` can be obtained by taking the last `k1` digits of the reverse of `l1`. However, there are two edge cases where `l2 = 1` and then `l1` becomes `0`: one is when `curP = \"1\"` and the other `curP = \"11\"`. The expression of  `preP` for both cases can be readily known:  `preP = \"0\"` for the former and  `preP = \"9\"` for the latter. On the other hand, if there is borrow going on from the MSD of `l2`, then `l2` must be of the form with a leading one followed by `p2 - 1` zeros. As a result, all digits in `l1` will be `9`, and `k1 = k2 >= p2 - 1 = p1`. Since now the number of digits in `r1` is no less than that in `l1`, not only should we put all digits of the reverse of `l1` into `r1`, but also need to fill in the additional digit by hand in cases where `k1 > p1`. That additional digit can only be `9` if we want to minimize the distance from `preP` to `curP`.\\n\\nIt turns out that the algorithm for solving `preP` and `nextP` can be combined into one, as I did in the codes below. The function **`nearestPalindrom`** will return the closest palindrome to the input palindrome `curP`, and depending on whether `dir` is true or false, the returned palindrome will be greater or smaller than `curP`. The main function **`nearestPalindromic`** follows my analyses in part **`II`**, in which we first replace the right half of the given number `n` to construct the palindrome `curP`. We then call **`nearestPalindrom`** to build the two closest candidate palindromes from it. Lastly, out of the three candidates, we return the one that is closest to the given number (return the smaller one if there is a tie). Anyway, here are the codes for the two functions.\\n\\n```\\npublic String nearestPalindromic(String n) {\\n    char[] arr = n.toCharArray();\\n    for (int i = 0, j = arr.length - 1; i < j; i++, j--) arr[j] = arr[i];\\n        \\n    String curP = String.valueOf(arr);\\n    String preP = nearestPalindrom(curP, false);\\n    String nextP = nearestPalindrom(curP, true);\\n        \\n    long num = Long.valueOf(n);\\n    long cur = Long.valueOf(curP);\\n    long pre = Long.valueOf(preP);\\n    long next = Long.valueOf(nextP);\\n        \\n    long d1 = Math.abs(num - pre);\\n    long d2 = Math.abs(num - cur);\\n    long d3 = Math.abs(num - next);\\n        \\n    if (num == cur) {\\n        return d1 <= d3 ? preP : nextP;\\n    } else if (num > cur) {\\n        return d2 <= d3 ? curP : nextP;\\n    } else {\\n        return d1 <= d2 ? preP : curP;\\n    }\\n}\\n    \\nprivate String nearestPalindrom(String curP, boolean dir) {\\n    int k = curP.length() >> 1, p = curP.length() - k;\\n    int l = Integer.valueOf(curP.substring(0, p));\\n    l += (dir ? 1 : -1);\\n    \\t\\n    if (l == 0) return k == 0 ? \"0\" : \"9\";\\n    \\t\\n    StringBuilder left = new StringBuilder(String.valueOf(l));\\n    StringBuilder right = new StringBuilder(left).reverse();\\n    if (k > left.length()) right.append(\"9\");\\n    \\t\\n    return left.append(right.substring(right.length() - k)).toString();\\n}\\n```"
		},
		{
			"lc_ans_id":"102400",
			"view":"1816",
			"top":"3",
			"title":"Concise Java Solution",
			"vote":"6",
			"content":"The following code attempts to simplify the logic by covering more cases. It is fine for this problem as the runtime is anyway O(1).\\n```Java\\nlong ans = 0, diff = Long.MAX_VALUE, n = 0;\\n\\nprivate void update(String val) {\\n    try {\\n        long tmp = Long.parseLong(val);\\n        if (tmp == n) return;\\n        if (Math.abs(tmp - n) < diff || (Math.abs(tmp - n) == diff && tmp < ans)) {\\n            ans = tmp;\\n            diff = Math.abs(tmp - n);\\n        }\\n    } catch (Exception e) { }\\n}\\n\\nprivate void concat(long leftHalf) {\\n    String s = \"\" + leftHalf, rs = new StringBuilder(s).reverse().toString();\\n    update(s + rs); // abc -> abccba\\n    update(s + rs.substring(1)); // abc -> abcba\\n}\\n\\npublic String nearestPalindromic(String n) {\\n    this.n = Long.parseLong(n);\\n    diff = Long.MAX_VALUE;\\n    long leftHalf = Long.parseLong(n.substring(0, (n.length() + 1) / 2));\\n    concat(leftHalf - 1);\\n    concat((leftHalf - 1) * 10 + 9); // Handle 1, 1000, 100000, etc.\\n    concat(leftHalf);\\n    concat(leftHalf + 1);\\n    concat((leftHalf + 1) / 10); // Handle 9, 999, 99999, etc.\\n    return \"\" + ans;\\n}\\n```"
		},
		{
			"lc_ans_id":"102396",
			"view":"1357",
			"top":"4",
			"title":"C++ short solution, only need to compare 5 numbers",
			"vote":"5",
			"content":"This solution is inspired by @awice , refer to https://discuss.leetcode.com/topic/87220/python-simple-with-explanation\\n```cpp\\nclass Solution {\\npublic:\\n    string nearestPalindromic(string n) {\\n        int l = n.size();\\n        set<long> candidates;\\n        // biggest, one more digit, 10...01\\n        candidates.insert(long(pow(10, l)) + 1);\\n        // smallest, one less digit, 9...9 or 0\\n        candidates.insert(long(pow(10, l - 1)) - 1);\\n        // the closest must be in middle digit +1, 0, -1, then flip left to right\\n        long prefix = stol(n.substr(0, (l + 1) / 2));\\n        for ( long i = -1; i <= 1; ++i ) {\\n            string p = to_string(prefix + i);\\n            string pp = p + string(p.rbegin() + (l & 1), p.rend());\\n            candidates.insert(stol(pp));\\n        }\\n        long num = stol(n), minDiff = LONG_MAX, diff, minVal;\\n        candidates.erase(num);\\n        for ( long val : candidates ) {\\n            diff = abs(val - num);\\n            if ( diff < minDiff ) {\\n                minDiff = diff;\\n                minVal = val;\\n            } else if ( diff == minDiff ) {\\n                minVal = min(minVal, val);\\n            }\\n        }\\n        return to_string(minVal);\\n    }\\n};\\n```\\nHere paste the shortened Python version as well\\n```python\\nclass Solution(object):\\n    def nearestPalindromic(self, n):\\n        \"\"\"\\n        :type n: str\\n        :rtype: str\\n        \"\"\"\\n        # based on @awice and @o_sharp\\n        l = len(n)\\n        # with different digits width, it must be either 10...01 or 9...9\\n        candidates = set((str(10 ** l + 1), str(10 ** (l - 1) - 1)))\\n        # the closest must be in middle digit +1, 0, -1, then flip left to right\\n        prefix = int(n[:(l + 1)/2])\\n        for i in map(str, (prefix - 1, prefix, prefix + 1)):\\n            candidates.add(i + [i, i[:-1]][l & 1][::-1])\\n        candidates.discard(n)\\n        return min(candidates, key=lambda x: (abs(int(x) - int(n)), int(x)))\\n```"
		},
		{
			"lc_ans_id":"102397",
			"view":"115",
			"top":"5",
			"title":"JAVA easy understanding comparison solution(18ms) with comments",
			"vote":"4",
			"content":"## How is it work \\nIn my solution, there are 5 situations: \\n> 1. **0**\\n> 2. **11**\\n> 3. **single digit** *like 1~9*\\n> 4. **10 based number** *like 10, 100, 1000 etc.*\\n> 5. **the others**\\n\\nThe most complicated one is **situation 5**, cause there would be **3** close palindromes of 1 number:\\n> 1. **palindrome by itself**\\n> 2. **palindrome a little bigger than itself**\\n> 3. **palindrome a little smaller than itself**\\n\\nSo, the value ```offset``` is to generate them. Then, we get palindrome with the offset number. And finally, we compare three of them, and get the closest and smaller one. \\n\\n## Complexity\\nThe time O is ```3 * n/2 + 3```= **n**\\n\\n## Code\\n```\\npublic String nearestPalindromic(String n) {\\n\\tlong num = Long.valueOf(n);\\n\\tif (num == 0) return \"1\";\\n\\tif (num == 11) return \"9\";\\n\\tif (num <= 10 || Math.log10(num)%1==0) return num - 1 + \"\";\\n\\t\\n\\tlong exp = n.length() - (n.length() - 1) / 2 - 1;\\n\\tlong offset = (long) Math.pow(10, exp);\\n\\t\\n\\treturn min(num, palindry(n), palindry(num + offset + \"\"), palindry(num - offset + \"\"));\\n}\\n\\n//choose the closest number away from target\\nprivate String min(long target, long s1, long s2, long s3) {\\n\\tlong[] array = { s1, s2, s3 };\\n\\tlong[] distance = new long[3];\\n\\tfor (int i = 0; i < array.length; i++) {\\n\\t\\tdistance[i] = Math.abs(target - array[i]);\\n                //exclude itself\\n\\t\\tif (distance[i] == 0) distance[i] = Long.MAX_VALUE;\\n\\t}\\n\\n\\tint minIndex = distance[0] > distance[1] ? 1 : 0;\\n\\treturn array[distance[2] > distance[minIndex] ? minIndex : 2] + \"\";\\n}\\n\\n//get a normal palindrome number\\nprivate long palindry(String n) {\\n\\tchar[] c = n.toCharArray();\\n\\tfor (int i = 0; i < c.length / 2; i++) {\\n\\t\\tc[c.length - i - 1] = c[i];\\n\\t}\\n\\treturn new Long(new String(c));\\n}\\n```"
		},
		{
			"lc_ans_id":"102423",
			"view":"2532",
			"top":"6",
			"title":"java solution",
			"vote":"4",
			"content":"```\\npublic class Solution {\\n    public String nearestPalindromic(String n) {\\n        if (n.length() >= 2 && allNine(n)) {\\n            String s = \"1\";\\n            for (int i = 0; i < n.length() - 1; i++) {\\n                s += \"0\";\\n            }\\n            s += \"1\";\\n            return s;\\n        }\\n        boolean isOdd = (n.length() % 2 != 0);\\n        String left = n.substring(0, (n.length() + 1) / 2);\\n        long[] increment = {-1, 0, +1};\\n        String ret = n;\\n        long minDiff = Long.MAX_VALUE;\\n        for (long i : increment) {\\n            String s = getPalindrom(Long.toString(Long.parseLong(left) + i), isOdd);\\n            if (n.length() >= 2 && (s.length() != n.length() || Long.parseLong(s) == 0)) {\\n                s = \"\";\\n                for (int j = 0; j < n.length() - 1; j++) {\\n                    s += \"9\";\\n                }\\n            }\\n            long diff = s.equals(n) ? Long.MAX_VALUE : Math.abs(Long.parseLong(s) - Long.parseLong(n));\\n            if (diff < minDiff) {\\n                minDiff = diff;\\n                ret = s;\\n            }\\n        }\\n        return ret;\\n    }\\n    private String getPalindrom(String s, boolean isOdd) {\\n        String right = new StringBuilder(s).reverse().toString();\\n        return isOdd ? s.substring(0, s.length() - 1) + right : s + right;\\n    }\\n    private boolean allNine(String s) {\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != '9') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"102388",
			"view":"33",
			"top":"7",
			"title":"my java solution",
			"vote":"1",
			"content":"```\\n    public String nearestPalindromic(String n) {\\n        long a = Long.valueOf(n), b;\\n        long half = (long) Math.pow(10L, n.length() / 2);\\n        long[] candidates = new long[] {b = a / half * half, b - (half > 1 ? half/10 : 1), b + half};\\n        long res = 0;\\n        for (long cand : candidates) {\\n            cand = mirroring(cand);\\n            if (cand == a) continue;\\n            if (Math.abs(res - a) > Math.abs(cand - a) || (Math.abs(res - a) == Math.abs(cand - a) && cand < res)) {\\n                res = cand;\\n            }\\n        }\\n        return ((Long) res).toString();\\n    }\\n    \\n    public long mirroring(long n) {\\n        long m = 0, x = n, half = 1, i = 0;\\n        while (x > 0) {\\n            m = m * 10 + x % 10;\\n            x /= 10;\\n            if (i++ % 2 > 0) half *= 10L;\\n        }\\n        return n / half * half + m % half;\\n    }\\n```"
		},
		{
			"lc_ans_id":"102403",
			"view":"319",
			"top":"8",
			"title":"16 lines C++",
			"vote":"1",
			"content":"Here's my short C++ solution. You can refer to the perfect explanation by @awice [here](https://discuss.leetcode.com/topic/87220/python-simple-with-explanation). Thanks for attention :-)\\n\\n```\\nclass Solution {\\npublic:\\n    string nearestPalindromic(string n) {\\n        function<long(long, int)> mirror = [&n](long mid, int d) {\\n            string prefix = to_string(mid + d);\\n            return stol(prefix + string(prefix.rbegin() + (n.size() % 2), prefix.rend()));\\n        };\\n        \\n        long mid = stol(n.substr(0, (n.size() + 1) / 2));\\n        set<long> candidates = { pow(10, n.size() - 1) - 1, mirror(mid, -1), mirror(mid, 0), mirror(mid, 1), pow(10, n.size()) + 1 };\\n\\n        long num = stol(n);\\n        candidates.erase(num);\\n        return to_string(*min_element(candidates.begin(), candidates.end(), [num](long a, long b) { return abs(num - a) < abs(num - b); }));\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"102392",
			"view":"31",
			"top":"9",
			"title":"C# solution--using numeric-based palindrome versus character-based solution",
			"vote":"0",
			"content":"This took me a while to get, but I figured it out using numerical methods versus arrays.  \\n\\nThere several important keys to consider:\\n\\n* MakePalidrome, itself, solves many of the case; however, sometimes it is over and/or under the nearest palindrome.  This is pretty cool itself.\\n* There are two cases to be considered: 1) Palindromes **lesser** than the **number**, and,  2) Palindromes **greater** than the **number**.  This has already been explained in other discussions (see the java code).\\n* Pay close attention to the pivot points. Let's call these the **secrets** of the Palindromes :-)  For example, answer the question,  \"why, changing the \"2\" in \"121\" or \"2\" in \"2233\" can find the nearest palindrome?\"\\n* This solution was converted from a Java solution that was using character arrays.  I didn't like how much copying and parsing that was going on so I tried to accomplish the same things using numerical methods.\\n* This solution is 100% faster, but that is kind of deceiving.  The N here is not large enough to expose the weaknesses of the numerical methods.  For example, indexing of a number isn't O(1).  MakePalidrome is O(N*logN) and so forth...\\n* At any rate, it was fun... Happy Coding..\\n***\\n    /// <summary>\\n    /// Given an integer n, find the closest integer (not including itself), which is a palindrome.\\n    /// The 'closest' is defined as absolute difference minimized between two integers.\\n    /// </summary>\\n    public class Solution\\n    {\\n        const long radix = 10;\\n\\n        //O(N) algorithm for creating a numerical palindrome\\n        private long MakePalindrome(long value, int length)\\n        {\\n            long exp = 1L;\\n            int mid = length / 2;\\n            long reverse = 0;\\n            int i = 0;\\n\\n            //Truncate value\\n            while (i++ < mid)\\n            {\\n                exp *= radix;\\n            }\\n            value /= exp;\\n\\n            \\n            i = 0;\\n            long temp = value;\\n\\n            //233 ==> 23 + 2\\n            if (length % 2 == 1)\\n            {\\n                temp /= radix;\\n            }\\n\\n            //Reverse truncated value\\n            while (i++ < mid)\\n            {\\n                reverse *= radix;\\n                reverse += temp % radix;\\n                temp /= radix;\\n            }\\n\\n            value *= exp;\\n            value += reverse;\\n\\n            return value;\\n        }\\n\\n        //Digit value is reversed-order\\n        //(10)==> Digit 1 is 1, Digit 0 is 0\\n        private int DigitValue(long x, int n)\\n        {\\n            long exp = 1;\\n\\n            while (n-- > 0)\\n            {\\n                exp *= radix;\\n            }\\n\\n            x /= exp;\\n            x %= radix;\\n\\n            return (int)x;\\n        }\\n\\n        //Digit order is reversed; 10 ==> 1 @ 1 and 0 @ 0\\n        private long IncrementAtDigitIndex(long value, long source, int nIndex)\\n        {\\n            int i = 0;\\n\\n            while(i++ < nIndex)\\n            {\\n                value *= radix;\\n            }\\n            \\n            return source + value;\\n        }\\n\\n        private int Len(long z)\\n        {\\n            long exp = radix;\\n            int i = 1;\\n            while (exp <= z)\\n            {\\n                i++;\\n                exp *= radix;\\n            }\\n            return i;\\n        }\\n\\n        private long FindHigherPalindrome(long limit)\\n        {\\n            int length = Len(limit);\\n            long result = MakePalindrome(limit, length);\\n                        \\n            for (int i = length - 1; i >= 0; i--)\\n            {\\n                int left = DigitValue(limit, i);\\n                int right = DigitValue(result, i);\\n                if (left  < right)\\n                {\\n                    break;\\n                }\\n                else if (left > right)\\n                {\\n                    int j = length / 2;//digit-order reversed\\n                    result = IncrementAtDigitIndex(1L, result, j);\\n                    // make it palindrome again\\n                    result = MakePalindrome(result, Len(length));\\n                    break;\\n                }\\n            }\\n            return result;\\n        }\\n\\n        private long FindLowerPalindrome(long limit)\\n        {\\n            int length = Len(limit);\\n            long result = MakePalindrome(limit, length);\\n\\n            for (int i = length - 1; i >= 0; i--)\\n            {\\n                int left = DigitValue(limit, i);\\n                int right = DigitValue(result, i);\\n                if (left > right)\\n                {\\n                    break;\\n                }\\n                else if (left < right)\\n                {\\n                    int j = length / 2;//digit-order reversed\\n                    result = IncrementAtDigitIndex(-1L, result, j);\\n\\n                    if(length == 2 && result < 10)\\n                    {\\n                        result = 9;\\n                        break;\\n                    }\\n\\n                    // make it palindrome again\\n                    result = MakePalindrome(result, Len(result));\\n                    break;\\n                }\\n            }\\n            return result;\\n        }\\n\\n        public string NearestPalindromic(string n)\\n        {\\n            string result=string.Empty;\\n\\n            if (n.Length > 0)\\n            {\\n                long number = long.Parse(n);\\n                long low = FindLowerPalindrome(number - 1L);\\n                long high = FindHigherPalindrome(number + 1L);\\n                result = Math.Abs(number - low) > Math.Abs(number - high) ? high.ToString() : low.ToString();\\n            }\\n\\n            return result;\\n        }\\n    }"
		}
	],
	"id":"545",
	"title":"Find the Closest Palindrome",
	"content":"<p>Given an integer n, find the closest integer (not including itself), which is a palindrome. </p>\r\n\r\n<p>The 'closest' is defined as absolute difference minimized between two integers.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"123\"\r\n<b>Output:</b> \"121\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The input <b>n</b> is a positive integer represented by string, whose length will not exceed 18.</li>\r\n<li>If there is a tie, return the smaller one as answer.</li>\r\n</ol>\r\n</p>",
	"frequency":"249",
	"ac_num":"4869"
}