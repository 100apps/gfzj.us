{
	"difficulty":"3",
	"submit_num":"15648",
	"show_id":"568",
	"leetcode_id":"568",
	"answers":[
		{
			"lc_ans_id":"102655",
			"view":"3655",
			"top":"0",
			"title":"Java DFS(TLE) and DP Solutions",
			"vote":"16",
			"content":"Solution 1. DFS. The idea is just try each ```possible``` city for every week and keep tracking the ```max``` vacation days. Time complexity O(N^K). Of course it will TLE....\\n```\\npublic class Solution {\\n    int max = 0, N = 0, K = 0;\\n    \\n    public int maxVacationDays(int[][] flights, int[][] days) {\\n        N = flights.length;\\n        K = days[0].length;\\n        dfs(flights, days, 0, 0, 0);\\n        \\n        return max;\\n    }\\n    \\n    private void dfs(int[][] f, int[][] d, int curr, int week, int sum) {\\n        if (week == K) {\\n            max = Math.max(max, sum);\\n            return;\\n        }\\n        \\n        for (int dest = 0; dest < N; dest++) {\\n            if (curr == dest || f[curr][dest] == 1) {\\n                dfs(f, d, dest, week + 1, sum + d[dest][week]);\\n            }\\n        }\\n    }\\n}\\n```\\nSolution 2. DP.  ```dp[i][j]``` stands for the max vacation days we can get in week ```i``` staying in city ```j```. It's obvious that ```dp[i][j] = max(dp[i - 1][k] + days[j][i]) (k = 0...N - 1, if we can go from city k to city j)```. Also because values of week ```i``` only depends on week ```i - 1```, so we can compress two dimensional ```dp``` array to one dimension. Time complexity O(K * N * N) as we can easily figure out from the 3 level of loops.\\n```\\npublic class Solution {\\n    public int maxVacationDays(int[][] flights, int[][] days) {\\n        int N = flights.length;\\n        int K = days[0].length;\\n        int[] dp = new int[N];\\n        Arrays.fill(dp, Integer.MIN_VALUE);\\n        dp[0] = 0;\\n        \\n        for (int i = 0; i < K; i++) {\\n            int[] temp = new int[N];\\n            Arrays.fill(temp, Integer.MIN_VALUE);\\n            for (int j = 0; j < N; j++) {\\n                for(int k = 0; k < N; k++) {\\n                    if (j == k || flights[k][j] == 1) {\\n                        temp[j] = Math.max(temp[j], dp[k] + days[j][i]);\\n                    }\\n                }\\n            }\\n            dp = temp;\\n        }\\n        \\n        int max = 0;\\n        for (int v : dp) {\\n            max = Math.max(max, v);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"102680",
			"view":"781",
			"top":"1",
			"title":"Python, Simple with Explanation",
			"vote":"6",
			"content":"Let's maintain ```best[i]```, the most vacation days you can have ending in city ```i``` on week t.  At the end, we simply want max(best), the best answer for any ending city.\\n\\nFor every flight ```i -> j``` (including staying in the same city, when ```i == j```), we have a candidate answer best[j] = best[i] + days[j][t], and we want the best answer of those.\\n\\nWhen the graph is sparse, we can precompute ```flights_available[i] = [j for j, adj in enumerate(flights[i]) if adj or i == j]``` instead to save some time, but this is not required.\\n\\n```\\ndef maxVacationDays(self, flights, days):\\n    NINF = float('-inf')\\n    N, K = len(days), len(days[0])\\n    best = [NINF] * N\\n    best[0] = 0\\n    \\n    for t in xrange(K):\\n        cur = [NINF] * N\\n        for i in xrange(N):\\n            for j, adj in enumerate(flights[i]):\\n                if adj or i == j:\\n                    cur[j] = max(cur[j], best[i] + days[j][t])\\n        best = cur\\n    return max(best)\\n```"
		},
		{
			"lc_ans_id":"102681",
			"view":"840",
			"top":"2",
			"title":"[C++] [Java] 10 lines Clean Code - Graphic Explanation",
			"vote":"2",
			"content":"```\\n/**\\n * DFS: start from city 0, for each week(on the Monday), find a city you can go, take the holiday you can take,\\n * there is a duplicate sub problem : \\n * dp[i][j] = days[i][j] + max(dp[i=0,m][j + 1]); // dp[i][j] : max days play if you spent week j in city i;\\n * \\n * flights:\\n *     0 1 2\\n *  --------\\n *  0 |0 1 1\\n *  1 |1 0 1\\n *  2 |1 1 0\\n * \\n * days:\\n *     0 1 2\\n *  --------\\n *  0 |1 3 1 \\n *  1 |6 0 3\\n *  2 |3 3 3\\n```\\n```\\n * dp:\\n *          0   1  (2)  (week 2)\\n *      ----------------\\n * city 0 |   |   | 1 |\\n *        +---+---+----\\n * city 1 |   |   | 3 |\\n *        +---+---+----\\n * city 2 |   |   | 3 |\\n *        +-------------\\n * \\n *          0  (1)  2   (week 1)\\n *      ----------------\\n * city 0 |   | 6 | 1 |\\n *        +---+---+----\\n * city 1 |   | 3 | 3 |\\n *        +---+---+----\\n * city 2 |   | 6 | 3 |\\n *        +-------------\\n * \\n *         (0)  1   2   (week 0)\\n *      ----------------\\n * city 0 | 7 | 6 | 1 |\\n *        +---+---+----\\n * city 1 |12 | 3 | 3 |\\n *        +---+---+----\\n * city 2 | 9 | 6 | 3 |\\n *        +-------------\\n */\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {\\n        int n = days.size(), k = days[0].size(); // n city , k weeks\\n        vector<vector<int>> dp(n, vector<int>(k, 0)); // dp[i][j] - max days play if you spent week j in city i;\\n        for (int j = k - 1; j >= 0; j--) {\\n            for (int i = 0; i < n; i++) {\\n                dp[i][j] = days[i][j];\\n                for (int i1 = 0; i1 < n && j < k - 1; i1++) {\\n                    if (flights[i][i1] || i == i1)\\n                        dp[i][j] = max(dp[i][j], days[i][j] + dp[i1][j + 1]);\\n                }\\n            }\\n        }\\n        int maxplay = dp[0][0];\\n        for (int i = 1; i < n; i++) {\\n            if (flights[0][i]) {\\n                maxplay = max(maxplay, dp[i][0]);\\n            }\\n        }\\n        return maxplay;\\n    }\\n};\\n```\\nCould be shorter:\\n```\\nclass Solution {\\npublic:\\n    int maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {\\n        int maxplay = 0, n = days.size(), k = days[0].size(); // n city , k weeks\\n        vector<vector<int>> dp(n, vector<int>(k, 0)); // dp[i][j] - max days play if you spent week j in city i;\\n        for (int j = k - 1; j >= 0; j--)\\n            for (int i = 0; i < n; i++) {\\n                dp[i][j] = days[i][j];\\n                for (int i1 = 0; i1 < n && j < k - 1; i1++)\\n                    if (flights[i][i1] || i == i1) dp[i][j] = max(dp[i][j], days[i][j] + dp[i1][j + 1]);\\n                if (j == 0 && (i == 0 || flights[0][i])) maxplay = max(maxplay, dp[i][0]);\\n            }\\n        return maxplay;\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int maxVacationDays(int[][] flights, int[][] days) {\\n        int maxplay = 0, n = days.length, k = days[0].length; // n city , k weeks\\n        int[][] dp = new int[n][k]; // dp[i][j] - max days play if you spent week j in city i;\\n        for (int j = k - 1; j >= 0; j--)\\n            for (int i = 0; i < n; i++) {\\n                dp[i][j] = days[i][j];\\n                for (int i1 = 0; i1 < n && j < k - 1; i1++)\\n                    if (flights[i][i1] > 0 || i == i1)\\n                        dp[i][j] = Math.max(dp[i][j], days[i][j] + dp[i1][j + 1]);\\n                if (j == 0 && (i == 0 || flights[0][i] > 0)) maxplay = Math.max(maxplay, dp[i][0]);\\n            }\\n        return maxplay;        \\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"102666",
			"view":"123",
			"top":"3",
			"title":"Short Java Recursion DFS + Memoization",
			"vote":"1",
			"content":"```\\n    int[][] mem;\\n    \\n    private int dfs(int[][] flights, int[][] days, int i, int k) {\\n        if(k==days[0].length)\\n            return 0;\\n        if(mem[i][k]>0)\\n            return mem[i][k];\\n        int maxVacations = 0;\\n        for(int n=0; n<flights[0].length; n++)\\n            if((n!=i && flights[i][n]==1) || n==i)\\n                maxVacations = Math.max(maxVacations, days[n][k] + dfs(flights, days, n, k+1));\\n        mem[i][k] = maxVacations;\\n        return maxVacations;\\n    }\\n    \\n    public int maxVacationDays(int[][] flights, int[][] days) {\\n        mem = new int[flights.length][days[0].length];\\n        return dfs(flights, days, 0, 0);\\n    }"
		},
		{
			"lc_ans_id":"102650",
			"view":"13",
			"top":"4",
			"title":"O(n* degree * k) DP Python solution (beats 100%)",
			"vote":"0",
			"content":"We can use directed graphs to think about this question. Cities are nodes, and `flights[i][j]` is an adjacency matrix that represents if a directed edge exists between `city i` and `city j`, while `days[i][k]` represents the edge weight of all edges with `city i` as the outgoing node at `week k`.\\n\\nThe idea is simple. We use `memo[i]` to store the maximum vacation days with a flight that ends in `city i` at the current week, and record -1 if a city is unreachable at the current week.\\n\\nInstead of iterating through `flights[j][i]` to find edges that lead to `city i`, we convert the adjacency matrix to an adjacency list `edgeSet[i]`. The running time complexity is then reduced to O(n * degree * k), where degree is the maximum number of incoming cities that is connected to one city.\\nOf course, in the worst case of a dense graph, where each city is connected to every city, the solution is still O(n^2 * k).\\n\\n```\\nclass Solution:\\n    def maxVacationDays(self, flights, days):\\n        \"\"\"\\n        :type flights: List[List[int]]\\n        :type days: List[List[int]]\\n        :rtype: int\\n     \\t\"\"\"\\n        nCities = len(flights)\\n\\n        if nCities == 0:\\n            return 0\\n        \\n        nWeeks = len(days[0])\\n\\n        # edgeSet[i] contains cities that have flights that travel to city i\\n        edgeSet = [ [] for i in range(nCities) ]\\n\\n        for i in range(nCities):\\n            # may stay in the same city\\n            flights[i][i] = 1\\n            for j in range(nCities):\\n                if flights[i][j] == 1:\\n                    edgeSet[j].append(i)\\n\\n        # memo[i] records the max vacation days you can have ending in city i\\n        # -1 means that the city is not reachable yet\\n        memo = [ -1 if flights[0][i] == 0 else days[i][0] for i in range(nCities)]\\n\\n        # compute for the rest of the weeks\\n        for week in range(1, nWeeks):\\n            newMemo = [-1 for i in range(nCities)]\\n            \\n            for i in range(nCities):\\n                vacDays = -1\\n                \\n                # get max vacation days of cities that can reach city i from the previous week\\n                for edge in edgeSet[i]:\\n                    vacDays = max(vacDays, memo[edge])\\n                if vacDays != -1:\\n                    newMemo[i] = vacDays + days[i][week]\\n\\n            memo = newMemo\\n\\n        return max(memo)\\n```"
		},
		{
			"lc_ans_id":"102651",
			"view":"24",
			"top":"5",
			"title":"Simple DP solution (java)",
			"vote":"0",
			"content":"class Solution {\\n    \\n      public int maxVacationDays(int[][] flights, int[][] days) {\\n        \\n        int N = flights.length;\\n        int K = days[0].length;\\n        \\n        int[][] counts = new int[N][N+1];\\n        \\n        for(int w = 1; w <= K; w++){\\n            for(int i = 0; i < N; i++){\\n                counts[i][w] = days[i][K-w] + counts[i][w-1];\\n                for(int j = 0; j < N; j++){\\n                    if(flights[i][j] == 1 && days[j][K-w] + counts[j][w-1] > counts[i][w]){\\n                        counts[i][w] = days[j][K-w] + counts[j][w-1];\\n                    }\\n                }\\n            }\\n        }\\n        return counts[0][K];\\n    }\\n}"
		},
		{
			"lc_ans_id":"102652",
			"view":"38",
			"top":"6",
			"title":"Java DP simple solution",
			"vote":"0",
			"content":"```\\nclass Solution {\\n    public int maxVacationDays(int[][] flights, int[][] days) {\\n        int K = days[1].length, N = flights.length;\\n        int[][] dp = new int[N][K + 1];\\n        for(int i = 1; i < N; ++i) dp[i][0] = -1;\\n        \\n        for(int k = 1; k <= K; ++k) {\\n            for(int i = 0; i < N; ++i) {\\n                boolean connected = false;\\n                for(int j = 0; j < N; ++j) {\\n                    if(flights[j][i] != 0 && dp[j][k - 1] != -1) { // i city can be reached from j city\\n                        connected = true;\\n                        dp[i][k] = Math.max(dp[j][k - 1] + days[i][k - 1], dp[i][k]);\\n                    }\\n                }\\n                if(dp[i][k - 1] != -1) dp[i][k] = Math.max(dp[i][k], dp[i][k - 1] + days[i][k - 1]); // i city in week k can be recheable from i city in week (k - 1)\\n                else if(!connected) dp[i][k] = -1; // i city in week k is not reachable\\n            }\\n        }\\n        int rst = 0;\\n        for(int i = 0; i < N; ++i) {\\n            rst = Math.max(rst, dp[i][K]);\\n        }\\n        return rst;\\n        \\n        \\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"102656",
			"view":"50",
			"top":"7",
			"title":"C++ 76ms solution beating 99.66% submissions with simple explanation",
			"vote":"0",
			"content":"class Solution {\\npublic:\\n\\n    //dp[i][j] = max # of days after arriving at city i at the start of week j\\n    //goal: max dp[i][0] among all k: k == 0 || flight[0][k]\\n    //dp[i][j] = max{dp[k][j+1] + days[i][j]} among all k: k == i || flight[i][k]\\n    //edge: dp[i][weeknum-1] = days[i][weeknum] /forall i\\n    int maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {\\n        int citynum = flights.size();\\n        int weeknum = days[0].size();\\n        vector<int> current(citynum, 0);\\n        vector<int> future(citynum, 0);\\n            \\n        vector<vector<int>> edges(citynum);\\n        for(int i = 0; i < citynum; i++){\\n            edges[i].push_back(i);\\n            for(int j = 0; j < citynum; j++)\\n                if(flights[i][j])\\n                    edges[i].push_back(j);\\n        }\\n        \\n        int week = weeknum - 1;\\n        //edges conditons\\n        for(int i = 0; i < citynum; i++)\\n            current[i] = days[i][week];\\n        \\n        for(week--; week >= 0; week--){\\n            for(int i = 0; i < citynum; i++){\\n                for(auto city : edges[i])\\n                    future[i] = max(future[i], days[i][week] + current[city]);\\n            }\\n            swap(current, future);\\n        }\\n        int maxdays = 0;\\n        for(auto city : edges[0]){\\n            maxdays = max(maxdays, current[city]);\\n        }\\n        return maxdays;\\n    }\\n};"
		},
		{
			"lc_ans_id":"102657",
			"view":"69",
			"top":"8",
			"title":"Java DFS with cache",
			"vote":"0",
			"content":"Easy understand DFS with cache. cache[k][i] is used for logging the maximum vacations of from kth week to Kth week and starting from city i.\\n\\n```\\npublic int maxVacationDays(int[][] flights, int[][] days) {\\n        int N = flights.length, K = days[0].length;\\n        int[][] cache = new int[K][N];\\n        for(int i=0; i<K; i++){\\n            Arrays.fill(cache[i], -1);\\n        }\\n        return DFS(flights, days, 0, 0, cache);\\n    }\\n    \\n    private int DFS(int[][] flights, int[][] days, int k, int i, int[][] cache){\\n        int N = flights.length, K = days[0].length;\\n        if(k==K) return 0;\\n        if(cache[k][i]>=0) return cache[k][i];\\n        int max = 0;\\n        for(int j=0; j<N; j++){\\n            if(i==j || flights[i][j]==1){\\n                int temp = DFS(flights, days, k+1, j, cache)+days[j][k];\\n                max = Math.max(max, temp);\\n            }\\n        }\\n        cache[k][i] = max;\\n        return max;\\n    }"
		},
		{
			"lc_ans_id":"102658",
			"view":"82",
			"top":"9",
			"title":"It is Viterbi Algorithm",
			"vote":"0",
			"content":"For those who are interested, it is a widely used algorithm in latent models, e.g. Hidden Markov Model. \\n\\nCheck it out: https://en.wikipedia.org/wiki/Viterbi_algorithm"
		}
	],
	"id":"549",
	"title":"Maximum Vacation Days",
	"content":"<p>\r\nLeetCode wants to give one of its best employees the option to travel among <b>N</b> cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow.\r\n</p>\r\n\r\n<p><b>Rules and restrictions:</b><br>\r\n<ol>\r\n<li>You can only travel among <b>N</b> cities, represented by indexes from 0 to N-1. Initially, you are in the city indexed 0 on <b>Monday</b>.</li>\r\n<li>The cities are connected by flights. The flights are represented as a <b>N*N</b> matrix (not necessary symmetrical), called <b>flights</b> representing the airline status from the city i to the city j. If there is no flight from the city i to the city j, <b>flights[i][j] = 0</b>; Otherwise, <b>flights[i][j] = 1</b>. Also, <b>flights[i][i] = 0</b> for all i.</li>\r\n<li>You totally have <b>K</b> weeks (<b>each week has 7 days</b>) to travel. You can only take flights at most once <b>per day</b> and can only take flights on each week's <b>Monday</b> morning. Since flight time is so short, we don't consider the impact of flight time.</li>\r\n<li>For each city, you can only have restricted vacation days in different weeks, given an <b>N*K</b> matrix called <b>days</b> representing this relationship. For the value of <b>days[i][j]</b>, it represents the maximum days you could take vacation in the city <b>i</b> in the week <b>j</b>.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>You're given the <b>flights</b> matrix and <b>days</b> matrix, and you need to output the maximum vacation days you could take during <b>K</b> weeks.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]]\r\n<b>Output:</b> 12\r\n<b>Explanation:</b> <br>Ans = 6 + 3 + 3 = 12. <br>\r\nOne of the best strategies is:\r\n1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day. <br/>(Although you start at city 0, we could also fly to and start at other cities since it is Monday.) \r\n2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.\r\n3rd week : stay at city 2, and play 3 days and work 4 days.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b>flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]]\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> <br>Ans = 1 + 1 + 1 = 3. <br>\r\nSince there is no flights enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. <br/>For each week, you only have one day to play and six days to work. <br/>So the maximum number of vacation days is 3.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b>flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]]\r\n<b>Output:</b> 21\r\n<b>Explanation:</b><br>Ans = 7 + 7 + 7 = 21<br>\r\nOne of the best strategies is:\r\n1st week : stay at city 0, and play 7 days. \r\n2nd week : fly from city 0 to city 1 on Monday, and play 7 days.\r\n3rd week : fly from city 1 to city 2 on Monday, and play 7 days.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><b>N and K</b> are positive integers, which are in the range of [1, 100].</li>\r\n<li>In the matrix <b>flights</b>, all the values are integers in the range of [0, 1].</li>\r\n<li>In the matrix <b>days</b>, all the values are integers in the range [0, 7].</li>\r\n<li>You could stay at a city beyond the number of vacation days, but you should <b>work</b> on the extra days, which won't be counted as vacation days.</li>\r\n<li>If you fly from the city A to the city B and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city B in that week.</li>\r\n<li>We don't consider the impact of flight hours towards the calculation of vacation days.</li>\r\n</ol>\r\n</p>",
	"frequency":"45",
	"ac_num":"5978"
}