{
	"difficulty":"1",
	"submit_num":"93796",
	"show_id":"581",
	"leetcode_id":"581",
	"answers":[
		{
			"lc_ans_id":"103057",
			"view":"17853",
			"top":"0",
			"title":"Java O(n) Time O(1) Space",
			"vote":"106",
			"content":"I use the variables `beg` and `end` to keep track of minimum subarray `A[beg...end]` which must be sorted for the entire array `A` to be sorted. If  `end < beg < 0` at the end of the `for` loop, then the array is already fully sorted.\\n\\n```\\npublic int findUnsortedSubarray(int[] A) {\\n    int n = A.length, beg = -1, end = -2, min = A[n-1], max = A[0];\\n    for (int i=1;i<n;i++) {\\n      max = Math.max(max, A[i]);\\n      min = Math.min(min, A[n-1-i]);\\n      if (A[i] < max) end = i;\\n      if (A[n-1-i] > min) beg = n-1-i; \\n    }\\n    return end - beg + 1;\\n}\\n```"
		},
		{
			"lc_ans_id":"103066",
			"view":"3736",
			"top":"1",
			"title":"Ideas behind the O(n) two-pass and one-pass solutions",
			"vote":"40",
			"content":"Well, you've probably already seen the O(n) solution [here](https://discuss.leetcode.com/topic/89282/java-o-n-time-o-1-space). If you've ever wondered how it is done, here is a detailed explanation. It will begin with the naive `O(nlogn)` solution by **sorting**, then transition to the `O(n)` **two-pass** solution and eventually the `O(n)` **one-pass** solution.\\n\\n---\\n**`I -- Naive solution by sorting`**\\n\\nThe original problem is asking for the shortest subarray that needs to be sorted in order to make the whole input array sorted. Assume `nums` is the input array with length `n`,  `nums_sorted` is the sorted version of `nums`, `nums[i, j]`(both indices inclusive) is such a subarray of the shortest length. Since we only need to sort `nums[i, j]` in order to transform `nums` into `nums_sorted`, all other elements in `nums` are left intact, which means the subarray `nums[0, i - 1]`  will be exactly the same as subarray `nums_sorted[0, i - 1]`, and the subarray `nums[j + 1, n - 1]` exactly the same as `nums_sorted[j + 1, n - 1]`. We can also conclude `nums[i] != nums_sorted[i]` and `nums[j] != nums_sorted[j]`. Otherwise the subarray `nums[i, j]` will not be the shortest (for example, if `nums[i] == nums_sorted[i]`, sorting `nums[i + 1, j]` will also render `nums` sorted).\\n\\nTherefore, the shortest subarray can be constructed as follows: its leftmost index can be obtained by finding the **first** index at which the two elements of `nums` and `nums_sorted` are different while its rightmost index can be obtained by finding the **last** such index.\\n\\nThe straightforward way for finding the two boundary indices would be comparing elements from `nums` and `nums_sorted` one by one. But we need to construct `nums_sorted` from `nums` first. This is the following `O(nlogn)` time and `O(n)` space solution:\\n\\n```\\npublic int findUnsortedSubarray(int[] nums) {\\n    int[] nums_sorted = Arrays.copyOf(nums, nums.length);\\n    Arrays.sort(nums_sorted);\\n        \\n    int i = 0, j = nums.length - 1;\\n        \\n    while (i < nums.length && nums[i] == nums_sorted[i]) i++;\\n    while (i < j && nums[j] == nums_sorted[j]) j--;\\n        \\n    return j - i + 1;\\n}\\n```\\n\\n---\\n**`II -- O(n) time two-pass solution`**\\n\\nIt turns out that the two boundary indices `i` and `j` can be found in linear time, if we take advantage of the following three properties:\\n\\n1. `nums[0, i - 1]` and `nums[j + 1, n - 1]` are both sorted.\\n\\n2. `nums[i] != nums_sorted[i]` and `nums[j] != nums_sorted[j]`.\\n\\n3. `nums[i - 1] <= min` and `max <= nums[j + 1]`, where `min` and `max` are the minimum and maximum values of subarray `nums[i, j]`.\\n\\nThe first and third properties guarantee that the subarray `nums[0, i - 1]`  will be exactly the same as subarray `nums_sorted[0, i - 1]`, and the subarray `nums[j + 1, n - 1]` exactly the same as `nums_sorted[j + 1, n - 1]`, while the second property ensures that `i` will be the **first** index at which the two elements of `nums` and `nums_sorted` are different and `j` be the **last** such index.\\n\\nSince we aim at the shortest subarrays, from the first property alone, we need to find the two longest sorted subarrays starting at index `0` and ending at index `n - 1`, respectively. Assume the two subarrays are `nums[0, l]` and `nums[r, n - 1]`. If there is overlapping between these two subarrays, i.e.`l >= r`, then the whole array is sorted so `0` will be returned. Otherwise, the input array is not sorted. However, we cannot say sorting `nums[l, r]` will leave the whole array sorted, because at this moment the third property may not be satisfied.\\n\\nTo guarantee the third property, assume `min` and `max` are the minimum and maximum values of subarray `nums[l, r]`, then we need to decrease `l` as long as `nums[l] > min`, and increase `r` as long as `nums[r] < max`. After this is done, it can be shown that the second property will be met automatically, and `nums[l + 1, r - 1]` will be the shortest subarray we are looking for (that is, `i = l + 1` and `j = r - 1`).\\n\\nFinding the longest subarrays and the maximum and minimum values of the middle subarray takes one-pass. Ensuring the third property requires a second pass. Therefore we have this two-pass solution:\\n\\n```\\npublic int findUnsortedSubarray(int[] nums) {\\n    int l = 0, r = nums.length - 1, max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        \\n    while (l < r && nums[l] <= nums[l + 1]) l++;\\n        \\n    if (l >= r) return 0;\\n        \\n    while (nums[r] >= nums[r - 1]) r--;\\n    \\n    for (int k = l; k <= r; k++) {\\n        max = Math.max(max, nums[k]);\\n        min = Math.min(min, nums[k]);\\n    }\\n    \\n    while (l >= 0 && min < nums[l]) l--;\\n    while (r < nums.length && nums[r] < max) r++;\\n        \\n    return (r - l - 1);\\n}\\n```\\n\\n---\\n**`III -- O(n) time one-pass solution`**\\n\\nTo understand this one-pass solution, we need to introduce some equivalent mathematical models for describing a sorted array (assuming in ascending order). Suppose the given array is `nums` with length `n`, these models are as follows:\\n1. `nums[k] <= nums[k + 1]` for all `0 <= k < n - 1`.\\n\\n2. `nums[k] == max[k]` for all `0 <= k <= n - 1`, where `max[k]` is the maximum value of subarray `nums[0, k]`.\\n\\n3. `nums[k] == min[k]` for all `0 <= k <= n - 1`, where `min[k]` is the minimum value of subarray `nums[k, n - 1]`.\\n\\nThe first model is the most common one (and probably the most familiar one) while the last two are less common. It's easy to show that the second model is equivalent to the first by noting that for any index `k < n - 1`, we have `max[k] <= max[k + 1]`, then `nums[k] = max[k] <= max[k + 1] = nums[k + 1]`. Similar results hold for the third model: `nums[k] = min[k] <= min[k + 1] = nums[k + 1]`.\\n\\nWith these models in place, we can show that if indices `i` and `j` satisfy the following conditions, then `nums[i, j]` will be the shortest subarray we are looking for:\\n\\n1. `i` is the **smallest** index such that `nums[i] != min[i]`;\\n2. `j` is the **largest** index such that `nums[j] != max[j]`.\\n\\nThe proof proceeds by showing that the two conditions above are equivalent to the three properties in part **`II`**.\\n\\nFirstly we will show that the first property in part **`II`** is held true. From condition `1`, we have `nums[k] == min[k]` for all `0 <= k < i`. Then `nums[k] = min[k] <= min[k + 1] = nums[k + 1]` for all `k < i - 1`. By definition, `nums[0, i - 1]` is sorted. Similarly from condition `2`, `nums[k] == max[k]` for all `j < k <= n - 1`. Then `nums[k] = max[k] <= max[k + 1] = nums[k + 1]` for all `j < k < n - 1`. By definition, `nums[j + 1, n - 1]` is sorted.\\n\\nThen we will show the third property is satisfied. Let `min_m` and `max_m` be the minimum and maximum values of subarray `nums[i, j]`, respectively, then we have `min_m >= min[i] >= min[i - 1] = nums[i - 1]` and `max_m <= max[j] <= max[j + 1] = nums[j + 1]`.\\n\\nLastly we will show that the second property is also valid. Note that if the first and third properties are both true, then we know the subarray `nums[0, i - 1]`  will be exactly the same as subarray `nums_sorted[0, i - 1]`, and the subarray `nums[j + 1, n - 1]` exactly the same as `nums_sorted[j + 1, n - 1]`. In this case just suppose we have `nums[i] == nums_sorted[i]` and `nums[j] == nums_sorted[j]`, let's see what will happen. Since the subarrays `nums[i, n -\\n 1]` and `nums_sorted[i, n - 1]` contain exactly the same elements (though the order may be different), then the minimum element of the former will be the same as the latter. Since `nums_sorted[i, n - 1]` is sorted in ascending order, we will have `min[i] = nums_sorted[i] = nums[i]`, which contradicts the assumption that `nums[i] != min[i]`. Similarly we can show that `nums[j] == nums_sorted[j]` implies `nums[j] == max[j]`, which contradicts the assumption that `nums[j] != max[j]`.\\n\\nFinding the smallest index `i` such that `nums[i] != min[i]` and the largest index `j` such that `nums[j] != max[j]` can be done in one-pass, as shown below. Note that we don't really need arrays to hold values for `min[r]` and `max[l]`, by taking advantage of the recurrence relation `min[r] = Math.min(min[r + 1], nums[r])` and `max[l] = Math.max(max[l - 1], nums[l])`. Also we initialized the indices `i` and `j` such that correct results will be returned even if the input array is already sorted (which requires initially `j - i + 1 = 0`).\\n\\n```\\npublic int findUnsortedSubarray(int[] nums) {\\n    int i = 0, j = -1, max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n    \\n    for (int l = 0, r = nums.length - 1; r >= 0; l++, r--) {\\n        max = Math.max(max, nums[l]);\\n        if (nums[l] != max) j = l;\\n        \\n        min = Math.min(min, nums[r]);\\n        if (nums[r] != min) i = r;\\n    }\\n    \\n    return (j - i + 1);\\n}\\n```"
		},
		{
			"lc_ans_id":"103070",
			"view":"5934",
			"top":"2",
			"title":"Java Solution, Sort.",
			"vote":"31",
			"content":"```\\npublic class Solution {\\n    public int findUnsortedSubarray(int[] nums) {\\n        int n = nums.length;\\n        int[] temp = nums.clone();\\n        Arrays.sort(temp);\\n        \\n        int start = 0;\\n        while (start < n  && nums[start] == temp[start]) start++;\\n        \\n        int end = n - 1;\\n        while (end > start  && nums[end] == temp[end]) end--;\\n        \\n        return end - start + 1;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"103052",
			"view":"3536",
			"top":"3",
			"title":"Python 2 lines easy understand solution",
			"vote":"14",
			"content":"Sort the list and check if it's still the same number in the list.\\n``````\\ndef findUnsortedSubarray(self, nums):\\n        is_same = [a == b for a, b in zip(nums, sorted(nums))]\\n        return 0 if all(is_same) else len(nums) - is_same.index(False) - is_same[::-1].index(False)"
		},
		{
			"lc_ans_id":"103081",
			"view":"4290",
			"top":"4",
			"title":"C++ O(n) solution",
			"vote":"9",
			"content":"```\\n   int findUnsortedSubarray(vector<int>& nums) {\\n        int shortest = 0;\\n        \\n        int left = 0, right = nums.size() - 1;\\n        while (left < nums.size() - 1 && nums[left] <= nums[left + 1]) { left++; }\\n        while (right > 0 && nums[right] >= nums[right - 1]) { right--; };\\n        \\n        if (right > left) {\\n            int vmin = INT_MAX, vmax = INT_MIN;\\n            for (int i = left; i <= right; ++i) {\\n                if (nums[i] > vmax) {\\n                    vmax = nums[i];\\n                }\\n                if (nums[i] < vmin) {\\n                    vmin = nums[i];\\n                }\\n            }\\n            \\n            while (left >= 0 && nums[left] > vmin) { left--; };\\n            while (right < nums.size() && nums[right] < vmax) { right++; };\\n            \\n            shortest = right - left - 1;\\n        }\\n        \\n        return shortest;\\n    }\\n```"
		},
		{
			"lc_ans_id":"103102",
			"view":"797",
			"top":"5",
			"title":"c++ O(n) one-pass solution which beats almost",
			"vote":"6",
			"content":"The idea is use variables `begin` and  `end` to record the beginning and ending of the unsorted array.\\n```\\n    int findUnsortedSubarray(vector<int>& nums) {\\n        int start = -1, end = -1,  max = INT_MIN;\\n        for(int i=0; i<nums.size();i++){\\n            if(max>nums[i]){\\n                if(start == -1)start = i-1;\\n                while(start-1>=0 && nums[start-1]>nums[i])start--;\\n                end = i+1;\\n            }\\n            else max = nums[i];\\n        }\\n        return end - start;   \\n    }\\n```\\n\\nFirstly, if the array is already a sorted array, then it means `nums[i]` is not less than any `nums[j]` for all  0<=j<i. Therefore, the value of `start` and `end` will never change. So the program returns 0 finally.\\n\\nNow, let's consider the case of the unsorted array. We use  [1, 3, 3, 2, 8, 10, 0, 15] as the example. We use `max` to record the largest value we visited. If it's a sorted array, then `max` should be equal to the last element we visited. We only update `start` and `end` when `max` is less then the next element we visit. The process is as follows: \\n     \\nWhen i =0, max = nums[0] = 1;\\n\\nWhen i=1, max = nums[1] = 3;\\n\\nWhen i=2, max = nums[1] = 3;\\n\\nWhen i =3, we find that max < nums[3], then it means that we find  a unsorted subarray. Since `start ==-1`, so we know it is the beginning of the unsorted  subarray, then update `start = i-1=2` and `end =i+1 = 4` (actually `end -1` should be the end of the unsorted subarray, but we use `end -start` to count the length of the unsorted subarray so we let `end =i+1`). Because, there might be duplicates in the array (like nums[1] = nums[2] = 3), we need to go back to check whether `nums[start-1] == nums[start]`. Then we update `start = 1`.\\n\\nWhen i =4, max = nums[4] = 8.\\n\\nWhen i =5, max = nums[5] = 10.\\n\\nWhen i =6, we find that max < nums[6]. So we update   `end =i+1 = 7` . Now we need to update `start`, since `start` does not equal to `-1` which means that we already have a start. So what need to do is to update `start` so that `nums[start] < =nums[i]` or we arrive the beginning of the array. Finally we update `start = 0` here.\\nwhen i =7,  max = nums[7] = 15.\\n\\nFinally we return `end - start` which is 7-0=7."
		},
		{
			"lc_ans_id":"103056",
			"view":"873",
			"top":"6",
			"title":"Python runs slow but with time O(n) space O(1)",
			"vote":"5",
			"content":"```\\nclass Solution(object):\\n    def findUnsortedSubarray(self, nums):\\n        nums = [float('-inf')] + nums + [float('inf')]\\n        '''find left boundary'''\\n        left = 0\\n        while left<len(nums)-1 and nums[left]<=nums[left+1]:\\n            left += 1\\n        # return 0 if already sorted ascending\\n        if left == len(nums)-1:\\n            return 0\\n        min_num = min(nums[left+1:])\\n        while nums[left] > min_num:\\n            left -= 1\\n        '''find right boundary'''\\n        right = len(nums)-1\\n        while right>0 and nums[right-1]<=nums[right]:\\n            right -= 1\\n        # return 0 if sorted descending\\n        if right == 0:\\n            return 0\\n        max_num = max(nums[:right])\\n        while nums[right] < max_num:\\n            right += 1\\n        return right - left - 1\\n```"
		},
		{
			"lc_ans_id":"103062",
			"view":"1842",
			"top":"7",
			"title":"[C++] Clean Code 2 Solution - Sort O(NlgN) & max min vectors O(N)",
			"vote":"5",
			"content":"**Sort**\\n```\\nclass Solution {\\npublic:\\n    int findUnsortedSubarray(vector<int>& nums) {\\n        vector<int> sorted(nums);\\n        sort(sorted.begin(), sorted.end());\\n        int n = nums.size(), i = 0, j = n - 1;\\n        while (i < n && nums[i] == sorted[i]) {\\n            i++;\\n        }\\n        while (j > i && nums[j] == sorted[j]) {\\n            j--;\\n        }\\n        return j + 1 - i;\\n    }\\n};\\n```\\n**max on left, min on right - O(N)**\\nThe idea is that:\\n1. From the left, for a number to stay untouched, there need to be no number less than it on the right hand side;\\n2. From the  right, for a number to stay untouched, there need to be no number greater than it on the left hand side;\\n\\nThose 2 can be easily checked if we build 2 vectors: \\n1.  max so far from the left, \\n2.  and min so far from the right;\\n\\n\\n```\\n/**\\n *            /------------\\\\\\n * nums:  [2, 6, 4, 8, 10, 9, 15]\\n * minr:   2  4  4  8   9  9  15\\n *         <--------------------\\n * maxl:   2  6  6  8  10 10  15\\n *         -------------------->\\n */\\nclass Solution {\\npublic:\\n    int findUnsortedSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> maxlhs(n);   // max number from left to cur\\n        vector<int> minrhs(n);   // min number from right to cur\\n        for (int i = n - 1, minr = INT_MAX; i >= 0; i--) minrhs[i] = minr = min(minr, nums[i]);\\n        for (int i = 0,     maxl = INT_MIN; i < n;  i++) maxlhs[i] = maxl = max(maxl, nums[i]);\\n\\n        int i = 0, j = n - 1;\\n        while (i < n && nums[i] <= minrhs[i]) i++;\\n        while (j > i && nums[j] >= maxlhs[j]) j--;\\n\\n        return j + 1 - i;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"103103",
			"view":"625",
			"top":"8",
			"title":"Java Sort Solution, easy to understand",
			"vote":"2",
			"content":"```\\npublic class Solution {\\n        public int findUnsortedSubarray(int[] nums) {\\n            int begin  = nums.length - 1;\\n            int end = nums.length - 1;\\n\\n            int[] sorted = nums.clone();\\n            Arrays.sort(sorted);\\n\\n            for(int i = 0; i < nums.length; i++){\\n                if(sorted[i] != nums[i]){\\n                    begin = i;\\n                    break;\\n                }\\n            }\\n            for(int i = nums.length - 1; i > begin; i--){\\n                if(sorted[i] != nums[i]){\\n                    end = i;\\n                    break;\\n                }\\n            }\\n\\n            return (end==begin)?0:(end-begin+1);\\n        }\\n}\\n```"
		},
		{
			"lc_ans_id":"103071",
			"view":"703",
			"top":"9",
			"title":"4 lines Python via sorting",
			"vote":"2",
			"content":"Since length of the array won't exceed 10000, O(nlogn) sorting is good enough.\\n```\\nclass Solution(object):\\n    def findUnsortedSubarray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n, sorts = len(nums), sorted(nums)\\n        if nums == sorts: return 0\\n        l, r = min(i for i in range(n) if nums[i] != sorts[i]), max(i for i in range(n) if nums[i] != sorts[i])\\n        return r - l + 1\\n```"
		}
	],
	"id":"562",
	"title":"Shortest Unsorted Continuous Subarray",
	"content":"<p>Given an integer array, you need to find one <b>continuous subarray</b> that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. </p> \r\n\r\n<p>You need to find the <b>shortest</b> such subarray and output its length.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [2, 6, 4, 8, 10, 9, 15]\r\n<b>Output:</b> 5\r\n<b>Explanation:</b> You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>Then length of the input array is in range [1, 10,000].</li>\r\n<li>The input array may contain duplicates, so ascending order here means <b><=</b>. </li>\r\n</ol>\r\n</p>",
	"frequency":"192",
	"ac_num":"27412"
}