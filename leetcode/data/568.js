{
	"difficulty":"3",
	"submit_num":"11455",
	"show_id":"587",
	"leetcode_id":"587",
	"answers":[
		{
			"lc_ans_id":"103299",
			"view":"5362",
			"top":"0",
			"title":"Java Solution, Convex Hull Algorithm - Gift wrapping aka Jarvis march",
			"vote":"17",
			"content":"There are couple of ways to solve Convex Hull problem. https://en.wikipedia.org/wiki/Convex_hull_algorithms\\nThe following code implements ```Gift wrapping aka Jarvis march``` algorithm https://en.wikipedia.org/wiki/Gift_wrapping_algorithm and also added logic to handle case of ```multiple Points in a line``` because original Jarvis march algorithm assumes ```no three points are collinear```.\\nIt also uses knowledge in this problem https://leetcode.com/problems/convex-polygon . Disscussion: https://discuss.leetcode.com/topic/70706/beyond-my-knowledge-java-solution-with-in-line-explanation\\n```\\npublic class Solution {\\n    public List<Point> outerTrees(Point[] points) {\\n        Set<Point> result = new HashSet<>();\\n        \\n        // Find the leftmost point\\n        Point first = points[0];\\n        int firstIndex = 0;\\n        for (int i = 1; i < points.length; i++) {\\n            if (points[i].x < first.x) {\\n                first = points[i];\\n                firstIndex = i;\\n            }\\n        }\\n        result.add(first);\\n        \\n        Point cur = first;\\n        int curIndex = firstIndex;\\n        do {\\n            Point next = points[0];\\n            int nextIndex = 0;\\n            for (int i = 1; i < points.length; i++) {\\n                if (i == curIndex) continue;\\n                int cross = crossProductLength(cur, points[i], next);\\n                if (nextIndex == curIndex || cross > 0 ||\\n                        // Handle collinear points\\n                        (cross == 0 && distance(points[i], cur) > distance(next, cur))) {\\n                    next = points[i];\\n                    nextIndex = i;\\n                }\\n            }\\n            // Handle collinear points\\n            for (int i = 0; i < points.length; i++) {\\n                if (i == curIndex) continue;\\n                int cross = crossProductLength(cur, points[i], next);\\n                if (cross == 0) {\\n                    result.add(points[i]);\\n                }\\n            }\\n\\n            cur = next;\\n            curIndex = nextIndex;\\n            \\n        } while (curIndex != firstIndex);\\n        \\n        return new ArrayList<Point>(result);\\n    }\\n    \\n    private int crossProductLength(Point A, Point B, Point C) {\\n        // Get the vectors' coordinates.\\n        int BAx = A.x - B.x;\\n        int BAy = A.y - B.y;\\n        int BCx = C.x - B.x;\\n        int BCy = C.y - B.y;\\n    \\n        // Calculate the Z coordinate of the cross product.\\n        return (BAx * BCy - BAy * BCx);\\n    }\\n\\n    private int distance(Point p1, Point p2) {\\n        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"103302",
			"view":"1885",
			"top":"1",
			"title":"Java Graham scan with adapted sorting to deal with collinear points",
			"vote":"12",
			"content":"The trick is that once all points are sorted by polar angle with respect to the reference point:\\n* For collinear points in the begin positions, make sure they are sorted by distance to reference point in **ascending** order.\\n* For collinear points in the end positions, make sure they are sorted by distance to reference point in **descending** order.\\n\\nFor example:\\n```(0, 0), (2, 0), (3, 0), (3, 1), (3, 2), (2, 2), (1, 2), (0, 2), (0, 1)```\\nThese points are sorted by polar angle\\nThe reference point (bottom left point) is ```(0, 0)```\\n* In the begin positions ```(0, 0)``` collinear with ```(2, 0), (3, 0)``` sorted by distance to reference point in **ascending** order.\\n* In the end positions ```(0, 0)``` collinear with ```(0, 2), (0, 1)``` sorted by distance to reference point in **descending** order.\\n\\nNow we can run the standard Graham scan to give us the desired result.\\n```\\npublic class Solution {\\n\\n    public List<Point> outerTrees(Point[] points) {\\n        if (points.length <= 1)\\n            return Arrays.asList(points);\\n        sortByPolar(points, bottomLeft(points));\\n        Stack<Point> stack = new Stack<>(); \\n        stack.push(points[0]);                      \\n        stack.push(points[1]);                              \\n        for (int i = 2; i < points.length; i++) {\\n            Point top = stack.pop();                                \\n            while (ccw(stack.peek(), top, points[i]) < 0)\\n                top = stack.pop();\\n            stack.push(top);\\n            stack.push(points[i]);\\n        }       \\n        return new ArrayList<>(stack);\\n    }                               \\n\\n    private static Point bottomLeft(Point[] points) {\\n        Point bottomLeft = points[0];\\n        for (Point p : points)          \\n            if (p.y < bottomLeft.y || p.y == bottomLeft.y && p.x < bottomLeft.x)\\n                bottomLeft = p;                 \\n        return bottomLeft;                                                  \\n    }\\n\\n    /**\\n     * @return positive if counter-clockwise, negative if clockwise, 0 if collinear\\n     */\\n    private static int ccw(Point a, Point b, Point c) {\\n        return a.x * b.y - a.y * b.x + b.x * c.y - b.y * c.x + c.x * a.y - c.y * a.x;       \\n    }\\n\\n    /**\\n     * @return distance square of |p - q|\\n     */\\n    private static int dist(Point p, Point q) {\\n        return (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\\n    }\\n                              \\n    private static void sortByPolar(Point[] points, Point r) {\\n        Arrays.sort(points, (p, q) -> {\\n            int compPolar = ccw(p, r, q);\\n            int compDist = dist(p, r) - dist(q, r); \\n            return compPolar == 0 ? compDist : compPolar;\\n        });     \\n        // find collinear points in the end positions\\n        Point p = points[0], q = points[points.length - 1];\\n        int i = points.length - 2;\\n        while (i >= 0 && ccw(p, q, points[i]) == 0)\\n            i--;    \\n        // reverse sort order of collinear points in the end positions\\n        for (int l = i + 1, h = points.length - 1; l < h; l++, h--) {\\n            Point tmp = points[l];\\n            points[l] = points[h];\\n            points[h] = tmp;\\n        }\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"103306",
			"view":"1649",
			"top":"2",
			"title":"C++ and Python easy wiki solution",
			"vote":"9",
			"content":"C++ version:\\n`````\\n// Ref: http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull.cpp\\nclass Solution {\\n public:\\n  typedef int coord_t;  // coordinate type\\n  typedef long long coord2_t;  // must be big enough to hold 2*max(|coordinate|)^2\\n  // 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross\\n  // product. Returns a positive value, if OAB makes a counter-clockwise turn,\\n  // negative for clockwise turn, and zero if the points are collinear.\\n  coord2_t cross(const Point &O, const Point &A, const Point &B) {\\n    return (A.x - O.x) * (coord2_t)(B.y - O.y) -\\n           (A.y - O.y) * (coord2_t)(B.x - O.x);\\n  }\\n\\n  static bool cmp(Point &p1, Point &p2) {\\n    return p1.x < p2.x || (p1.x == p2.x && p1.y < p2.y);\\n  }\\n\\n  static bool equ(Point &p1, Point &p2) { return p1.x == p2.x && p1.y == p2.y; }\\n  // Returns a list of points on the convex hull in counter-clockwise order.\\n  // Note: the last point in the returned list is the same as the first one.\\n  vector<Point> outerTrees(vector<Point> &P) {\\n    int n = P.size(), k = 0;\\n    vector<Point> H(2 * n);\\n\\n    // Sort points lexicographically\\n    sort(P.begin(), P.end(), cmp);\\n\\n    // Build lower hull\\n    for (int i = 0; i < n; i++) {\\n      while (k >= 2 && cross(H[k - 2], H[k - 1], P[i]) < 0) k--;\\n      H[k++] = P[i];\\n    }\\n\\n    // Build upper hull\\n    for (int i = n - 2, t = k + 1; i >= 0; i--) {\\n      while (k >= t && cross(H[k - 2], H[k - 1], P[i]) < 0) k--;\\n      H[k++] = P[i];\\n    }\\n\\n    // Remove duplicates\\n    H.resize(k);\\n    sort(H.begin(), H.end(), cmp);\\n    H.erase(unique(H.begin(), H.end(), equ), H.end());\\n    return H;\\n  }\\n};\\n`````\\n\\nPython version:\\n````\\n# http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull.py\\n\\n\\nclass Solution(object):\\n\\n    def outerTrees(self, points):\\n        \"\"\"Computes the convex hull of a set of 2D points.\\n\\n        Input: an iterable sequence of (x, y) pairs representing the points.\\n        Output: a list of vertices of the convex hull in counter-clockwise order,\\n          starting from the vertex with the lexicographically smallest coordinates.\\n        Implements Andrew's monotone chain algorithm. O(n log n) complexity.\\n        \"\"\"\\n\\n        # Sort the points lexicographically (tuples are compared lexicographically).\\n        # Remove duplicates to detect the case we have just one unique point.\\n        # points = sorted(set(points))\\n        points = sorted(points, key=lambda p: (p.x, p.y))\\n\\n        # Boring case: no points or a single point, possibly repeated multiple times.\\n        if len(points) <= 1:\\n            return points\\n\\n        # 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.\\n        # Returns a positive value, if OAB makes a counter-clockwise turn,\\n        # negative for clockwise turn, and zero if the points are collinear.\\n        def cross(o, a, b):\\n            # return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\\n            return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)\\n\\n        # Build lower hull\\n        lower = []\\n        for p in points:\\n            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0:\\n                lower.pop()\\n            lower.append(p)\\n\\n        # Build upper hull\\n        upper = []\\n        for p in reversed(points):\\n            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) < 0:\\n                upper.pop()\\n            upper.append(p)\\n\\n        # Concatenation of the lower and upper hulls gives the convex hull.\\n        # Last point of each list is omitted because it is repeated at the\\n        # beginning of the other list.\\n        # return lower[:-1] + upper[:-1]\\n        return list(set(lower[:-1] + upper[:-1]))\\n````"
		},
		{
			"lc_ans_id":"103320",
			"view":"1371",
			"top":"3",
			"title":"Python, AM Chain with Explanation",
			"vote":"8",
			"content":"Based on the formula for the signed area of a triangle, we can find whether a triangle PQR has vertices which are counter-clockwise (sign 1), collinear (sign 0), or clockwise (sign -1).\\n\\nWe will now perform the AM-Chain algorithm for finding the lower and upper hulls which together form the convex hull of these points.\\n\\nTo find the lower hull of points, we process the points in sorted order.  Focus on the function ```drive```.  Our loop invariant is that we started the function ```drive``` with a lower hull, and we return a lower hull.  This answer must include the new right-most point ```r``` as it cannot be contained by some points below it.  During the while loop, whenever our last turn XYZ was clockwise, the middle point Y cannot be part of the lower hull, as it is contained by WXZ (where W is the point in the hull before X.)\\n\\nWe can do this process again with the points sorted in reverse to find the upper hull.  Both hulls combined is the total convex hull as desired.\\n```\\ndef outerTrees(self, A):\\n    def sign(p, q, r):\\n        return cmp((p.x - r.x)*(q.y - r.y), (p.y - r.y)*(q.x - r.x))\\n    \\n    def drive(hull, r):\\n        hull.append(r)\\n        while len(hull) >= 3 and sign(*hull[-3:]) < 0:\\n            hull.pop(-2)\\n        return hull\\n    \\n    A.sort(key = lambda p: (p.x, p.y))\\n    lower = reduce(drive, A, [])\\n    upper = reduce(drive, A[::-1], [])\\n    return list(set(lower + upper))\\n```"
		},
		{
			"lc_ans_id":"103300",
			"view":"431",
			"top":"4",
			"title":"Detailed explanation of Graham scan in 14 lines (Python)",
			"vote":"4",
			"content":"Graham scan is an O(n log n) algorithm to find the convex hull of a set of points, which is exactly what this problem entails.  The idea is to start at one extreme point in the set (I chose the bottom most point on the left edge) and sweep in a circle.  Going counterclockwise is convenient due to the convention in trigonometry that polar angles in the unit circle increase as you move counterclockwise with respect to the positive x-axis, but this algorithm could potentially be performed sweeping clockwise as well.  As you perform this sweep, add the encountered points to the solution set.  After each addition check the last three points in the solution set.  If these points rotate in a direction opposite of the direct of your sweep, you know that the second to last point cannot be correct (assuming there are more than 3 points in your solution set).  What does it mean for points to rotate?  Imagine yourself starting at the first point, walking directly to the second point, and then directly to the third point.  The rotation of the points is the rotation you had to make at point 2 in order to face point 3.  It is easy to intuit that if you are walking a giant counterclockwise circle around the boundary of the points, then turning clockwise at any point puts you inside the absolute outside boundary (i.e. inside the convex hull).\\n\\nThere are two details to be sorted out:\\n\\n* How do we know what direction the last three points turn in?  Let's call them `p1`,`p2`, and `p3` in order of their appearance in the solution set.  Let the vector from `p1` to `p2` be `v1`; from `p2` to `p3`, be `v2`.  The cross product of `v1` and `v2` give the direction that points turn in.  If the cross product is negative, it is a right hand / clockwise turn; if it is positive, left hand / counterclockwise turn.  If the cross product is zero, the three points are colinear.\\n* How do we traverse the points in a circular fashion?  Sure you can import trigonometric functions to help you find the polar angle of the line formed between each point and the start.  Maybe a simpler, more intuitive approach, is to simply sort the points by the slope of the line made with the start point.  Incidentally, this is also why I chose the smallest left point in the set as my start.  It is now convenient  that all the slopes monotonically increase in the (-infinity, infinity] domain as you traverse counterclockwise from the negative verticle.  If two slopes are equivalent, take the point with the higher y-coordinate.  If two slopes are both zero, take the point with smaller x-coordinate.\\n\\n\\n    def outerTrees(self, points):\\n        # Computes the cross product of vectors p1p2 and p2p3\\n        # value of 0 means points are colinear; < 0, cw; > 0, ccw\\n        def cross(p1, p2, p3):\\n            return (p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x)\\n            \\n        # Computes slope of line between p1 and p2\\n        def slope(p1, p2):\\n            return 1.0*(p1.y-p2.y)/(p1.x-p2.x) if p1.x != p2.x else float('inf')\\n            \\n        # Find the smallest left point and remove it from points\\n        start = min(points, key=lambda p: (p.x, p.y))\\n        points.pop(points.index(start))\\n        \\n        # Sort points so that traversal is from start in a ccw circle.\\n        points.sort(key=lambda p: (slope(p, start), -p.y, p.x))\\n        \\n        # Add each point to the convex hull.\\n        # If the last 3 points make a cw turn, the second to last point is wrong. \\n        ans = [start]\\n        for p in points:\\n            ans.append(p)\\n            while len(ans) > 2 and cross(ans[-3], ans[-2], ans[-1]) < 0:\\n                ans.pop(-2)\\n        \\n        return ans"
		},
		{
			"lc_ans_id":"103305",
			"view":"653",
			"top":"5",
			"title":"Find convex hull using scipy with explanation",
			"vote":"4",
			"content":"```scipy.spatial.ConvexHull(points)``` returns all points that form the hull.\\nIt helps a lot already. However, in this question, we need to return all points on the hull.\\nI write a funciton ```isHull(point, hull)``` to check if a point is on the hull.\\nWhen ConvexHull throws a exception, it means the points can not form a hull.\\nIn this case, I return all points.\\n\\n`````\\ndef outerTrees(self, points):\\n        from scipy.spatial import ConvexHull\\n        import numpy as np\\n\\n        def isHull(point, hull, tol=1e-12):\\n            return any((abs(np.dot(eq[:-1], point) + eq[-1]) < tol) for eq in hull.equations)\\n        try:\\n            hull = ConvexHull([(p.x, p.y) for p in points])\\n            return [p for p in points if isHull((p.x, p.y), hull)]\\n        except:\\n            return points"
		},
		{
			"lc_ans_id":"103307",
			"view":"655",
			"top":"6",
			"title":"c++ Graham Scan/Monotone Chain dealing with collinear cases",
			"vote":"4",
			"content":"I implemented two different approach: 1.Graham Scan; 2. Andrew's monotone chain.\\n\\nFor the Graham Scan, here is the modified implementation discussed in the following link:\\nhttp://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/\\nThe modified part is to deal with the degenerate case. As the original algorithm outputs the extreme points instead of vertices (the difference is that a vertex can lie in between two extreme points), I added the logic for output all the vertices. \\nThere are two parts:\\n1. During the Graham scan after the radial sorting, we don't pop the points if p[i], top, next_to_top are collinear;\\n2. A special case is that in the largest radial angle, there may be several points lies on a line, we need to reverse the order of these points. In the initial radial sorting, a tie is broke by closer one comes first. But for the points in the largest radial angle, the closer one comes last.\\n```\\nclass Solution {\\npublic:\\n    // A utility function to return square of distance\\n    // between p1 and p2\\n    static int distSq(Point p1, Point p2) {\\n        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\\n    }\\n \\n    // To find orientation of ordered triplet (p, q, r).\\n    // The function returns following values\\n    // 0 --> p, q and r are colinear\\n    // 1 --> Clockwise\\n    // 2 --> Counterclockwise\\n    static int orientation(Point p, Point q, Point r) {\\n        int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\\n        if (val == 0) {\\n            return 0;  // colinear\\n        }\\n        return (val > 0) ? 1 : 2; // clock or counterclock wise\\n    }\\n\\n    // A comparison function object using specified reference point\\n    struct pointsComparator {\\n        Point p0;\\n        bool operator() (const Point& p1, const Point& p2) {\\n \\n            // Find orientation\\n            int o = orientation(p0, p1, p2);\\n            if (o == 0) {\\n                return distSq(p0, p2) >= distSq(p0, p1);\\n            }\\n            return o == 2;\\n        }\\n        pointsComparator(Point p) : p0(p) {}\\n    };\\n    \\n    // Prints convex hull of a set of n points.\\n    vector<Point> outerTrees(vector<Point> points) {\\n        int n = points.size();\\n        if (n <= 3) {\\n            return points;\\n        }\\n        // Find the bottommost point\\n        int ymin = points[0].y, min = 0;\\n        for (int i = 1; i < n; i++) {\\n            int y = points[i].y;\\n            // Pick the bottom-most or chose the left most point in case of tie\\n            if ((y < ymin) || (ymin == y && points[i].x < points[min].x)) {\\n                ymin = points[i].y, min = i;\\n            }\\n        }\\n \\n        // Place the bottom-most point at first position\\n        Point temp = points[0];\\n        points[0] = points[min];\\n        points[min] = temp;\\n        \\n        // Sort n-1 points with respect to the first point.\\n        // A point p1 comes before p2 in sorted ouput \\n        // if p2 has larger polar angle (in counterclockwise direction) than p1\\n        // In the tied case, the one has smaller distance from p0 comes first\\n        Point p0 = points[0];\\n        sort(points.begin(), points.end(), pointsComparator(p0));\\n        //As we need to output all the vertices instead of extreme points\\n        //We need to sort the points with the same largest polar angle w.r.p. p0 in another way to break tie\\n        //Closer one comes last\\n        Point pn = points.back();        \\n        if (orientation(p0, points[1], pn) != 0) {\\n            int idx = n-1;\\n            while (orientation(p0, points[idx], pn) == 0) {\\n                idx--;\\n            }\\n            reverse(points.begin() + idx + 1, points.end());\\n        }\\n \\n        // Create an empty stack and push first three points to it.\\n        vector<Point> vertices;\\n        vertices.push_back(points[0]);\\n        vertices.push_back(points[1]);\\n        vertices.push_back(points[2]);\\n        // Process remaining n-3 points\\n        for (int i = 3; i < n; i++) {\\n            // Keep removing top while the angle formed by\\n            // points next-to-top, top, and points[i] makes a right (in clockwise) turn\\n            while (orientation(vertices[vertices.size() - 2], vertices.back(), points[i]) == 1) {\\n                vertices.pop_back();\\n            }\\n            vertices.push_back(points[i]);\\n        }\\n        return vertices;\\n    }\\n};\\n```\\n\\nFor the Andrew's monotone chain method, the only part you need to take care is one degenerate case: all the vertices lie on a single line. The others is basically two Graham Scans for upper hull and lower hull. Of course, we don't pop the top point in the stack if three points are collinear.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool pointCompare(const Point& a, const Point& b) {\\n        //Sort the points by x-coordinates, break a tie by y-coordinate\\n        return (a.x < b.x) || ((a.x == b.x) && (a.y < b.y));\\n    }\\n    \\n    bool isEqual(const Point& a, const Point& b) {\\n        return (a.x == b.x) && (a.y == b.y);    \\n    }\\n    \\n    int crossProduct(const Point& a, const Point& b, const Point& c) {\\n        // > 0 if a,b,c forms a counter clockwise turn\\n        // < 0 if a,b,c forms a clockwise turn\\n        // = 0 if a,b,c are collinear\\n        return (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\\n    }\\n    \\n    vector<Point> outerTrees(vector<Point>& points) {\\n        //Sort the points\\n        sort(points.begin(), points.end(), pointCompare);\\n        vector<Point> upper;\\n        vector<Point> lower;\\n        //Find upper hull, in the dereasing order of x-coordinate\\n        for (int i = points.size() - 1; i >= 0; --i) {\\n            //Pop the top point if next_to_top, top, points[i] forms a right turn (in clockwise turn)\\n            while ((upper.size() > 1) \\n                && (crossProduct(upper[upper.size() - 2], upper[upper.size() - 1], points[i]) < 0)) {\\n                upper.pop_back();\\n            }\\n            upper.push_back(points[i]);\\n        }\\n        //Find lower hull, in the increasing order of x-coordinate \\n        for (int i=0; i<points.size(); i++) {\\n            //Pop the top point if next_to_top, top, points[i] forms a right turn (in clockwise turn)\\n            while ((lower.size() > 1) \\n                && (crossProduct(lower[lower.size() - 2], lower[lower.size() - 1], points[i]) < 0)) {\\n                lower.pop_back();\\n            }\\n            lower.push_back(points[i]);            \\n        }\\n        //Check the degenerate case if the convex hull is a line\\n        //In this case, lower == upper, we only need to check if upper[1] == lower[lower.size() - 2]\\n        if ((points.size() == 1) || (isEqual(upper[1],lower[lower.size() - 2]))) {\\n            return vector<Point>(upper.begin(), upper.end());\\n        }\\n        //In non-degenerate case, remove the starting point for both hulls\\n        //The right most one and the left most one is duplicated in both hulls\\n        vector<Point> vertices(upper.begin() + 1, upper.end());\\n        vertices.insert(vertices.end(), lower.begin() + 1, lower.end());\\n        return vertices;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"103310",
			"view":"100",
			"top":"7",
			"title":"C++ Monotone Chain Solution",
			"vote":"1",
			"content":"```\\nclass Solution {\\npublic:\\n    int orientation(Point &p, Point &q, Point &r) {\\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\\n    }\\n    \\n    vector<Point> outerTrees(vector<Point>& points) {\\n        if (points.size() < 4)\\n            return points;\\n        \\n        sort(points.begin(), points.end(), [](Point &p, Point &q) {\\n            return p.x < q.x || (p.x == q.x && p.y < q.y);\\n        });\\n        \\n        vector<Point> ans;\\n        for (int i = 0; i < points.size(); ++i) {\\n            while (ans.size() >= 2 && orientation(ans[ans.size() - 2], ans[ans.size() - 1], points[i]) < 0)\\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        ans.pop_back();\\n        for (int i = points.size() - 1; i >= 0; --i) {\\n            while (ans.size() >= 2 && orientation(ans[ans.size() - 2], ans[ans.size() - 1], points[i]) < 0)\\n                ans.pop_back();\\n            ans.push_back(points[i]);\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"103316",
			"view":"151",
			"top":"8",
			"title":"C++ O(nlogn) Solution",
			"vote":"1",
			"content":"```\\n    vector<Point> outerTrees(vector<Point>& points) {\\n        if(points.size() < 3) return points;\\n        auto cmp = [](Point& a, Point& b) -> bool {\\n            return a.x < b.x || (a.x == b.x && a.y < b.y);\\n        };\\n        sort(points.begin(), points.end(), cmp);\\n        vector<Point> stack;\\n        stack.push_back(points[0]);\\n        stack.push_back(points[1]);\\n        //left to right;\\n        for(int i = 2; i < points.size(); ++i) {\\n            while(stack.size() > 1) {\\n                auto &t1 = stack.back();\\n                auto &t2 = stack[stack.size() - 2];\\n                if(isRightTurn(t2, t1, points[i])) break;\\n                else stack.pop_back();\\n            }\\n            stack.push_back(points[i]);\\n        }\\n        int n = stack.size();\\n        if(n == points.size()) return stack; //check if linear\\n        stack.push_back(points[points.size() - 2]);\\n        //right to left;\\n        for(int i = points.size() - 3; i >= 0; --i) {\\n            while(stack.size() > n) {\\n                auto &t1 = stack.back();\\n                auto &t2 = stack[stack.size() - 2];\\n                if(isRightTurn(t2, t1, points[i])) break;\\n                else stack.pop_back();\\n            }\\n            stack.push_back(points[i]);\\n        }\\n        stack.pop_back();\\n        return stack;\\n    }\\n    \\n    bool isRightTurn(Point &a, Point &b, Point &c) {\\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) <= 0;\\n    }\\n```"
		},
		{
			"lc_ans_id":"103324",
			"view":"478",
			"top":"9",
			"title":"QuickHull C++ solution 29ms",
			"vote":"1",
			"content":"Pseudo code (from Wikipedia):\\n   Input = a set S of n points \\n   Assume that there are at least 2 points in the input set S of points\\n   QuickHull (S) \\n   { \\n       // Find convex hull from the set S of n points\\n       Convex Hull := {} \\n       Find left and right most points, say A & B, and add A & B to convex hull \\n       Segment AB divides the remaining (n-2) points into 2 groups S1 and S2 \\n           where S1 are points in S that are on the right side of the oriented line from A to B, \\n           and S2 are points in S that are on the right side of the oriented line from B to A \\n       FindHull (S1, A, B) \\n       FindHull (S2, B, A) \\n   }\\n   FindHull (Sk, P, Q) \\n   { \\n       // Find points on convex hull from the set Sk of points \\n       // that are on the right side of the oriented line from P to Q\\n       If Sk has no point, then return. \\n       From the given set of points in Sk, find farthest point, say C, from segment PQ \\n       Add point C to convex hull at the location between P and Q \\n       Three points P, Q, and C partition the remaining points of Sk into 3 subsets: S0, S1, and S2 \\n           where S0 are points inside triangle PCQ, S1 are points on the right side of the oriented \\n           line from  P to C, and S2 are points on the right side of the oriented line from C to Q. \\n       FindHull(S1, P, C) \\n       FindHull(S2, C, Q) \\n   }\\n   Output = convex hull\\n\\n\\n````\\nclass Solution {\\npublic:\\n    static bool mycmp(Point &a, Point &b) {\\n        return a.x < b.x;\\n    }\\n    \\n    int testSide(Point &a, Point &b, Point &c) {\\n        // cross product of (AB and AC vectors)\\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\\n    }\\n    \\n    double distPointLine(Point &A, Point &B, Point &C) {\\n        // dist(line: ax+by+c=0, and point(x0, y0)): (a*x0 + b*y0 + c)/sqrt(a^2+b^2)\\n        // line: (y2-y1)*x - (x2-x1)*y + x2*y1 - y2*x1 = 0\\n        int a = B.y - A.y, b = B.x - A.x;\\n        return abs((a*C.x - b*C.y + B.x*A.y - B.y*A.x)/sqrt(a*a + b*b));\\n    }\\n    \\n    void FindHull(vector<Point> &points, Point &A, Point &B) {\\n        if (points.empty())\\n            return;\\n        \\n        int idx = 0;\\n        double dist = distPointLine(A, B, points[0]);\\n        for (int i=1; i<points.size(); i++) {\\n            if (distPointLine(A, B, points[i]) > dist) {\\n                dist = distPointLine(A, B, points[i]);\\n                idx = i;\\n            }\\n        }\\n        ret.push_back(points[idx]);\\n        \\n        vector<Point> R, T;\\n        for (int i=0; i<points.size(); i++) {\\n            if (i != idx) {\\n                int tmp = testSide(A, points[idx], points[i]);\\n                if (tmp >= 0)\\n                    R.push_back(points[i]);\\n                else {\\n                    tmp = testSide(points[idx], B, points[i]);\\n                    if (tmp >= 0)\\n                        T.push_back(points[i]);\\n                }\\n            }\\n        }\\n        FindHull(R, A, points[idx]);\\n        FindHull(T, points[idx], B);\\n        \\n        return;\\n    }\\n    \\n    vector<Point> ret;\\n    \\n    vector<Point> outerTrees(vector<Point>& points) {\\n        // find the convex hull; use QuickHull algorithm\\n        if (points.size() <= 1)\\n            return points;\\n        \\n        // find the left most and right most two points\\n        sort(points.begin(), points.end(), mycmp);\\n        ret.push_back(points[0]);\\n        ret.push_back(points.back());\\n        \\n        // test whether a point on the left side right side or on the line\\n        vector<Point> Left, Right, Online;\\n        for (int i=1; i<points.size()-1; i++) {\\n            int tmp = testSide(points[0], points.back(), points[i]);\\n            if (tmp < 0)\\n                Right.push_back(points[i]);\\n            else if (tmp > 0)\\n                Left.push_back(points[i]);\\n            else\\n                Online.push_back(points[i]);\\n        }\\n        // if Upper or Down is empty, Online should be pushed into ret\\n        if (Left.empty() || Right.empty())\\n            for (int i=0; i<Online.size(); i++)\\n                ret.push_back(Online[i]);\\n\\n        FindHull(Left, points[0], points.back());\\n        FindHull(Right, points.back(), points[0]);\\n        \\n        return ret;\\n    }\\n};\\n````"
		}
	],
	"id":"568",
	"title":"Erect the Fence",
	"content":"<p>There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the <b>minimum length</b> of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\r\n<b>Output:</b> [[1,1],[2,0],[4,2],[3,3],[2,4]]\r\n<b>Explanation:</b>\r\n<img src=\"/static/images/problemset/erect_the_fence_1.png\" width = \"30%\" />\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1,2],[2,2],[4,2]]\r\n<b>Output:</b> [[1,2],[2,2],[4,2]]\r\n<b>Explanation:</b>\r\n<img src=\"/static/images/problemset/erect_the_fence_2.png\" width = \"30%\" />\r\nEven you only have trees in a line, you need to use rope to enclose them. \r\n</pre>\r\n</p>\r\n\r\n<p> Note: \r\n<ol>\r\n<li>All trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group.</li>\r\n<li>All input integers will range from 0 to 100. </li>\r\n<li>The garden has at least one tree. </li>\r\n<li>All coordinates are distinct. </li>\r\n<li>Input points have <b>NO</b> order. No order required for output.</li>\r\n</ol>\r\n</p>",
	"frequency":"57",
	"ac_num":"3798"
}