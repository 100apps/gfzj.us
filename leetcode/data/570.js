{
	"difficulty":"3",
	"submit_num":"8439",
	"show_id":"591",
	"leetcode_id":"591",
	"answers":[
		{
			"lc_ans_id":"103368",
			"view":"2691",
			"top":"0",
			"title":"Java Solution: Use startsWith and indexOf",
			"vote":"32",
			"content":"```\\npublic class Solution {\\n    public boolean isValid(String code) {\\n        Stack<String> stack = new Stack<>();\\n        for(int i = 0; i < code.length();){\\n            if(i>0 && stack.isEmpty()) return false;\\n            if(code.startsWith(\"<![CDATA[\", i)){\\n                int j = i+9;\\n                i = code.indexOf(\"]]>\", j);\\n                if(i < 0) return false;\\n                i += 3;\\n            }else if(code.startsWith(\"</\", i)){\\n                int j = i + 2;\\n                i = code.indexOf('>', j);\\n                if(i < 0 || i == j || i - j > 9) return false;\\n                for(int k = j; k < i; k++){\\n                    if(!Character.isUpperCase(code.charAt(k))) return false;\\n                }\\n                String s = code.substring(j, i++);\\n                if(stack.isEmpty() || !stack.pop().equals(s)) return false;\\n            }else if(code.startsWith(\"<\", i)){\\n                int j = i + 1;\\n                i = code.indexOf('>', j);\\n                if(i < 0 || i == j || i - j > 9) return false;\\n                for(int k = j; k < i; k++){\\n                    if(!Character.isUpperCase(code.charAt(k))) return false;\\n                }\\n                String s = code.substring(j, i++);\\n                stack.push(s);\\n            }else{\\n                i++;\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"103370",
			"view":"1712",
			"top":"1",
			"title":"Short Python, accepted but not sure if correct",
			"vote":"15",
			"content":"It does get accepted (in about 90 ms), though I'm not entirely sure it's correct because I didn't think it through because I don't find the description clear. Anyway... first I replace any CDATA with `c`. Then repeatedly replace any tags not containing `<` with `t`. I return whether I end up with `'t'`.\\n\\n    def isValid(self, code):\\n        if code == 't':\\n            return False\\n        code = re.sub(r'<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>', 'c', code)\\n        prev = None\\n        while code != prev:\\n            prev = code\\n            code = re.sub(r'<([A-Z]{1,9})>[^<]*</\\\\1>', 't', code)\\n        return code == 't'\\n\\nEdit: Thanks to @tyuan73 for pointing out the problem of the given string already being `\"t\"`. Fixed now by adding that annoying initial check.\\n\\nEdit 2: Here's a version where I handle that problem a different way, by also replacing any initial 't' along with any cdata.\\n\\n    def isValid(self, code):\\n        code = re.sub(r'<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>|t', '-', code)\\n        prev = None\\n        while code != prev:\\n            prev = code\\n            code = re.sub(r'<([A-Z]{1,9})>[^<]*</\\\\1>', 't', code)\\n        return code == 't'"
		},
		{
			"lc_ans_id":"103364",
			"view":"1251",
			"top":"2",
			"title":"Java Solution, 7 lines, Regular Expression",
			"vote":"11",
			"content":"Inspired by @StefanPochmann 's idea in this post https://discuss.leetcode.com/topic/91381/short-python-accepted-but-not-sure-if-correct\\n\\nOnly change is in Java we need to use double ```\\\\``` to quote a special character.\\n\\nTwo brilliant points:\\n1. Use ```Non Greedy``` mode (```.*?```) when matching ```CDATA```. Reference: https://stackoverflow.com/questions/3075130/what-is-the-difference-between-and-regular-expressions\\n2. Use ```Group``` (```([A-Z]{1,9})``` then ```\\\\\\\\1```) when matching ```TAG_NAME```. Reference: http://www.regular-expressions.info/refcapture.html\\n\\n```\\npublic class Solution {\\n    public boolean isValid(String code) {\\n        if (code.equals(\"t\")) return false;\\n        code = code.replaceAll(\"<!\\\\\\\\[CDATA\\\\\\\\[.*?\\\\\\\\]\\\\\\\\]>\", \"c\");\\n\\n        String prev = \"\";\\n        while (!code.equals(prev)) {\\n            prev = code;\\n            code = code.replaceAll(\"<([A-Z]{1,9})>[^<]*</\\\\\\\\1>\", \"t\");\\n        }\\n\\n        return code.equals(\"t\");\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"103374",
			"view":"627",
			"top":"3",
			"title":"[C++] Clean Code - Recursive Parser",
			"vote":"10",
			"content":"A simple summary for all the elements in this syntax is like this:\\n```\\ntag :\\n    <tagname> + content + </tagname>\\ntagname : \\n    [A-Z]{1, 9}                 # 1 ~ 9 uppercase chars\\ncontent : \\n    (tag|cdata|text)*           # 0 or more of : tag, cdata, text\\ncdata : \\n    \"<![CDATA[\" + .* + \"]]>\"\\ntext :\\n    [^<]+                       # non '<' chars\\n```\\nSo we can just create parser for each elements, and dedicate the work to the right parsers.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        int i = 0;\\n        return validTag(code, i) && i == code.size();\\n    }\\n\\nprivate:\\n    bool validTag(string s, int& i) {\\n        int j = i;\\n        string tag = parseTagName(s, j);\\n        if (tag.empty()) return false;\\n        if (!validContent(s, j)) return false;\\n        int k = j + tag.size() + 2; // expecting j = pos of \"</\" , k = pos of '>'\\n        if (k >= s.size() || s.substr(j, k + 1 - j) != \"</\" + tag + \">\") return false;\\n        i = k + 1;\\n        return true;\\n    }\\n\\n    string parseTagName(string s, int& i) {\\n        if (s[i] != '<') return \"\";\\n        int j = s.find('>', i);\\n        if (j == string::npos || j - 1 - i < 1 || 9 < j - 1 - i) return \"\";\\n        string tag = s.substr(i + 1, j - 1 - i);\\n        for (char ch : tag) {\\n            if (ch < 'A' || 'Z' < ch) return \"\";\\n        }\\n        i = j + 1;\\n        return tag;\\n    }\\n\\n    bool validContent(string s, int& i) {\\n        int j = i;\\n        while (j < s.size()) {\\n            if (!validText(s, j) && !validCData(s, j) && !validTag(s, j)) break;\\n        }\\n        i = j;\\n        return true;\\n    }\\n\\n    bool validText(string s, int& i) {\\n        int j = i;\\n        while (i < s.size() && s[i] != '<') { i++; }\\n        return i != j;\\n    }\\n\\n    bool validCData(string s, int& i) {\\n        if (s.find(\"<![CDATA[\", i) != i) return false;\\n        int j = s.find(\"]]>\", i);\\n        if (j == string::npos) return false;\\n        i = j + 3;\\n        return true;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"103379",
			"view":"340",
			"top":"4",
			"title":"Should add more test case",
			"vote":"3",
			"content":"Suggest to add this test case:\\n\"<![CDATA[<div>]]>\""
		},
		{
			"lc_ans_id":"103373",
			"view":"178",
			"top":"5",
			"title":"Clean C++ Solution",
			"vote":"2",
			"content":"Inspired by https://discuss.leetcode.com/topic/91300/java-solution-use-startswith-and-indexof\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string code) \\n    {\\n        stack<string> stk;\\n\\tfor (int i = 0; i < code.length(); i++) {        \\n\\t    if (i > 0 && stk.empty()) return false;\\n\\t    if (code.substr(i, 9) == \"<![CDATA[\") {\\n\\t\\tint j = i + 9;\\n\\t\\ti = code.find(\"]]>\", j);\\n\\t\\tif (i < 0) return false;\\n\\t\\ti += 2;\\n            } else if (code.substr(i, 2) == \"</\") {\\n\\t\\tint j = i + 2;\\n\\t\\ti = code.find('>', j);\\n\\t\\tstring s = code.substr(j, i - j);\\n\\t\\tif (stk.empty() || s != stk.top()) return false;\\n\\t\\tstk.pop();\\n\\t    } else if (code.substr(i, 1) == \"<\") {\\n\\t\\tint j = i + 1;\\n\\t\\ti = code.find('>', j);\\n\\t\\tif (i < 0 || i == j || i - j > 9) return false;\\n\\t\\tfor (int k = j; k < i; k++) {\\n\\t            if (!isupper(code[k])) return false;\\n\\t\\t}\\n\\t\\tstring s = code.substr(j, i - j);\\n\\t\\tstk.push(s);\\n            }\\n\\t}\\n\\treturn stk.empty();        \\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"103377",
			"view":"239",
			"top":"6",
			"title":"Java solution. Sequentially build current structure, use stack for tag matching",
			"vote":"1",
			"content":"Use a stack to match start_tag and end_tag pairs. Everything else will be \"any characters\"\\nwhich can be ignored, or cdata which can be detected once and throw away. Be careful of\\n```\"<A></A><B></B>\"``` case. The entire code has to be exact ONE valid closed tag.\\n```\\npublic class Solution {\\n\\tpublic boolean isValid(String code) {\\n\\t\\tif (!code.startsWith(\"<\")) return false;\\n\\t\\tif (code.length() < 2 || !(code.charAt(1) >= 'A' && code.charAt(1) <= 'Z')) return false;\\n\\t\\t\\n\\t\\tStack<String> stack = new Stack<>();\\n\\t\\tString cur = \"\";\\n\\t\\tfor (int i = 0; i < code.length(); i++) {\\n\\t\\t\\tcur += code.charAt(i);\\n\\t\\t\\tif (cur.startsWith(\"<![CDATA[\")) {\\n\\t\\t\\t\\tif (cur.endsWith(\"]]>\")) {\\n\\t\\t\\t\\t\\tcur = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (cur.startsWith(\"</\")) {\\n\\t\\t\\t\\tif (cur.endsWith(\">\")) {\\n\\t\\t\\t\\t\\tString tag = cur.substring(2, cur.length()-1);\\n\\t\\t\\t\\t\\tif (stack.isEmpty() || !stack.peek().equals(\"<\"+tag+\">\")) return false;\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\t\\tcur = \"\";\\n\\t\\t\\t\\t\\tif (i < code.length()-1 && stack.isEmpty()) return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (cur.startsWith(\"<\")) {\\n\\t\\t\\t\\tif (cur.endsWith(\">\")) {\\n\\t\\t\\t\\t\\tif (!valid_tag(cur)) return false;\\n\\t\\t\\t\\t\\tstack.push(cur);\\n\\t\\t\\t\\t\\tcur = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcur = \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn stack.isEmpty() && cur.length() == 0;\\n        }\\n\\tboolean valid_tag(String tag) {\\n\\t\\tif (!tag.startsWith(\"<\") || !tag.endsWith(\">\")) return false;\\n\\t\\tif (tag.length() < 3 || tag.length() > 11) return false;\\n\\t\\tfor (int i = 1; i < tag.length()-1; i++) {\\n\\t\\t\\tchar c = tag.charAt(i);\\n\\t\\t\\tif (!Character.isUpperCase(c)) return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n\\n```"
		},
		{
			"lc_ans_id":"103380",
			"view":"240",
			"top":"7",
			"title":"Python, Straightforward with Explanation",
			"vote":"1",
			"content":"Let's check for the valid closed tag first.  The function ```collect_tag(i)``` will find the tag that starts at ```S[i] == '<'``` and ends at ```S[j] == '>'``` and output ```S[i+1:j]```.\\n\\nAfterwards, S will be just the content section between the valid closed tag.  Whenever a tag could start, we complete it, overriding our usual checks if it is part of some cdata.  Otherwise, an opening tag goes on the stack, and a closing tag is checked against the top of the stack.\\n\\n```\\ndef isValid(self, S):\\n    CDATA_BEGIN = '![CDATA['\\n    CDATA_END = ']]>'\\n    \\n    def collect_tag(i):\\n        for j in xrange(i, len(S)):\\n            if S[j] == '>': break\\n        else:\\n            return None\\n        return S[i+1:j]\\n    \\n    def valid_tag(tag):\\n        return 1 <= len(tag) <= 9 and all('A' <= c <= 'Z' for c in tag)\\n    \\n    if not S or S[0] != '<': return False\\n    tag = collect_tag(0)\\n    if (tag is None or \\n            not S.startswith('<{}>'.format(tag)) or \\n            not S.endswith('</{}>'.format(tag)) or\\n            not valid_tag(tag)):\\n        return False\\n    S = S[len(tag) + 2: -len(tag) - 3]\\n    \\n    i = 0\\n    stack = []\\n    while i < len(S):\\n        if S[i] == '<':\\n            tag = collect_tag(i)\\n            if tag is None: return False\\n            if tag.startswith(CDATA_BEGIN):\\n                while i < len(S) and S[i:i+3] != CDATA_END:\\n                    i += 1\\n                if not S[i:i+3] == CDATA_END:\\n                    return False\\n                i += 2\\n            elif tag.startswith('/'):\\n                tag = tag[1:]\\n                if not valid_tag(tag) or not stack or stack.pop() != tag:\\n                    return False\\n            else:\\n                if not valid_tag(tag):\\n                    return False\\n                stack.append(tag)\\n        i += 1\\n\\n    return not stack\\n```"
		},
		{
			"lc_ans_id":"103366",
			"view":"37",
			"top":"8",
			"title":"AC python solution & easy to read",
			"vote":"0",
			"content":"```\\nclass Solution(object):\\n    def isValid(self, code):\\n        \"\"\"\\n        :type code: str\\n        :rtype: bool\\n        \"\"\"\\n        stack=[]\\n        i=0\\n        firstMoodFlag=0\\n        maxStackDepth=0\\n        while i<len(code):\\n            if code[i]=='<':\\n                i=i+1\\n                \\n                if i==len(code):\\n                    return False\\n                if code[i].isupper():\\n                    firstMoodFlag+=1\\n                    j=i\\n                    while code[j]!='>':\\n                        if not code[j].isupper():\\n                            return False\\n                        j=j+1\\n                        if j==len(code):\\n                            return False\\n                    if len(code[i:j])<1 or len(code[i:j])>9:\\n                        return False\\n                    stack.append(code[i:j])\\n                    maxStackDepth=max(len(stack), maxStackDepth)\\n                    i=j+1\\n                    \\n                elif code[i]=='/':\\n                    i=i+1\\n                    j=i\\n                    \\n                    while code[j]!='>':\\n                        if not code[j].isupper():\\n                            return False\\n                        j=j+1\\n                        if j==len(code):\\n                            return False\\n                    tagName=code[i: j]\\n                    if len(stack)==0 or tagName!=stack[-1]:\\n                        return False\\n                    else:\\n                        stack.pop()\\n                    \\n                    i=j+1\\n                elif code[i]=='!':\\n                    cdata0, cdata1='[CDATA[',']]>'\\n                    j=i+1\\n                    track=0\\n                    while track<len(cdata0):\\n                        if cdata0[track].lower()!=code[j].lower():\\n                            return False\\n                        track=track+1\\n                        j=j+1\\n                        if j==len(code):\\n                            return False\\n                    while j< len(code)-3 and code[j:j+3]!=cdata1:\\n                        j=j+1\\n                    i=j+1\\n                else:\\n                    return False\\n            else:\\n                if len(stack)==0:\\n                    return False\\n                i=i+1\\n        if firstMoodFlag>1 and maxStackDepth==1:\\n            return False\\n    \\n        return True if(len(stack)==0 and firstMoodFlag>=1)else False\\n```"
		},
		{
			"lc_ans_id":"103367",
			"view":"79",
			"top":"9",
			"title":"Recursive decent parser in python",
			"vote":"0",
			"content":"```\\nclass Parser(object):\\n\\n    class SyntaxError(Exception):\\n        pass\\n\\n    def __init__(self, code):\\n        self.code = code\\n        self.i = 0\\n        self.n = len(code)\\n\\n    def peek(self, n=1):\\n        beg = self.i\\n        end = beg + n\\n        if end > self.n:\\n            return self.code[beg:]\\n        else:\\n            return self.code[beg:end]\\n\\n    def has_next(self):\\n        return self.i < self.n\\n\\n    def next(self, n=1):\\n        beg = self.i\\n        end = beg + n\\n        if end > self.n:\\n            self.i = self.n\\n            return self.code[beg:]\\n        else:\\n            self.i = end\\n            return self.code[beg:end]\\n\\n    def error(self):\\n        raise Parser.SyntaxError(self.code[self.i:])\\n\\n    def accept(self, s):\\n        if self.peek(len(s)) == s:\\n            return True\\n        else:\\n            return False\\n\\n    def expect(self, s):\\n        if self.next(len(s)) != s:\\n            self.error()\\n    # tags\\n    def parse_tag(self):\\n        tag_name = self.parse_open_tag()\\n        self.parse_tag_content()\\n        self.parse_closed_tag(tag_name)\\n\\n    def parse_tag_name(self):\\n        tag_name = ''\\n        while self.peek().isupper():\\n            tag_name += self.next()\\n            if len(tag_name) > 9:\\n                self.error()\\n\\n        if len(tag_name) == 0:\\n            self.error()\\n\\n        return tag_name\\n\\n    def parse_open_tag(self):\\n        self.expect('<')\\n        tag_name = self.parse_tag_name()\\n        self.expect('>')\\n        return tag_name\\n\\n    def parse_closed_tag(self, expected_tag_name):\\n        self.expect('</')\\n        tag_name = self.parse_tag_name()\\n        if tag_name != expected_tag_name:\\n            self.error()\\n        self.expect('>')\\n\\n    # content\\n    def parse_tag_content(self):\\n\\n        def parse_one_time():\\n            if self.accept('<!'):       # it should be a cdata\\n                self.parse_cdata()\\n            elif self.accept('<'):      # it should be a tag\\n                self.parse_tag()\\n            elif self.has_next() and not self.accept('</'):  # it should be common strings\\n                while self.has_next() and self.peek() != '<':\\n                    self.next()\\n            else:\\n                self.error()\\n\\n        while self.has_next() and not self.accept('</'):\\n            parse_one_time()\\n\\n    def parse_cdata(self):\\n        self.expect('<![CDATA[')\\n        self.parse_cdata_content()\\n        self.expect(']]>')\\n\\n    def parse_cdata_content(self):\\n        while self.has_next():\\n            if self.peek(3) != ']]>':\\n                self.next()\\n            else:\\n                break\\n\\nclass Solution(object):\\n    def isValid(self, code):\\n        \"\"\"\\n        :type code: str\\n        :rtype: bool\\n        \"\"\"\\n        parser = Parser(code)\\n        try:\\n            parser.parse_tag()\\n            return not parser.has_next()\\n        except Parser.SyntaxError:\\n            return False\\n```"
		}
	],
	"id":"570",
	"title":"Tag Validator",
	"content":"<p>Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:<p>\r\n<ol>\r\n<li>The code must be wrapped in a <b>valid closed tag</b>. Otherwise, the code is invalid.</li>\r\n<li>A <b>closed tag</b> (not necessarily valid) has exactly the following format : <code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code>. Among them, <code>&lt;TAG_NAME&gt;</code> is the start tag, and <code>&lt;/TAG_NAME&gt;</code> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is <b>valid</b> if and only if the TAG_NAME and TAG_CONTENT are valid.</li>\r\n<li>A <b>valid</b> <code>TAG_NAME</code> only contain <b>upper-case letters</b>, and has length in range [1,9]. Otherwise, the <code>TAG_NAME</code> is <b>invalid</b>.</li>\r\n<li>A <b>valid</b> <code>TAG_CONTENT</code> may contain other <b>valid closed tags</b>, <b>cdata</b> and any characters (see note1) <b>EXCEPT</b> unmatched <code>&lt;</code>, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the <code>TAG_CONTENT</code> is <b>invalid</b>.</li>\r\n<li>A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.</li>\r\n<li>A <code>&lt;</code> is unmatched if you cannot find a subsequent <code>></code>. And when you find a <code>&lt;</code> or <code>&lt;/</code>, all the subsequent characters until the next <code>></code> should be parsed as TAG_NAME  (not necessarily valid).</li>\r\n<li>The cdata has the following format : <code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>. The range of <code>CDATA_CONTENT</code> is defined as the characters between <code>&lt;![CDATA[</code> and the <b>first subsequent</b> <code>]]></code>. </li>\r\n<li><code>CDATA_CONTENT</code> may contain <b>any characters</b>. The function of cdata is to forbid the validator to parse <code>CDATA_CONTENT</code>, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as <b>regular characters</b>. </li>\r\n</ol>\r\n\r\n<p><b>Valid Code Examples:</b><br />\r\n<pre>\r\n<b>Input:</b> \"&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;\"<br />\r\n<b>Output:</b> True<br />\r\n<b>Explanation:</b> <br>\r\nThe code is wrapped in a closed tag : &lt;DIV> and &lt;/DIV>. <br>\r\nThe TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. <br>\r\nAlthough CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.<br>\r\nSo TAG_CONTENT is valid, and then the code is valid. Thus return true.<br />\r\n\r\n<b>Input:</b> \"&lt;DIV>>>  ![cdata[]] &lt;![CDATA[&lt;div>]>]]>]]>>]&lt;/DIV>\"<br />\r\n<b>Output:</b> True<br />\r\n<b>Explanation:</b><br />\r\nWe first separate the code into : start_tag|tag_content|end_tag.<br />\r\nstart_tag -> <b>\"&lt;DIV&gt;\"</b><br />\r\nend_tag -> <b>\"&lt;/DIV>\"</b><br />\r\ntag_content could also be separated into : text1|cdata|text2.<br />\r\ntext1 -> <b>\">>  ![cdata[]] \"</b><br />\r\ncdata -> <b>\"&lt;![CDATA[&lt;div>]>]]>\"</b>, where the CDATA_CONTENT is <b>\"&lt;div>]>\"</b><br />\r\ntext2 -> <b>\"]]>>]\"</b><br />\r\n\r\nThe reason why start_tag is NOT <b>\"&lt;DIV>>>\"</b> is because of the rule 6.\r\nThe reason why cdata is NOT <b>\"&lt;![CDATA[&lt;div>]>]]>]]>\"</b> is because of the rule 7.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Invalid Code Examples:</b><br />\r\n<pre>\r\n<b>Input:</b> \"&lt;A>  &lt;B> &lt;/A>   &lt;/B>\"\r\n<b>Output:</b> False\r\n<b>Explanation:</b> Unbalanced. If \"&lt;A>\" is closed, then \"&lt;B>\" must be unmatched, and vice versa.\r\n\r\n<b>Input:</b> \"&lt;DIV&gt;  div tag is not closed  &lt;DIV&gt;\"\r\n<b>Output:</b> False\r\n\r\n<b>Input:</b> \"&lt;DIV&gt;  unmatched &lt  &lt;/DIV&gt;\"\r\n<b>Output:</b> False\r\n\r\n<b>Input:</b> \"&lt;DIV&gt; closed tags with invalid tag name  &lt;b>123&lt;/b> &lt;/DIV&gt;\"\r\n<b>Output:</b> False\r\n\r\n<b>Input:</b> \"&lt;DIV&gt; unmatched tags with invalid tag name  &lt;/1234567890> and &lt;CDATA[[]]>  &lt;/DIV&gt;\"\r\n<b>Output:</b> False\r\n\r\n<b>Input:</b> \"&lt;DIV&gt;  unmatched start tag &lt;B>  and unmatched end tag &lt;/C>  &lt;/DIV&gt;\"\r\n<b>Output:</b> False\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>For simplicity, you could assume the input code (including the <b>any characters</b> mentioned above) only contain <code>letters</code>, <code>digits</code>, <code>'&lt;'</code>,<code>'>'</code>,<code>'/'</code>,<code>'!'</code>,<code>'['</code>,<code>']'</code> and <code>' '</code>.</li>\r\n</ol>\r\n</p>",
	"frequency":"15",
	"ac_num":"2602"
}