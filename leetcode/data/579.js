{
	"difficulty":"3",
	"submit_num":"15475",
	"show_id":"600",
	"leetcode_id":"600",
	"answers":[
		{
			"lc_ans_id":"103749",
			"view":"7869",
			"top":"0",
			"title":"Java Solution, DP",
			"vote":"29",
			"content":"Reference: http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/\\n\\n```\\npublic class Solution {\\n    public int findIntegers(int num) {\\n        StringBuilder sb = new StringBuilder(Integer.toBinaryString(num)).reverse();\\n        int n = sb.length();\\n        \\n        int a[] = new int[n];\\n        int b[] = new int[n];\\n        a[0] = b[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            a[i] = a[i - 1] + b[i - 1];\\n            b[i] = a[i - 1];\\n        }\\n        \\n        int result = a[n - 1] + b[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (sb.charAt(i) == '1' && sb.charAt(i + 1) == '1') break;\\n            if (sb.charAt(i) == '0' && sb.charAt(i + 1) == '0') result -= b[i];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"103754",
			"view":"2434",
			"top":"1",
			"title":"C++, Non-DP, O(32) Fibonacci solution",
			"vote":"19",
			"content":"The solution is based on 2 facts:\\n1) the number of length k string without consecutive 1 is Fibonacci sequence f(k);\\nFor example, if k = 5, the range is 00000-11111. We can consider it as two ranges, which are 00000-01111 and 10000-10111. Any number >= 11000 is not allowed due to consecutive 1. The first case is actually f(4), and the second case is f(3), so f(5)= f(4)+f(3).\\n2) Scan the number from most significant digit, i.e. left to right, in binary format. If we find a '1' with k digits to the right, count increases by f(k) because we can put a '0' at this digit and any valid length k string behind; After that, we continue the loop to consider the remaining cases, i.e., we put a '1' at this digit. If consecutive 1s are found, we exit the loop and return the answer. By the end of the loop, we return count+1 to include the number n itself.\\nFor example, if n is 10010110,\\nwe find first '1' at 7 digits to the right, we add range 00000000-01111111, which is f(7);\\nsecond '1' at 4 digits to the right,             add range 10000000-10001111,              f(4);\\nthird '1' at 2 digits to the right,                  add range 10010000-10010011,             f(2);\\nfourth '1' at 1 digits to the right,                add range 10010100-10010101,             f(1);\\nThose ranges are continuous from 00000000 to 10010101. And any greater number <= n will have consecutive 1.\\n```\\nclass Solution {\\npublic:\\n    int findIntegers(int num) {\\n        int f[32];\\n        f[0] = 1;\\n        f[1] = 2;\\n        for (int i = 2; i < 32; ++i)\\n            f[i] = f[i-1]+f[i-2];\\n        int ans = 0, k = 30, pre_bit = 0;\\n        while (k >= 0) {\\n            if (num&(1<<k)) {\\n                ans += f[k];\\n                if (pre_bit) return ans;\\n                pre_bit = 1;\\n            }\\n            else\\n                pre_bit = 0;\\n            --k;\\n        }\\n        return ans+1;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"103766",
			"view":"2554",
			"top":"2",
			"title":"C++ 4 lines DP/Fibonacci 6 ms",
			"vote":"8",
			"content":"If we have n bits, the number of integers without consecutive ones f(n) = f(n - 1) + f (n - 2). f(n - 1) is for the case when first bit is zero, and f(n - 2) is when then the first bit is one and second bit is zero (as we cannot have consecutive ones): \\n\\n* f(n) = \"0\" f(n - 1) + \"10\" f(n - 2). \\n\\nThese are Fibonacci numbers, and we can have them in a static array for [0..31] bits.\\n\\nFirst, we find *n*, which is the position of the highest set bit in our number.\\n\\nNow, if the binary representation of our number starts with \"11\", then all integers will be smaller than our number, and we can just return a Fibonacci number for *n* bits.\\n\\n* For example, if n == 12 (binary 0b1100), highest bit at the position 4, next bit is set, so the result is 8 (fb[4]).\\n\\nIf the binary representation of our number starts with \"10\", then all integers with *n - 1* bits will be smaller than our number. So, we will grab a Fibonacci number for *n - 1* bits. That's \"0\" + f(n - 1) case. Plus, we need to add \"10..\" case, so we remove the highest bit from our number and recursively call our function.\\n\\n* For example, if n == 18 (binary 0b10010), the highest bit at the position 5, next bit is unset, so taking 8 (fb[4] for 0x01111) and adding 3 (fb[2] for 0x00010).\\n\\n```\\nint findIntegers(int num) {\\n    static int fb[31] = { 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,\\n        17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578 };\\n    if (num < 3) return num + 1;\\n    for (int bt = 29; bt >= 0; --bt) // bt should start from 30, but OJ accepts it from 29.\\n        if (num & (1 << bt)) return num & (1 << (bt - 1)) ? fb[bt] : fb[bt - 1] + findIntegers((num & ~(1 << bt)));\\n}\\n```"
		},
		{
			"lc_ans_id":"103751",
			"view":"1572",
			"top":"3",
			"title":"Java O(1) time O(1) space DP Solution",
			"vote":"6",
			"content":"Build a tree to consider all possible number.\\n\\nLet 1.and 0 for each bit be tree node \\n\\ncompress to 4 possible result for each bit:\\n1. all bit before cur is less than num and no continues 1 and cur bit is at one.\\n2. all bit before cur is less than num and no continues 1 and cur bit is at zero.\\n3. cur and prev bit is equal to num.\\n4. larger than num or has contiunes '1'.\\n\\nthen run through the tree.\\n\\n```\\npublic class Solution {\\n    public int findIntegers(int num) {\\n        //one:all bit before cur is less than num and no continues 1 and cur bit is at one;\\n        //zero:all bit before cur is less than num and no continues 1 and cur bit is at zero;\\n        int one=0,zero=0,temp;\\n        boolean isNum=true;\\n        for(int i=31;i>=0;i--){\\n            temp=zero;\\n            zero+=one;\\n            one=temp;\\n            if(isNum&&((num>>i)&1)==1){\\n                zero+=1;\\n            }\\n            if(((num>>i)&1)==1&&((num>>i+1)&1)==1){\\n                isNum=false;\\n            }\\n            \\n        }\\n        return one+zero+(isNum?1:0);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"103755",
			"view":"531",
			"top":"4",
			"title":"python dp solution easily understood",
			"vote":"4",
			"content":"```\\nclass Solution(object):\\n    def findIntegers(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: int\\n        \"\"\"\\n        # A[0] is the lowest bit, A[-1] is the highest bit\\n        A=bin(num)[2:][::-1]\\n        # dp[i][0] is the number of integers with (i+1)bits, highest bit is 0 and without consecutive ones\\n        # dp[i][1] is the number of integers with (i+1)bits, highest bit is 1 and without consecutive ones\\n        dp=[[1,1] for _ in range(len(A))]\\n        # res is the number of integers less than A[:i] without consecutive ones.\\n        res=1 if A[0]=='0' else 2\\n        for i in range(1, len(A)):\\n            dp[i][0]=dp[i-1][0]+dp[i-1][1]\\n            dp[i][1]=dp[i-1][0]\\n            # try to get the number of integers less than A[:i+1]\\n            if A[i-1:i+1]=='01':\\n                # if A[i-1:i+1]=='01', we can append '1' after integers less than A[:i] without consecutive ones, \\n                # also any integer with (i+1) bits, highest bit is '0', without consecutive ones\\n                # is less than A[:i+1]\\n                res+=dp[i][0]\\n            elif A[i-1:i+1]=='11':\\n                # if A[i-1:i+1]=='11', then any integer with i+1 bits and without consecutive ones \\n                # is less than A[:i+1]\\n                res=dp[i][0]+dp[i][1]\\n            # if A[i]=='0', the number of integers  with i+1 bits, less than A[:i+1]  and without \\n            # consecutive ones is the same as A[:i]\\n        return res\\n```"
		},
		{
			"lc_ans_id":"103771",
			"view":"706",
			"top":"5",
			"title":"Python, Straightforward with Explanation",
			"vote":"4",
			"content":"Say ```X``` is the given number, and A = a list of that number in binary.  For example, if ```X = 1234 = 0b10011010010```, ```A = [1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0]```.\\n\\nWe will perform a 'flag-dp': let dp[i][flag] = the answer for the number corresponding to A[i:], where flag = 1 if we have written a lower number than A[i] at some point in our writing process (and can now freely write higher numbers), else flag = 0.\\n\\n1234 has bitlength 11.  With that example, we would try to write 11 binary digits (without writing consecutive 1s) from left to right, such that the number it represents is less than or equal to 1234.\\n\\nIf our flag is down (flag = 0), then we cannot write a higher number than A[i].  If A[i] = 1, then we can write '10' or '0'.  If A[i] = 0, we can only write '0'.  We should check as we write a zero, to lower our flag if we wrote a lower number.  This is what ```dp[.][A[i]]``` and ```dp[.][A[i+1]]``` do.\\n\\nIf our flag is up, then we can freely write '10' or '0'.\\n\\n```\\ndef findIntegers(self, X):\\n    A = map(int, bin(X)[2:])\\n    N = len(A)\\n    dp = [[0, 0] for _ in xrange(N+2)]\\n    dp[N] = dp[N+1] = [1, 1]\\n    \\n    for i in xrange(N-1, -1, -1):\\n        dp[i][0] = dp[i+1][A[i]] + A[i] * dp[i+2][i+1 < N and A[i+1]]\\n        dp[i][1] = dp[i+1][1] + dp[i+2][1]\\n\\n    return dp[0][0]\\n```"
		},
		{
			"lc_ans_id":"103757",
			"view":"1338",
			"top":"6",
			"title":"Java Memoized DP Solution",
			"vote":"3",
			"content":"```\\npublic int findIntegers(int num) {\\n  return findIntegers(num, new HashMap<>());\\n}    \\n\\npublic int findIntegers(int num, Map<Integer, Integer> memo) {\\n    if (num <= 2) return num + 1; // base case\\n    if (memo.containsKey(num)) return memo.get(num); // check if this result has already been computed   \\n    \\n    int msb = 31 - Integer.numberOfLeadingZeros(num); // retrieve index of most significant bit\\n    int subNum = (1 << msb) - 1, subNum2 = ~(1 << msb) & num;\\n    if (subNum2 >= 1 << msb - 1) subNum2 = subNum >> 1;\\n    int result = findIntegers(subNum, memo) + findIntegers(subNum2, memo);\\n    \\n    memo.put(num, result); // add result to memo\\n    return result;\\n}\\n```"
		},
		{
			"lc_ans_id":"103750",
			"view":"320",
			"top":"7",
			"title":"Python solution with explanation",
			"vote":"2",
			"content":"```x, y``` are used to calculate Fibonacci numbers.\\n```num & 1 and num & 2``` will check if num ends with `11` in binary.\\n\\nWhy can I use fibonacci numbers?\\na(n) = the number of valid integers less than 2^n\\na(5) = the number of valid integers less than 0b100000\\nIt equals to the number of valid integers in [0b0, 0b10000[ and in [0b10000, 0b11000[.\\nThe number of valid integers [0b0, 0b10000[, which is like '0b0XXXX', equals to a(4).\\nThe number of valid integers [0b10000, 0b11000[, which is like '0b101XX', equals to a(3).\\nSo a(5) = a(4) + a(3).\\nThis rule is the same for other values of n, and it is the same as Fibonacci numbers recurrence relation definition.\\n````\\ndef findIntegers(self, num):\\n        x, y = 1, 2\\n        res = 0\\n        num += 1\\n        while num:\\n            if num & 1 and num & 2:\\n                res = 0\\n            res += x * (num & 1)\\n            num >>= 1\\n            x, y = y, x + y\\n        return res\\n````\\nShorter version:\\n````\\ndef findIntegers(self, num):\\n        res, x, y, num = 0, 1, 2, num + 1\\n        while num:  res, x, y, num = res if not num & 1 else x if num & 2 else res + x, y, x + y, num >> 1\\n        return res"
		},
		{
			"lc_ans_id":"103758",
			"view":"239",
			"top":"8",
			"title":"Share my O(logn) C++ DP solution with thinking process and explanation",
			"vote":"1",
			"content":"---\\n## 1. Problem\\n\\n---\\nGiven a positive integer n, find the number of **non-negative** integers less than or equal to n, whose binary representations do NOT contain **consecutive ones**.\\n\\n---\\n## 2. Thinking process\\n\\n---\\n#### 2.1 Divide the whole problem into sub-problems\\n\\n---\\nBefore introducing the way to calculate the number of **non-negative** integers less than or equal to n **without consecutive ones**, we divide the problem into **several parts**.\\n\\n---\\nIt is clear that **if an integer has less binary digits than n, it must be smaller than n**.\\n\\n---\\nThat is to say. \\n\\n---\\n> #### Step 1: calculate the number of all integers **without consecutive ones** which has **less binary digits than n**.\\n\\n>#### Step 2: calculate the number of all integers ***less than or equal to n* without consecutive ones** which **has the same binary digits as n**.\\n\\n>#### Step 3: add them together.\\n\\n---\\n**Suppose integer n has k digits, k \\u2265 2**, the total number of integers can be divided into\\n\\n---\\n>#### **Total**\\n>#### **(Part 1)**\\n>#### **= number of 1-binary-digit-integers without consecutive ones**\\n>#### **+ number of 2-binary-digit-integers without consecutive ones**\\n>#### **+ ......**\\n>#### **+ number of (k-1)-binary-digit-integers without consecutive ones**\\n\\n---\\n>#### **(Part 2)**\\n>#### **+ number of k-binary-digit-integers *less than or equal to n* without consecutive ones**\\n\\n---\\n#### 2.2 Solve Part 1 by dynamic programming\\n\\n---\\nThe problem is\\n\\n---\\n>#### **Calculate number of p-binary-digit-integers without consecutive ones (p \\u2265 1).**\\n\\n---\\n##### 2.2.1 Divide the problem\\n\\n---\\nAs a binary number is always ended by either 0 or 1, the number of integers can be divided into 2 parts.\\n\\n---\\nDefine **Zero(p)** and **One(p)** as\\n\\n---\\n>#### **Zero(p)**: the number of p-binary-digit-integers **ended by zero.**\\n>#### **One(p)**: the number of p-binary-digit-integers **ended by one.**\\n\\n---\\nSuppose the total is f(p), then\\n\\n---\\n>#### **f(p) = Zero(p) + One(p), p \\u2265 1.**\\n\\n---\\n##### 2.2.2 Find recursive relation of Zero(p) and One(p)\\n\\n---\\nAs I use dynamic programming, I need to find out the **recursive relation** in the first part of sub-problems.\\n\\n---\\nIt can be inferred that\\n\\n---\\n>#### **A p-binary-digit-integer** can be generated by **attaching 0 or 1 to a (p - 1)-binary-digit-integer's Least Significant Bit (LSB)**, p \\u2265 2.\\n\\n---\\nFor an integer **with p - 1 binary digits**, p \\u2265 2\\n\\n---\\n- If its **LSB is '0'** ---- **CAN attach '0' or '1'**. (\"00\" or \"01\")\\n\\n- If its **LSB is '1'** ---- **CAN attach '0'** (\"10\"), **CAN NOT attach 1** (**\"11\" is consecutive ones**)\\n\\n---\\nwhich means the **recursive formula** is\\n\\n>#### **Zero(p) = Zero(p - 1) + One(p - 1), p \\u2265 2.**\\n\\n>#### **One(p) = Zero(p - 1), p \\u2265 2.**\\n\\n---\\nThe formula can be simplified to\\n\\n>#### **Zero(p) = Zero(p - 1) + Zero(p - 2), p \\u2265 3.**\\n\\n>#### **One(p) = One(p - 1) + One(p - 2), p \\u2265 3.**\\n\\n---\\nAs **p \\u2265 2**, **the Most Significant Digit (MSB) of all integers with *p binary digits* must be 1.**\\n\\n---\\nIf **treating 0 separately**, the **initial value for the recursive formula** will be\\n\\n---\\n>#### **Zero(1) = 0, don't take \"0\" into account.**\\n\\n>#### **Zero(2) = 1, only \"10\",  ignore \"00\" whose MSB is \"0\".**\\n\\n>#### **One(1) = 1, only \"1\".**\\n\\n>#### **One(2) = 0. ignore \"01\" whose MSB is \"0\" and \"11\" which has consecutive ones.**\\n\\n---\\n##### 2.2.3 calculate f(p)\\n\\n---\\nIt can be inferred that\\n\\n>#### **f(p) = One(p) + Zero(p) + 1(stands for \"0\"), p = 1.**\\n\\n>#### **f(p) = One(p) + Zero(p), p \\u2265 2.**\\n\\n---\\nThe whole answer to the problem is simplified to\\n\\n>#### **Total**\\n>#### **(Part 1)**\\n>#### **= 1 (stands for \"0\")**\\n>#### **+ One(1) + Zero(1)**\\n>#### **+ One(2) + Zero(2)**\\n>#### **+ ......**\\n>#### **+ One(k-1) + Zero(k-1)**\\n\\n---\\n>#### **(Part 2)**\\n>#### **+ number of k-binary-digit-integers *less than or equal to n* without consecutive ones**\\n\\n---\\n#### 2.3 Solve Part 2 by dynamic programming\\n\\n---\\nThe problem is\\n\\n---\\n>#### **Calculate number of k-binary-digit-integers *less than or equal to n* without consecutive ones (k is the number of binary digits that n has).**\\n\\n---\\n##### 2.3.1 Pre-definition\\n\\n---\\nBefore introducing the algorithm, suppose **n has k bits**\\n\\n---\\n>#### **n = a(1)a(2)a(3)...a(k), k \\u2265 2.**\\n\\n---\\nSince **\"0\" has been treated** in **Section 2.2.3**, here\\n\\n---\\n>#### **a(1) is ALWAYS 1**.\\n\\n---\\nDefine **part(n, p)** as\\n\\n---\\n>#### **part(n, p) = n >> (k - p) = a(1)a(2)a(3)...a(p), 1 \\u2264 p \\u2264 k.**\\n\\n---\\nAs a binary number is always ended by either 0 or 1, the number of integers ***less than or equal to part(n, p)*** can be divided into 2 parts.\\n\\n---\\nDefine 2 new series **Zero(n, p)** and **One(n, p)**, k \\u2265 1:\\n\\n---\\n>#### **Zero(n, p)**: the number of **p-binary-digit-integers ended by zero** which is ***less than or equal to part(n, p)***.\\n\\n>#### **One(n, p)**: the number of **p-binary-digit-integers ended by one** which is ***less than or equal to part(n, p)***.\\n\\n---\\nSince **a(1) is always 1**, and **\"0\" has been treated** in **Section 2.2.3**, define the **initial value** for **One(n, p)** and **Zero(n, p)** as\\n\\n---\\n>#### **One(n, 1) = 1.**\\n\\n>#### **Zero(n, 1) = 0.**\\n\\n---\\n##### 2.3.2 Find recursive relation of Zero(n, p) and One(n, p)\\n\\n---\\n>#### We can **attach 0 or 1 to an integer's Least Significant Bit (LSB)** and **make sure** the new integer has **no consecutive ones**, \\n\\n>#### if an integer with **p binary digits** is **less than or equal to part(n, p)**, \\n\\n>#### after attaching 0 or 1 to it, how can I make sure the new integer is **less than or equal to part(n, p + 1)**?\\n\\n>#### In this way, the problem is different to the one in **Section 2.2**.\\n\\n---\\nSuppose m is a **p-binary-digit-integer less than or equal to part(n, p)**, p \\u2265 2.\\n\\n>#### **m = m(1)m(2)...m(p-1)m(p) \\u2264 a(1)a(2)...a(p-1)a(p), p \\u2265 2.**\\n\\n---\\nAfter **attaching 0 or 1 to m's LSB**, according to **a(p), a(p + 1) and m(p)**, there are **several cases** below for us to discuss.\\n\\n**As the cases are complicated,  please read carefully.**\\n\\n---\\n**For 1 \\u2264 p < k**\\n\\n---\\n>#### **Case 1: a(p) = 1,  a(p+1) = 0**\\n\\n---\\n- **m(p) = 1: m = m(1)m(2)...m(p-1)1 \\u2264 a(1)a(2)...a(p-1)1 = part(n, p).**\\n    - **m(p + 1)  = 0:**\\n      **m' = m(1)m(2)...m(p-1)10 \\u2264 a(1)a(2)...a(p-1)10 = part(n, p + 1).**\\n\\n---\\n- **m(p) = 0: m = m(1)m(2)...m(p-1)0 < a(1)a(2)...a(p-1)1 = part(n, p).**\\n    - **m(p + 1)  = 0 :**\\n      **m' = m(1)m(2)...m(p-1)00 < a(1)a(2)...a(p-1)10 = part(n, p + 1).**\\n    - **m(p + 1)  = 1 :**\\n      **Although m(p + 1) > a(p + 1),**\\n      **since m(p) with higher significant is smaller than a(p),**\\n      **m' = m(1)m(2)...m(p-1)01 < a(1)a(2)...a(p-1)10 = part(n, p + 1).**\\n\\n---\\n>#### **Case 2: a(p) = 0, a(p+1) = 1**\\n\\n---\\n- **m(p) = 1 : m = m(1)m(2)...m(p-1)1 < a(1)a(2)...a(p-1)0 = part(n, p).**\\n  - **m(p + 1)  = 0 :**\\n  **m' = m(1)m(2)...m(p-1)10 < a(1)a(2)...a(p-1)00 < a(1)a(2)...a(p-1)01 = part(n, p + 1).**\\n\\n---\\n- **m(p) = 0 : m = m(1)m(2)...m(p-1)0 \\u2264 a(1)a(2)...a(p-1)0 = part(n, p).**\\n  - **m(p + 1)  = 0 :**\\n  **m' = m(1)m(2)...m(p-1)00 < a(1)a(2)...a(p-1)01 = part(n, p + 1).**\\n  - **m(p + 1)  = 1:**\\n  **m' = m(1)m(2)...m(p-1)01 \\u2264 a(1)a(2)...a(p-1)01 = part(n, p + 1).**\\n\\n---\\n>#### **Case 3: a(p) = 0, a(p+1) = 0**\\n\\n---\\n- **m(p) = 1 : m = m(1)m(2)...m(p-1)1 < a(1)a(2)...a(p-1)0 = part(n, p).**    \\n  - **m(p + 1)  = 0 :**\\n  **m' = m(1)m(2)...m(p-1)10 < a(1)a(2)...a(p-1)00 = part(n, p+1).**\\n\\n---\\n- **m(p) = 0 : m = m(1)m(2)...m(p-1)0 \\u2264 a(1)a(2)...a(p-1)0 = part(n, p).**\\n  - **m(p + 1)  = 0 :**\\n  **m' = m(1)m(2)...m(p-1)00 \\u2264 a(1)a(2)...a(p-1)00 = part(n, p+1).**\\n  - **m(p + 1)  = 1:**\\n  **m' = m(1)m(2)...m(p-1)01, part(n, p+1) = a(1)a(2)...a(p-1)00.**\\n  **Since m \\u2264 part(n, p) and have same LSB**,\\n  **If m = part(n, p), then m' > part(n, p+1).**\\n  **If m < part(n, p), then m' < part(n, p+1).**\\n  **After attaching 1 to LSB of m, *ONLY when m = part(n, p)*, m' doesn't meet the requirement**.\\n\\n---\\n>#### **Case 4: a(p) = 1, a(p+1) = 1**\\n\\n---\\n- **m(p) = 1 : m = m(1)m(2)...m(p-1)1 \\u2264 a(1)a(2)...a(p-1)1 = part(n, p).**\\n  - **m(p + 1)  = 0 :**\\n  **m' = m(1)m(2)...m(p-1)10 < a(1)a(2)...a(p-1)11 = part(n, p+1).**\\n\\n---\\n- **m(p) = 0 : m = m(1)m(2)...m(p-1)0 < a(1)a(2)...a(p-1)1 = part(n, p).**\\n  - **m(p + 1)  = 0 :**\\n  **m' = m(1)m(2)...m(p-1)00 < a(1)a(2)...a(p-1)11 = part(n, p+1).**\\n  - **m(p + 1)  = 1:**\\n  **m' = m(1)m(2)...m(p-1)01 < a(1)a(2)...a(p-1)11 = part(n, p+1).**\\n\\n---\\n**If case 4 happens, since m' < part(n, p + 1), the later m without **consecutive ones** will *ALWAYS* be smaller than part(n ,q), q > p + 1.**\\n\\n**We can directly use the formula in Section 2.2.2**.\\n\\n---\\nTill now, if \\n\\n>#### **n = a(1)a(2)a(3)...a(k), k \\u2265 2.**\\n\\n---\\nThe **recursive formula** for **Zero(n, p)** and **One(n, p), 1 \\u2264 p < k** is\\n\\n---\\nIf **a(p) \\u2260 a(p+1)**:\\n\\n- **Zero(n, p+1) = Zero(n, p) + One(n, p).**\\n\\n- **One(n, p+1) = Zero(n, p).**\\n\\n---\\nIf **a(p) = a(p+1) = 0**:\\n\\n- **Zero(n, p+1) = Zero(n, p) + One(n, p).**\\n\\n- **One(n, p+1) = Zero(n, p) - 1. (-1 for the ONLY ONE case m' > part(n, p + 1))**\\n\\n---\\nIf **a(p) = a(p+1) = 1**, **for all p \\u2264 q \\u2264 k**\\n\\n- **Zero(n, q+1) = Zero(n, q) + One(n, q).**\\n\\n- **One(n, q+1) = Zero(n, q).**\\n\\n---\\nThe number of **k-binary-digit-integers *less than or equal to n*** without **consecutive ones** is\\n\\n>#### **Zero(n, k) + One(n, k), k \\u2265 2**\\n\\n---\\n#### 2.4 Summarize\\n\\n---\\n**If k = 1** \\n\\n>#### **When n = 0, Total = 1.**\\n\\n>#### **When n = 1, Total = 2.**\\n\\n---\\n**If k \\u2265 2, the total number is**\\n\\n>#### **Total**\\n>#### **= 1 (stands for \"0\")**\\n>#### **+ One(1) + Zero(1)**\\n>#### **+ One(2) + Zero(2)**\\n>#### **+ ......**\\n>#### **+ One(k-1) + Zero(k-1)**\\n>#### **+ One(n, k) + Zero(n, k)**\\n\\n---\\n## 3. Complexity analysis\\n\\n---\\n#### 3.1 Time complexity\\n\\n---\\nSince the algothrim is divided into 2 parts\\n\\n>#### **Part 1: iterate from a(1) to a(k - 1)**\\n>#### **Part 2: iterate from a(1) to a(k)**\\n\\n> #### **The time complexity is O(k) = O(logn)**.\\n\\n---\\n#### 3.2 Space complexity\\n\\n---\\n> #### **Two size-k-arrays** are used to save **Zero(p), One(p) in Part 1**, and **Zero(n, p), One(n, p) in Part 2**.\\n\\n>#### **One size-k-array** is used to save **k binary digits of n**.\\n\\nthe total size is **3k**.\\n\\n> #### **The space complexity is O(k) = O(logn)**.\\n\\n---\\n## 4. Code\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    int findIntegers(int num) {\\n         if(num == 0) return 1;\\n         if(num == 1) return 2; \\n        \\n         //STEP 1         \\n         int digit = 0;\\n         while(num >= 1 << digit) digit++;\\n         \\n         int *digitsOfNum = new int[digit];\\n         int *zero = new int[digit];\\n         int *one = new int[digit];\\n         \\n         //not include 0 in DP\\n         zero[0] = 0;\\n         zero[1] = 1;\\n         one[0] = 1;\\n         one[1] = 0;\\n         \\n         int sum = 1; //include 0\\n         \\n         for(int i = 0; i < digit; i++)\\n         {\\n             if(i > 1) \\n             {\\n                 zero[i] = zero[i - 1] + zero[i - 2];\\n                 one[i] = one[i - 1] + one[i - 2];\\n             }\\n             if(i < digit - 1) sum += zero[i] + one[i];\\n             digitsOfNum[digit - 1 - i] = num % 2;\\n             num >>= 1;\\n         }        \\n         \\n         // STEP 2\\n         \\n         int i = 0;\\n         bool isValid = true;\\n         \\n         while(true)\\n         {\\n             if(i + 1 == digit)break;\\n             if(isValid)\\n             {\\n                 if(digitsOfNum[i] != digitsOfNum[i + 1])\\n                 {\\n                     zero[i + 1] = zero[i] + one[i];\\n                     one[i + 1] = zero[i];\\n                     i++;\\n                 }else{\\n                     if(digitsOfNum[i] == 1)\\n                     {\\n                         isValid = false;\\n                     }else{\\n                         zero[i + 1] = zero[i] + one[i];\\n                         one[i + 1] = zero[i] - 1;\\n                         i++;\\n                     }\\n                 }\\n             }else{\\n                 zero[i + 1] = zero[i] + one[i];\\n                 one[i + 1] = zero[i];\\n                 i++;\\n             }\\n         }\\n         \\n         return sum + zero[digit - 1] + one[digit - 1];\\n    }\\n};\\n```\\n---"
		},
		{
			"lc_ans_id":"103761",
			"view":"282",
			"top":"9",
			"title":"JAVA 31 ms DP Solution with Explanation",
			"vote":"1",
			"content":"Here I implement two DP arrays to record the intermediate information bit by bit of the binary represented input number.\\n\\ninclude[i]: the **i bit length target number (whose binary representations do NOT contain consecutive ones)**  **less than or equal to** the **first i th bit binary representation of the input number** (hard to understand? I will give you the example later)\\n\\nexclude[i]: **the i bit length target number larger than** the **first i th bit binary representation of the input number**. \\n\\n</br>\\n</br>\\nExample: Let's assume the input number is 13(1101)\\n    \\n    the initial state: include[0] = 1; exclude[0] = 0;\\n\\n    when i = 1, the first i th binary representation of the input number is 1\\n    include[1] = 2 (the include numbers are 0, 1);\\n    exclude[1] = 0; \\n\\n    when i = 2, the first i th binary representation of the input number is 01\\n    include[2] = 2 (the include numbers are 00, 01);\\n    exclude[2] = 1 (the exclude number is 10);\\n\\n    when i = 3, the first i th binary representation of the input number is 101\\n    include[3] = 4 (the include numbers are 000, 001, 010, 100, 101);\\n    exclude[3] = 0;\\n\\n    when i = 4, the first i th binary representation of the input number is 1101\\n    include[4] = 8 (the include numbers are 0000, 0001, 0010, 0100, 0101, 1000, 1001, 1010);\\n    exclude[4] = 0;\\n\\nIn conclusion: the recursive formula is as followed:\\n```\\n// Here the flag implys whether the i - 1 th bit of the input number is 0 or not,\\n// if the i - 1 th bit is '0' flag = true; else flag = false;\\n if((num & 1) == 1){\\n     include[i] = (exclude[i - 1] + include[i - 1]) /*(consider the i th bit of the include number is '0')*/  + (flag ? include[i - 1] : include[i - 2] + exclude[i - 2])/*(consider the i th bit of the include number is '1')*/;\\n     exclude[i] = flag ? exclude[i - 2] : 0; // consider the i th bit of the exclude number must be '1', as a result the i - 1 th bit of the exclude number must be '0' \\n     flag = false;\\n}\\nelse{\\n     include[i] = include[i - 1]; // consider i th bit of the include number is '0'\\n     exclude[i] = exclude[i - 1]  /* consider the i th bit of the exclude number is '0' */+ (include[i - 2] + exclude[i - 2]) /* consider the i th bit of the exclude number is '1'*/; \\n     flag = true;\\n}\\n```\\n\\nNow the full code is pasted:\\n\\n```\\npublic class Solution {\\n    public int findIntegers(int num) {\\n        if(num < 3){\\n            return num + 1;\\n        }\\n        \\n        int len = 1;\\n        int tmp = num;\\n        // get the bit length of the input number\\n        while(tmp / 2 > 0){\\n            len++;\\n            tmp /= 2;\\n        }\\n        \\n        int[] include = new int[len + 1];\\n        int[] exclude = new int[len + 1];\\n        boolean flag;\\n        \\n// initial state\\n        include[0] = 1;\\n        exclude[0] = 0;\\n        \\n        if((num & 1) == 1){\\n            include[1] = 2;\\n            exclude[1] = 0;\\n            flag = false;\\n        }\\n        else{\\n            include[1] = 1;\\n            exclude[1] = 1;\\n            flag = true;\\n        }\\n        \\n        \\n        \\n        for(int i = 2; i <= len; i++){\\n            num >>>= 1;\\n            if((num & 1) == 1){\\n                include[i] = exclude[i - 1] + include[i - 1] + (flag ? include[i - 1] : include[i - 2] + exclude[i - 2]);\\n                exclude[i] = flag ? exclude[i - 2] : 0;\\n                flag = false;\\n            }\\n            \\n            else{\\n                include[i] = include[i - 1];\\n                exclude[i] = exclude[i - 1] + include[i - 2] + exclude[i - 2]; \\n                \\n                flag = true;\\n            }\\n        }\\n         \\n        return include[len];\\n    }\\n}\\n```"
		}
	],
	"id":"579",
	"title":"Non-negative Integers without Consecutive Ones",
	"content":"<p>Given a positive integer n, find the number of <b>non-negative</b> integers less than or equal to n, whose binary representations do NOT contain <b>consecutive ones</b>.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> 5\r\n<b>Output:</b> 5\r\n<b>Explanation:</b> \r\nHere are the non-negative integers <= 5 with their corresponding binary representations:\r\n0 : 0\r\n1 : 1\r\n2 : 10\r\n3 : 11\r\n4 : 100\r\n5 : 101\r\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n1 <= n <= 10<sup>9</sup>\r\n</p>\r\n",
	"frequency":"81",
	"ac_num":"4854"
}