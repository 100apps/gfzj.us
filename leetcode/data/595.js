{
	"difficulty":"2",
	"submit_num":"19717",
	"show_id":"616",
	"leetcode_id":"616",
	"answers":[
		{
			"lc_ans_id":"104248",
			"view":"5123",
			"top":"0",
			"title":"Java Solution, boolean array",
			"vote":"33",
			"content":"Use a boolean array to mark if character at each position is bold or not. After that, things will become simple.\\n\\n```\\npublic class Solution {\\n    public String addBoldTag(String s, String[] dict) {\\n        boolean[] bold = new boolean[s.length()];\\n        for (int i = 0, end = 0; i < s.length(); i++) {\\n            for (String word : dict) {\\n                if (s.startsWith(word, i)) {\\n                    end = Math.max(end, i + word.length());\\n                }\\n            }\\n            bold[i] = end > i;\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (!bold[i]) {\\n                result.append(s.charAt(i));\\n                continue;\\n            }\\n            int j = i;\\n            while (j < s.length() && bold[j]) j++;\\n            result.append(\"<b>\" + s.substring(i, j) + \"</b>\");\\n            i = j - 1;\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"104263",
			"view":"2265",
			"top":"1",
			"title":"Java solution, Same as Merge Interval.",
			"vote":"14",
			"content":" Consider you have string  \\n\\t   s = \"aaabbcc\"\\n       dict = [\"aaa\",\"aab\",\"bc\"]\\n       \\n       you find the index of each string in dict, conver to an interval, you will get\\n       \\n       [[0, 3], [1, 4], [4, 6]]\\n         aaa     aab      bc\\n       then combine these intervals\\n       \\n       Ater merged, we got [0,6], so we know \"aaabbc\" needs to be surrounded by tag. \\n\\n\\n\\n```\\npublic String addBoldTag(String s, String[] dict) {\\n        List<Interval> intervals = new ArrayList<>();\\n        for (String str : dict) {\\n        \\tint index = -1;\\n        \\tindex = s.indexOf(str, index);\\n        \\twhile (index != -1) {\\n        \\t\\tintervals.add(new Interval(index, index + str.length()));\\n        \\t\\tindex +=1;\\n        \\t\\tindex = s.indexOf(str, index);\\n        \\t}\\n        }\\n        System.out.println(Arrays.toString(intervals.toArray()));\\n        intervals = merge(intervals);\\n        System.out.println(Arrays.toString(intervals.toArray()));\\n        int prev = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for (Interval interval : intervals) {\\n        \\tsb.append(s.substring(prev, interval.start));\\n        \\tsb.append(\"<b>\");\\n        \\tsb.append(s.substring(interval.start, interval.end));\\n        \\tsb.append(\"</b>\");\\n        \\tprev = interval.end;\\n        }\\n        if (prev < s.length()) {\\n        \\tsb.append(s.substring(prev));\\n        }\\n        return sb.toString();\\n    }\\n\\t\\n\\tclass Interval {\\n\\t\\tint start, end;\\n\\t\\tpublic Interval(int s, int e) {\\n\\t\\t\\tstart = s;\\n\\t\\t\\tend = e;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"[\" + start + \", \" + end + \"]\" ;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic List<Interval> merge(List<Interval> intervals) {\\n        if (intervals == null || intervals.size() <= 1) {\\n            return intervals;\\n        }\\n        Collections.sort(intervals, new Comparator<Interval>(){\\n            public int compare(Interval a, Interval b) {\\n                return a.start - b.start;\\n            }\\n        });\\n        \\n        int start = intervals.get(0).start;\\n        int end = intervals.get(0).end;\\n        List<Interval> res = new ArrayList<>();\\n        for (Interval i : intervals) {\\n            if (i.start <= end) {\\n                end = Math.max(end, i.end);\\n            } else {\\n                res.add(new Interval(start, end));\\n                start = i.start;\\n                end = i.end;\\n            }\\n        }\\n        res.add(new Interval(start, end));\\n        return res;\\n    }\\n```"
		},
		{
			"lc_ans_id":"104289",
			"view":"679",
			"top":"2",
			"title":"c++ code KMP+boolean array 26ms, Hashing + intervals 145ms, Trie + boolean array 160ms.",
			"vote":"10",
			"content":"Let string s.size() = m, dict.size() = k, longest word length in dict is n. The question has two parts. The first is to find occurrences of words in s and the second is how to tag given these occurrences. \\n* The first solution is to use KMP algorithm. For each word in dict, we search all occurrences of word in s, and use boolean array to tag. The time complexity is O(k(m + n)). The answer accepted in around 26ms.\\n```\\nclass Solution {\\npublic:\\n    vector<int> preprocessKMP(string& p, string& s) {\\n        vector<int> ret(p.size());//ret[i] means the longest proper prefix that is also a suffix in p[0...i]\\n        for (int i=1; i<p.size(); i++) {\\n            int len = ret[i-1];\\n            while ((len > 0) && (p[i] != p[len])) {\\n                len = ret[len - 1];\\n            }  \\n            if (p[i] == p[len]) {\\n                ret[i] = len + 1;\\n            }//else ret[i] == 0\\n        }\\n        return ret;\\n    }\\n    \\n    string addBoldTag(string s, vector<string>& dict) {\\n        if (s.size() == 0) {\\n            return s;\\n        }\\n        vector<bool> bold(s.size());\\n        for (auto word : dict) {\\n            //Do the kmp search for the pattern word in s\\n            vector<int> kmp = preprocessKMP(word, s);\\n            int idx = 0;\\n            int last = -1;\\n            for (int i=0; i<s.size(); i++) {\\n                if (word[idx] == s[i]) {\\n                    idx++;\\n                } else {\\n                    while ((idx > 0) && (s[i] != word[idx])) {\\n                        idx = kmp[idx - 1];\\n                    }\\n                    if (word[idx] == s[i]) {\\n                        idx++;\\n                    }                    \\n                }\\n                if (idx == kmp.size()) {\\n                    int start = max(last + 1, i - (int)kmp.size() + 1);\\n                    fill(bold.begin() + start, bold.begin() + i + 1, true);\\n                    last = i;\\n                    idx = kmp[idx - 1];\\n                }\\n            }\\n        }\\n        //Tag string s using boolean array bold\\n        string ret;\\n        bool state = true;\\n        for (int i=0; i<s.size(); i++) {\\n            if (state && bold[i]) {\\n                ret += \"<b>\";\\n                state = false;\\n            } else if (!state && !bold[i]) {\\n                ret += \"</b>\";\\n                state = true;\\n            }\\n            ret.push_back(s[i]);\\n        }\\n        if (!state) {\\n            ret += \"</b>\";\\n        }\\n        return ret;        \\n    }\\n};\\n```\\n\\n* The second solution is to use hashing + interval merging. Simply enumerate all possible substrings (double for-loops) and to check if it is in dict by hashing, then merge it into pos arrays, which stores the intervals need to be bold. Time complexity in average is O(m^2 + kn), first term for substrings enumeration, second term for hash map building. Accepted in around 1100ms. \\nHowever, we can improve it a little bit.  When enumerating the substrings starting at s[i], we only have to enumerate the ending char from s[i] + (maxLength of word in dict) down to s[i+1]. The time complexity is now O(mn + kn). Accepted in around 145ms.\\n```\\nclass Solution {\\npublic:\\n    string addBoldTag(string s, vector<string>& dict) {\\n        if (s.size() == 0) {\\n            return s;\\n        }\\n        unordered_set<string> hash;\\n        vector<pair<int, int>> pos;\\n        int maxLen = 0;\\n        //Build hash map\\n        for (auto word : dict) {\\n            hash.insert(word);\\n            maxLen = max(maxLen, (int)word.size());\\n        }\\n        //Enumerate substrings and record tag intervals\\n        for (int i = 0; i < s.size(); i++) {\\n            int end = min(i + maxLen - 1, (int)s.size() - 1);\\n            string t = string(s.begin() + i, s.begin() + end + 1);\\n            int start = (pos.size() > 0) ? pos.back().second + 1 : -1;\\n            start = max(i, start);\\n            //Enumerate substrings starting at s[i], ending char is in s[start...end]\\n            for (int j = end; j >= start; j--) {\\n                if (hash.find(t) != hash.end()) {\\n                    pair<int, int> p = {i, j};\\n                    if ((pos.size() == 0) || (i > pos.back().second + 1)) {\\n                        pos.push_back(p);\\n                    } else {\\n                        pos.back().second = j;\\n                    }\\n                    break;\\n                }\\n                t.pop_back();\\n            }\\n        }\\n        //Tagging intervals\\n        if (pos.size() == 0) {\\n            return s;\\n        }\\n        string ret = (pos[0].first > 0) ? string(s.begin(), s.begin() + pos[0].first) : \"\";\\n        for (int i=0; i<pos.size(); i++) {\\n            ret += \"<b>\";\\n            ret += string(s.begin() + pos[i].first, s.begin() + pos[i].second + 1);\\n            ret += \"</b>\";\\n            if (i < pos.size() - 1) {\\n                ret += string(s.begin() + pos[i].second + 1, s.begin() + pos[i+1].first);\\n            }\\n        }\\n        if (pos.back().second < s.size() - 1) {\\n            ret += string(s.begin() + pos.back().second + 1, s.end());\\n        }\\n        return ret;\\n    }\\n};\\n```\\n* The third solution using trie + boolean array solution. Build up a trie on the words in dict. Then for each index i in s, find the longest substring that matches words in trie and mark all the chars in this substring so that we know how to add the bold tag. The time complexity is O(kn + mn). The first term is the time to build a trie, the second term is the time for searching substrings of s in the trie. The solution is accepted in around 160ms.\\n ```\\nstruct Node {\\n    bool isEnd;\\n    unordered_map<char, Node*> children;   \\n    Node() : isEnd() {}\\n};\\n\\nclass Trie {\\n    Node* root;\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n    \\n    void add(string& s) {\\n        Node* node = root;\\n        int idx = 0;\\n        while (idx < s.size()) {\\n            if (node->children.find(s[idx]) == node->children.end()) {\\n                Node* newNode = new Node();\\n                node->children[s[idx]] = newNode;\\n            }\\n            node = node->children[s[idx]];\\n            idx++;\\n        }\\n        node->isEnd = true;\\n    }\\n    \\n    int search(int idx, string& s) {\\n        Node* node = root;\\n        int ret = -1;\\n        while (idx < s.size()) {\\n            if (node->children.find(s[idx]) == node->children.end()) {\\n                return ret;\\n            }\\n            node = node->children[s[idx]];\\n            if (node->isEnd) {\\n                ret = idx;\\n            }            \\n            idx++;\\n        }\\n        return ret;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string addBoldTag(string s, vector<string>& dict) {\\n        if (s.size() == 0) {\\n            return s;\\n        }\\n        vector<bool> bold(s.size());\\n        //Build a trie\\n        Trie trie;\\n        for (auto word : dict) {\\n            trie.add(word);\\n        }\\n        //Search in s, mark bold array\\n        for (int i=0; i<s.size(); i++) {\\n            int idx = trie.search(i, s);\\n            for (int j=i; j<=idx; j++) {\\n                bold[j] = true;\\n            }\\n        }\\n        //Tag using boolean array\\n        bool state = true;\\n        string ret;\\n        for (int i=0; i<s.size(); i++) {\\n            if (state && bold[i]) {\\n                ret += \"<b>\";\\n                state = false;\\n            } else if (!state && !bold[i]) {\\n                ret += \"</b>\";\\n                state = true;\\n            }\\n            ret.push_back(s[i]);\\n        }\\n        if (!state) {\\n            ret += \"</b>\";\\n        }\\n        return ret;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"104262",
			"view":"1074",
			"top":"3",
			"title":"short java solution",
			"vote":"8",
			"content":"```\\n    public String addBoldTag(String s, String[] dict) {\\n        int n = s.length();\\n        int[] mark = new int[n+1];\\n        for(String d : dict) {\\n            int i = -1;\\n            while((i = s.indexOf(d, i+1)) >= 0) {\\n                mark[i]++;\\n                mark[i + d.length()]--;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int sum = 0;\\n        for(int i = 0; i <= n; i++) {\\n            int cur = sum + mark[i];\\n            if (cur > 0 && sum == 0) sb.append(\"<b>\");\\n            if (cur == 0 && sum > 0) sb.append(\"</b>\");\\n            if (i == n) break;\\n            sb.append(s.charAt(i));\\n            sum = cur;\\n        }\\n        return sb.toString();\\n    }\\n```"
		},
		{
			"lc_ans_id":"104295",
			"view":"611",
			"top":"4",
			"title":"[C++] Clean Code - Merge Intevals",
			"vote":"5",
			"content":"```\\nclass Solution {\\npublic:\\n    string addBoldTag(string s, vector<string>& dict) {\\n        vector<pair<int, int>> ranges = findpairs(s, dict);\\n        ranges = merge(ranges);\\n        for (auto it = ranges.rbegin(); it != ranges.rend(); it++) {\\n            s.insert(it->second, \"</b>\");\\n            s.insert(it->first, \"<b>\");\\n        }\\n        return s;\\n    }\\n\\nprivate:\\n    vector<pair<int, int>> findpairs(string s, vector<string>& dict) {\\n        vector<pair<int, int>> res;\\n        for (string w : dict) {\\n            int n = w.size();\\n            for (int i = 0; (i = s.find(w, i)) != string::npos; i++) {\\n                res.push_back(pair<int, int>(i, i + n));\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<pair<int, int>> merge(vector<pair<int, int>>& a) {\\n        vector<pair<int, int>> r;\\n        sort(a.begin(), a.end(), compare);\\n        for (int i = 0, j = -1; i < a.size(); i++) {\\n            if (j < 0 || a[i].first > r[j].second) {\\n                r.push_back(a[i]);\\n                j++;\\n            }\\n            else {\\n                r[j].second = max(r[j].second, a[i].second);\\n            }\\n        }\\n        \\n        return r;\\n    }\\n\\n    static bool compare(pair<int, int>& a, pair<int, int>& b) {\\n        return a.first < b.first || a.first == b.first && a.second < b.second;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"104297",
			"view":"610",
			"top":"5",
			"title":"Java Parsing Solution",
			"vote":"4",
			"content":"```\\npublic static String addBoldTag(String s, String[] dict) {\\n    int n = s.length();\\n    boolean[] marked = new boolean[n];\\n    for (String word : dict) {\\n        int m = word.length();\\n        for (int i=0;i<=n-m;i++) \\n            if (s.substring(i, i + m).equals(word)) \\n                for (int j=i;j<i+m;j++) marked[j] = true;\\n    }\\n    \\n    int i = 0;\\n    StringBuilder res = new StringBuilder();\\n    while (i < n) {\\n        if (marked[i]) {             \\n          int j = i;\\n          while (j < n && marked[j]) j++;\\n          res.append(\"<b>\").append(s.substring(i,j)).append(\"</b>\");\\n          i = j;                 \\n        }\\n        else res.append(s.charAt(i++));\\n    }\\n    \\n    return res.toString();   \\n    \\n}\\n```"
		},
		{
			"lc_ans_id":"104281",
			"view":"239",
			"top":"6",
			"title":"19ms One-pass C++ solution with classify and sort",
			"vote":"3",
			"content":"Classify dict elements by first character and sort them by length first.\\nOne pass, match dict elements start with current character in descending order by length.\\nUse left and right to store current bold interval, use _left to store the left end of current not bold interval.\\n```\\nclass Solution {\\npublic:\\n    string addBoldTag(string s, vector<string>& dict) {\\n        vector<pair<int,int>> d[128];\\n        int len = dict.size(), cur, goal;\\n        int sl = s.size();\\n        for (int i = 0 ; i < len; ++i){\\n            d[dict[i][0]].push_back({dict[i].size(),i});\\n        }\\n        for (int i = 0; i < 128; ++i){\\n            sort(d[i].begin(),d[i].end(),greater<pair<int,int>>());\\n        }\\n        int left = -1, right = -1, _left = 0;\\n        stringstream ans;\\n        for (int i = 0; i < sl; ++i){\\n            cur = 0;\\n            goal = right + 1 - i;\\n            for (auto & j : d[s[i]]){\\n                if (left != -1 && j.first < goal)\\n                    break;\\n                if (s.substr(i,j.first) == dict[j.second]){\\n                    cur = j.first;\\n                    break;\\n                }\\n            }\\n            if (cur){\\n                right = i + cur - 1;\\n                if (left == -1){\\n                    left = i;\\n                    if (left > _left)\\n                        ans << s.substr(_left,left-_left);\\n                }\\n            } else if (left != -1 && i > right){\\n                _left = right + 1;\\n                ans << \"<b>\";\\n                ans << s.substr(left,right-left+1);\\n                ans << \"</b>\";\\n                left = -1;\\n            }\\n        }\\n        if (left != -1) {\\n            ans << \"<b>\";\\n            ans << s.substr(left);\\n            ans << \"</b>\";\\n        }\\n        else\\n            ans << s.substr(_left);\\n        return ans.str();\\n    }\\n};\\n````"
		},
		{
			"lc_ans_id":"104269",
			"view":"664",
			"top":"7",
			"title":"Python, Straightforward with Explanation",
			"vote":"2",
			"content":"We put all the words in our given wordlist into a trie.  Then, let's paint any letter in our string that should be bolded.  For every starting position ```i``` in our string, let's find the longest word that ```S[i:]``` starts with, and paint ```S[i:i+len(word)]```.  \\n\\nAfterwards, we have a boolean array where ```paint[i] = True``` iff ```S[i]``` is bolded.  Let's write our letters from left to right.  If we are on a bolded letter and there is an unbolded letter to the left (or if we are at the leftmost letter), we should start a ```<b>``` tag.  Similarly for ```</b>``` tags: they start when our bolded letter has an unbolded right neighbor (or we are at the right-most letter.)\\n\\n```\\ndef addBoldTag(self, S, A):\\n    END = False\\n    _trie = lambda: collections.defaultdict(_trie)\\n    trie = _trie()\\n    \\n    for word in A:\\n        cur = trie\\n        for letter in word:\\n            cur = cur[letter]\\n        cur[END] = END\\n    \\n    paint = [False] * len(S)\\n    for i in xrange(len(S)):\\n        cur = trie\\n        end = i\\n        for j in xrange(i, len(S)):\\n            if S[j] not in cur: break\\n            cur = cur[S[j]]\\n            if END in cur:\\n                end = j + 1\\n        paint[i:end] = [True] * (end - i)\\n    \\n    ans = []\\n    for i, u in enumerate(S):\\n        if paint[i] and (i == 0 or not paint[i-1]):\\n            ans.append('<b>')\\n        ans.append(u)\\n        if paint[i] and (i == len(S) - 1 or not paint[i+1]):\\n            ans.append('</b>')\\n        \\n    return \"\".join(ans)\\n```\\n\\nAlternatively, for a simpler but slower idea, we could check if each word starts at each position.\\n\\n```\\ndef addBoldTag(self, S, A): \\n    paint = [False] * len(S)\\n    for i in xrange(len(S)):\\n        block = S[i:]\\n        for word in A:\\n            if block.startswith(word):\\n                paint[i:i+len(word)] = [True] * len(word)\\n\\n    ans = []\\n    for i, u in enumerate(S):\\n        if paint[i] and (i == 0 or not paint[i-1]):\\n            ans.append('<b>')\\n        ans.append(u)\\n        if paint[i] and (i == len(S) - 1 or not paint[i+1]):\\n            ans.append('</b>')\\n        \\n    return \"\".join(ans)\\n```"
		},
		{
			"lc_ans_id":"104255",
			"view":"152",
			"top":"8",
			"title":"easy java solution with explanation beats 80%",
			"vote":"1",
			"content":"```\\npublic String addBoldTag(String s, String[] dict) {\\n        StringBuilder res = new StringBuilder(s);\\n        int n = s.length();\\n        // use boolean[] inDict   to record which char in the string is contained in at least one dict word\\n        boolean[] inDict = new boolean[n];\\n        StringBuilder sb = new StringBuilder(s);\\n        for(String word : dict) {\\n            int index = sb.indexOf(word);\\n            while(index != -1) {\\n                sb.setCharAt(index,' ');\\n                for(int i = 0; i < word.length(); i++) {\\n                    inDict[i + index] = true;\\n                }\\n                index = sb.indexOf(word);\\n            }\\n            sb = new StringBuilder(s);\\n        }\\n        // use st to record how the insert index is affected by <b>(3 chars) and </b>(4 chars)\\n        int i = 0, j = 0,st = 0;\\n        while(i < n && j < n) {\\n            while(i < n && !inDict[i]) i++;\\n            if(i == n) break;\\n            j = i + 1;\\n            while(j < n && inDict[j]) j++; \\n            res.insert(i + st,\"<b>\");\\n            res.insert(j + st + 3,\"</b>\");\\n            i = j + 1;\\n            st += 7;\\n        }\\n        return res.toString();\\n    }"
		},
		{
			"lc_ans_id":"104246",
			"view":"13",
			"top":"9",
			"title":"My Java Solution using an int array",
			"vote":"0",
			"content":"Please find the inline explanation in the code\\n```\\nclass Solution {\\n    public String addBoldTag(String s, String[] dict) {\\n        if (s==null || s.length()==0) {\\n            return s;\\n        } else {\\n            StringBuilder sb = new StringBuilder();\\n            // ranges[i]=The maximum length of the string that matches the substring of s starting from i\\n            int[] ranges = new int[s.length()];\\n            // curEnd=The first idx beyond the currently 'covered' range. \\n            // A range of string s is covered if it's enclosed within a pair of <b></b>\\n            int curEnd = -1;\\n            \\n            for (int idx = 0; idx < s.length(); idx++) {\\n                for (String w:dict) {\\n                    if (s.startsWith(w, idx)) {\\n                        ranges[idx] = Math.max(ranges[idx], w.length());\\n                    }\\n                }\\n            }\\n            for (int idx = 0; idx < ranges.length; idx++) {\\n                if (idx <= curEnd) {\\n                    if (idx == curEnd) {\\n                        // If idx is the first index right after the currently covered range,\\n                        // then we should check if the substring starting from idx has a matched word in dict,\\n                        // i.e., check whether ranges[idx]>0 or not.\\n                        // If ranges[idx]>0, then the substring starting from idx has a matched word, and we should\\n                        // extend the covered range.\\n                        // Otherwise, we should enclose the current cover range with </b>\\n                        // Finally, we should append the current character to our new string\\n                        if (ranges[idx] > 0) {\\n                            curEnd = idx+ranges[idx];\\n                        } else {\\n                            sb.append(\"</b>\");\\n                        }\\n                    } else {\\n                        // If idx is still within the current cover range, then we should try to extend\\n                        // the current cover range, and append the current character to the new string.\\n                        curEnd = Math.max(curEnd, idx+ranges[idx]);\\n                    }\\n                } else {\\n                    if (ranges[idx] > 0) {\\n                        // idx is already beyond the current cover range, and even beyond the first index after \\n                        // the current cover range. In this case, we should check whether idx is the start\\n                        // of a new cover range by checking whether ranges[idx] is zero or not.\\n                        // If ranges[idx]>0, then idx is the start of a new cover range, and we should first \\n                        // append a <b> to our new string, and then update curEnd. Finally, we should append the \\n                        // current character to the new string.\\n                        sb.append(\"<b>\");\\n                        curEnd = idx+ranges[idx];\\n                    } // Otherwise, we just need to append the current character to our new string\\n                }\\n                // In all cases, the current character needs to be appended. So we can do it in the end, with one shot.\\n                sb.append(s.charAt(idx));\\n            }\\n            if (curEnd == ranges.length) {\\n                // enclose the cover range at the end of the string\\n                sb.append(\"</b>\");\\n            }\\n            \\n            return sb.toString();\\n        }\\n    }\\n}\\n```"
		}
	],
	"id":"595",
	"title":"Add Bold Tag in String",
	"content":"Given a string <b>s</b> and a list of strings <b>dict</b>, you need to add a closed pair of bold tag <code>&lt;b&gt;</code> and <code>&lt;/b&gt;</code> to wrap the substrings in s that exist in dict. If two such substrings overlap, you need to wrap them together by only one pair of closed bold tag. Also, if two substrings wrapped by bold tags are consecutive, you need to combine them. \r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\ns = \"abcxyz123\"\r\ndict = [\"abc\",\"123\"]\r\n<b>Output:</b>\r\n\"&lt;b&gt;abc&lt;/b&gt;xyz&lt;b&gt;123&lt;/b&gt;\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\ns = \"aaabbcc\"\r\ndict = [\"aaa\",\"aab\",\"bc\"]\r\n<b>Output:</b>\r\n\"&lt;b&gt;aaabbc&lt;/b&gt;c\"\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The given dict won't contain duplicates, and its length won't exceed 100.</li>\r\n<li>All the strings in input have length in range [1, 1000]. </li>\r\n</ol>\r\n</p>",
	"frequency":"80",
	"ac_num":"7683"
}