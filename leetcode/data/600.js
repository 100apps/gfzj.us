{
	"difficulty":"2",
	"submit_num":"56786",
	"show_id":"621",
	"leetcode_id":"621",
	"answers":[
		{
			"lc_ans_id":"104496",
			"view":"23424",
			"top":"0",
			"title":"concise Java Solution O(N) time O(26) space",
			"vote":"89",
			"content":"```\\n// (c[25] - 1) * (n + 1) + 25 - i  is frame size\\n// when inserting chars, the frame might be \"burst\", then tasks.length takes precedence\\n// when 25 - i > n, the frame is already full at construction, the following is still valid.\\npublic class Solution {\\n    public int leastInterval(char[] tasks, int n) {\\n\\n        int[] c = new int[26];\\n        for(char t : tasks){\\n            c[t - 'A']++;\\n        }\\n        Arrays.sort(c);\\n        int i = 25;\\n        while(i >= 0 && c[i] == c[25]) i--;\\n\\n        return Math.max(tasks.length, (c[25] - 1) * (n + 1) + 25 - i);\\n    }\\n}\\n```\\nFirst consider the most frequent characters, we can determine their relative positions first and use them as a frame to insert the remaining less frequent characters. Here is a proof by construction:\\n\\nLet F be the set of most frequent chars with frequency k.\\nWe can create k chunks, each chunk is identical and is a string consists of chars in F in a specific fixed order.\\nLet the heads of these chunks to be H_i; then H_2 should be at least n chars away from H_1, and so on so forth; then we insert the less frequent chars into the gaps between these chunks sequentially one by one ordered by frequency in a decreasing order and try to fill the k-1 gaps as full or evenly as possible each time you insert a character. **In summary, append the less frequent characters to the end of each chunk of the first k-1 chunks sequentially and round and round, then join the chunks and keep their heads' relative distance from each other to be at least n**.\\n\\nExamples:\\n\\nAAAABBBEEFFGG 3\\n\\nhere X represents a space gap:\\n\\n    Frame: \"AXXXAXXXAXXXA\"\\n    insert 'B': \"ABXXABXXABXXA\" <--- 'B' has higher frequency than the other characters, insert it first.\\n    insert 'E': \"ABEXABEXABXXA\"\\n    insert 'F': \"ABEFABEXABFXA\" <--- each time try to fill the k-1 gaps as full or evenly as possible.\\n    insert 'G': \"ABEFABEGABFGA\"\\n\\nAACCCBEEE 2\\n\\n    3 identical chunks \"CE\", \"CE CE CE\" <-- this is a frame\\n    insert 'A' among the gaps of chunks since it has higher frequency than 'B' ---> \"CEACEACE\"\\n    insert 'B' ---> \"CEABCEACE\" <----- result is tasks.length;\\n\\nAACCCDDEEE 3\\n\\n    3 identical chunks \"CE\", \"CE CE CE\" <--- this is a frame.\\n    Begin to insert 'A'->\"CEA CEA CE\"\\n    Begin to insert 'B'->\"CEABCEABCE\" <---- result is tasks.length;\\n\\nACCCEEE 2\\n\\n    3 identical chunks \"CE\", \"CE CE CE\" <-- this is a frame\\n    Begin to insert 'A' --> \"CEACE CE\" <-- result is (c[25] - 1) * (n + 1) + 25 -i = 2 * 3 + 2 = 8"
		},
		{
			"lc_ans_id":"104501",
			"view":"10261",
			"top":"1",
			"title":"Java PriorityQueue solution - Similar problem Rearrange string K distance apart",
			"vote":"31",
			"content":"\\nThe idea used here is similar to - https://leetcode.com/problems/rearrange-string-k-distance-apart\\nWe need to arrange the characters in string such that each same character is K distance apart, where distance in this problems is time b/w two similar task execution.\\n\\nIdea is to add them to a priority Q and sort based on the highest frequency. \\nAnd pick the task in each round of 'n' with highest frequency. As you pick the task, decrease the frequency, and put them back after the round.\\n\\n    public int leastInterval(char[] tasks, int n) {\\n         Map<Character, Integer> map = new HashMap<>();\\n        for (int i = 0; i < tasks.length; i++) {\\n            map.put(tasks[i], map.getOrDefault(tasks[i], 0) + 1); // map key is TaskName, and value is number of times to be executed.\\n        }\\n        PriorityQueue<Map.Entry<Character, Integer>> q = new PriorityQueue<>( //frequency sort\\n                (a,b) -> a.getValue() != b.getValue() ? b.getValue() - a.getValue() : a.getKey() - b.getKey());\\n\\n        q.addAll(map.entrySet());\\n\\n        int count = 0;\\n        while (!q.isEmpty()) {\\n            int k = n + 1;\\n            List<Map.Entry> tempList = new ArrayList<>();\\n            while (k > 0 && !q.isEmpty()) {\\n                Map.Entry<Character, Integer> top = q.poll(); // most frequency task\\n                top.setValue(top.getValue() - 1); // decrease frequency, meaning it got executed\\n                tempList.add(top); // collect task to add back to queue\\n                k--;\\n                count++; //successfully executed task\\n            }\\n\\n            for (Map.Entry<Character, Integer> e : tempList) {\\n                if (e.getValue() > 0) q.add(e); // add valid tasks \\n            }\\n\\n            if (q.isEmpty()) break;\\n            count = count + k; // if k > 0, then it means we need to be idle\\n        }\\n        return count;\\n    }"
		},
		{
			"lc_ans_id":"104507",
			"view":"4668",
			"top":"2",
			"title":"Python, Straightforward with Explanation",
			"vote":"27",
			"content":"```\\ndef leastInterval(self, tasks, N):\\n    task_counts = collections.Counter(tasks).values()\\n    M = max(task_counts)\\n    Mct = task_counts.count(M)\\n    return max(len(tasks), (M - 1) * (N + 1) + Mct)\\n```\\n\\nLet's say the most frequent tasks occur ```M``` times, and there are ```Mct``` of them.\\n\\nWhen ```N > Mct```, let's make our scheduling constraint strictly stronger by choosing ```N = Mct```.  So from now on, let's suppose ```Mct <= N```, and the most frequent tasks are denoted #A, #B, #C, ... #K.  \\n\\nThen we could schedule say, ABC...K__..._ABC...K__..._ABC...K__....., where A...K occurs ```Mct``` times, ```_``` denotes idle time, and there is ```N``` space between ```A```'s.  This partial schedule would have length ```L = (M-1) * (N+1) + Mct```.  Clearly, we need at least L intervals of time in our schedule to fit our given tasks.  Let's show this is enough.\\n\\nStart inserting the remaining similar tasks in the following 'writing' order:\\n* The first space to the right of the first K\\n* The first space to the right of the second K\\n* ...\\n* The first space to the right of the last K\\n* The second space to the right of the first K\\n* ...\\n* The second space to the right of the last K\\n* The third space to the right of the first K\\n* ....\\n\\nFor example, say we have A B C 1 4 7 10 A B C 2 5 8 11 A B C 3 6 9 12 A B C D.\\nThe numbers denote idle time in the order we will insert.\\nIf we have EEEFFGGHHJJK left, we would insert:\\nA B C E F G J A B C E F H J A B C E G H K A B C D\\n\\nSay two tasks of the same type *collide* if they are scheduled within ```N``` time of each other.  After we have inserted all tasks of frequency ```M - 1``` (which clearly will not collide), other tasks of frequency lower than ```M - 1``` will never have any task written collide with it's left-neighbor (because of the writing order), and the last task written does not collide with the first task written as they are at least ```2N - 1``` apart.\\n\\nIf ```len(tasks) <= L```, this proves that an ```L```-length schedule satisfies.\\n\\nWhen ```len(tasks) > L```, clearly we need at least ```len(tasks)``` intervals of time to schedule all tasks - one interval for each task.  Let's insert remaining tasks as before, possibly having one task incomplete.  For example, we might have A B C E F G J A B C E F H J A B C E G H K A B C D, with KLLMMNNOO left to insert - and K is incomplete.  Our strategy will now be to insert these tasks into our compact schedule.\\n\\nOur incomplete task (K in our example) can be completed by inserting tasks K in the writing order spots that preceded it.  For example, if we wrote J 10th, J 11th, and K 12th, then the positions 11 and 10 are suitable to add K without collision (and numerous enough to permit adding them all).  Now with our remaining tasks, say LL, we will insert in the 1st, N+1th, (and 2N+1th, 3N+1th, etc. if necessary) positions in schedule order.\\n\\nSo we've shown that the answer is ```max(len(tasks), L)```."
		},
		{
			"lc_ans_id":"104504",
			"view":"6292",
			"top":"3",
			"title":"C++ 8lines O(n)",
			"vote":"25",
			"content":"```\\nclass Solution {\\npublic:\\n    int leastInterval(vector<char>& tasks, int n) {\\n        unordered_map<char,int>mp;\\n        int count = 0;\\n        for(auto e : tasks)\\n        {\\n            mp[e]++;\\n            count = max(count, mp[e]);\\n        }\\n        \\n        int ans = (count-1)*(n+1);\\n        for(auto e : mp) if(e.second == count) ans++;\\n        return max((int)tasks.size(), ans);\\n    }\\n};"
		},
		{
			"lc_ans_id":"104493",
			"view":"5582",
			"top":"4",
			"title":"[C++] [Java] Clean Code - Priority Queue",
			"vote":"18",
			"content":"The idea is:\\n0. To work on the same task again, CPU has to wait for time ``n``, therefore we can think of as if there is a ``cycle``, of ``time n+1``, regardless whether you schedule some other task in the cycle or not.\\n1. To avoid leave the CPU with limited choice of tasks and having to sit there cooling down frequently at the end, it is critical the keep the diversity of the task pool for as long as possible.\\n2. In order to do that, we should try to schedule the CPU to ``always try round robin between the most popular tasks at any time``.\\n\\n**priority_queue<``task``, ``count``>**\\n```\\nclass Solution {\\npublic:\\n    int leastInterval(vector<char>& tasks, int n) {\\n        unordered_map<char, int> counts;\\n        for (char t : tasks) {\\n            counts[t]++;\\n        }\\n        priority_queue<pair<int, char>> pq;\\n        for (pair<char, int> count : counts) {\\n            pq.push(make_pair(count.second, count.first));\\n        }\\n        int alltime = 0;\\n        int cycle = n + 1;\\n        while (!pq.empty()) {\\n            int time = 0;\\n            vector<pair<int, char>> tmp;\\n            for (int i = 0; i < cycle; i++) {\\n                if (!pq.empty()) {\\n                    tmp.push_back(pq.top());\\n                    pq.pop();\\n                    time++;\\n                }\\n            }\\n            for (auto t : tmp) {\\n                if (--t.first) {\\n                    pq.push(t);\\n                }\\n            }\\n            alltime += !pq.empty() ? cycle : time;\\n        }\\n        return alltime;\\n    }\\n};\\n```\\n**priority_queue<``count``>**\\nAs @milu point out, we don't really need to store <task - count> pair in the priority_queue, we don't need to know the task name, store counts works good enough:\\n```\\nclass Solution {\\npublic:\\n    int leastInterval(vector<char>& tasks, int n) {\\n        unordered_map<char, int> counts;\\n        for (char t : tasks) {\\n            counts[t]++;\\n        }\\n        priority_queue<int> pq;\\n        for (pair<char, int> count : counts) {\\n            pq.push(count.second);\\n        }\\n        int alltime = 0;\\n        int cycle = n + 1;\\n        while (!pq.empty()) {\\n            int time = 0;\\n            vector<int> tmp;\\n            for (int i = 0; i < cycle; i++) {\\n                if (!pq.empty()) {\\n                    tmp.push_back(pq.top());\\n                    pq.pop();\\n                    time++;\\n                }\\n            }\\n            for (int cnt : tmp) {\\n                if (--cnt) {\\n                    pq.push(cnt);\\n                }\\n            }\\n            alltime += !pq.empty() ? cycle : time;\\n        }\\n        return alltime;\\n    }\\n};\\n```\\n\\n**Java Version**\\n```\\npublic class Solution {\\n    public int leastInterval(char[] tasks, int n) {\\n        Map<Character, Integer> counts = new HashMap<Character, Integer>();\\n        for (char t : tasks) {\\n            counts.put(t, counts.getOrDefault(t, 0) + 1);\\n        }\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        pq.addAll(counts.values());\\n\\n        int alltime = 0;\\n        int cycle = n + 1;\\n        while (!pq.isEmpty()) {\\n            int worktime = 0;\\n            List<Integer> tmp = new ArrayList<Integer>();\\n            for (int i = 0; i < cycle; i++) {\\n                if (!pq.isEmpty()) {\\n                    tmp.add(pq.poll());\\n                    worktime++;\\n                }\\n            }\\n            for (int cnt : tmp) {\\n                if (--cnt > 0) {\\n                    pq.offer(cnt);\\n                }\\n            }\\n            alltime += !pq.isEmpty() ? cycle : worktime;\\n        }\\n        \\n        return alltime;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"104500",
			"view":"1498",
			"top":"5",
			"title":"Java O(n) time O(1) space 1 pass, no sorting solution with detailed explanation",
			"vote":"17",
			"content":"The key is to find out how many idles do we need.\\nLet's first look at how to arrange them. it's not hard to figure out that we can do a \"greedy arrangement\": always arrange task with most frequency first.\\nE.g. we have following tasks : 3 A, 2 B, 1 C. and we have n = 2. According to what we have above, we should first arrange A, and then B and C. Imagine there are \"slots\" and we need to arrange tasks by putting them into \"slots\". Then A should be put into slot 0, 3, 6 since we need to have at least n = 2 other tasks between two A. After A put into slots, it looks like this:\\n\\nA ? ? A ? ? A\\n\"?\" is \"empty\" slots.\\n\\nNow we can use the same way to arrange B and C. The finished schedule should look like this:\\n\\nA B C A B # A\\n\"#\" is idle\\n\\nNow we have a way to arrange tasks. But the problem only asks for number of CPU intervals, so we don't need actually arrange them. Instead we only need to get the total idles we need and the answer to problem is just number of idles + number of tasks.\\nSame example: 3 A, 2 B, 1 C, n = 2. After arranging A, we have:\\nA ? ? A ? ? A\\nWe can see that A separated slots into (count(A) - 1) = 2 parts, each part has length n. With the fact that A is the task with most frequency, it should need more idles than any other tasks. **In this case if we can get how many idles we need to arrange A, we will also get number of idles needed to arrange all tasks.** Calculating this is not hard, we first get number of parts separated by A: partCount = count(A) - 1; then we can know number of empty slots: emptySlots = partCount * n; we can also get how many tasks we have to put into those slots: availableTasks = tasks.length - count(A). Now if we have emptySlots > availableTasks which means we have not enough tasks available to fill all empty slots, we must fill them with idles. Thus we have **idles = max(0, emptySlots - availableTasks);**\\nAlmost done. One special case: what if there are more than one task with most frequency? OK, let's look at another example: 3 A 3 B 2 C 1 D,  n = 3\\nSimilarly we arrange A first:\\nA ? ? ? A ? ? ? A\\nNow it's time to arrange B, we find that we have to arrange B like this:\\nA B ? ? A B ? ? A B\\nwe need to put every B right after each A. Let's look at this in another way, think of sequence \"A B\" as a special task \"X\", then we got:\\nX ? ? X ? ? X\\nComparing to what we have after arranging A:\\nA ? ? ? A ? ? ? A\\nThe only changes are length of each parts (from 3 to 2) and available tasks. By this we can get more general equations:\\n**partCount = count(A) - 1\\nemptySlots = partCount * (n - (count of tasks with most frequency - 1))\\navailableTasks = tasks.length - count(A) * count of tasks with most frenquency\\nidles = max(0, emptySlots - availableTasks)\\nresult = tasks.length + idles**\\n\\nWhat if we have more than n tasks with most frequency and we got emptySlot negative? Like 3A, 3B, 3C, 3D, 3E, n = 2. In this case seems like we can't put all B C S inside slots since we only have n = 2.\\nWell partCount is actually the \"minimum\" length of each part required for arranging A. You can always make the length of part longer.\\nE.g. 3A, 3B, 3C, 3D, 2E, n = 2.\\nYou can always first arrange A, B, C, D as:\\nA B C D | A B C D | A B C D\\nin this case you have already met the \"minimum\" length requirement for each part (n = 2), you can always put more tasks in each part if you like:\\ne.g.\\nA B C D E | A B C D E | A B C D\\n\\nemptySlots < 0 means you have already got enough tasks to fill in each part to make arranged tasks valid. But as I said you can always put more tasks in each part once you met the \"minimum\" requirement.\\n\\nTo get count(A) and count of tasks with most frequency, we need to go through inputs and calculate counts for each distinct char. This is O(n) time and O(26) space since we only handle upper case letters.\\nAll other operations are O(1) time O(1) space which give us total time complexity of O(n) and space O(1)\\n```\\npublic class Solution {\\n    public int leastInterval(char[] tasks, int n) {\\n        int[] counter = new int[26];\\n        int max = 0;\\n        int maxCount = 0;\\n        for(char task : tasks) {\\n            counter[task - 'A']++;\\n            if(max == counter[task - 'A']) {\\n                maxCount++;\\n            }\\n            else if(max < counter[task - 'A']) {\\n                max = counter[task - 'A'];\\n                maxCount = 1;\\n            }\\n        }\\n        \\n        int partCount = max - 1;\\n        int partLength = n - (maxCount - 1);\\n        int emptySlots = partCount * partLength;\\n        int availableTasks = tasks.length - max * maxCount;\\n        int idles = Math.max(0, emptySlots - availableTasks);\\n        \\n        return tasks.length + idles;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"104511",
			"view":"2065",
			"top":"6",
			"title":"Java Solution, PriorityQueue and HashMap",
			"vote":"12",
			"content":"1. ```Greedy``` - It's obvious that we should always process the task which has largest amount left.\\n2. Put tasks (only their counts are enough, we don't care they are 'A' or 'B') in a ```PriorityQueue``` in descending order.\\n3. Start to process tasks from front of the queue. If amount left > 0, put it into a ```coolDown HashMap```\\n4. If there's task which cool-down expired, put it into the queue and wait to be processed.\\n5. Repeat step 3, 4 till there is no task left. \\n```\\npublic class Solution {\\n    public int leastInterval(char[] tasks, int n) {\\n        if (n == 0) return tasks.length;\\n        \\n        Map<Character, Integer> taskToCount = new HashMap<>();\\n        for (char c : tasks) {\\n            taskToCount.put(c, taskToCount.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        Queue<Integer> queue = new PriorityQueue<>((i1, i2) -> i2 - i1);\\n        for (char c : taskToCount.keySet()) queue.offer(taskToCount.get(c));\\n        \\n        Map<Integer, Integer> coolDown = new HashMap<>();\\n        int currTime = 0;\\n        while (!queue.isEmpty() || !coolDown.isEmpty()) {\\n            if (coolDown.containsKey(currTime - n - 1)) {\\n                queue.offer(coolDown.remove(currTime - n - 1));\\n            }\\n            if (!queue.isEmpty()) {\\n                int left = queue.poll() - 1;\\n        \\tif (left != 0) coolDown.put(currTime, left);\\n            }\\n            currTime++;\\n        }\\n        \\n        return currTime;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"104494",
			"view":"1624",
			"top":"7",
			"title":"Java greedy algorithm with correctness proof, using PriorityQueue and waiting list",
			"vote":"11",
			"content":"The idea of greedy algorithm is at each time point we choose the task with most amount to be done and is also at least n apart from the last execution of the same task. Below is a proof of the correctness:\\n\\nAt some time, task A has the most remaining amount to be done and A is also at least n apart from its most recent execution. However, suppose the optimal solution doesn't choose A as the first task but rather chooses B. Assume we have x task A remain and y task B remain, we know x >= y. \\nAlso assume in the optimal solution those m task A are done at a series of time points of a1, a2 ... ax, and n task B are done at a series of time points of b1, b2 ... by and we know that b1 <  a1.  \\nFurther, we assume k is the largest number that for all i <= k, bi < ai. Now if we swap a1 and b1, a2 and b2 ... ak and bk, it will still be a valid solution since the separation between ak and ak+1 (if exists) becomes even larger. As to bk, it's the previous ak and bk+1 > ak+1 > ak(prev) + n = bk(now) + n.\\n\\nSo we proved that no solution will better than schedule A first.\\n\\nBelow is the code, I used priority queue to keep track of task with highest remaining amount. And a job can only enter the priority queue after n time points elapse from the previous execution of the same task which is achieved by a waiting list.\\n```\\n    public static int leastInterval(char[] tasks, int n) {\\n        if(n == 0) return tasks.length;\\n        int[] count = new int[26];\\n        for (int t : tasks) count[t-'A']++;\\n        PriorityQueue<int[]> maxheap = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o2[1] - o1[1];\\n            }\\n        });\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] > 0) maxheap.add(new int[]{i, count[i]});\\n        }\\n        LinkedList<int[]> waitlist = new LinkedList<>();\\n        int t = 0, waitCount = 0;\\n        while (!maxheap.isEmpty() || waitCount > 0) {\\n            t++;\\n            int[] top = null;\\n            if (!maxheap.isEmpty()) top = maxheap.poll();\\n            if (top == null || --top[1] == 0) {\\n                waitlist.add(null);\\n            } else {\\n                waitlist.add(top);\\n                waitCount++;\\n            }\\n            if (waitlist.size() == n+1) {\\n                int[] job = waitlist.poll();\\n                if (job != null) {\\n                    maxheap.add(waitlist.poll());\\n                    waitCount--;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n```"
		},
		{
			"lc_ans_id":"104495",
			"view":"484",
			"top":"8",
			"title":"Java O(n) solution beats 99.76%, use only array, easy understanding",
			"vote":"5",
			"content":"There is one crucial point for you:\\nthe ONLY thing you need to care is **the max number of one task**!\\nWe set apart each max task with interval n, and we hope to put all other tasks into those intervals. If the number of those tasks exceeds the interval space, then we don't need any idle interval at all. If not, the interval space plus the max tasks will be the least interval. Be care for the existent of multiple max tasks. \\n```\\npublic class Solution {\\n    public int leastInterval(char[] tasks, int n) {\\n        int[] storage = new int[26];\\n        for (char c : tasks) {\\n            storage[(c - 'A')]++;\\n        }\\n        int max = 0;\\n        int count = 1;\\n        for (int num : storage) {\\n            if (num == 0) {\\n                continue;\\n            }\\n            if (max < num) {\\n                max = num;\\n                count = 1;\\n            } else if (max == num) {\\n                count++;\\n            }\\n        }\\n        int space = (n + 1) * (max - 1) + count;\\n        return (space < nums.length) ? nums.length : space;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"104499",
			"view":"652",
			"top":"9",
			"title":"Python O(n) time O(1) space",
			"vote":"5",
			"content":"First solution is O(nlogn) which uses a heap to place most frequent elements in first priority.\\nSecond solution is O(n): the number of the most frequent tasks will determine the length and tied tasks will exist in the last cycle.\\n```\\nclass Solution(object):\\n    \\n    # O(nlogn) greedy to place most popular and distinct tasks first\\n    # Actually, I don't think this is greedy\\n    # We always place different tasks in a cycle which will minimize steps\\n    # If not different tasks can be placed in a cycle, place an `idle`.\\n    \\n    def _leastInterval(self, tasks, n):\\n        \"\"\"\\n        :type tasks: List[str]\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        n += 1\\n        ans = 0\\n        d = collections.Counter(tasks)\\n        heap = [-c for c in d.values()]\\n        heapq.heapify(heap)\\n        while heap:\\n            stack = []\\n            cnt = 0\\n            for _ in range(n):\\n                if heap:\\n                    c = heapq.heappop(heap)\\n                    cnt += 1\\n                    if c < -1:\\n                        stack.append(c + 1)\\n            for item in stack:\\n                heapq.heappush(heap, item)\\n            ans += heap and n or cnt # == if heap then n else cnt\\n        return ans\\n        \\n    \\n    # O(n) # of the most frequent tasks, say longest, will determine the legnth\\n    # to void counting idle intervals, we count (longest - 1) * (n + 1)\\n    # then count how many will in the last cycle which means finding ties\\n    # if counted number is less than # of tasks which means \\n    # less frequent tasks can be always placed in such cycle\\n    # and it won't cause any conflicts with requirement since even most frequent can be settle\\n    # finally, return max(# of task, total counted number)\\n    \\n    def leastInterval(self, tasks, n):\\n        d = collections.Counter(tasks)\\n        counts = d.values()\\n        longest = max(counts)\\n        ans = (longest - 1) * (n + 1)\\n        for count in counts:\\n            ans += count == longest and 1 or 0\\n        return max(len(tasks), ans)\\n```"
		}
	],
	"id":"600",
	"title":"Task Scheduler",
	"content":"<p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>\r\n\r\n<p>However, there is a non-negative cooling interval <b>n</b> that means between two <b>same tasks</b>, there must be at least n intervals that CPU are doing different tasks or just be idle. </p>\r\n\r\n<p>You need to return the <b>least</b> number of intervals the CPU will take to finish all the given tasks.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\r\n<b>Output:</b> 8\r\n<b>Explanation:</b> A -> B -> idle -> A -> B -> idle -> A -> B.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The number of tasks is in the range [1, 10000].</li>\r\n<li>The integer n is in the range [0, 100].</li>\r\n</ol>\r\n</p>",
	"frequency":"387",
	"ac_num":"24319"
}