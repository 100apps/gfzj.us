{
	"difficulty":"3",
	"submit_num":"16061",
	"show_id":"629",
	"leetcode_id":"629",
	"answers":[
		{
			"lc_ans_id":"104815",
			"view":"4106",
			"top":"0",
			"title":"Java DP O(nk) solution",
			"vote":"40",
			"content":"dp[n][k] denotes the number of arrays that have k inverse pairs for array composed of 1 to n\\nwe can establish the recursive relationship between dp[n][k] and dp[n-1][i]:\\n\\n\\nif we put n as the last number then all the k inverse pair should come from the first n-1 numbers\\nif  we put n as the second last number then there's 1 inverse pair involves n so the rest k-1 comes from the first n-1 numbers\\n...\\nif  we put n as the first number then there's n-1 inverse pairs involve n so the rest k-(n-1) comes from the first n-1 numbers\\n\\n<code>dp[n][k] = dp[n-1][k]+dp[n-1][k-1]+dp[n-1][k-2]+...+dp[n-1][k+1-n+1]+dp[n-1][k-n+1]</code>\\n\\nIt's possible that some where in the right hand side the second array index become negative, since we cannot generate negative inverse pairs we just treat them as 0, but still leave the item there as a place holder.\\n\\n<code>dp[n][k] =                          dp[n-1][k]+dp[n-1][k-1]+dp[n-1][k-2]+...+dp[n-1][k+1-n+1]+dp[n-1][k-n+1]</code>\\n<code>dp[n][k+1] = dp[n-1][k+1]+dp[n-1][k]+dp[n-1][k-1]+dp[n-1][k-2]+...+dp[n-1][k+1-n+1]                        </code>\\n\\nso by deducting the first line from the second line, we have\\n\\n<code>dp[n][k+1] = dp[n][k]+dp[n-1][k+1]-dp[n-1][k+1-n]</code>\\n\\nBelow is the java code:\\n```\\n    public static int kInversePairs(int n, int k) {\\n        int mod = 1000000007;\\n        if (k > n*(n-1)/2 || k < 0) return 0;\\n        if (k == 0 || k == n*(n-1)/2) return 1;\\n        long[][] dp = new long[n+1][k+1];\\n        dp[2][0] = 1;\\n        dp[2][1] = 1;\\n        for (int i = 3; i <= n; i++) {\\n            dp[i][0] = 1;\\n            for (int j = 1; j <= Math.min(k, i*(i-1)/2); j++) {\\n                dp[i][j] = dp[i][j-1] + dp[i-1][j];\\n                if (j >= i) dp[i][j] -= dp[i-1][j-i];\\n                dp[i][j] = (dp[i][j]+mod) % mod;\\n            }\\n        }\\n        return (int) dp[n][k];\\n    }"
		},
		{
			"lc_ans_id":"104825",
			"view":"2527",
			"top":"1",
			"title":"Shared my C++ O(n * k) solution with explanation",
			"vote":"17",
			"content":"For a better understanding, I would  use O(n * k ) space instead of O(k) space. It's easy to write O(k) space version when you understand this DP process.\\nAs @awice said in his [Post ](https://discuss.leetcode.com/topic/93721/python-straightforward-with-explanation)\\n> For example, if we have some permutation of 1...4\\n>* 5 x x x x creates 4 new inverse pairs\\n>* x 5 x x x creates 3 new inverse pairs\\n...\\n>* x x x x 5 creates 0 new inverse pairs\\n\\n### O(n * k ^ 2) Solution\\nWe can use this formula to solve this problem\\n```\\ndp[i][j] //represent the number of permutations of (1...n) with k inverse pairs.\\ndp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ..... +dp[i-1][j - i + 1]\\n```\\nSo, We write a O(k*n^2) Solution through above formula like this \\n```\\npublic:\\n    int kInversePairs(int n, int k) {\\n        vector<vector<int>> dp(n + 1, vector<int>(k+1, 0));\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; ++i){\\n            for(int j = 0; j < i; ++j){ // In number i, we can create 0 ~ i-1 inverse pairs \\n                for(int m = 0; m <= k; ++m){ //dp[i][m] +=  dp[i-1][m-j]\\n                    if(m - j >= 0 && m - j <= k){\\n                        dp[i][m] = (dp[i][m] + dp[i-1][m-j]) % mod; \\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\nprivate:\\n    const int mod = pow(10, 9) + 7;\\n};\\n```\\nBut the above solution is too slow, it spends 1000+ms\\n\\n### O(n * l) Solution\\nLook back to the above formula.\\n\\n`dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ..... +dp[i-1][j - i + 1]`\\nLet's consider this example\\nif `i = 5 `\\n```\\ndp[i][0] = dp[i-1][0] (creates 0 inverse pair)\\ndp[i][1] = dp[i-1][0] (1) + dp[i-1][1] (0)  =  dp[i][0] + dp[i-1][1]\\ndp[i][2] = dp[i-1][0] (2) + dp[i-1][1] (1) + dp[i-1][2] (0) = dp[i][1] + dp[i-1][2]\\n.\\n.\\n.\\ndp[i][4] = dp[i-1][0] (4) + dp[i-1][1] (3) + dp[i-1][2] (2) + dp[i-1][3] (1) + dp[i-1][4] (0)  = dp[i][3] + dp[i-1][4]\\n```\\nCan you find the rules about above formula. \\nif `j < i` , we can compute `dp[i][j] = dp[i][j-1] +dp[i-1][j]`\\n\\nSo, how about `j >= i`\\nWe know if we add number i into permutation(0 .. i -1 ), i can create 0 ~i -1 inverse pair\\nIf `j >= i` , we still use `dp[i][j] = dp[i][j-1] +dp[i-1][j]`.\\nWe must minus `dp[i][j-i]`. (In fact it minus` dp[i-1][j-i]`, because every` j >= i `in dp vecor,it minus `dp[i-1][j-i] `individually)\\nFor example, if `i = 5`\\n\\n`dp[i][5] = dp[i][4] + dp[i-1][5] - dp[i-1][0]`\\n`dp[i][6] = dp[i][5] + dp[i-1][6] - dp[i-1][1]`\\n\\nreference code\\n```\\nclass Solution {\\npublic:\\n    int kInversePairs(int n, int k) {\\n        vector<vector<int>> dp(n+1, vector<int>(k+1));\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; ++i){\\n            dp[i][0] = 1;\\n            for(int j = 1; j <= k; ++j){\\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % mod;\\n                if(j - i >= 0){\\n                    dp[i][j] = (dp[i][j] - dp[i-1][j-i] + mod) % mod; \\n                    //It must + mod, If you don't know why, you can check the case 1000, 1000\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\nprivate:\\n    const int mod = pow(10, 9) + 7;\\n};\\n```"
		},
		{
			"lc_ans_id":"104822",
			"view":"2416",
			"top":"2",
			"title":"Python, Straightforward with Explanation",
			"vote":"16",
			"content":"Let's try for a top-down dp.  Suppose we know ```dp[n][k]```, the number of permutations of (1...n) with k inverse pairs.\\n\\nLooking at a potential recursion for ```dp[n+1][k]```, depending on where we put the element (n+1) in our permutation, we may add 0, 1, 2, ..., n new inverse pairs.  For example, if we have some permutation of 1...4, then:\\n* 5 x x x x creates 4 new inverse pairs\\n* x 5 x x x creates 3 new inverse pairs\\n* ...\\n* x x x x 5 creates 0 new inverse pairs\\n\\nwhere in the above I'm representing any permutation of 1...4 with x's.\\nThus, ```dp[n+1][k] = sum_{x=0..n} dp[n][k-x]```.\\n\\nThis dp has ```NK``` states with ```K/2``` work, which isn't fast enough.  We need to optimize further.\\n\\nLet ```ds[n][k] = sum_{x=0..k-1} dp[n][x]```.  \\nThen ```dp[n+1][k] = ds[n][k+1] - ds[n][k-n]```,\\nand the left hand side is ```ds[n+1][k+1] - ds[n+1][k]```.\\nThus, we can perform all calculations in terms of ```ds```.\\n\\nFinally, to save space, we will only store the two most recent rows of ```ds```, using ```ds``` and ```new```.\\n\\nIn the code, we refer to ```-ds[n][k-n+1]``` instead of ```-ds[n][k-n]``` because the ```n``` being considered is actually n+1.  For example, when ```n=2```, we are appending information about ```ds[2][k]``` to ```new```, so our formula of ```dp[n+1][k] = ds[n][k+1] - ds[n][k-n]``` is ```dp[2][k] = ds[1][k+1] - ds[1][k-1]```.\\n\\n```\\ndef kInversePairs(self, N, K):\\n    MOD = 10**9 + 7\\n    ds = [0] + [1] * (K + 1)\\n    for n in xrange(2, N+1):\\n        new = [0]\\n        for k in xrange(K+1):\\n            v = ds[k+1]\\n            v -= ds[k-n+1] if k >= n else 0\\n            new.append( (new[-1] + v) % MOD )\\n        ds = new\\n    return (ds[K+1] - ds[K]) % MOD\\n```"
		},
		{
			"lc_ans_id":"104834",
			"view":"1394",
			"top":"3",
			"title":"java,DP.Thank you so much @GardenAAA for your advice.",
			"vote":"4",
			"content":"\\nthink in DP.\\n(n+1,k) means the sum of arrays that consist of n+1 number with k inverse pairs.\\nfor arrays that match (n,k),we put the (N+1)th number at the end ,so the new array match (n+1,k).\\nfor arrays that match (n,k-1),we put the (N+1)th number before the last number, the sum of inverse pairs increase 1,so the new array match (n+1,k).\\n...\\n the max increase is n (put the (N+1)th number at the begin)\\n\\nThus (n+1,k) equals (n,k)+(n,k-1)+(n,k-2)+.....+\\uff08n,k-n\\uff09\\nbelow is my code:\\n```java\\npublic int kInversePairs(int n, int k) {\\n        long[][] dp = new long[n][k+1];\\n        dp[0][0]=1;//mean sum of arrays that consist of 1 with 0 inverse pairs\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<=k;j++){\\n                for(int m=j;m>=0&&m>=(j-i);m--){\\n                    dp[i][j]+=dp[i-1][m];\\n                }\\n                dp[i][j]=dp[i][j]%1000000007;\\n            }\\n        }\\n        return (int)dp[n-1][k];\\n    }\\n```\\nThank you so much @GardenAAA for your advice.\\nthe above code can be optimizated,\\n```java\\npublic int kInversePairs(int n, int k) {\\n        long[][] dp = new long[n][k+1];\\n        dp[0][0]=1;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<=k;j++){\\n                if(j>0){\\n                    dp[i][j]=dp[i][j-1]+dp[i-1][j];\\n                    dp[i][j]=j-i>0?(dp[i][j]-dp[i-1][j-i-1]):dp[i][j];\\n                }\\n                else{\\n                    for(int m=j;m>=0&&m>=(j-i);m--){\\n                        dp[i][j]+=dp[i-1][m];\\n                    }\\n                }\\n                dp[i][j]=dp[i][j]>0?dp[i][j]%1000000007:(dp[i][j]+1000000007)%1000000007;\\n            }\\n        }\\n        return (int)dp[n-1][k];\\n    }\\n```\\nHope you have better method."
		},
		{
			"lc_ans_id":"104824",
			"view":"308",
			"top":"4",
			"title":"Python concise solution",
			"vote":"2",
			"content":"````\\nf(n,k) = sum(f(n-1,i)), where max(k-n+1,0) <= i <= k\\nf(0,k) = 0\\nf(n,0) = 1\\n`````\\n````\\ndef kInversePairs(self, n, k):\\n        dp = [1] + [0] * k\\n        for i in range(2, n + 1):\\n            for j in range(1, k + 1): dp[j] += dp[j - 1]\\n            for j in range(k, 0, -1): dp[j] -= j - i >= 0 and dp[j - i]\\n        return dp[k] % (10**9 + 7)"
		},
		{
			"lc_ans_id":"104831",
			"view":"110",
			"top":"5",
			"title":"Python O(nk) time solution from O(nk) space to O(k) space with explanation.",
			"vote":"1",
			"content":"#### Idea:\\n\\nYou can write down some the cases from 1 to 4 and you will find the pattern.\\nLike when `i = 4`, you  insert 4 to all the cases in a proper position when `i = 3` to get the number of results when `i=4`.\\nNote that `i` limits the number of places you can do the insertion. If `i = 5`, there is only `5` places you can insert.\\nSo you start from `i = 0` as base case and you can get the final result at the end.\\n\\nThis is what we get from the above conclusion.\\n\\n`dp[i][j] = dp[i-1][j - i + 1] + dp[i-1][j - i + 2] + ... + dp[i-1][j]`\\n\\nBut if you want to get your solution accepted in Python, then you need more optimization (BTW: I think is unfair since C++'s solution can pass it).\\nActually, the above formula does have lots of redundant computation. As you can see, for` dp[i][j] `and` dp[i][j-1]`, we may use `dp[i-1][j-1], dp[i-1][j-2],...,dp[i-1][j-i+1] `twice. Thus, I rewrite the formula as follows.\\n\\n`dp[i][j] = dp[i][j-1] + dp[i-1][j] - (if j - i >= 0: dp[i-1][j-i] else: 0)`\\n\\nIt works like a sliding window, adding `dp[i-1][j] `to `dp[i][j-1]` and then reducing `dp[i-1][j-i]` if applicable to remain a sliding window whose size is `i`.\\n\\nO(nk) space solution\\n```\\nclass Solution(object):\\n    def kInversePairs(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        MOD = 10**9 + 7\\n        upper = n * (n - 1) / 2\\n        if k == 0 or k == upper:\\n            return 1\\n        if k > upper:\\n            return 0\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        dp[0][0] = 1\\n        for i in range(1, n + 1):\\n            dp[i][0] = 1\\n            for j in range(k + 1):\\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % MOD\\n                if j - i >= 0:\\n                    dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + MOD) % MOD\\n        return dp[n][k]\\n```\\n\\nO(k) space solution\\n```\\nclass Solution(object):\\n    def kInversePairs(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        MOD = 10**9 + 7\\n        upper = n * (n - 1) / 2\\n        if k == 0 or k == upper:\\n            return 1\\n        if k > upper:\\n            return 0\\n        dp = [0] * (k + 1)\\n        dp[0] = 1\\n        for i in range(1, n + 1):\\n            temp =[1] + [0] * k\\n            for j in range(k + 1):\\n                temp[j] = (temp[j-1] + dp[j]) % MOD\\n                if j - i >= 0:\\n                    temp[j] = (temp[j] - dp[j - i]) % MOD\\n            dp = temp\\n        return dp[k]\\n```"
		},
		{
			"lc_ans_id":"104832",
			"view":"310",
			"top":"6",
			"title":"share O(nK) solution using Java with some explanation !",
			"vote":"1",
			"content":"Here we have two arrays:\\none is res[k],which denotes the number of k inverse pairs given a new element!\\nanother is sum[k],which denotes the number of <=k inverse pairs given a new elements. \\nThen, we can use a for loop to iterate n-times to get final result, basically the core relation between res and sum is : res[j]=sum[j]-sum[j-i] if j-i>=0, else res[j] is simply equal to sum[j] given a new element has been considered, where i is 1<=i<=n, and j is i<=j<=k. Hope it helps!\\nMore specifically, suppose we have calculated 1,2,3,4,5,6,7 elements' res and sum array. Then,  after the next step, the 8 comes in. Now, as for every k, we will consider each of {8-k, 8-k+1,8-k+2,...8} as the last element to form k inverse pairs' array, that's why will have res[k]=sum[k]-sum[k-8] if k-8>=0, or res[k]=sum[k] if k<8.   \\n\\nMore details:\\nIt means that if k=4, then we will consider {1,2,3,4,5,6,7,8}, {1,2,3,4,5,6,8,7},{1,2,3,4,5,7,8,6}, {1,2,3,4,6,7,8,5} and {1,2,3,5,6,7,8,4} cases. As for every case, we need to fix the last element, and then focus on all the permutations of previous 7 elements. Since we already calculated res and sum for the previous step(I mean the step for only having 7 elements), so we can just retrieve information directly from res and sum and update their values. \\n\\n```\\npublic class Solution {\\n    public int kInversePairs(int n, int k) {\\n         long mod=(long)(1e9+7);\\n         \\n         long[] res=new long[k+1];\\n         long[] sum=new long[k+1];\\n         res[0]=1;\\n         Arrays.fill(sum,1);\\n         \\n         for(int i=2;i<=n;i++){\\n            //long[] temp=sum.clone();\\n            for(int j=0;j<=k;j++){\\n                if(j==0){\\n                    res[0]=1;\\n                }else{\\n                    res[j]=(j-i)>=0 ? ((sum[j]-sum[j-i]+mod)%mod) : ((sum[j]+mod)%mod);\\n                }\\n            }\\n            \\n            for(int j=1;j<=k;j++){\\n                sum[j]=(res[j]+sum[j-1]+mod)%mod;\\n            }\\n         }\\n         \\n         return (int)res[k];\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"104827",
			"view":"526",
			"top":"7",
			"title":"Java O(nk) Time O(k) Space DP Solution",
			"vote":"1",
			"content":"```\\npublic static int kInversePairs(int n, int k) {   \\n  int[] dp = new int[k+1];\\n  dp[0] = 1; int mod = 1000000007;\\n  for (int i=1;i<=n;i++) {\\n      int[] temp = new int[k+1];\\n      for (int j=0;j<=k;j++) {\\n          if (j==0) temp[j] = 1;\\n          else {\\n            temp[j] = temp[j-1] + dp[j]; \\n            temp[j] %= mod;\\n            if (j >= 1 + Math.min(i-1, j))  temp[j] += mod - dp[j-1-Math.min(i-1, j)];\\n            temp[j] %= mod;\\n          }\\n      }\\n      dp = temp;\\n  }\\n  return dp[k];\\n}\\n```"
		},
		{
			"lc_ans_id":"104816",
			"view":"32",
			"top":"8",
			"title":"From TLE to working solution: my thinking process",
			"vote":"0",
			"content":"Started with getting a TLE for Python using O(n) space. This is simply because we're doing a lot of redundant calculations such as adding all the previous cols many times. \\n1) dp[i][j]= dp[i-1][j]+dp[i-1][j-1]+...dp[i-1][j-i+1]\\n\\nI did dp[i-1][j-i+1] as the last because you can't insert the current n into a position of the previous n because you ran out of positions to insert. For example, if I want to insert 3 into 12, I only have 3 places to insert my 3.\\n\\n~~~\\nclass Solution(object):\\n    def kInversePairs(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[1]+[0]*k\\n        for i in xrange(2,n+1):\\n            for j in xrange(k,0,-1):\\n                for col in xrange(j-1,j-(i-1)-1,-1):\\n                    if 0<=col<=k:\\n                        dp[j]+=dp[col] \\n        return dp[-1]\\n\\n~~~\\n2) dp[i][j-1]=dp[i-1][j-1]+dp[i-1][j-2]+...+ dp[i-1][j-1-(i-1)]\\n\\nCombining 1 and 2 with above we get \\n3) dp[i][j]=dp[i-1][j]+dp[i][j-1]- dp[i-1][j-i] \\n\\nObviously, j-i>=0 or else it would be out of our bounds. \\nThen you create solutions like others have on here."
		},
		{
			"lc_ans_id":"104817",
			"view":"46",
			"top":"9",
			"title":"Java DP solution",
			"vote":"0",
			"content":"It is hard. My initial solution is O(n * k * k) and got TLE. Then looking back at my approach, it's a little bit tricky to figure out the relationship between `dp[i][j]` and `dp[i][j-1]`.\\nIn addition, `MOD` minus would lead to a negative number, which was beyond my expectation as well.\\n```\\n    public int kInversePairs(int n, int k) {\\n        int[][] dp = new int[n + 1][k + 1];\\n        int MOD = 1000000007;\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            dp[i][0] = 1;\\n            for (int j = 1; j <= k; j++) {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n                if (j >= i) {\\n                    dp[i][j] -= dp[i-1][j-i];\\n                }\\n                dp[i][j] = dp[i][j] > 0 ? dp[i][j] % MOD : (dp[i][j] + MOD) % MOD;\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n```"
		}
	],
	"id":"607",
	"title":"K Inverse Pairs Array",
	"content":"<p>\r\nGiven two integers <code>n</code> and <code>k</code>, find how many different arrays consist of numbers from <code>1</code> to <code>n</code> such that there are exactly <code>k</code> inverse pairs. \r\n</p>\r\n<p>\r\nWe define an inverse pair as following:\r\nFor <code>i<sub>th</sub></code> and <code>j<sub>th</sub></code> element in the array, if <code>i</code> < <code>j</code> and <code>a[i]</code> > <code>a[j]</code> then it's an inverse pair; Otherwise, it's not.\r\n</p>\r\n\r\n<p>\r\nSince the answer may be very large, the answer should be modulo 10<sup>9</sup> + 7.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> n = 3, k = 0\r\n<b>Output:</b> 1\r\n<b>Explanation:</b> \r\nOnly the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> n = 3, k = 1\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> \r\nThe array [1,3,2] and [2,1,3] have exactly 1 inverse pair.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The integer <code>n</code> is in the range [1, 1000] and <code>k</code> is in the range [0, 1000].</li>\r\n</ol>\r\n</p>",
	"frequency":"131",
	"ac_num":"4301"
}