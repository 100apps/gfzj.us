{
	"difficulty":"2",
	"submit_num":"8589",
	"show_id":"635",
	"leetcode_id":"635",
	"answers":[
		{
			"lc_ans_id":"105008",
			"view":"3500",
			"top":"0",
			"title":"Concise Java Solution",
			"vote":"31",
			"content":"```\\npublic class LogSystem {\\n    \\n    List<String[]> timestamps = new LinkedList<>();\\n    List<String> units = Arrays.asList(\"Year\", \"Month\", \"Day\", \"Hour\", \"Minute\", \"Second\");\\n    int[] indices = new int[]{4,7,10,13,16,19};\\n    \\n    public void put(int id, String timestamp) { timestamps.add(new String[]{Integer.toString(id), timestamp}); }\\n\\n    public List<Integer> retrieve(String s, String e, String gra) {\\n        List<Integer> res = new LinkedList<>();\\n        int idx = indices[units.indexOf(gra)];\\n        for (String[] timestamp : timestamps) {\\n            if (timestamp[1].substring(0, idx).compareTo(s.substring(0, idx)) >= 0 &&\\n               \\ttimestamp[1].substring(0, idx).compareTo(e.substring(0, idx)) <= 0) res.add(Integer.parseInt(timestamp[0]));\\n        }\\n        return res;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"105016",
			"view":"1466",
			"top":"1",
			"title":"Python, Straightforward with Explanation",
			"vote":"21",
			"content":"```\\nclass LogSystem(object):\\n    def __init__(self):\\n        self.logs = []\\n\\n    def put(self, tid, timestamp):\\n        self.logs.append((tid, timestamp))\\n        \\n    def retrieve(self, s, e, gra):\\n        index = {'Year': 5, 'Month': 8, 'Day': 11, \\n                 'Hour': 14, 'Minute': 17, 'Second': 20}[gra]\\n        start = s[:index]\\n        end = e[:index]\\n        \\n        return sorted(tid for tid, timestamp in self.logs\\n                      if start <= timestamp[:index] <= end)\\n```\\nBecause the number of operations is very small, we do not need a complicated structure to store the logs: a simple list will do.\\n\\nLet's focus on the ```retrieve``` function.  For each granularity, we should consider all timestamps to be truncated to that granularity.  For example, if the granularity is ```'Day'```, we should truncate the timestamp '2017:07:02:08:30:12' to be '2017:07:02'.  Now for each log, if the truncated timetuple ```cur``` is between ```start``` and ```end```, then we should add the id of that log into our answer."
		},
		{
			"lc_ans_id":"105006",
			"view":"708",
			"top":"2",
			"title":"Java range query using TreeMap.subMap()",
			"vote":"10",
			"content":"Given the granularity we can set a lower bound and upper bound of timestamp so we could do a range query using TreeMap. To get the lower bound we append a suffix of \"2000:01:01:00:00:00\" to the prefix of s and to get the upper bound we append a suffix of \"2017:12:31:23:59:59\" to the prefix of e.\\n```\\npublic class LogSystem {\\n    private String min, max;\\n    private HashMap<String, Integer> map;\\n    private TreeMap<String, LinkedList<Integer>> logs;\\n    public LogSystem() {\\n        min = \"2000:01:01:00:00:00\";\\n        max = \"2017:12:31:23:59:59\";\\n        map = new HashMap<>();\\n        map.put(\"Year\", 4);\\n        map.put(\"Month\", 7);\\n        map.put(\"Day\", 10);\\n        map.put(\"Hour\", 13);\\n        map.put(\"Minute\", 16);\\n        map.put(\"Second\", 19);\\n        logs = new TreeMap<>();\\n    }\\n\\n    public void put(int id, String timestamp) {\\n        if(!logs.containsKey(timestamp)) logs.put(timestamp, new LinkedList<>());\\n        logs.get(timestamp).add(id);\\n    }\\n\\n    public List<Integer> retrieve(String s, String e, String gra) {\\n        int index = map.get(gra);\\n        String start = s.substring(0, index)+min.substring(index), end = e.substring(0, index)+max.substring(index);\\n        NavigableMap<String, LinkedList<Integer>> sub = logs.subMap(start, true, end, true);\\n        LinkedList<Integer> ans = new LinkedList<>();\\n        for (Map.Entry<String, LinkedList<Integer>> entry : sub.entrySet()) {\\n            ans.addAll(entry.getValue());\\n        }\\n        return ans;\\n    }\\n}"
		},
		{
			"lc_ans_id":"105042",
			"view":"875",
			"top":"3",
			"title":"Java 8 and enum, very concise solution",
			"vote":"5",
			"content":"```\\nclass LogSystem {\\n    Map<Integer,String> map = new HashMap<>();\\n\\n    public  enum Index {\\n        Year(4), Month(7), Day(10), Hour(13), Minute(16), Second(19);\\n        int idx;   Index(int i) {this.idx = i;}\\n    }\\n\\n    public void put(int id, String timestamp) { map.put(id,timestamp); }\\n\\n    public List<Integer> retrieve(final String s, final String e, String gra) {\\n        Function<String, String> fn = str -> str.substring(0, Index.valueOf(gra).idx);\\n        return map.entrySet().stream().filter(\\n                x -> fn.apply(x.getValue()).compareTo(fn.apply(s)) >= 0 && fn.apply(x.getValue()).compareTo(fn.apply(e)) <= 0)\\n                .collect(mapping(v -> v.getKey(), toList()));\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"105025",
			"view":"368",
			"top":"4",
			"title":"Straight forward C++ multimap solution",
			"vote":"4",
			"content":"```\\nclass LogSystem {\\nprivate:\\n    multimap<string, int> m;\\n    \\npublic:\\n    LogSystem() {\\n        \\n    }\\n    \\n    void put(int id, string timestamp) {\\n        m.emplace(timestamp, id);\\n    }\\n    \\n    vector<int> retrieve(string s, string e, string gra) {\\n        if (gra == \"Year\") {\\n            s = s.substr(0, 4) + \":01:01:00:00:00\";\\n            e = e.substr(0, 4) + \":12:31:23:59:59\";\\n        }\\n        else if (gra == \"Month\") {\\n            s = s.substr(0, 7) + \":01:00:00:00\";\\n            e = e.substr(0, 7) + \":31:23:59:59\";\\n        }\\n        else if (gra == \"Day\") {\\n            s = s.substr(0, 10) + \":00:00:00\";\\n            e = e.substr(0, 10) + \":23:59:59\";\\n        }\\n        else if (gra == \"Hour\") {\\n            s = s.substr(0, 13) + \":00:00\";\\n            e = e.substr(0, 13) + \":59:59\";\\n        }\\n        else if (gra == \"Minute\") {\\n            s = s.substr(0, 16) + \":00\";\\n            e = e.substr(0, 16) + \":59\";\\n        }\\n        auto start = m.lower_bound(s), end = m.upper_bound(e);\\n        vector<int> ans;\\n        for (auto iter = start; iter != end; ++iter)\\n            ans.push_back(iter->second);\\n        return ans;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"105009",
			"view":"139",
			"top":"5",
			"title":"[C++] CleanCode",
			"vote":"3",
			"content":"```\\nclass LogSystem {\\npublic:\\n    LogSystem() { }\\n\\n    void put(int id, string time) {\\n        logs.emplace(time, id);\\n    }\\n\\n    vector<int> retrieve(string s, string e, string gra) {\\n        vector<int> ids;\\n        int el = lengths[gra]; // effective length\\n        string es = s.substr(0, el); // effective start time string, eg.: 2017:01:01\\n        string ee = e.substr(0, el); // effective end time string, eg.: 2017:01:02\\n\\n        for (auto it = logs.begin(); it != logs.end(); it++) {\\n            string time = it->first; // 2017:01:01:23:59:59\\n            int id = it->second;\\n            string etime = time.substr(0, el);\\n            if (es <= etime && etime <= ee) {\\n                ids.push_back(id);\\n            }\\n        }\\n        return ids;\\n    }\\n\\nprivate:\\n    multimap<string, int> logs;\\n\\n    // effective lengths of time stamps for different granularity\\n    map<string, int> lengths{ { \"Year\", 4 },{ \"Month\", 7 },{ \"Day\", 10 },{ \"Hour\", 13 },{ \"Minute\", 16 },{ \"Second\", 19 } };\\n};"
		},
		{
			"lc_ans_id":"105026",
			"view":"876",
			"top":"6",
			"title":"Java Code Using HashMap",
			"vote":"2",
			"content":"```\\npublic class LogSystem {\\n    Map<Integer,String> map=new HashMap<>();\\n    public LogSystem() {\\n        \\n    }\\n    \\n    public void put(int id, String timestamp) {\\n        map.put(id,timestamp);\\n    }\\n    \\n    public List<Integer> retrieve(String s, String e, String gra) {\\n        int x=0;\\n        switch (gra){\\n            case \"Year\":\\n                x=4; \\n                break;\\n            case \"Month\":\\n                x=7;\\n                break;\\n            case \"Day\":\\n                x=10;\\n                break;\\n            case \"Hour\":\\n                x=13;\\n                break;\\n            case \"Minute\":\\n                x=16;\\n                break;\\n            case \"Second\":\\n                x=19;\\n                break;\\n        }\\n        s=s.substring(0,x);\\n        e=e.substring(0,x);\\n        List<Integer> ans=new ArrayList<>();\\n        for (Integer i:map.keySet())\\n        {\\n            String ss=map.get(i).substring(0,x);\\n            if (ss.compareTo(s)>=0 && ss.compareTo(e)<=0) ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your LogSystem object will be instantiated and called as such:\\n * LogSystem obj = new LogSystem();\\n * obj.put(id,timestamp);\\n * List<Integer> param_2 = obj.retrieve(s,e,gra);\\n */\\n```"
		},
		{
			"lc_ans_id":"105049",
			"view":"1005",
			"top":"7",
			"title":"C++ easy to understand solution",
			"vote":"2",
			"content":"```\\nclass LogSystem {\\npublic:\\n    unordered_map<string, int> mp;\\n    unordered_map<string, int> mapping;\\n\\n    LogSystem() {\\n        mapping[\"Year\"] = 0;\\n        mapping[\"Month\"] = 1;\\n        mapping[\"Day\"] = 2;\\n        mapping[\"Hour\"] = 3;\\n        mapping[\"Minute\"] = 4;\\n        mapping[\"Second\"] = 5;\\n    }\\n    \\n    void put(int id, string timestamp) {\\n        mp[timestamp] = id;   \\n    }\\n    \\n    vector<int> retrieve(string s, string e, string gra) {\\n        vector<int> result;\\n        for (auto p : mp) {\\n            string tp = p.first;\\n            if (bigger(tp, s, gra) && smaller(tp, e, gra)) result.push_back(p.second);\\n        }\\n        return result;\\n    }\\n    bool smaller(string t1, string t2, string grad) {\\n        auto w1 = split(t1);\\n        auto w2 = split(t2);\\n        for (int i = 0; i <= mapping[grad]; i++) {\\n            if (w1[i] > w2[i]) return false;\\n            else if (w1[i] < w2[i]) return true;\\n        }\\n        return true;\\n    }\\n    \\n    bool bigger(string t1, string t2, string grad) {\\n        auto w1 = split(t1);\\n        auto w2 = split(t2);\\n        for (int i = 0; i <= mapping[grad]; i++) {\\n            if (w1[i] < w2[i]) return false;\\n            else if (w1[i] > w2[i]) return true;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> split(string t) {\\n        vector<int> words;\\n        istringstream iss(t);\\n        string s;\\n        while (getline(iss, s, ':')) {\\n            words.push_back(stoi(s));\\n        }\\n        return words;\\n    }\\n};\\n\\n/**\\n * Your LogSystem object will be instantiated and called as such:\\n * LogSystem obj = new LogSystem();\\n * obj.put(id,timestamp);\\n * vector<int> param_2 = obj.retrieve(s,e,gra);\\n */\\n```"
		},
		{
			"lc_ans_id":"105031",
			"view":"264",
			"top":"8",
			"title":"Java, using Trie. O(1) add,   O(number of id in the result) for retrieve",
			"vote":"1",
			"content":"May not be necessary for small data set. \\n\\nUsing Trie (prefix tree) like structure.\\nYear-->Month-->Day-->Hour-->Minute-->Second.\\nFor any given time, take O(1) to get the node represent the time, just need to start from the year node to the second node.\\nFor retrieve, find the start node, and the end node,  O(1);\\nThen iterate from the start node to the end node in the trie, O(number of id in the result).\\n\\n\\n```\\npublic class LogSystem {    \\n    TimeNode root;\\n        \\n    public LogSystem() {\\n        root = new TimeNode(null, -1);\\n    }\\n    \\n    public void put(int id, String timestamp) {\\n        int[] timeArr = convert(timestamp);\\n        root.add(timeArr, 0, id);\\n    }\\n    \\n    public List<Integer> retrieve(String s, String e, String gra) {\\n        List<Integer> res = new ArrayList<Integer>(300);\\n        int graIdx = getGraIndex(gra);\\n        int[] start = convert(s);\\n        int[] end = convert(e);\\n        end[graIdx]++;\\n        TimeNode startNode = root.getTimeNode(start, 0, graIdx);\\n        TimeNode endNode = root.getTimeNode(end, 0, graIdx);\\n        TimeNode node = startNode;\\n        while(node !=null && node !=  endNode){\\n            res.add(node.id);\\n            node = node.nextSecNode();\\n        }\\n        return res;\\n    }\\n    \\n    private int[] convert(String timestamp){\\n        String[] timeStrs = timestamp.split(\":\");\\n        int[] timeDigits = new int[timeStrs.length];\\n        for(int i=0; i<timeStrs.length; i++){\\n            timeDigits[i]=Integer.valueOf(timeStrs[i]);\\n        }\\n        return timeDigits;\\n    }\\n    \\n    private int getGraIndex(String gra){\\n        switch(gra){\\n            case \"Year\":\\n                return 0;\\n            case \"Month\":\\n                return 1;\\n            case \"Day\":\\n                return 2;\\n            case \"Hour\":\\n                return 3;\\n            case \"Minute\":\\n                return 4;\\n            case \"Second\":\\n                return 5;\\n        }\\n        return -1;       \\n    }\\n    \\n    class TimeNode{\\n        TimeNode parent; \\n        TreeMap<Integer, TimeNode> children;\\n        int key;\\n        int id=-1;\\n        \\n        public TimeNode(TimeNode parent, int key){\\n            this.parent = parent;\\n            this.key = key;\\n            children = new TreeMap<>();\\n        }\\n        \\n        public void add(int[] time, int i, int id){\\n            if(i==time.length){\\n                this.id = id;\\n                return;\\n            }\\n            TimeNode node = children.get(time[i]);\\n            if(node == null){\\n                node = new TimeNode(this, time[i]);\\n                children.put(time[i], node);\\n            }\\n            node.add(time, i+1, id);\\n        }\\n        //the Time second node which is >= given time\\n        public TimeNode getTimeNode(int[] time, int i, int graLevel){\\n            if(i==graLevel+1){\\n                return this.getFirstSecNode();\\n            }\\n            if(children.containsKey(time[i])){\\n                return children.get(time[i]).getTimeNode(time, i+1, graLevel);\\n            }\\n            TimeNode nextSibling = getNextSibling(time[i]);\\n            if(nextSibling != null) return nextSibling.getFirstSecNode();\\n            else return nextSecNode();\\n        }\\n           \\n        public TimeNode nextSecNode(){\\n            TimeNode node = this;\\n            TimeNode nextSibling = null;\\n            while (node.parent != null ){\\n                nextSibling = node.parent.getNextSibling(node.key);\\n                if (nextSibling != null) break;\\n                node = node.parent;\\n            }\\n            return nextSibling == null? null : nextSibling.getFirstSecNode();\\n        }\\n        \\n        //For any node in the tree, return the first node represent Second\\n        private TimeNode getFirstSecNode(){\\n            TimeNode node = this;\\n            while(!node.children.isEmpty()){\\n                Integer firstKey=node.children.firstKey();\\n                node = node.children.get(firstKey);\\n            }\\n            return node;\\n        }\\n        \\n        private TimeNode getNextSibling(int key){\\n            Integer nextSiblingIdx = children.ceilingKey(key+1);\\n            if (nextSiblingIdx == null)  return null;\\n            return children.get(nextSiblingIdx);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LogSystem object will be instantiated and called as such:\\n * LogSystem obj = new LogSystem();\\n * obj.put(id,timestamp);\\n * List<Integer> param_2 = obj.retrieve(s,e,gra);\\n */\\n```"
		},
		{
			"lc_ans_id":"105032",
			"view":"65",
			"top":"9",
			"title":"Just some thinking. When the problem goes bigger (much more than 300 operations) and query is more frequent than input , BST or TreeMap(Java) or any other self balanced trees are better solutions.",
			"vote":"1",
			"content":"Just some analysis first, code will come later.\\nFor this query, if you do it in hashmap way, u need traverse the entire collection to pick out the satisfied records. But for BST, u only need go through part of nodes on average. (For extreme cases like the start is the earliest timestamp and the end is the latest one, of course you need go through the entire data structure. )  There is another problem of BST, balance. The structure of BST really depends on the input sequence. But for TreeMap in Java, it is implemented by red-black tree, it is always balanced comparing to BST. So when you query some short period of time, it works better. \\nPS: 1. The BST here may need store nodes with the same timestamp. \\n       2. The smaller the time period is, the performance of tree structure is closer to O(log(n)).\\n\\nBST Solution (TreeMap one will come soon.):\\n\\n    TreeNode root;\\n    public LogSystem() {\\n        root = null;\\n    }   \\n    public void put(int id, String timestamp) {\\n        TreeNode newNode = new TreeNode(id, timestamp);\\n        insert(newNode);    \\n    }\\n    public List<Integer> retrieve(String s, String e, String gra) {\\n        List<Integer> ret = new ArrayList<>();\\n        query(s, e, gra, ret, root);\\n        return ret;\\n    }\\n    private void query(String s, String e, String gra, List<Integer> ret, TreeNode current) {\\n        if (current == null) return;\\n        if (compareTS(current.ts, s, gra) >= 0 && compareTS(current.ts, e, gra) <= 0) {\\n            ret.add(current.id);\\n            query(s, e, gra, ret, current.left);\\n            query(s, e, gra, ret, current.right);\\n        }\\n        else if ( compareTS(current.ts, s, gra) < 0) {\\n            query(s, e, gra, ret, current.right);\\n        }\\n        else{\\n            query(s, e, gra, ret, current.left);\\n        }\\n    }\\n    private int compareTS(String t1, String t2, String gra) {\\n        String[] ts1 = t1.split(\":\");\\n        String[] ts2 = t2.split(\":\");\\n        int end = ts1.length;\\n        switch (gra) {\\n            case \"Year\":\\n                end = 0;\\n                break;\\n            case \"Month\":\\n                end = 1;\\n                break;\\n            case \"Day\":\\n                end = 2;\\n                break;\\n            case \"Hour\":\\n                end = 3;\\n                break;\\n            case \"Minute\":\\n                end = 4;\\n                break;\\n            case \"Second\":\\n                end = 5;\\n                break;\\n        }\\n        for (int i = 0; i <= end; i++) {\\n            if (Integer.parseInt(ts1[i]) < Integer.parseInt(ts2[i])) return -1; // t1 < t2 return -1\\n            else if (Integer.parseInt(ts1[i]) > Integer.parseInt(ts2[i])) return 1; // t1 > t2 return 1;\\n        }\\n        return 0; // 2 timestamps are the same, return 0;\\n    }   \\n    private void insert(TreeNode newNode) {\\n        if (root == null) {\\n            root = newNode;\\n            return;\\n        } \\n        TreeNode current = root;\\n        while(current != null) { // bigger or equal to the current node timestamp put onto the left child, else right.\\n            if (compareTS(newNode.ts, current.ts, \"Second\") <= 0) {\\n                if (current.left == null) {\\n                    current.left = newNode;\\n                    break;\\n                }\\n                else {\\n                    current = current.left;\\n                }\\n            }\\n            else {\\n                if(current.right == null) { \\n                    current.right = newNode;\\n                    break;\\n                }\\n                else {\\n                    current = current.right;\\n                }\\n            }\\n        }\\n    }\\n    class TreeNode{\\n        int id;\\n        String ts;\\n        TreeNode left;\\n        TreeNode right;\\n        public TreeNode(int id, String ts) {\\n            this.id = id;\\n            this.ts = ts;\\n        }\\n    }"
		}
	],
	"id":"613",
	"title":"Design Log Storage System",
	"content":"<p>You are given several logs that each log contains a unique id and timestamp. Timestamp is a string that has the following format: <code>Year:Month:Day:Hour:Minute:Second</code>, for example, <code>2017:01:01:23:59:59</code>. All domains are zero-padded decimal numbers. </p>\r\n\r\n<p>Design a log storage system to implement the following functions:</p>\r\n\r\n<p><code>void Put(int id, string timestamp)</code>: Given a log's unique id and timestamp, store the log in your storage system.</p>\r\n<br>\r\n<p><code>int[] Retrieve(String start, String end, String granularity)</code>: Return the id of logs whose timestamps are within the range from start to end. Start and end all have the same format as timestamp. However, granularity means the time level for consideration. For example, start = \"2017:01:01:23:59:59\", end = \"2017:01:02:23:59:59\", granularity = \"Day\", it means that we need to find the logs within the range from Jan. 1st 2017 to Jan. 2nd 2017.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\nput(1, \"2017:01:01:23:59:59\");\r\nput(2, \"2017:01:01:22:59:59\");\r\nput(3, \"2016:01:01:00:00:00\");\r\nretrieve(\"2016:01:01:01:01:01\",\"2017:01:01:23:00:00\",\"Year\"); // return [1,2,3], because you need to return all logs within 2016 and 2017.\r\nretrieve(\"2016:01:01:01:01:01\",\"2017:01:01:23:00:00\",\"Hour\"); // return [1,2], because you need to return all logs start from 2016:01:01:01 to 2017:01:01:23, where log 3 is left outside the range.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>There will be at most 300 operations of Put or Retrieve.</li>\r\n<li>Year ranges from [2000,2017]. Hour ranges from [00,23].</li>\r\n<li>Output for Retrieve has no order required.</li>\r\n</ol>\r\n</p>",
	"frequency":"104",
	"ac_num":"4234"
}