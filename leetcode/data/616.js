{
	"difficulty":"2",
	"submit_num":"19683",
	"show_id":"638",
	"leetcode_id":"638",
	"answers":[
		{
			"lc_ans_id":"105194",
			"view":"7035",
			"top":"0",
			"title":"Simple Java recursive solution",
			"vote":"20",
			"content":"The basic idea is to pick each offer, and subtract the needs. And then compute the price without the offer. \\nPick whichever is minimum.\\n\\nEdit : ) much appreciated if someone can shorten the code with Java8 :)\\n\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int result = Integer.MAX_VALUE;\\n        //apply each offer to the needs, and recurse\\n        for(int i = 0; i < special.size(); i++) {\\n            List<Integer> offer = special.get(i);\\n            boolean invalidOffer = false;\\n            for(int j = 0; j < needs.size(); j++) { // subtract offer items from needs\\n                int remain = needs.get(j) - offer.get(j);\\n                needs.set(j, remain);\\n                if(!invalidOffer && remain < 0) invalidOffer = true; // if offer has more items than needs\\n            }\\n            if(!invalidOffer) { //if valid offer, add offer price and recurse remaining needs\\n                result = Math.min(result, shoppingOffers(price, special, needs) + offer.get(needs.size()));\\n            }\\n            for(int j = 0; j < needs.size(); j++) { // reset the needs\\n                int remain = needs.get(j) + offer.get(j);\\n                needs.set(j, remain);\\n            }\\n        }\\n        // choose b/w offer and non offer\\n        int nonOfferPrice = 0;\\n        for(int i = 0; i < needs.size(); i++) {\\n            nonOfferPrice += price.get(i) * needs.get(i);\\n        }\\n        return Math.min(result, nonOfferPrice);\\n    }\\n\\n**`UPDATE 1` :** For the below test case, we get time limit exceeded since it's exponential. TLE due to needs=30+.\\nI've requested admins to add this testcase.\\n```\\n[2,5]\\n[[1,0,5],[1,2,10]]\\n[39,39]\\n```\\n\\n~~So I made some optimization to reduce the recursive calls, by precomputing the number of times offer can be applied.~~  See **UPDATE 3**, there's an example that breaks this greedy optimization.\\n\\n```java\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        int result = Integer.MAX_VALUE;\\n        //apply each offer to the needs, and recurse\\n        for(int i = 0; i < special.size(); i++) {\\n            List<Integer> offer = special.get(i);\\n            boolean invalidOffer = false;\\n            int offerCount = Integer.MAX_VALUE; // number of times offer can be applied\\n            for(int j = 0; j < needs.size(); j++) { // pre-compute number of times offer can be called\\n                int remain = needs.get(j) - offer.get(j);\\n                if(!invalidOffer && remain < 0) invalidOffer = true; // if offer has more items than needs\\n                if(offer.get(j) > 0)\\n                offerCount = Math.min(offerCount, needs.get(j)/offer.get(j));\\n            }\\n            for(int j = 0; j < needs.size(); j++) { // subtract offer items from needs\\n                int remain = needs.get(j) - offer.get(j) * offerCount;\\n                needs.set(j, remain);\\n            }\\n            if(!invalidOffer) { //if valid offer, add offer price and recurse remaining needs\\n                result = Math.min(result, shoppingOffers(price, special, needs) + (offerCount * offer.get(needs.size())));\\n            }\\n\\n            for(int j = 0; j < needs.size(); j++) { // reset the needs\\n                int remain = needs.get(j) + offer.get(j) * offerCount;\\n                needs.set(j, remain);\\n            }\\n        }\\n\\n        // choose b/w offer and non offer\\n        int nonOfferPrice = 0;\\n        for(int i = 0; i < needs.size(); i++) {\\n            nonOfferPrice += price.get(i) * needs.get(i);\\n        }\\n        return Math.min(result, nonOfferPrice);\\n    }\\n```\\n\\n**`UPDATE 2:`** I think OJ is breaking with the below test case. My code handles it though. Expected output is 8000, since it has two items of 1$ each. I've requested to add the test case. Also, another assumption is that result doesn't exceed Integer.MAX_VALUE. @administrators \\n```\\n[1,1]\\n[[1,1,2],[1,1,3]]\\n[4000,4000]\\n```\\n\\n**`UPDATE 3:`** From @Red_Eden 's thought, I found a test case that breaks my optimization. OJ is missing this test as well. My solution gives answer = 6, but actual is pick one offer just once = 4.\\n```\\n[500]\\n[[2,1],[3,2],[4,1]]\\n[9]\\n```"
		},
		{
			"lc_ans_id":"105211",
			"view":"5050",
			"top":"1",
			"title":"Java DFS + DP",
			"vote":"15",
			"content":"```public class Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        Map<List<Integer>, Integer> dp = new HashMap<>();\\n        List<Integer> allZero = new ArrayList<>();\\n        for(int i=0;i<needs.size();i++) {\\n            allZero.add(0);\\n        }\\n        dp.put(allZero, 0);\\n        return dfs(needs, price, special, dp);\\n    }\\n    private int dfs(List<Integer> needs, List<Integer> price, List<List<Integer>> special, Map<List<Integer>, Integer> dp) {\\n        if(dp.containsKey(needs)) return dp.get(needs);\\n        int res = Integer.MAX_VALUE;\\n        for(List<Integer> s : special) {\\n            List<Integer> needsCopy = new ArrayList<>(needs);\\n            boolean valid = true;\\n            for(int i=0;i<needs.size();i++) {\\n                needsCopy.set(i, needsCopy.get(i) - s.get(i));\\n                if(needsCopy.get(i) < 0) {\\n                    valid = false;\\n                    break;\\n                }\\n            }\\n            if(valid) {\\n                res = Math.min(res, s.get(needs.size()) + dfs(needsCopy, price, special, dp));\\n            }\\n        }\\n        //What if we do not use specials? specials can be deceiving,\\n        //perhaps buying using regular prices is cheaper.\\n        int noSpecial = 0;\\n            for(int i=0;i<needs.size();i++) {\\n                noSpecial += needs.get(i) * price.get(i);\\n            }\\n        res = Math.min(res, noSpecial);    \\n\\n        dp.put(needs, res);\\n        return res;\\n    }\\n}"
		},
		{
			"lc_ans_id":"105212",
			"view":"483",
			"top":"2",
			"title":"Very Easy to understand JAVA Solution beats 95% with explanation",
			"vote":"8",
			"content":"The idea is very similar to combination sum. In combination sum where each element can be repeated, check each element to see if it can be used (in this case, if the sum doesn't exceed the target). If so, use it. Repeat this until we get the result.\\n\\nFor this question, we check each promotion offers, if the offer can be used, use it. Repeat the process and find the minimum result. In this question, the condition whether one offer can be used is the number of items in the offer doesn't exceed the needed number. Find the minimum among all combinations. \\n\\nThe thing to remember, which also happens in real life is that some special offers are actually more expensive than buying each individual item in the offers!!! Thus be smart and compare if buying directly is cheaper.\\n\\nhere is my code:\\n\\n```\\npublic class Solution {\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n    \\treturn helper(price, special, needs, 0);\\n    }\\n    \\n    private int helper(List<Integer> price, List<List<Integer>> special, List<Integer> needs, int pos) {\\n    \\tint local_min = directPurchase(price, needs);\\n    \\tfor (int i = pos; i < special.size(); i++) {\\n    \\t\\tList<Integer> offer = special.get(i);\\n    \\t\\tList<Integer> temp = new ArrayList<Integer>();\\n        \\tfor (int j= 0; j < needs.size(); j++) {\\n        \\t\\tif (needs.get(j) < offer.get(j)) { // check if the current offer is valid\\n        \\t\\t\\ttemp =  null;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\ttemp.add(needs.get(j) - offer.get(j));\\n        \\t}\\n        \\t\\n    \\t\\tif (temp != null) { // use the current offer and try next\\n    \\t\\t\\tlocal_min = Math.min(local_min, offer.get(offer.size() - 1) + helper(price, special, temp, i)); \\n    \\t\\t}\\n    \\t}\\n\\n    \\treturn  local_min;\\n    }\\n    \\n    private int directPurchase(List<Integer> price, List<Integer> needs) {\\n    \\tint total = 0;\\n    \\tfor (int i = 0; i < needs.size(); i++) {\\n    \\t\\ttotal += price.get(i) * needs.get(i);\\n    \\t}\\n    \\t\\n    \\treturn total;\\n    }\\n}\\n\\n```"
		},
		{
			"lc_ans_id":"105204",
			"view":"1003",
			"top":"3",
			"title":"Python dfs with memorization.",
			"vote":"8",
			"content":"```\\ndef shoppingOffers(self, price, special, needs):\\n        d = {}\\n        def dfs(cur):\\n            val = sum(cur[i]*price[i] for i in range(len(needs))) #cost without special\\n            for spec in special:\\n                tmp = [cur[j] - spec[j] for j in range(len(needs))]\\n                if min(tmp) >= 0: # skip deals that exceed needs\\n                    val = min(val, d.get(tuple(tmp), dfs(tmp)) + spec[-1]) # .get check the dictionary first for result, otherwise perform dfs.\\n            d[tuple(cur)] = val\\n            return val\\n        return dfs(needs)\\n```"
		},
		{
			"lc_ans_id":"105251",
			"view":"2451",
			"top":"4",
			"title":"C++, DP/DFS with Memoization",
			"vote":"8",
			"content":"The idea is to try every special offer using DFS, and memorize intermediate results, which is one type of DP. \\n1) There is at most 6 items and each item is at most 6, so we can use a 6 digit int as the key.\\n2) Test every special offer. If invalid, break. We have to pay for **EXACTLY** certain items, no more no less.\\n3) Greedy doesn't work. One example is [3, 2], [[1, 2, 4] [2, 1, 5]], [6, 6]. We need 2 first offers and 2 second offers. Greedy would choose 3 first offers.\\n```\\nclass Solution {\\npublic:\\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\\n        // memorize intermediate results \\n        unordered_map<int, int> mp;\\n        return helper(price, special, mp, get_key(needs));\\n    }\\nprivate:\\n    int helper(vector<int>& price, vector<vector<int>>& special, unordered_map<int, int>& mp, int k) {\\n        if (mp.count(k)) return mp[k];\\n        int n = price.size(), ans = 0;\\n        // pows is to help get each digit of key\\n        vector<int> pows(n, 1);\\n        for (int i = n-2; i >= 0; i--) pows[i] = pows[i+1]*10;\\n        for (int i = 0; i < n; i++) ans += ((k/pows[i])%10)*price[i];\\n        for (auto spe:special) {\\n            int key = 0, i = 0;\\n            // check whether this offer is valid\\n            while (i < n) {\\n                int t = (k/pows[i])%10;\\n                if (t >= spe[i]) \\n                    key = key*10+(t-spe[i++]);\\n                else\\n                    break;\\n            } \\n            if (i == n) ans = min(ans, spe[n]+helper(price, special, mp, key));\\n        }\\n        mp[k] = ans;\\n        return ans;\\n    }\\n    int get_key(vector<int>& needs) {\\n        int n = needs.size(), key = 0;\\n        for (int i = n-1, p = 1; i >= 0; i--, p *= 10)\\n            key += needs[i]*p;\\n        return key;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"105214",
			"view":"3147",
			"top":"5",
			"title":"A just for fun only DP solution",
			"vote":"8",
			"content":"it seems very like the dynamic programming problem. But when I solve the dp problem such like knapsack problem. I need the end of this problem, i.e. the volume of knapsack. If I know this, then the problem totally a knapsack problem. luckily, I get this from\\n1. There are at most 6 kinds of items, 100 special offers.\\n2. For each item, you need to buy at most 6 of them.\\nThen I add to 6 item for every input argument.\\nThis code have O(special offers size) time complex. When the input is small, it's not the best time complex. And it also not very general.\\n```\\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs)\\n{\\n\\tint n = price.size();\\n\\tfor (int i = n; i < 6; i++)\\n\\t{\\n\\t\\tprice.push_back(0);\\n\\t\\tneeds.push_back(0);\\n\\t}\\n\\tfor (int i = special.size() - 1; i >= 0; i--)  // fill special to 6 items\\n\\t{\\n\\t\\tint t = special[i][n];\\n\\t\\tspecial[i][n] = 0;\\n\\t\\tfor (int j = n + 1; j < 7; j++)\\n\\t\\t\\tspecial[i].push_back(0);\\n\\t\\tspecial[i][6] = t;\\n\\t}\\n\\tint dp[7][7][7][7][7][7], m = special.size();\\n\\t//memset(dp, INT_MAX, 7 * 7 * 7 * 7 * 7 * 7);      \\n\\t//as @vallentin-petrov point out, memset fill the space by byte\\n\\tfor (int j = 0; j < 7; j++)\\n\\t{\\n\\t\\tfor (int k = 0; k < 7; k++)\\n\\t\\tfor (int p = 0; p < 7; p++)\\n\\t\\tfor (int q = 0; q < 7; q++)\\n\\t\\tfor (int r = 0; r < 7; r++)\\n\\t\\tfor (int s = 0; s < 7; s++)\\n\\t\\t\\tdp[j][k][p][q][r][s]=j*price[0]+k*price[1]+p*price[2]+q*price[3]+r*price[4]+s*price[5];\\n\\t}\\n\\tfor (int i = 0; i < m; i++)  // then it just a dynamic programming problem\\n\\t{\\n\\t\\tfor (int j = special[i][0]; j < 7; j++)\\n\\t\\tfor (int k = special[i][1]; k < 7; k++)\\n\\t\\tfor (int p = special[i][2]; p < 7; p++)\\n\\t\\tfor (int q = special[i][3]; q < 7; q++)\\n\\t\\tfor (int r = special[i][4]; r < 7; r++)\\n\\t\\tfor (int s = special[i][5]; s < 7; s++)\\n\\t\\t{\\n\\t\\t\\tint tt=dp[j-special[i][0]][k-special[i][1]][p-special[i][2]]\\n\\t\\t\\t\\t[q-special[i][3]][r-special[i][4]][s-special[i][5]];\\n\\t\\t\\tif (tt != INT_MAX)\\n\\t\\t\\t\\tdp[j][k][p][q][r][s]=min(dp[j][k][p][q][r][s],tt+special[i][6]);\\n\\t\\t}\\n\\t}\\n\\treturn dp[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\\n}\\n```\\nspecial thanks to @vallentin-petrov for point out the problem about memset~~\\nAnd thanks to @wulingyun16 for his advice~~"
		},
		{
			"lc_ans_id":"105200",
			"view":"744",
			"top":"6",
			"title":"C++ solution",
			"vote":"4",
			"content":"    class Solution {\\n    public:\\n        int shoppingOffers(const vector<int>& price, const vector<vector<int>>& special, const vector<int>& needs) {\\n            int result = inner_product(price.begin(), price.end(), needs.begin(), 0);\\n            for (const vector<int>& offer : special) {\\n                vector<int> r = can(needs, offer);\\n                if (r.empty()) continue;\\n                result = min(result, offer.back() + shoppingOffers(price, special, r));\\n            }\\n            return result;\\n        }\\n        vector<int> can(const vector<int>& needs, const vector<int>& offer) {\\n            vector<int> r(needs.size(), 0);\\n            for (int i = 0, n = needs.size(); i < n; ++i) {\\n                if (offer[i] > needs[i]) return vector<int>();\\n                r[i] = needs[i] - offer[i];\\n            }\\n            return r;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"105252",
			"view":"340",
			"top":"7",
			"title":"Concise c++ DFS solution, 6ms",
			"vote":"3",
			"content":"```\\nint shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int cost = 0) {\\n    if (needs < 0)\\n        return INT_MAX;\\n\\n    int m = cost + needs * price;\\n\\n    for (auto &offer : special) {\\n        if (cost + offer.back() >= m) // pruning\\n            continue;\\n        needs -= offer;\\n        m = min(m, shoppingOffers(price, special, needs, cost + offer.back()));\\n        needs += offer;\\n    }\\n\\n    return m;\\n}\\n```\\n\\nwith the following operators defined above the Solution class:\\n```\\nvoid operator+=(vector<int> &a, const vector<int> &b) {\\n    for (int i = 0; i < a.size(); i++)\\n        a[i] += b[i];\\n}\\n\\nvoid operator-=(vector<int> &a, const vector<int> &b) {\\n    for (int i = 0; i < a.size(); i++)\\n        a[i] -= b[i];\\n}\\n\\nbool operator<(const vector<int> &a, const int &n) {\\n    for (int i : a)\\n        if (i < n)\\n            return true;\\n    return false;\\n}\\n\\nint operator*(const vector<int> &a, const vector<int> &b) {\\n    int res = 0;\\n    for (int i = 0; i < a.size(); i++)\\n        res += a[i] * b[i];\\n    return res;\\n}\\n```"
		},
		{
			"lc_ans_id":"105199",
			"view":"713",
			"top":"8",
			"title":"Scala solutions are rejected because they exceed compile time limit...",
			"vote":"3",
			"content":"I think I have a quite reasonable 80-line answer to this question in Scala, but it was rejected because the compile time limit is exceeded... Either this limit should be raised, or Scala should not be accepted as a language option. It's otherwise a waste of time."
		},
		{
			"lc_ans_id":"105241",
			"view":"632",
			"top":"9",
			"title":"Java code using DFS with memorization",
			"vote":"2",
			"content":"```\\npublic class Solution {\\n    List<Integer> a,c;\\n    List<List<Integer>> b;\\n    int n,m;\\n    Map<Integer,Integer> map=new HashMap<>();\\n    int hashc(List<Integer> a) //Hashcode for the needs list (we turn an state array to an integer)\\n    {\\n        int num=0;\\n        for (int i=0;i<a.size();i++) num=num*10+a.get(i);\\n        return num;\\n    }\\n    int dfs(List<Integer> c)\\n    {\\n        for (int i=0;i<n;i++) // needs<0 is illegal\\n            if (c.get(i)<0) return 10000000;\\n        int ha=hashc(c);\\n        if (map.containsKey(ha)) return map.get(ha); // If we have dealt with this state before, just use our previous result (to avoid repetitive computation)\\n        int ans=0;\\n        for (int i=0;i<n;i++) ans+=c.get(i)*a.get(i); // buy all goods one by one\\n        for (int i=0;i<m;i++) //use each offer\\n        {\\n            List<Integer> now=b.get(i);\\n            int price=now.get(n);\\n            for (int j=0;j<n;j++) c.set(j,c.get(j)-now.get(j));\\n            ans=Math.min(ans,price+dfs(c));\\n            for (int j=0;j<n;j++) c.set(j,c.get(j)+now.get(j));\\n        }\\n        map.put(ha,ans); //Store the result for this state\\n        return ans;\\n    }\\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\\n        a=price;\\n        b=special;\\n        n=price.size();\\n        m=special.size();\\n        return dfs(needs);\\n    }\\n}\\n```"
		}
	],
	"id":"616",
	"title":"Shopping Offers",
	"content":"<p>\r\nIn LeetCode Store, there are some kinds of items to sell. Each item has a price.\r\n</p>\r\n\r\n<p>\r\nHowever, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\r\n</p>\r\n\r\n<p>\r\nYou are given the each item's price, a set of special offers, and the number we need to buy for each item.\r\nThe job is to output the lowest price you have to pay for <b>exactly</b> certain items as given, where you could make optimal use of the special offers.\r\n</p>\r\n\r\n<p>\r\nEach special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.\r\n</p>\r\n\r\n<p>You could use any of special offers as many times as you want.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [2,5], [[3,0,5],[1,2,10]], [3,2]\r\n<b>Output:</b> 14\r\n<b>Explanation:</b> \r\nThere are two kinds of items, A and B. Their prices are $2 and $5 respectively. \r\nIn special offer 1, you can pay $5 for 3A and 0B\r\nIn special offer 2, you can pay $10 for 1A and 2B. \r\nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]\r\n<b>Output:</b> 11\r\n<b>Explanation:</b> \r\nThe price of A is $2, and $3 for B, $4 for C. \r\nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \r\nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \r\nYou cannot add more items, though only $9 for 2A ,2B and 1C.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br />\r\n<ol>\r\n<li>There are at most 6 kinds of items, 100 special offers.</li>\r\n<li>For each item, you need to buy at most 6 of them.</li>\r\n<li>You are <b>not</b> allowed to buy more items than you want, even if that would lower the overall price.</li>\r\n</ol>\r\n</p>",
	"frequency":"162",
	"ac_num":"8815"
}