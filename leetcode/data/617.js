{
	"difficulty":"3",
	"submit_num":"38690",
	"show_id":"639",
	"leetcode_id":"639",
	"answers":[
		{
			"lc_ans_id":"105274",
			"view":"3938",
			"top":"0",
			"title":"Python, Straightforward with Explanation",
			"vote":"38",
			"content":"```.\\ndef numDecodings(self, S):\\n    MOD = 10**9 + 7\\n    e0, e1, e2 = 1, 0, 0\\n    for c in S:\\n        if c == '*':\\n            f0 = 9*e0 + 9*e1 + 6*e2\\n            f1 = e0\\n            f2 = e0\\n        else:\\n            f0 = (c > '0') * e0 + e1 + (c <= '6') * e2\\n            f1 = (c == '1') * e0\\n            f2 = (c == '2') * e0\\n        e0, e1, e2 = f0 % MOD, f1, f2\\n    return e0\\n```\\n\\nLet's keep track of:\\n* ```e0 =``` current number of ways we could decode, ending on any number;\\n* ```e1 =``` current number of ways we could decode, ending on an open 1;\\n* ```e2 =``` current number of ways we could decode, ending on an open 2;\\n\\n(Here, an \"open 1\" means a 1 that may later be used as the first digit of a 2 digit number, because it has not been used in a previous 2 digit number.)\\n\\nWith the right idea of what to keep track of, our dp proceeds straightforwardly.\\n\\n<hr>\\n\\nSay we see some character ```c```.  We want to calculate ```f0, f1, f2```, the corresponding versions of ```e0, e1, e2``` after parsing character ```c```.\\n\\nIf ```c == '*'```, then the number of ways to finish in total is: we could put * as a single digit number (```9*e0```), or we could pair * as a 2 digit number ```1*``` in ```9*e1``` ways, or we could pair * as a 2 digit number ```2*``` in ```6*e2``` ways.  The number of ways to finish with an open 1 (or 2) is just ```e0```.\\n\\nIf ```c != '*'```, then the number of ways to finish in total is: we could put ```c``` as a single digit if it is not zero (```(c>'0')*e0```), or we could pair ```c``` with our open 1, or we could pair ```c``` with our open 2 if it is 6 or less (```(c<='6')*e2```).  The number of ways to finish with an open 1 (or 2) is ```e0``` iff ```c == '1'``` (or ```c == '2'```)."
		},
		{
			"lc_ans_id":"105275",
			"view":"6410",
			"top":"1",
			"title":"Java DP, O(n) time and O(1) space",
			"vote":"29",
			"content":"The idea for DP is simple when using two helper functions\\n ways(i) -> that gives the number of ways of decoding a single character\\nand \\nways(i, j) -> that gives the number of ways of decoding the two character string formed by i and j.\\nThe actual recursion then boils down to :\\n```\\nf(i) = (ways(i) * f(i+1)) + (ways(i, i+1) * f(i+2))\\n```\\nThe solution to a string f(i), where i represents the starting index, \\n\\nf(i)  =  no.of ways to decode the character at i, which is ways(i) + solve for remainder of the string using recursion f(i+1) \\nand \\nno.of ways to decode the characters at i and i+1, which is ways(i, i+1) + solve for remainder of the string using recursion f(i+2) \\n\\nThe base case is , \\n```\\nreturn ways(s.charAt(i)) if(i == j) \\n```\\n\\nThe above recursion when implemented with a cache, is a viable DP solution, but it leads to stack overflow error, due to the depth of the recursion. So its better to convert to memoized version.\\n\\nFor the memoized version, the equation changes to \\n\\n```\\nf(i) = ( f(i-1) * ways(i) ) + ( f(i-2) *ways(i-1, i) )\\n```\\nThis is exactly the same as the previous recursive version in reverse,\\n\\nThe solution to a string f(i), where i represents the ending index of the string, \\n\\nf(i)  =  solution to the prefix of the string f(i-1) + no.of ways to decode the character at i, which is ways(i) \\nand \\nsolution to the prefix f(i-2) + no.of ways to decode the characters at i - 1 and i, which is ways(i-1, i) \\n```\\npublic class Solution {\\n    public static int numDecodings(String s) {\\n        long[] res = new long[2];\\n        res[0] = ways(s.charAt(0));\\n        if(s.length() < 2) return (int)res[0];\\n\\n        res[1] = res[0] * ways(s.charAt(1)) + ways(s.charAt(0), s.charAt(1));\\n        for(int j = 2; j < s.length(); j++) {\\n            long temp = res[1];\\n            res[1] = (res[1] * ways(s.charAt(j)) + res[0] * ways(s.charAt(j-1), s.charAt(j))) % 1000000007;\\n            res[0] = temp;\\n        }\\n        return  (int)res[1];\\n    }\\n    \\n    private static int ways(int ch) {\\n        if(ch == '*') return 9;\\n        if(ch == '0') return 0;\\n        return 1;\\n    }\\n\\n    private static int ways(char ch1, char ch2) {\\n        String str = \"\" + ch1 + \"\" + ch2;\\n        if(ch1 != '*' && ch2 != '*') {\\n            if(Integer.parseInt(str) >= 10 && Integer.parseInt(str) <= 26)\\n                return 1;\\n        } else if(ch1 == '*' && ch2 == '*') {\\n            return 15;\\n        } else if(ch1 == '*') {\\n            if(Integer.parseInt(\"\"+ch2) >= 0 && Integer.parseInt(\"\"+ch2) <= 6)\\n                return 2;\\n            else\\n                return 1;\\n        } else {\\n            if(Integer.parseInt(\"\"+ch1) == 1 ) {\\n                return 9;\\n            } else if(Integer.parseInt(\"\"+ch1) == 2 ) {\\n                return 6;\\n            } \\n        }\\n        return 0;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"105258",
			"view":"1671",
			"top":"2",
			"title":"Java O(N) by General Solution for all DP problems",
			"vote":"27",
			"content":"Here, I try to provide not only code but also the steps and thoughts of solving this problem completely which can also be applied to many other DP problems.\\n\\n(1) Try to solve this problem in Backtracking way, because it is the most straight-forward method. \\n```\\n E.g '12*3'\\n                   12*3\\n              /             \\\\\\n           12*(3)           12(*3) \\n         /     \\\\            /      \\\\\\n    12(*)(3)  1(2*)(3)  1(2)(*3)   \"\"\\n      /    \\\\      \\\\       /\\n1(2)(*)(3) \"\"     \"\"     \"\"   \\n    /\\n   \"\"\\n```\\n\\n(2) There are many nodes visited multiple times, like ```12``` and ```1```. Most importantly, the subtree of those nodes are \"exactly\" the same. The backtracking solution possibly can be improved by DP. Try to merge the same nodes.\\n```      \\n        12*3\\n        /  \\\\\\n      12*  |\\n       | \\\\ |\\n       |  12\\n       | / |\\n       1   |\\n        \\\\  |\\n          \"\"\\n```\\n\\n(3) Successfully merge those repeated nodes and find out the **optimal substructure**, which is:\\n```\\n      current state = COMBINE(next state ,  next next state)\\n      e.g\\n              12* \\n              / \\\\    \\n            COMBINE (few different conditions)\\n            /     \\\\       \\n           12      1\\n```\\nTherefore, we can solve this problem by DP in **bottom-up** way instead of top-down **memoization**.\\n    Now, we formulate the **optimal substructure**:\\n```\\n    dp[i] = COMBINE dp[i-1] and dp[i-2]\\n```\\nwhere **dp[i]  --> number of all possible decode ways of substring s(0 : i-1)**. Just keep it in mind.\\nBut we need to notice there are some different conditions for this COMBINE operation.\\n\\n(4) The pseudo code of solution would be:\\n```\\nSolution{\\n    /* initial conditions */\\n    dp[0] = ??\\n       :\\n\\n    /* bottom up method */\\n    foreach( i ){\\n        dp[i] = COMBINE dp[i-1] and dp[i-2] ;\\n    }\\n\\n    /* Return */\\n    return dp[last];\\n}\\n```\\n\\nThe COMBINE part will be something like:\\n```\\n    // for dp[i-1]\\n    if(condition A)\\n        dp[i] +=??  dp[i-1];\\n    else if(condition B)\\n        dp[i] +=??  dp[i-1];\\n            :\\n            :\\n\\n     // for dp[i-2]\\n    if(condition C)\\n        dp[i] +=?? dp[i-2];\\n    else if(condition D)   \\n        dp[i] +=?? dp[i-2];\\n             :\\n```\\n\\n(5) The core step of this solution is to find out all possible conditions and their corresponding operation of combination.\\n```\\n        For dp[i-1]:\\n\\n                  /           \\\\\\n                 /             \\\\\\n            s[i-1]='*'    s[i-1]>0     \\n                |               |\\n          + 9*dp[i-1]        + dp[i-1]\\n\\n             \\n        For dp[i-2]:\\n\\n                   /                                  \\\\\\n                  /                                    \\\\  \\n              s[n-2]='1'||'2'                         s[n-2]='*'\\n              /            \\\\                       /             \\\\     \\n        s[n-1]='*'         s[n-1]!='*'          s[n-1]='*'       s[n-1]!='*'\\n         /       \\\\               |                  |              /         \\\\\\n  s[n-2]='1'  s[n-2]='2'   num(i-2,i-1)<=26         |         s[n-1]<=6    s[n-1]>6\\n      |            |             |                  |              |            |\\n + 9*dp[i-2]   + 6*dp[i-2]     + dp[i-2]       + 15*dp[i-2]    + 2*dp[i-2]   + dp[i-2]\\n```\\n\\n(6) Fill up the initial conditions before i = 2. \\nBecause we need to check if num(i-2,i-1)<=26 for each i, we make the bottom-up process to begin from i=2. Just fill up the dp[0] and dp[1] by observation and by the definition of **dp[i]  --> number of all possible decode ways of substring s(0 : i-1)**.\\n\\n             dp[0]=1;\\n             /      \\\\\\n        s[0]=='*'  s[0]!='*'\\n            |         |\\n        dp[1]=9     dp[1]=1\\n\\n(7) The final Solution:\\n```\\n    public int numDecodings(String s) {\\n        /* initial conditions */\\n        long[] dp = new long[s.length()+1];\\n        dp[0] = 1;\\n        if(s.charAt(0) == '0'){\\n            return 0;\\n        }\\n        dp[1] = (s.charAt(0) == '*') ? 9 : 1;\\n\\n        /* bottom up method */\\n        for(int i = 2; i <= s.length(); i++){\\n            char first = s.charAt(i-2);\\n            char second = s.charAt(i-1);\\n\\n            // For dp[i-1]\\n            if(second == '*'){\\n                dp[i] += 9*dp[i-1];\\n            }else if(second > '0'){\\n                dp[i] += dp[i-1];\\n            }\\n            \\n            // For dp[i-2]\\n            if(first == '*'){\\n                if(second == '*'){\\n                    dp[i] += 15*dp[i-2];\\n                }else if(second <= '6'){\\n                    dp[i] += 2*dp[i-2];\\n                }else{\\n                    dp[i] += dp[i-2];\\n                }\\n            }else if(first == '1' || first == '2'){\\n                if(second == '*'){\\n                    if(first == '1'){\\n                       dp[i] += 9*dp[i-2]; \\n                    }else{ // first == '2'\\n                       dp[i] += 6*dp[i-2]; \\n                    }\\n                }else if( ((first-'0')*10 + (second-'0')) <= 26 ){\\n                    dp[i] += dp[i-2];    \\n                }\\n            }\\n\\n            dp[i] %= 1000000007;\\n        }\\n        /* Return */\\n        return (int)dp[s.length()];\\n    }\\n```\\n\\n\\nP.S The space complexity can be further improved to O(1) because the current state i is only related to i-1 and i-2 during the bottom-up."
		},
		{
			"lc_ans_id":"105265",
			"view":"2622",
			"top":"3",
			"title":"C++, DP, O(n) time O(1) space",
			"vote":"12",
			"content":"The idea is DP. One of the hints is that you need mod the answer with a huge prime number.\\n1) For any string s longer than 2, we can decode either the last 2 characters as a whole or the last 1 character. So dp[i] = dp[i-1]* f(s.substr(i,1)) + dp[i-2]* f(s.substr(i-1, 2)). f() is the number of ways to decode a string of length 1 or 2. f() could be 0, for example f(\"67\").\\n2) There is a lot of cases and corner cases for f(string s).  For example, * cannot be '0', so ** has 15 instead of 16 possibilities, because \"20\" is excluded. But the time complexity is still O(n).\\nThe code is as below.\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size(), p = 1000000007;\\n        // f2 is the answer to sub string ending at position i; Initially i = 0.\\n        long f1 = 1, f2 = helper(s.substr(0,1));\\n        // DP to get f2 for sub string ending at position n-1;\\n        for (int i = 1; i < n; i++) {\\n            long f3 = (f2*helper(s.substr(i, 1)))+(f1*helper(s.substr(i-1, 2)));\\n            f1 = f2;\\n            f2 = f3%p;\\n        }\\n        return f2;\\n    }\\nprivate:\\n    int helper(string s) {\\n        if (s.size() == 1) {\\n            if (s[0] == '*') return 9;\\n            return s[0] == '0'? 0:1;\\n        }\\n        // 11-26, except 20 because '*' is 1-9\\n        if (s == \"**\")  \\n            return 15;\\n        else if (s[1] =='*') {\\n            if (s[0] =='1') return 9;\\n            return s[0] == '2'? 6:0;\\n        }\\n        else if (s[0] == '*') \\n            return s[1] <= '6'? 2:1;\\n        else \\n            // if two digits, it has to be in [10 26]; no leading 0\\n            return stoi(s) >= 10 && stoi(s) <= 26? 1:0; \\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"105301",
			"view":"1063",
			"top":"4",
			"title":"What about \\u2018*\\u2019 can be from 0 to 9",
			"vote":"8",
			"content":"I found '*' in this question can only be 1 to 9. But things may be more complicated when it can also be 0;\\n\\nInput: \"1*\"\\nthere should be 19 ways:\\n(1) from 10  to 19 :  10 ways;\\n(2) from A1 to A9: 9 ways;\\nthen the total ways are 10 + 9 = 19\\n\\nInput: \"**\"\\nthe first '*' can not be set to 0, as 0 is not any character."
		},
		{
			"lc_ans_id":"105276",
			"view":"1812",
			"top":"5",
			"title":"Java DP Solution O(n) time and space, Some Explanations",
			"vote":"8",
			"content":"Take \"1*\" as an example. It can be \"11\"-\"19\". You can read it into \"A\" and \"A\" to \"A\" and \"I\" or you can treat it as a two digit number as \"K\" to \"S\".  That is the way you decode the code.\\nSo if you treat the current character s.charAt(i) as a single character, the dp result of the index i should be the number of choices of current character times dp[i-1]. If you put the s.charAt(i) together with s.charAt(i-1) as a two digit number (if possible, something like \"29\" is not a possible pair), dp[i] should add the choices of the current pair times dp[i-2]. That is basic thinking of dp for this problem. Then what should be done is to find what kind of pairs or single numbers are valid. Like a single \"0\" is not valid, and there is no answer for something like \"30\".\\nJust think about the different conditions carefully.\\n\\n \\n\\n    public int numDecodings(String s) {\\n        int len = s.length();\\n        int mod = 1000000007;\\n        long [] dp = new long[len + 1];\\n        dp[0] = 1;\\n        if (s.charAt(0) == '0') return 0;\\n        if (s.charAt(0) == '*'){\\n            dp[1] = 9;\\n        }\\n        else{\\n            dp[1] = 1;\\n        }\\n        for (int i = 2; i<=len; i++) { // i-1 the index of current character in s. \\n            if (s.charAt(i-1) == '0') {\\n                if (s.charAt(i-2) == '1' || s.charAt(i -2) == '2') {\\n                    dp[i] = dp[i-2];\\n                }\\n                else if(s.charAt(i-2) == '*'){\\n                    dp[i] = 2*dp[i-2];\\n                }\\n                else {\\n                    return 0;\\n                }\\n            }\\n            else if(s.charAt(i-1) >= '1' && s.charAt(i-1) <= '9') {\\n                dp[i] = dp[i-1];\\n                if (s.charAt(i-2) == '1' || (s.charAt(i-2) == '2' && s.charAt(i-1) <= '6') ){\\n                    dp[i] = (dp[i] + dp[i-2]) % mod;\\n                }\\n                else if (s.charAt(i-2) == '*') {\\n                    if (s.charAt (i-1) <= '6') {\\n                        dp[i] = (dp[i] + dp[i-2] * 2) % mod;\\n                    }\\n                    else {\\n                        dp[i] = (dp[i] + dp[i-2]) % mod;\\n                    }\\n                }\\n            }\\n            else { //s.charAt(i-1) == '*'\\n                dp[i] = (9*dp[i-1]) % mod;\\n                if ( s.charAt(i-2) == '1' ){ // 11 - 19\\n                    dp[i] = ( dp[i] + 9 * dp[i-2] ) % mod;\\n                }\\n                else if (s.charAt(i-2) == '2') { // 21 - 26\\n                    dp[i] = ( dp[i] + 6 * dp[i-2] ) % mod;\\n                }\\n                else if (s.charAt(i - 2) == '*') {\\n                    dp[i] = ( dp[i] + 15 * dp[i-2] ) % mod;\\n                }\\n            }\\n        }\\n        return (int)dp[len];\\n    }"
		},
		{
			"lc_ans_id":"105278",
			"view":"568",
			"top":"6",
			"title":"why does \"1101\" answer  2, I think it should be 1",
			"vote":"5",
			"content":"![0_1499683970159_WechatIMG19676.jpeg](/assets/uploads/files/1499683957842-wechatimg19676-resized.jpeg)"
		},
		{
			"lc_ans_id":"105273",
			"view":"295",
			"top":"7",
			"title":"Wrong Expected Output",
			"vote":"5",
			"content":"Hi, \\nI am getting expected output `0` for input `10` and `20`. Shouldn't it be `1`."
		},
		{
			"lc_ans_id":"105257",
			"view":"207",
			"top":"8",
			"title":"My code passed \"********\" test but not \"*********\" (one extra *). Why?",
			"vote":"3",
			"content":"The test \"*********\" on my code:\\n\\nYour answer\\n1291868919\\nExpected answer\\n291868912\\n\\n\\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [0] * (len(s)+1)\\n        dp[0] = 1\\n        for i, c in enumerate(s):\\n            dpi = i+1\\n            # single digit\\n            if c == '*':\\n                ways1 = dp[dpi-1] * 9\\n            elif c != '0':\\n                ways1 = dp[dpi-1]\\n            else:\\n                ways1 = 0\\n            # double digits\\n            if i != 0:\\n                substr = s[i-1:i+1]\\n                if '*' not in substr:\\n                    ways2 = dp[dpi-2] if 10 <= int(substr) <= 26 else 0\\n                else:\\n                    if substr == \"**\":\\n                        ways2 = dp[dpi-2]*(9+6)\\n                    elif substr[0] == '*':\\n                        ways2 = dp[dpi-2] if int(substr[1]) > 6 else dp[dpi-2]*2\\n                    else:\\n                        assert substr[1] == '*'\\n                        if substr[0] == '1':\\n                            ways2 = dp[dpi-2]*9\\n                        elif substr[0] == '2':\\n                            ways2 = dp[dpi-2]*6\\n                        else:\\n                            ways2 = 0\\n            else:\\n                ways2 = 0\\n            dp[dpi] = ways1 + ways2\\n        return dp[-1]"
		},
		{
			"lc_ans_id":"105262",
			"view":"204",
			"top":"9",
			"title":"Python 6-lines DP solution",
			"vote":"3",
			"content":"```\\none = {'1': 1, '2': 1, '3': 1, '4': 1, '5': 1, '6': 1, '7': 1, '8': 1, '9': 1, '*': 9}\\ntwo = {'10': 1, '11': 1, '12': 1, '13': 1, '14': 1, '15': 1, '16': 1, '17': 1, '18': 1, '19': 1, '20': 1, '21': 1,\\n       '22': 1, '23': 1, '24': 1, '25': 1, '26': 1, '*0': 2, '*1': 2, '*2': 2, '*3': 2, '*4': 2, '*5': 2, '*6': 2,\\n       '*7': 1, '*8': 1, '*9': 1, '1*': 9, '2*': 6, '**': 15}\\n\\ndef numDecodings(self, s):\\n    \"\"\"\\n    :type s: str\\n    :rtype: int\\n    \"\"\"        \\n    dp = 1, one.get(s[:1], 0)\\n    \\n    for i in xrange(1, len(s)):\\n        dp = dp[1], (one.get(s[i], 0) * dp[1] + two.get(s[i-1: i+1], 0) * dp[0]) % 1000000007\\n    \\n    return dp[-1]\\n```"
		}
	],
	"id":"617",
	"title":"Decode Ways II",
	"content":"<p>\r\nA message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping way:\r\n</p>\r\n\r\n<pre>\r\n'A' -> 1\r\n'B' -> 2\r\n...\r\n'Z' -> 26\r\n</pre>\r\n\r\n<p>\r\nBeyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.\r\n</p>\r\n\r\n\r\n<p>\r\nGiven the encoded message containing digits and the character '*', return the total number of ways to decode it.\r\n</p>\r\n\r\n<p>\r\nAlso, since the answer may be very large, you should return the output mod 10<sup>9</sup> + 7.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"*\"\r\n<b>Output:</b> 9\r\n<b>Explanation:</b> The encoded message can be decoded to the string: \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\".\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"1*\"\r\n<b>Output:</b> 9 + 9 = 18\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the input string will fit in range [1, 10<sup>5</sup>].</li>\r\n<li>The input string will only contain the character '*' and digits '0' - '9'.</li>\r\n</ol>\r\n</p>",
	"frequency":"58",
	"ac_num":"9496"
}