{
	"difficulty":"3",
	"submit_num":"14182",
	"show_id":"642",
	"leetcode_id":"642",
	"answers":[
		{
			"lc_ans_id":"105376",
			"view":"5404",
			"top":"0",
			"title":"Java solution, Trie and PriorityQueue",
			"vote":"24",
			"content":"Only thing more than a normal ```Trie``` is added a map of ```sentence``` to ```count``` in each of the ```Trie``` node to facilitate process of getting top 3 results.\\n\\n```\\npublic class AutocompleteSystem {\\n    class TrieNode {\\n        Map<Character, TrieNode> children;\\n        Map<String, Integer> counts;\\n        boolean isWord;\\n        public TrieNode() {\\n            children = new HashMap<Character, TrieNode>();\\n            counts = new HashMap<String, Integer>();\\n            isWord = false;\\n        }\\n    }\\n    \\n    class Pair {\\n        String s;\\n        int c;\\n        public Pair(String s, int c) {\\n            this.s = s; this.c = c;\\n        }\\n    }\\n    \\n    TrieNode root;\\n    String prefix;\\n    \\n    \\n    public AutocompleteSystem(String[] sentences, int[] times) {\\n        root = new TrieNode();\\n        prefix = \"\";\\n        \\n        for (int i = 0; i < sentences.length; i++) {\\n            add(sentences[i], times[i]);\\n        }\\n    }\\n    \\n    private void add(String s, int count) {\\n        TrieNode curr = root;\\n        for (char c : s.toCharArray()) {\\n            TrieNode next = curr.children.get(c);\\n            if (next == null) {\\n                next = new TrieNode();\\n                curr.children.put(c, next);\\n            }\\n            curr = next;\\n            curr.counts.put(s, curr.counts.getOrDefault(s, 0) + count);\\n        }\\n        curr.isWord = true;\\n    }\\n    \\n    public List<String> input(char c) {\\n        if (c == '#') {\\n            add(prefix, 1);\\n            prefix = \"\";\\n            return new ArrayList<String>();\\n        }\\n        \\n        prefix = prefix + c;\\n        TrieNode curr = root;\\n        for (char cc : prefix.toCharArray()) {\\n            TrieNode next = curr.children.get(cc);\\n            if (next == null) {\\n                return new ArrayList<String>();\\n            }\\n            curr = next;\\n        }\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> (a.c == b.c ? a.s.compareTo(b.s) : b.c - a.c));\\n        for (String s : curr.counts.keySet()) {\\n            pq.add(new Pair(s, curr.counts.get(s)));\\n        }\\n\\n        List<String> res = new ArrayList<String>();\\n        for (int i = 0; i < 3 && !pq.isEmpty(); i++) {\\n            res.add(pq.poll().s);\\n        }\\n        return res;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"105397",
			"view":"1069",
			"top":"1",
			"title":"Python, Straightforward with Explanation",
			"vote":"5",
			"content":"Let's use a trie.  Because the requirement to enter the top 3 at a node can only get stronger, we do not have to recall discarded information.  Thus, we can freely store the answer (top 3 sentences) directly on each node.  When we get queries, we simply read off the answer.\\n\\nWhenever we add a sentence, at each node of the corresponding trie, we will update that node's info appropriately in case its top 3 answers changes.  We'll use a \"ShortList\" to store our answer, which will keep track of only the top 3 answers.\\n\\nOur implementation could be better (for example, handling ShortList better, or storing sentence indices instead of full sentences), but because the limits are small, it doesn't matter for the question, so we choose the most straightforward approach.\\n\\n```\\n_trie = lambda: collections.defaultdict(_trie)\\nINFO, END = True, False\\n\\nclass ShortList(list):\\n    def append(self, val):\\n        for i, (nt, s) in enumerate(self):\\n            if s == val[1]:\\n                self[i] = val\\n                break\\n        else:\\n            list.append(self, val)\\n        \\n        self.sort()\\n        if len(self) > 3:\\n            self.pop()\\n\\nclass AutocompleteSystem(object):\\n    \\n    def __init__(self, sentences, counts):\\n        self.curnode = self.trie = _trie()\\n        self.sentence_to_count = collections.Counter()\\n        self.search = ''\\n        \\n        for sentence, count in zip(sentences, counts):\\n            self.add(sentence, count)\\n    \\n    def add(self, sentence, count):\\n        self.sentence_to_count[sentence] = count\\n        cur = self.trie\\n        self._add_info(cur, sentence, count)\\n        for letter in sentence:\\n            cur = cur[letter]\\n            self._add_info(cur, sentence, count)\\n        cur[END] = sentence\\n    \\n    def _add_info(self, node, sentence, count):\\n        if INFO not in node:\\n            node[INFO] = ShortList()\\n        node[INFO].append((-count, sentence))\\n        \\n    def input(self, c):\\n        if c != '#':\\n            self.search += c\\n            if self.curnode is None:\\n                return []\\n            if c not in self.curnode:\\n                self.curnode = None\\n                return []\\n            \\n            self.curnode = self.curnode[c]\\n            return [s for nt, s in self.curnode[INFO]]\\n        else:\\n            self.sentence_to_count[self.search] += 1\\n            self.add(self.search, self.sentence_to_count[self.search])\\n            self.search = ''\\n            self.curnode = self.trie\\n            return []\\n```"
		},
		{
			"lc_ans_id":"105379",
			"view":"1081",
			"top":"2",
			"title":"Straight-forward hash table + priority queue solution in c++, no trie",
			"vote":"4",
			"content":"```\\nclass AutocompleteSystem {\\n    unordered_map<string, int> dict;\\n    string data;\\n\\npublic:\\n    AutocompleteSystem(vector<string> sentences, vector<int> times) {\\n        for (int i = 0; i < times.size(); i++)\\n            dict[sentences[i]] += times[i];\\n        data.clear();\\n    }\\n    \\n    vector<string> input(char c) {\\n        if (c == '#') {\\n            dict[data]++;\\n            data.clear();\\n            return {};\\n        }\\n\\n        data.push_back(c);\\n        auto cmp = [](const pair<string, int> &a, const pair<string, int> &b) {\\n            return a.second > b.second || a.second == b.second && a.first < b.first;\\n        };\\n\\n        priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(cmp)> pq(cmp);\\n\\n        for (auto &p : dict) {\\n            bool match = true;\\n            for (int i = 0; i < data.size(); i++) {\\n                if (data[i] != p.first[i]) {\\n                    match = false;\\n                    break;\\n                }\\n            }\\n            if (match) {\\n                pq.push(p);\\n                if (pq.size() > 3)\\n                    pq.pop();\\n            }\\n        }\\n\\n        vector<string> res(pq.size());\\n        for (int i = pq.size() - 1; i >= 0; i--) {\\n            res[i] = pq.top().first;\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"105412",
			"view":"286",
			"top":"3",
			"title":"JavaScript straightforward with explanations. Two approaches - Trie and First character indexing",
			"vote":"3",
			"content":"**First approach - First character indexing**\\n\\nSince the input size is small, it is sufficient to have improve the brute force solution by just having a separate map of sentences categorized by the first character of each sentence.\\n\\n```\\n/**\\n * @param {string[]} sentences\\n * @param {number[]} times\\n */\\nvar AutocompleteSystem = function(sentences, times) {\\n    this.searchHistory = {};\\n    'abcdefghijklmnopqrstuvwxyz'.split('').forEach(char => {\\n        this.searchHistory[char] = {};\\n    });\\n    this.inputString = '';\\n    this.MAX_RESULTS = 3;\\n    for (let i = 0; i < times.length; i++) {\\n        const sentence = sentences[i];\\n        this.searchHistory[sentence[0]][sentence] = times[i];\\n    }\\n};\\n\\n/**\\n * @param {character} c\\n * @return {string[]}\\n */\\nAutocompleteSystem.prototype.input = function(c) {\\n    if (c === '#') {\\n        const firstChar = this.inputString[0];\\n        if (!this.searchHistory[firstChar][this.inputString]) {\\n            this.searchHistory[firstChar][this.inputString] = 0;\\n        }\\n        this.searchHistory[firstChar][this.inputString] += 1;\\n        this.inputString = '';\\n        return [];\\n    }\\n    this.inputString += c;\\n    const firstChar = this.inputString[0];\\n    const results = Object.keys(this.searchHistory[firstChar]).filter(sentence => {\\n        return sentence.startsWith(this.inputString);\\n    });\\n    results.sort((a, b) => {\\n        const aFreq = this.searchHistory[firstChar][a];\\n        const bFreq = this.searchHistory[firstChar][b];\\n        return aFreq !== bFreq ? bFreq - aFreq : (a > b ? 1 : -1);\\n    });\\n    return results.slice(0, this.MAX_RESULTS);\\n};\\n\\n/** \\n * Your AutocompleteSystem object will be instantiated and called as such:\\n * var obj = Object.create(AutocompleteSystem).createNew(sentences, times)\\n * var param_1 = obj.input(c)\\n */\\n```\\n\\n\\n**Second approach - Augmented Trie**\\n\\nThe `Trie` used in this solution is modified from my answer in [208 - Implement Trie Prefix Tree](https://leetcode.com/problems/implement-trie-prefix-tree/) to store the count in each last node of the sentence. The code may be long, but it is really quite easy to understand.\\n\\n```\\n// Using a Trie (Prefix tree).\\n/**\\n * Initialize your data structure here.\\n */\\nvar Trie = function() {\\n    this._trie = {};\\n};\\n\\n/**\\n * Inserts a string into the trie a number of times.\\n * @param {string} word\\n * @param {number} [count=1]\\n * @return {void}\\n */\\nTrie.prototype.insert = function(word, count = 1) {\\n    if (!word.length || count < 1) {\\n        return;\\n    }\\n    let curr = this._trie;\\n    for (let i = 0; i < word.length; i++) {\\n        const char = word[i];\\n        if (!curr.hasOwnProperty(char)) {\\n            curr[char] = {};\\n        }\\n        curr = curr[char];\\n    }\\n    if (!curr.hasOwnProperty('#')) {\\n        curr['#'] = 0;\\n    }\\n    curr['#'] += count;\\n};\\n\\n/**\\n * Returns if there is any string in the trie that starts with the given prefix.\\n * @param {string} prefix\\n * @return {Object}\\n */\\n // Time: O(n), where n is the number of different strings in the Trie.\\n // Space: O(1)\\nTrie.prototype.stringsStartingWith = function(prefix) {\\n    if (!prefix.length) {\\n        return false;\\n    }\\n    let curr = this._trie;\\n    for (let i = 0; i < prefix.length; i++) {\\n        const char = prefix[i];\\n        if (!curr.hasOwnProperty(char)) {\\n            return false;\\n        }\\n        curr = curr[char];\\n    }\\n    const results = {};\\n    function traverse(node, chars) {\\n        if (!node) {\\n            return;\\n        }\\n        Object.keys(node).forEach(char => {\\n            if (char === '#') {\\n                results[chars] = node[char];\\n                return;\\n            }\\n            traverse(node[char], chars + char);\\n        });\\n    }\\n    traverse(curr, prefix);\\n    return results;\\n};\\n\\n/**\\n * @param {string[]} sentences\\n * @param {number[]} times\\n */\\nvar AutocompleteSystem = function(sentences, times) {\\n    this.trie = new Trie();\\n    this.inputString = '';\\n    this.MAX_RESULTS = 3;\\n    for (let i = 0; i < times.length; i++) {\\n        const sentence = sentences[i];\\n        this.trie.insert(sentence, times[i]);\\n    }\\n};\\n\\n/**\\n * @param {character} c\\n * @return {string[]}\\n */\\nAutocompleteSystem.prototype.input = function(c) {\\n    if (c === '#') {\\n        this.trie.insert(this.inputString);\\n        this.inputString = '';\\n        return [];\\n    }\\n    this.inputString += c;\\n\\n    const strings = this.trie.stringsStartingWith(this.inputString);\\n    const results = Object.keys(strings);\\n    results.sort((a, b) => {\\n        const aFreq = strings[a];\\n        const bFreq = strings[b];\\n        return aFreq !== bFreq ? bFreq - aFreq : (a > b ? 1 : -1);\\n    });\\n    return results.slice(0, this.MAX_RESULTS);\\n};\\n\\n/** \\n * Your AutocompleteSystem object will be instantiated and called as such:\\n * var obj = Object.create(AutocompleteSystem).createNew(sentences, times)\\n * var param_1 = obj.input(c)\\n */\\n```"
		},
		{
			"lc_ans_id":"105411",
			"view":"1105",
			"top":"4",
			"title":"Trie Solution",
			"vote":"2",
			"content":"I used Trie Data Structure for this problem and I don't know whether this is the optimal way to do this problem.   \\n\\nAlso don't forget to cache the searched string into the database.\\n\\n```\\npublic class AutocompleteSystem {\\n    public Trie trie;\\n    public TrieNode root;\\n    public String prefix;\\n    public AutocompleteSystem(String[] sentences, int[] times) {\\n        trie = new Trie();\\n        root = trie.root;\\n        prefix = \"\";\\n        for (int i = 0; i < times.length; i++) {\\n            trie.insert(sentences[i], times[i]);\\n        }\\n    }\\n    \\n    public List<String> input(char c) {\\n        List<String> list = new ArrayList<>();\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b)-> (a.freq == b.freq) ? (a.token.compareTo(b.token)) : b.freq - a.freq);\\n        if (c == '#')   {\\n            root = trie.root;\\n            trie.insert(prefix, 1);\\n            prefix = \"\";\\n            return new ArrayList<String>();\\n        }\\n        prefix = prefix + c;\\n        root = trie.searchHelper(prefix);\\n        trie.addToPQ(root, pq, prefix);\\n        for (int i = 1; i <= 3; i++){\\n            if (pq.size() > 0)\\n                list.add(pq.poll().token);\\n        }        \\n        return list;\\n    }\\n    \\n    class Pair {\\n        String token;\\n        int freq;\\n        Pair(String token, int freq){\\n            this.token = token;\\n            this.freq = freq;\\n        }\\n    }\\n    \\n    \\n    class TrieNode{\\n        int freq;\\n        TrieNode[] children;\\n        public TrieNode() {\\n            freq = 0;\\n            children = new TrieNode[27];\\n        }\\n    }\\n    \\n    class Trie {\\n        public TrieNode root;\\n        /** Initialize your data structure here. */\\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n\\n        /** Inserts a word into the trie. */\\n        public void insert(String word, int f) {\\n            TrieNode ws = root;\\n            for (char ch: word.toCharArray()) {\\n                int id = ch - 'a';\\n                if (ch == ' ')  id = 26;\\n                if (ws.children[id] == null)     \\n                    ws.children[id] = new TrieNode();\\n                ws = ws.children[id];\\n            }\\n            ws.freq += f;\\n        }\\n\\n        /** Returns if the word is in the trie. */\\n        public boolean search(String word) {\\n            TrieNode ws = searchHelper(word);\\n            return ws != null && ws.freq > 0;\\n        }\\n\\n        /** Returns if there is any word in the trie that starts with the given prefix. */\\n        public boolean startsWith(String prefix) {\\n            return searchHelper(prefix) != null;\\n        }\\n\\n        public TrieNode searchHelper(String str) {\\n            TrieNode ws = root;\\n            for (char ch: str.toCharArray()){\\n                int id = ch - 'a';\\n                if (ch == ' ')  id = 26;\\n                if (ws == null) return null;\\n                ws = ws.children[id];\\n            }\\n            return ws;\\n        }\\n        \\n        public void addToPQ(TrieNode root, PriorityQueue<Pair> pq, String prefix) {\\n            if (root == null)   return;\\n            if (root.freq > 0)   pq.offer(new Pair(prefix, root.freq));\\n            for (int i = 0; i < 27; i++) {\\n                if (root.children[i] != null) {\\n                    char ch = ' ';\\n                    if (i != 26)    ch = (char) ('a' + i);\\n                    addToPQ(root.children[i], pq, prefix + ch);\\n                }\\n            }\\n        }\\n    }    \\n}\\n```"
		},
		{
			"lc_ans_id":"105380",
			"view":"85",
			"top":"5",
			"title":"Java Trie Solution Avoiding traversal from root and subtree",
			"vote":"1",
			"content":"Trading space for time. Main improvements are :\\n1. avoiding traversal from root for each input invocation by  keeping track of current node and current sentence.\\n2. Using a string buffer instead of string.\\n3. Avoiding subtree traversal to get list of matching sentences . Each node maintains a list of sentence indices.\\n```java\\nclass AutocompleteSystem {\\n    \\n    private static class TrieNode {\\n        private static final int MAX_LINKS = 27;\\n\\n        private TrieNode[] links;\\n\\n        private boolean end;\\n\\n        private Set<Integer> sentenceIndices;\\n\\n        public TrieNode() {\\n            links = new TrieNode[MAX_LINKS];\\n            sentenceIndices = new HashSet<>();\\n        }\\n\\n        public boolean containsKey(final char ch) {\\n            return links[charIndex(ch)] != null;\\n        }\\n\\n        public TrieNode get(final char ch) {\\n            return links[charIndex(ch)];\\n        }\\n\\n        public void put(final char ch, final TrieNode node) {\\n            links[charIndex(ch)] = node;\\n        }\\n\\n        public boolean isEnd() {\\n            return end;\\n        }\\n\\n        public void setEnd() {\\n            this.end = true;\\n        }\\n\\n        public void addSentenceIndex(final int index) {\\n            if (!sentenceIndices.contains(index)) {\\n                sentenceIndices.add(index);\\n            }\\n        }\\n\\n        private int charIndex(final char ch) {\\n            return ch != ' ' ? ch - 'a' : links.length-1;//links[26] will represent space character\\n        }\\n    }\\n\\n    private List<String> sentences;\\n    private Map<String, Integer> sentenceCountMap;\\n\\n    private TrieNode root;\\n    private StringBuffer buffer;\\n    private TrieNode currentNode;\\n\\n    public AutocompleteSystem(final String[] sentences, final int[] times) {\\n        this.sentences = new ArrayList<>(Arrays.asList(sentences));\\n        this.sentenceCountMap = new HashMap<>();\\n        for (int i = 0; i < sentences.length; i++) {\\n            sentenceCountMap.put(sentences[i], times[i]);\\n        }\\n\\n        this.root = new TrieNode();\\n        this.buffer = new StringBuffer();\\n        this.currentNode = root;\\n\\n        for (int i = 0; i < sentences.length; i++) {\\n            insert(i);\\n        }\\n    }\\n\\n    public List<String> input(final char c) {\\n        if (c == '#') {\\n            String sentence = this.buffer.toString();\\n            this.buffer.setLength(0);\\n            this.currentNode = root;\\n\\n            if (!sentenceCountMap.containsKey(sentence)) {\\n                sentences.add(sentence);\\n                insert(sentences.size()-1);\\n            }\\n            sentenceCountMap.put(sentence, sentenceCountMap.getOrDefault(sentence, 0) + 1);\\n            return Collections.emptyList();\\n        } else {\\n            this.buffer.append(c);\\n\\n            if (currentNode == null) {// no more matching is possible\\n                return Collections.emptyList();\\n            } else if (!currentNode.containsKey(c)) {// no more matching is possible\\n                currentNode = null;\\n                return Collections.emptyList();\\n            } else {\\n                currentNode = currentNode.get(c);\\n\\n                List<Integer> candidateIndices = new ArrayList<>();\\n                candidateIndices.addAll(currentNode.sentenceIndices);\\n                Collections.sort(candidateIndices, (index1, index2) -> {\\n                    String sentence1 = sentences.get(index1);\\n                    String sentence2 = sentences.get(index2);\\n                    int count1 = sentenceCountMap.get(sentence1);\\n                    int count2 = sentenceCountMap.get(sentence2);\\n                    return count1 == count2 ? sentence1.compareTo(sentence2) : Integer.compare(count2, count1);\\n                });\\n\\n                final List<Integer> resultIndices = candidateIndices.subList(0, Math.min(3, candidateIndices.size()));\\n                return resultIndices.stream().map(index -> this.sentences.get(index)).collect(Collectors.toList());\\n            }\\n        }\\n    }\\n\\n    private void insert(final int sentenceIndex) {\\n        TrieNode current = root;\\n        String sentence = sentences.get(sentenceIndex);\\n        for (char ch : sentence.toCharArray()) {\\n            if (!current.containsKey(ch)) {\\n                current.put(ch, new TrieNode());\\n            }\\n            current = current.get(ch);\\n            current.addSentenceIndex(sentenceIndex);\\n        }\\n        current.setEnd();\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"105393",
			"view":"132",
			"top":"6",
			"title":"C++ Trie and DFS solution beats 80%",
			"vote":"1",
			"content":"Match the prefix using a Trie and do a DFS to find all the competing strings and put them in a priority queue. Initially I created a map of (string, count) at each TrieNode but it's very inefficient as far as memory's concerned. Also, I search the trie from the previous character encountered and reset the starting TrieNode for new input sequence.  \\n\\n```\\n\\nclass AutocompleteSystem {\\n    \\n    class TrieNode{\\n        public:\\n            unordered_map<char, TrieNode*> child;\\n            string str;\\n            int count;\\n            TrieNode(): str(\"\"), count(0) {}\\n    };\\n    \\n    void insert(string& s, TrieNode* root, int times){\\n        TrieNode* curr = root;\\n        for (int i=0;i<s.size();i++){\\n            if (!curr->child.count(s[i]))\\n                curr->child[s[i]] = new TrieNode();\\n            curr = curr->child[s[i]];\\n        }\\n        curr->count += times;\\n        curr->str = s;\\n    }\\n    \\npublic:\\n    void dfs(TrieNode* temp){\\n        if (temp->str != \"\") q.push({temp->str, temp->count});\\n        \\n        for (auto& ele: temp->child){\\n            dfs(ele.second);\\n        }\\n    }\\n    \\n    struct comp{\\n        bool operator() (pair<string, int>& a, pair<string, int>& b){\\n            return a.second<b.second || a.second==b.second && a.first>b.first;\\n        }\\n    };\\n    \\n    priority_queue<pair<string, int>, vector<pair<string, int> >, comp> q;\\n        \\n    TrieNode* root, *curr;\\n    AutocompleteSystem(vector<string> sentences, vector<int> times) {\\n        root = new TrieNode();\\n        for (int i=0;i<sentences.size();i++){\\n            insert(sentences[i], root, times[i]);\\n        }\\n        curr = root;\\n    }\\n    \\n    \\n    string s=\"\";\\n    vector<string> input(char c) {\\n        q = priority_queue<pair<string, int>, vector<pair<string, int> >, comp>();\\n        if (c=='#'){\\n            insert(s, root, 1);\\n            s=\"\";\\n            curr = root; //start searching from the beginning node for the next sentence\\n            return {};\\n        }\\n        s += c;\\n        if (curr && curr->child.count(c)){\\n            curr = curr->child[c];\\n        }else{\\n            curr = NULL; //curr node is null so empty result for any further characters in current input \\n            return {};\\n        }\\n        \\n        if (curr->str != \"\") q.push({curr->str, curr->count});\\n        for (auto& ele: curr->child){\\n            dfs(ele.second);\\n        }\\n        \\n        vector<string> res;\\n        while (!q.empty() && res.size()<3){\\n            res.push_back(q.top().first);\\n            q.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n/**\\n * Your AutocompleteSystem object will be instantiated and called as such:\\n * AutocompleteSystem obj = new AutocompleteSystem(sentences, times);\\n * vector<string> param_1 = obj.input(c);\\n */\\n```"
		},
		{
			"lc_ans_id":"105400",
			"view":"147",
			"top":"7",
			"title":"Naive Python Solution (Easy to implement and beats 90%)",
			"vote":"1",
			"content":"```\\nfrom collections import defaultdict\\n\\n\\nclass AutocompleteSystem(object):\\n    def __init__(self, sentences, times):\\n        \"\"\"\\n        :type sentences: List[str]\\n        :type times: List[int]\\n        \"\"\"\\n        self.prefix_dict = defaultdict(list)\\n        self.freq_dict = defaultdict(int)\\n        N = len(sentences)\\n        for i in range(N):\\n            self.freq_dict[sentences[i]] = times[i]\\n            for j in range(1, len(sentences[i]) + 1):\\n                self.prefix_dict[sentences[i][:j]].append(sentences[i])\\n        self.sentence = ''\\n\\n    def input(self, c):\\n        \"\"\"\\n        :type c: str\\n        :rtype: List[str]\\n        \"\"\"\\n        if c == '#':\\n            if self.sentence not in self.freq_dict:\\n                for j in range(1, len(self.sentence) + 1):\\n                    self.prefix_dict[self.sentence[:j]].append(self.sentence)\\n            self.freq_dict[self.sentence] += 1\\n            self.sentence = ''\\n            return []\\n        self.sentence += c\\n        if self.sentence not in self.prefix_dict:\\n            return []\\n        self.prefix_dict[self.sentence].sort(key=lambda s: (-self.freq_dict[s], s))\\n        return self.prefix_dict[self.sentence][:3]\\n```"
		},
		{
			"lc_ans_id":"105404",
			"view":"472",
			"top":"8",
			"title":"Hybrid of treap and segment tree, worst time strictly O(log n), n = # of dictionary, for query and modify dictionary",
			"vote":"1",
			"content":"Maintain a balanced BST. Each node is a struct:\\n```\\n    struct node{\\n        string key;\\n        vector<pair<int, string>> most_used;\\n        int freq;\\n        T leftest;\\n        T rightest;\\n        int priority;\\n        node* left;\\n        node* right;\\n    };\\n```\\nwhere key is a string in the dictionary, freq is its frequency, most_used is a list (of length at most 3) which records the most frequently used strings together with their frequencies. Leftest is the key of the leftest offspring of this node; rightest is the key of the rightest offspring of this node (so this tree is very much like a hybrid of segment tree and BST).\\n\\n# Search\\nGiven a prefix, say, pref = \"i lov\". The usual way of doing segment tree gives a list of nodes [node_1, ..., node_k], where some string has prefix = pref if and only if it is a offspring of some node_i. We have k = O(log n) and it takes O(log n) to get the list [node_1, ..., node_k].\\nWe merge the most_used list of each of node_i to get the top three most frequently used strings in constant time.\\n\\n# Modify frequency\\nIf we want to increase the frequency of some word in the dictionary, we just find the node corresponding to this word and modify its frequency. Then we update the most_used list of the ancestors of this node. There are O(log n) ancestors and it takes O(log n) to do this.\\n\\n# Insert a word\\nThis is the most difficult part. Let's take Treap for example. First we do binary search and find a node which, e.g., has no left child and the left child of this node is the place to go. We insert this word to that place. We modify the leftest key and the most_used list for each of the ancestors of this node. Then we choose a random number as the priority of this new node. We do what we do to rebalance this treap (do left rotations and right rotations). Take care to maintain leftest key, rightest key and most used list when doing rotations. It is easy but tedious.\\n\\n# Implementation of main program\\n```\\n\\nvector<pair<int, string>> ci(string k, int f, vector<vector<pair<int, string>>> v){\\n    vector<pair<int, string>> ret = {make_pair(-f, k)};\\n    for (auto &x: v) for (auto &y: x) ret.push_back(y);\\n    sort(ret.begin(), ret.end());\\n    if (ret.size() > 3) ret.resize(3);\\n    return ret;\\n}\\n\\nclass AutocompleteSystem {\\npublic:\\n    string pref;\\n    segtreap t;\\n    AutocompleteSystem(vector<string> sentences, vector<int> times) {\\n        pref.clear();\\n        t.calc_info = ci;\\n        for (int i = 0; i < times.size(); i++)\\n            t.insert(sentences[i], times[i]);\\n    }\\n    \\n    vector<string> input(char c) {\\n        vector<string> ret;\\n        if (c == '#'){\\n            t.insert(pref, 1);\\n            pref.clear();\\n        }\\n        else{\\n            pref += c;\\n            auto v = t.info();\\n            string pref1 = pref + ('{');\\n            auto cut = t.cut(pref, pref1);\\n            vector<pair<int, string>> s;\\n            for (auto &x: cut.singletons) s.push_back(make_pair(-x->frequency, x->key));\\n            for (auto &x: cut.segments) for (auto &y: x->info) s.push_back(y);\\n            sort(s.begin(), s.end());\\n            if (s.size() > 3) s.resize(3);\\n            for (auto &x: s) ret.push_back(x.second);\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\n# Seg-Treap implementation\\n```\\ntypedef string T;\\ntypedef vector<pair<int, string>> S;\\n\\nstruct segtreap {\\n    struct node{\\n        T key;\\n        S info;\\n        int frequency;\\n        T leftest;\\n        T rightest;\\n        int priority;\\n        node* left;\\n        node* right;\\n    };\\n    node* root;\\n    node* new_node(const T& k);\\n    void clear(node* n);\\n    void rotate(node* n, node* p, node* x);\\n    void update_bounds(node* n);\\n    function<S(T, int, vector<S>)> calc_info;\\n    void update_info(node* n);\\n    void clear() { if (root) clear(root); root = nullptr; }\\n    node* begin() const;\\n    segtreap() { root = nullptr; }\\n    ~segtreap() { clear(); }\\n    void insert(const T& key, const int& freq);\\n    bool verify() const;\\n    S info() const { return root->info; }\\n    struct tree_cut {\\n        vector<node*> singletons;\\n        vector<node*> segments;\\n    };\\n    tree_cut cut(const T& l, const T& r) const;\\n    segtreap::node* find(const T& key) const;\\n};\\n\\ntypename segtreap::node* segtreap::new_node(const T& k) { \\n    decltype(this->root) n = new node(); \\n    n->key = k;\\n    n->frequency = 1;\\n    n->leftest = k;\\n    n->rightest = k;\\n    n->priority = rand();\\n    n->left = nullptr;\\n    n->right = nullptr;\\n    return n;\\n}\\n\\ntypename segtreap::node* segtreap::begin() const{\\n    if (!this->root) return nullptr;\\n    auto n = this->root;\\n    while (n->left) n = n->left;\\n    return n;\\n}\\n\\ntypename segtreap::node* segtreap::find(const T& key) const{\\n    if (!this->root) return nullptr;\\n    auto n = this->root;\\n    while (n){\\n        if (n->key == key) return n;\\n        else if (key < n->key) n = n->left;\\n        else n = n->right;\\n    }\\n    return nullptr;\\n}\\n\\ntypename segtreap::tree_cut segtreap::cut(const T& l, const T& r) const{\\n    tree_cut ret;\\n    if (this->root){\\n        function<void(T, T, segtreap::node*)> find = [&](const T& l, const T& r, segtreap::node* n){\\n            if (l > r) return;\\n            if ((n->leftest == l) && (n->rightest == r)){\\n                ret.segments.push_back(n);\\n                return;\\n            }\\n            if ((l <= n->key) && (n->key <= r)) ret.singletons.push_back(n);\\n            if (l < n->key) {\\n                find(l, min(n->left->rightest, r), n->left);\\n            }\\n            if (r > n->key) {\\n                find(max(l, n->right->leftest), r, n->right);\\n            }\\n        };\\n        find(max(l, this->root->leftest), min(r, this->root->rightest), this->root);\\n    }\\n    return ret;\\n}\\n\\nvoid segtreap::update_bounds(node* n){\\n    n->leftest = n->left ? n->left->leftest : n->key;\\n    n->rightest = n->right ? n->right->rightest : n->key;\\n}\\n\\nvoid segtreap::update_info(node* n){\\n    vector<S> vec;\\n    if (n->left) vec.push_back(n->left->info);\\n    if (n->right) vec.push_back(n->right->info);\\n    n->info = this->calc_info(n->key, n->frequency, vec);\\n}\\n\\nvoid segtreap::clear(node* n){\\n    if (n->left) this->clear(n->left);\\n    if (n->right) this->clear(n->right);\\n    delete n;\\n}\\n\\nvoid segtreap::rotate(node* n, node *p, node *x){\\n    if (n->left == x){\\n        if (p){\\n            if (p->left == n){\\n                p->left = n->left;\\n                n->left = x->right;\\n                x->right = n;\\n            }\\n            else{\\n                p->right = n->left;\\n                n->left = x->right;\\n                x->right = n;\\n            }\\n        }\\n        else{\\n            this->root = n->left;\\n            n->left = x->right;\\n            x->right = n;\\n        }\\n    }\\n    else{\\n        if (p){\\n            if (p->right == n){\\n                p->right = n->right;\\n                n->right = x->left;\\n                x->left = n;\\n            }\\n            else{\\n                p->left = n->right;\\n                n->right = x->left;\\n                x->left = n;\\n            }\\n        }\\n        else{\\n            this->root = n->right;\\n            n->right = x->left;\\n            x->left = n;\\n        }\\n    }\\n    this->update_bounds(n);\\n    this->update_bounds(x);\\n    this->update_info(n);\\n    this->update_info(x);\\n}\\n\\nvoid segtreap::insert(const T& key, const int& freq){\\n    if (!this->root) {\\n        this->root = this->new_node(key);\\n        this->root->frequency = freq;\\n        this->update_info(this->root);\\n    }\\n    else {\\n        vector<decltype(this->root)> ancestors = {nullptr, this->root};\\n        while (true){\\n            auto n = ancestors.back();\\n            auto p = ancestors[ancestors.size() - 2];\\n            if (n->key == key) {\\n                n->frequency += freq;\\n                this->update_info(n);\\n                for (int i = ancestors.size() - 1; i; i--){\\n                    auto anc = ancestors[i];\\n                    this->update_info(anc);\\n                }\\n                break;\\n            }\\n            else if (key < n->key){\\n                if (n->left) n = n->left;\\n                else{\\n                    n->left = this->new_node(key);\\n                    auto x = n->left;\\n                    x->frequency = freq;\\n                    this->update_info(x);\\n                    for (int i = ancestors.size() - 1; i; i--){\\n                        auto anc = ancestors[i];\\n                        if (key < anc->leftest) anc->leftest = key;\\n                        this->update_info(anc);\\n                    }\\n                    while ((ancestors.size() >= 2) && (x->priority < ancestors.back()->priority)){\\n                        this->rotate(ancestors.back(), ancestors[ancestors.size() - 2], x);\\n                        ancestors.pop_back();\\n                    }\\n                    break;\\n                }\\n            }\\n            else{\\n                if (n->right) n = n->right;\\n                else{\\n                    n->right = this->new_node(key);\\n                    auto x = n->right;\\n                    x->frequency = freq;\\n                    this->update_info(x);\\n                    for (int i = ancestors.size() - 1; i; i--){\\n                        auto anc = ancestors[i];\\n                        if (key > anc->rightest) anc->rightest = key;\\n                        this->update_info(anc);\\n                    }\\n                    while ((ancestors.size() >= 2) && (x->priority < ancestors.back()->priority)){\\n                        this->rotate(ancestors.back(), ancestors[ancestors.size() - 2], x);\\n                        ancestors.pop_back();\\n                    }\\n                    break;\\n                }\\n            }\\n            ancestors.push_back(n);\\n        }\\n    }\\n}\\n```\\n\\n# Q & A\\nQ: The most_used field will depend on search key words. When the search key changes, all the tree nodes will need to be updated. Am I missing something?\\n\\nA: Only the ancestors of the modified node need to update their most_used field, so it takes O(log n).\\n\\nQ: Another question is the segment tree is not trimmed as we go. So search for \"i\" will cost the same as \"i \". While for the BST solution, the BST is trimmed as we go.\\n\\nA: Say prefix  = \"i lov\", you simply cut all segments lying in the range [\"i lov\", \"i lov{\"], note that '{' is the next char to 'z'."
		},
		{
			"lc_ans_id":"105377",
			"view":"17",
			"top":"9",
			"title":"C++ with Trie keeping a topk set in every node.",
			"vote":"0",
			"content":"Trie Node keeps a topk set<pair<string,int>> for the top 3. update(s, count) first traverses to the end char of string s. Sum counts at that node. Then start from root again, to populate the topk set of every node along the string path: scan the set first to see if string s is already in set. If yes, erase it and reinsert new {s,count} pair, we are done. If not done, then insert {s,count} and erase the last one in the set when p->topk.size()>3. \\n\\n```\\nstruct Cmp {\\n    bool operator()(const pair<string, int> &a, const pair<string, int> &b) const {\\n        return a.second>b.second||(a.second==b.second&&a.first<b.first);\\n    }  \\n};\\nstruct Trie {\\n    int count;\\n    unordered_map<char, Trie*> next;\\n    set<pair<string, int>, Cmp> topk;\\n    Trie():count(0){}\\n};\\n\\nclass AutocompleteSystem {\\nprivate:\\n    Trie *root;\\n    Trie *prev;\\n    string prefix;\\npublic:\\n    AutocompleteSystem(vector<string> sentences, vector<int> times) {\\n        prefix=\"\";\\n        root=new Trie();\\n        prev=root;\\n        for(int i=0; i<sentences.size(); ++i) {\\n            update(sentences[i], times[i]);\\n        }\\n    }\\n    \\n    vector<string> input(char c) {\\n        vector<string> res;\\n        if(c=='#') {\\n            update(prefix,1);\\n            prefix=\"\";\\n            prev=root;\\n        } else {\\n            prefix+=c;\\n            if(!prev->next[c]) prev->next[c]=new Trie;\\n            prev=prev->next[c];\\n            \\n            for(const auto &si:prev->topk) {\\n                res.push_back(si.first);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    void update(const string &s, int count) {\\n        Trie *p=root;\\n        for(const auto &c:s) {\\n            if(!p->next[c]) p->next[c]=new Trie;\\n            p=p->next[c];\\n        }\\n        \\n        p->count+=count;\\n        count=p->count; //update count\\n        \\n        p=root;\\n        for(const auto &c:s) {\\n            p=p->next[c];\\n            \\n            // update p->topk\\n            bool done=false;\\n            for(set<pair<string, int>>::iterator it=p->topk.begin(); it!=p->topk.end(); ++it) { // already in set\\n                if(it->first==s) {\\n                    p->topk.erase(it);\\n                    p->topk.insert({s, count});\\n                    done=true;\\n                    break;\\n                }\\n            }\\n            if(!done) {\\n                p->topk.insert({s, count});\\n                if(p->topk.size()>3) p->topk.erase(--p->topk.end());\\n            }            \\n        }\\n    }\\n};\\n```"
		}
	],
	"id":"619",
	"title":"Design Search Autocomplete System",
	"content":"<p>Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character <code>'#'</code>). For <b>each character</b> they type <b>except '#'</b>, you need to return the <b>top 3</b> historical hot sentences that have prefix the same as the part of sentence already typed. Here are the specific rules:</p>\r\n<ol>\r\n<li>The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before. </li>\r\n<li>The returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same degree of hot, you need to use ASCII-code order (smaller one appears first). </li>\r\n<li>If less than 3 hot sentences exist, then just return as many as you can.</li>\r\n<li>When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.</li>\r\n</ol>\r\n\r\n<p>Your job is to implement the following functions:</p>\r\n\r\n<p>The constructor function:</p>\r\n\r\n<p><code>AutocompleteSystem(String[] sentences, int[] times):</code> This is the constructor. The input is <b>historical data</b>. <code>Sentences</code> is a string array consists of previously typed sentences. <code>Times</code> is the corresponding times a sentence has been typed. Your system should record these historical data.</p>\r\n\r\n<p>Now, the user wants to input a new sentence. The following function will provide the next character the user types: </p>\r\n\r\n<p><code>List&lt;String&gt; input(char c):</code> The input <code>c</code> is the next character typed by the user. The character will only be lower-case letters (<code>'a'</code> to <code>'z'</code>), blank space (<code>' '</code>) or a special character (<code>'#'</code>). Also, the previously typed sentence should be recorded in your system. The output will be the <b>top 3</b> historical hot sentences that have prefix the same as the part of sentence already typed.</p>\r\n\r\n<br>\r\n<p><b>Example:</b><br />\r\n\r\n<b>Operation:</b> AutocompleteSystem([\"i love you\", \"island\",\"ironman\", \"i love leetcode\"], [5,3,2,2])\r\n<br>\r\nThe system have already tracked down the following sentences and their corresponding times:\r\n<br>\r\n<code>\"i love you\"</code> : <code>5</code> times\r\n<br>\r\n<code>\"island\"</code> : <code>3</code> times\r\n<br>\r\n<code>\"ironman\"</code> : <code>2</code> times\r\n<br>\r\n<code>\"i love leetcode\"</code> : <code>2</code> times\r\n<br>\r\nNow, the user begins another search:\r\n<br><br>\r\n<b>Operation:</b> input('i')\r\n<br>\r\n<b>Output:</b> [\"i love you\", \"island\",\"i love leetcode\"]\r\n<br>\r\n<b>Explanation:</b> \r\n<br>\r\nThere are four sentences that have prefix <code>\"i\"</code>. Among them, \"ironman\" and \"i love leetcode\" have same hot degree. Since <code>' '</code> has ASCII code 32 and <code>'r'</code> has ASCII code 114, \"i love leetcode\" should be in front of \"ironman\". Also we only need to output top 3 hot sentences, so \"ironman\" will be ignored.\r\n<br><br>\r\n<b>Operation:</b> input(' ')\r\n<br>\r\n<b>Output:</b> [\"i love you\",\"i love leetcode\"]\r\n<br>\r\n<b>Explanation:</b> \r\n<br>\r\nThere are only two sentences that have prefix <code>\"i \"</code>.\r\n<br><br>\r\n<b>Operation:</b> input('a')\r\n<br>\r\n<b>Output:</b> []\r\n<br>\r\n<b>Explanation:</b> \r\n<br>\r\nThere are no sentences that have prefix <code>\"i a\"</code>.\r\n<br><br>\r\n<b>Operation:</b> input('#')\r\n<br>\r\n<b>Output:</b> []\r\n<br>\r\n<b>Explanation:</b> \r\n<br>\r\nThe user finished the input, the sentence <code>\"i a\"</code> should be saved as a historical sentence in system. And the following input will be counted as a new search.\r\n<br>\r\n\r\n</p>\r\n<br>\r\n<p><b>Note:</b><br>\r\n\r\n<ol>\r\n\r\n<li>The input sentence will always start with a letter and end with '#', and only one blank space will exist between two words. </li>\r\n<li>The number of <b>complete sentences</b> that to be searched won't exceed 100. The length of each sentence including those in the historical data won't exceed 100. </li>\r\n<li>Please use double-quote instead of single-quote when you write test cases even for a character input.</li>\r\n<li>Please remember to <b>RESET</b> your class variables declared in class AutocompleteSystem, as static/class variables are <b>persisted across multiple test cases</b>. Please see <a href=\"https://leetcode.com/faq/#different-output\">here</a> for more details.</li>\r\n</ol>\r\n\r\n</p>",
	"frequency":"135",
	"ac_num":"4448"
}