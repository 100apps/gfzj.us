{
	"difficulty":"3",
	"submit_num":"17673",
	"show_id":"644",
	"leetcode_id":"644",
	"answers":[
		{
			"lc_ans_id":"105476",
			"view":"3896",
			"top":"0",
			"title":"Python, Advanced O(n) solution (Convex Hull Window)",
			"vote":"29",
			"content":"Let ```d(x, y)``` be the density of segment ```[x, y]```, ie. ```d(x, y) = (A[x]+...+A[y]) / (y-x+1)```.  It can be computed quickly with prefix sums.\\n\\nNow we refer to section 3 of [*Kai-min Chung, Hsueh-I Lu - An Optimal Algorithm for the Maximum-Density Segment Problem. 2008.*](https://arxiv.org/pdf/cs/0311020.pdf)\\n\\nFor each ending index ```j```, the current interval for ```i``` under consideration, ```[0, j-K+1]``` (minus parts on the left we have already discarded), has been decomposed into *minimum* density segments of longest length ```[hull[i], hull[i+1]-1]```, and we discard these segments as appropriate.  That is, for each ```i``` in increasing order, ```hull[i+1]``` is the largest index in ```[hull[i], j-K+1]``` so that ```[hull[i], hull[i+1]-1]``` has minimum density.\\n\\nThis is simply a lower hull of candidate points ```i```, in a geometric interpretation where ```d(a, b)``` is the slope of the line segment ```(a, P[a]) to (b+1, P[b+1])```.  Then, we can prove that discarding components with lower density than our current candidate ```d(hull[0], j)``` must leave us with the highest density option remaining.\\n\\n```\\ndef findMaxAverage(self, A, K):\\n    N = len(A)\\n    P = [0]\\n    for x in A:\\n        P.append(P[-1] + x)\\n\\n    def d(x, y):\\n        return (P[y+1] - P[x]) / float(y+1-x)\\n\\n    hull = collections.deque()\\n    ans = float('-inf')\\n\\n    for j in xrange(K-1, N):\\n        while len(hull) >= 2 and d(hull[-2], hull[-1]-1) >= d(hull[-2], j-K):\\n            hull.pop()\\n        hull.append(j-K + 1)\\n        while len(hull) >= 2 and d(hull[0], hull[1]-1) <= d(hull[0], j):\\n            hull.popleft()\\n        ans = max(ans, d(hull[0], j))\\n\\n    return ans\\n```"
		},
		{
			"lc_ans_id":"105480",
			"view":"5202",
			"top":"1",
			"title":"Java solution O(nlogM) Binary search the answer",
			"vote":"21",
			"content":"(nums[i]+nums[i+1]+...+nums[j])/(j-i+1)>x\\n=>nums[i]+nums[i+1]+...+nums[j]>x*(j-i+1)\\n=>(nums[i]-x)+(nums[i+1]-x)+...+(nums[j]-x)>0\\n\\n```\\npublic class Solution {\\n    boolean check(int[] nums,int k,double x) //Check whether we can find a subarray whose average is bigger than x\\n    {\\n        int n=nums.length;\\n        double[] a=new double[n];\\n        for (int i=0;i<n;i++) a[i]=nums[i]-x; //Transfer to a[i], find whether there is a subarray whose sum is bigger than 0\\n        double now=0,last=0;\\n        for (int i=0;i<k;i++) now+=a[i];\\n        if (now>=0) return true;\\n        for (int i=k;i<n;i++)\\n        {\\n            now+=a[i];\\n            last+=a[i-k];\\n            if (last<0) \\n            {\\n                now-=last;\\n                last=0;\\n            }\\n            if (now>=0) return true;\\n        }\\n        return false;\\n    }\\n    public double findMaxAverage(int[] nums, int k) {\\n        double l=Integer.MIN_VALUE,r=Integer.MAX_VALUE;\\n        while (r-l>0.000004) //Binary search the answer\\n        {\\n            double mid=(l+r)/2;\\n            if (check(nums,k,mid)) l=mid; else r=mid;\\n        }\\n        return r;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"105477",
			"view":"1771",
			"top":"2",
			"title":"[C++] Clean binary search solution with explanation",
			"vote":"12",
			"content":"The idea is using the binary search to find the maximum average value. We know that the maximum average value must be between the minimal value (```left``` in the code ) and maximum value (```right``` in the code ) in ```nums```. Each time we can check if ```mid = (left+right)/2``` is larger or less than the the maximum average value:\\n    \\nwe use ```max_ave``` to denote the maximum average value. Then,  for any ```i, j (j-i>=k-1)```,  we can have ```(nums[i] - max_ave) + (nums[i+1] - max_ave)+...+  (nums[j] - max_ave) <=0```. Therefore, for some ```i, j (j-i>=k-1)```, if we find ```(nums[i] - mid) + (nums[i+1] - mid)+...+  (nums[j] - mid) >0```, then ```mid```  must be smaller than ```max_ave```. The code is as follows:\\n\\n```\\n    double findMaxAverage(vector<int>& nums, int k) {\\n        double left = INT_MAX, right = INT_MIN, mid;\\n        for(int num:nums){\\n            right = max(right, double(num));\\n            left = min(left, double(num));\\n        }\\n        while(left + 0.00001 < right){\\n            mid = left + (right - left)/2;\\n            if(islarger(nums, mid, k))right = mid;\\n            else left = mid;\\n        }\\n        return left;\\n    }\\n    \\n    //Return true when mid is larger than or equal to the maximum average value;\\n    //Return false when mid is smaller than the maximum average value.\\n    bool islarger(vector<int>& nums, double mid, int k){\\n        // sum: the sum from nums[0] to nums[i];\\n        // prev_sum:  the sum from nums[0] to nums[i-k];\\n        // min_sum: the minimal sum from nums[0] to nums[j] ( 0=< j  <= i-k );\\n        double sum = 0, prev_sum = 0, min_sum = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i] - mid;\\n            if(i >= k){\\n                prev_sum += nums[i-k] - mid;                        \\n                min_sum = min(prev_sum, min_sum); \\n            }\\n            if(i >= k-1 && sum > min_sum)return false;\\n        }\\n        return true;                                               \\n    }\\n```"
		},
		{
			"lc_ans_id":"105489",
			"view":"1791",
			"top":"3",
			"title":"Python, Straightforward with Explanation",
			"vote":"6",
			"content":"We binary search on the answer.  Let ```P[i] = A[0] + A[1] + ... + A[i-1]```, the i-th prefix sum under A.\\n\\nLet's focus our attention on ```possible(x)```, a function that is true iff it is possible to have an average of at least ```x```.  Consider the elements ```B = [a-x for a in A]``` with corresponding prefix sum ```Q[i] = P[i] - i*x``` under B.  \\n\\nWe want to know if there is some ```>= K``` length subarray in B with average at least zero.  Suppose the subarray is ```B[i] + B[i+1] + ... + B[j] = Q[j+1] - Q[i]```.  To check whether this quantity is positive, for any ```j```, and any ```i <= j - K + 1```, we should check whether ```Q[j+1] >= min_{i <= j-K+1} Q[i]```.  Keeping a running minimum ```m``` of this array Q, we can check this in linear time. \\n\\nUnfortunately, the time constraint on Python solutions is fairly tight, so we need another trick to avoid TLE.  If a segment has the biggest average and we break it into two pieces, one of its pieces also has at least the same average.  When the length is ```>= 2*K```, we can split it into pieces of at least length ```K```, with the largest such piece being less than length ```2*K```.  \\n\\nThus, we only need to check segments of length ```K <= L < 2*K``` to find an instance of the maximum average.  When K is small, this admits an O(NK) solution that we use instead.  Our solution in that case is identical to *Maximum Average Subarray I*, repeated K times.\\n\\n```\\ndef findMaxAverage(self, A, K):\\n    N = len(A)\\n    P = [0]\\n    for x in A:\\n        P.append(P[-1] + x)\\n\\n    if K < 100:\\n        ans = float('-inf')\\n        for k in xrange(K, min(2*K, N+1)):\\n            best_sum = max(P[i+k] - P[i] for i in xrange(N-k+1))\\n            ans = max(ans, best_sum / float(k))\\n        return ans\\n\\n    def possible(x):\\n        m = P[0]\\n        for i, v in enumerate(P):\\n            m = min(m, v-i*x)\\n            if i+K == len(P): break\\n            if P[i+K] - (i+K)*x >= m:\\n                return True\\n        return False\\n\\n    lo, hi = min(A), max(A)\\n    while hi - lo > .00001:\\n        mi = (lo + hi) / 2.0\\n        if possible(mi):\\n            lo = mi\\n        else:\\n            hi = mi\\n    return lo\\n```"
		},
		{
			"lc_ans_id":"105482",
			"view":"165",
			"top":"4",
			"title":"Python solution with detailed explanation",
			"vote":"4",
			"content":"**Maximum Average Subarray II** https://leetcode.com/problems/maximum-average-subarray-ii/#/description\\n\\n**Brute Force Solution**\\n* Simply call Maximum Average SubArray I in a look for all possible values of k. \\n* Time Complexity is O(N^2).\\n```\\nclass Solution:\\n    def get_max_average(self, nums, k):\\n        if len(nums) < k:\\n            return 0.0\\n        max_so_far = sum_so_far = sum(nums[:k])\\n        for i in range(k, len(nums)):\\n            sum_so_far = sum_so_far + nums[i] - nums[i-k]\\n            max_so_far = max(max_so_far, sum_so_far)\\n        return float(max_so_far)/k    \\n    \\n    def findMaxAverage(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: float\\n        \"\"\"\\n        result = float('-inf')\\n        for x in range(k, len(nums)+1):\\n            result = max(result, self.get_max_average(nums, x))\\n        return result\\n```\\n\\n**Binary Search Solution**\\n* What is the range for the average value? Clearly, any average will lie between min(nums) and max(nums). So the intuition is to use binary search between this range.\\n* lo is initialized to min(nums). hi is initialized to max(nums). x = mid = (lo+hi)/2\\n* Now we want to solve the sub-problem: Does the array nums have a subarray of length greater than equal to k with average atleast x? If yes, then we can restrict our search to the range [x,hi]. Otherwise, we will search in the range [lo,x]. \\n* Can we devise a linear time solution for the problem: *Does the array nums have a subarray of length greater than equal to k with average atleast x?*\\n* nums[i]+...+nums[j] >= x * (j-i-1). This evaluates to: (nums[i]-x) + (nums[i+1]-x) + ...(nums[j]-x) >=0\\n* The problem is transformed into the following problem: Do we have a sub-array of length greater than k in the transformed array with sum greater than zero?\\n* The above problem can be solved in linear time. Start by finding the sum of first k elements nums[i]-mid. If this sum is greater than zero, then we can return True. Otherwise, say we have the cumulative sum until index j i.e. cum(j) where j >= k. Now say we know the minimum cumulative sum until index i i.e. mcum(i) such that j-i >= k. Then if the cum(j) >= mcum(i), we can return True.\\n\\n```\\nclass Solution:\\n    def can_process(self, mid, nums, k):\\n        sum_so_far = 0\\n        for i in range(k):\\n            sum_so_far += nums[i] - mid\\n        if sum_so_far >= 0:\\n            return True\\n        prev, min_so_far = 0.0, 0.0\\n        for i in range(k, len(nums)):\\n            sum_so_far += nums[i] - mid\\n            prev += nums[i-k]-mid\\n            min_so_far = min(min_so_far, prev)\\n            if sum_so_far >= min_so_far:\\n                return True\\n        return False\\n    \\n    def findMaxAverage(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: float\\n        \"\"\"\\n        lo, hi = min(nums), max(nums)\\n        precision = 1E-6\\n        while hi-lo > precision:\\n            mid = lo + (hi-lo)/2.0\\n            if self.can_process(mid, nums, k):\\n                lo = mid\\n            else:\\n                hi = mid\\n        return lo\\n```"
		},
		{
			"lc_ans_id":"105486",
			"view":"444",
			"top":"5",
			"title":"Short and fast Python",
			"vote":"3",
			"content":"Just implementing the binary search solution using NumPy for brevity and efficiency. Gets accepted in about 260 ms, easily beating 100% in the current runtime distribution (where times range from 439 ms to 1892 ms).\\n```\\nimport numpy as np\\n\\nclass Solution(object):\\n    def findMaxAverage(self, nums, k):\\n        lo, hi = min(nums), max(nums)\\n        nums = np.array([0] + nums)\\n        while hi - lo > 1e-5:\\n            mid = nums[0] = (lo + hi) / 2.\\n            sums = (nums - mid).cumsum()\\n            mins = np.minimum.accumulate(sums)\\n            if (sums[k:] - mins[:-k]).max() > 0:\\n                lo = mid\\n            else:\\n                hi = mid\\n        return lo\\n```"
		},
		{
			"lc_ans_id":"105492",
			"view":"1179",
			"top":"6",
			"title":"Python time limit too tight? O(nlog(m)) solution time out. O(n) solution passes.",
			"vote":"3",
			"content":"This is a binary search solution, should be O(nlog(m)). Still getting time out?\\n```\\n    def findMaxAverage(self, nums, k):\\n        hi, lo = max(nums), min(nums)\\n            \\n        arr = [0.0] * (len(nums) + 1)\\n        \\n        def isTrueAvgHigher(avg):\\n            minval = 2**32\\n            for i in xrange(len(nums)):\\n                arr[i+1] = nums[i] + arr[i] - avg\\n                if i >= (k-1):\\n                    if arr[i-k+1] < minval:\\n                        minval = arr[i-k+1]\\n                    if arr[i+1] - minval >= 0:\\n                        return True\\n            return False\\n        \\n        while (hi - lo) > 1e-5:\\n            mid = 1.0 * (hi + lo) / 2\\n            if isTrueAvgHigher(mid):\\n                lo = mid\\n            else:\\n                hi = mid\\n            \\n        return 1.0*(hi+lo)/2\\n```\\n\\n#Edit: following is an O(N) solution using similar idea as above, except you directly calculate how much average you need to add to get to the true solution.\\n\\n```\\n        def findMaxAverage(self, nums, k):\\n            arr = [0.0] * (len(nums) + 1)\\n            def getDelta(avg):\\n                minval, minval_pos = 2**32, -1\\n                delta = 0\\n                for i in xrange(len(nums)):\\n                    arr[i+1] = nums[i] + arr[i] - avg\\n                    if i >= (k-1):\\n                        if arr[i-k+1] < minval: # keep track of lowest average sum .\\n                            minval = arr[i-k+1]\\n                            minval_pos = i-k+1\\n                        if arr[i+1] - minval >= 0: # calculate the diff you need to add to reach the true average.\\n                            delta = max(delta, 1.0 * (arr[i+1] - minval) / (i+1 - minval_pos))\\n                return delta\\n            \\n            lo = min(nums) # use minimum as initial guess.\\n            for i in range(4): # Should only take 1 iteration, but need at least 4 iterations due to machine precision in calculating average for large arrays.\\n                lo += getDelta(lo)\\n            return lo\\n```"
		},
		{
			"lc_ans_id":"105475",
			"view":"545",
			"top":"7",
			"title":"Dear friends, please take a look at this code, It passes 70 test cases. gives me incorrect response on the 71st one. I am not sure what is going wrong.",
			"vote":"2",
			"content":"Idea is : avg[i] = max( (avg[i - 1] * len[i  - 1] + nums[i]) / (len[i - 1] + 1), sum /k);\\n\\nWhere sum is the running sum which keeps sum of last k elements. avg[i] represents max average of the array which ends at ith index. len[i] keeps track of how many numbers used to compute the max average that ends at ith index. \\n\\n```\\npublic class Solution {\\n    public double findMaxAverage(int[] nums, int k) {\\n        double sum = 0, maxAvg = Integer.MIN_VALUE;\\n        double[] sums = new double[nums.length];\\n        int[] lens = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (i >= k) {\\n                sum -= nums[i - k];\\n                double prev = (sums[i - 1] + nums[i]) / (lens[i - 1] + 1);\\n                double curr = sum / k;\\n                if (prev > curr) {\\n                    sums[i] = sums[i - 1] + nums[i];\\n                    lens[i] = lens[i - 1] + 1;\\n                } else {\\n                    sums[i] = sum;\\n                    lens[i] = k;\\n                }\\n                maxAvg = Math.max(maxAvg, sums[i]/lens[i]);\\n            }\\n            if (i + 1 == k) {\\n                sums[i] = sum;\\n                lens[i] = k;\\n                maxAvg = sum/k;\\n            }\\n        }\\n        \\n        return maxAvg;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"105497",
			"view":"1367",
			"top":"8",
			"title":"Share my c++ solution",
			"vote":"2",
			"content":"```\\ndouble findMaxAverage(vector<int>& nums, int k) {\\n        //calculate the average of the first k elements\\n        double maxAvg = 0;\\n        double sum = 0;\\n        int len = k;\\n        for(int i = 0;i<k;i++){\\n            sum+=nums[i];\\n        }\\n        maxAvg = sum/k;\\n        double avg = maxAvg;\\n        \\n        //find the maximum average value which ends with ith element.\\n        for(int i = k;i<nums.size();i++){\\n            len++;\\n            sum+=nums[i];\\n            avg = sum/len;\\n            \\n            double tempSum = sum;\\n            double tempAvg = avg;\\n            for(int j = len-1;j>=k;j--){\\n                tempSum-=nums[i-(j)];\\n                tempAvg = tempSum/j;\\n                if(tempAvg>=avg){\\n                    avg = tempAvg;\\n                    sum = tempSum;\\n                    len = j;\\n                }\\n            }\\n            if(avg>maxAvg){\\n                maxAvg = avg;\\n            }\\n        }\\n        return maxAvg;\\n    }\\n```"
		},
		{
			"lc_ans_id":"105484",
			"view":"76",
			"top":"9",
			"title":"C++ solution, simple improvement to brute force, O(nk)",
			"vote":"1",
			"content":"Start with the brute force O(n^2) solution, where we check each range of size >= k. The sum of values in that range can be calculated from running sums.\\n\\nNow observe that we only need to check ranges of size k, k+1, ... 2k-1.\\nFor any larger range, it can be partitioned into two smaller sub-ranges of size >= k, and one of these sub-ranges will have average at least as good.\\n\\n```\\nclass Solution {\\npublic:\\n    double findMaxAverage(vector<int>& nums, int k) {\\n        double res= -10000;\\n        int k2=k*2-1;\\n        vector<int> lsum (nums.size());\\n        lsum[0]=nums[0];\\n        for (int i=1;i<nums.size();++i){\\n            lsum [i] = lsum[i-1] +nums[i];\\n        }\\n        for(int i=0;i<nums.size();++i){\\n            for(int d=k; i+d<=nums.size()&&d <=k2; ++d){\\n                auto s = lsum[i+d-1];\\n                if (i>0) s -= lsum[i-1];\\n                if (res*d<=s) res = s*1.0/d;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```"
		}
	],
	"id":"621",
	"title":"Maximum Average Subarray II",
	"content":"<p>\r\nGiven an array consisting of <code>n</code> integers, find the contiguous subarray whose <b>length is greater than or equal to</b> <code>k</code> that has the maximum average value. And you need to output the maximum average value.\r\n</p>\r\n\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,12,-5,-6,50,3], k = 4\r\n<b>Output:</b> 12.75\r\n<b>Explanation:</b>\r\nwhen length is 5, maximum average value is 10.8,\r\nwhen length is 6, maximum average value is 9.16667.\r\nThus return 12.75.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>1 <= <code>k</code> <= <code>n</code> <= 10,000.</li>\r\n<li>Elements of the given array will be in range [-10,000, 10,000].</li>\r\n<li>The answer with the calculation error less than 10<sup>-5</sup> will be accepted.</li>\r\n</ol>\r\n</p>",
	"frequency":"145",
	"ac_num":"4287"
}