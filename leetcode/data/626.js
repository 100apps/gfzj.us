{
	"difficulty":"2",
	"submit_num":"11650",
	"show_id":"649",
	"leetcode_id":"649",
	"answers":[
		{
			"lc_ans_id":"105858",
			"view":"3735",
			"top":"0",
			"title":"[Java/C++] Very simple greedy solution with explanation",
			"vote":"33",
			"content":"This is obliviously a greedy algorithm problem. Each senate ```R``` must ban its next **closest** senate ```D``` who is from another party, or else ```D``` will ban its next  senate from  ```R's``` party. \\n\\nThe idea is to use two queues to save the index of each senate from ```R's``` and ```D's``` parties, respectively. During each round, we delete the banned senate's index; and plus the remainning senate's index with ```n```(the length of the input string ```senate```), then move it to the back of its respective queue.\\n\\nJava version:\\n```\\n    public String predictPartyVictory(String senate) {\\n        Queue<Integer> q1 = new LinkedList<Integer>(), q2 = new LinkedList<Integer>();\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++){\\n            if(senate.charAt(i) == 'R')q1.add(i);\\n            else q2.add(i);\\n        }\\n        while(!q1.isEmpty() && !q2.isEmpty()){\\n            int r_index = q1.poll(), d_index = q2.poll();\\n            if(r_index < d_index)q1.add(r_index + n);\\n            else q2.add(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n```\\n\\nC++ version:\\n```\\nstring predictPartyVictory(string senate) {\\n        queue<int> q1, q2;\\n        int n = senate.length();\\n        for(int i = 0; i<n; i++)\\n            (senate[i] == 'R')?q1.push(i):q2.push(i);\\n        while(!q1.empty() && !q2.empty()){\\n            int r_index = q1.front(), d_index = q2.front();\\n            q1.pop(), q2.pop();\\n            (r_index < d_index)?q1.push(r_index + n):q2.push(d_index + n);\\n        }\\n        return (q1.size() > q2.size())? \"Radiant\" : \"Dire\";\\n    }\\n```"
		},
		{
			"lc_ans_id":"105879",
			"view":"1278",
			"top":"1",
			"title":"Python, Straightforward with Explanation",
			"vote":"12",
			"content":"Simulate the process.  We don't have to resolve bans until later - we can just let them \"float\".\\n\\nWe have ```people = [int, int]``` representing how many people are in the queue, and ```bans = [int, int]``` representing how many \"floating\" bans there are.  When we meet a person, if there is a floating ban waiting for them, then they are banned and we skip them.  Eventually, the queue will just have one type of person, which is when we break.\\n\\n```\\ndef predictPartyVictory(self, senate):\\n    A = collections.deque()\\n    people = [0, 0]\\n    bans = [0, 0]\\n\\n    for person in senate:\\n        x = person == 'R'\\n        people[x] += 1\\n        A.append(x)\\n\\n    while all(people):\\n        x = A.popleft()\\n        people[x] -= 1\\n        if bans[x]:\\n            bans[x] -= 1\\n        else:\\n            bans[x^1] += 1\\n            A.append(x)\\n            people[x] += 1\\n\\n    return \"Radiant\" if people[1] else \"Dire\"\\n```"
		},
		{
			"lc_ans_id":"105889",
			"view":"913",
			"top":"2",
			"title":"Java solution, Greedy",
			"vote":"7",
			"content":"It is obvious that the best strategy is to ban the first opponent following the current senate.\\n\\n```\\npublic class Solution {\\n    public String predictPartyVictory(String senate) {\\n        int r = 0, d = 0, start = 0;\\n        char[] arr = senate.toCharArray();\\n        for (char c : arr) {\\n            if (c == 'R') r++;\\n            else d++;\\n        }\\n        \\n        while (r > 0 && d > 0) {\\n            while (arr[start] != 'R' && arr[start] != 'D') {\\n                start = (start + 1) % arr.length;\\n            }\\n            \\n            char ban = 'R';\\n            if (arr[start] == 'R') {\\n                ban = 'D';\\n                d--;\\n            }\\n            else {\\n                r--;\\n            }\\n            int idx = (start + 1) % arr.length;\\n            while (arr[idx] != ban) {\\n                idx = (idx + 1) % arr.length;\\n            }\\n            \\n            arr[idx] = ' ';\\n            start = (start + 1) % arr.length;\\n        }\\n        \\n        return d == 0 ? \"Radiant\" : \"Dire\";\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"105860",
			"view":"396",
			"top":"3",
			"title":"C++, O(n) solution",
			"vote":"4",
			"content":"It is not hard to see the greedy way to win is to ban next earliest opponent in a circle.\\nI use a variable \"count\" for how many R or D, and a string s for the state after current iteration. count > 0 means more active R, while count < 0 means more active D. When encountering 'D', if count > 0, this 'D' is banned, and count--. This 'D' is not appended to string s. If count <= 0, it will be appended to s.\\nBecause every active senate will ban another senate in a circle, the length of senate will shrink in half. Otherwise the game is over in current or next iteration. So the run time is n+n/2+n/4+..., which is O(n).\\n```\\nclass Solution {\\npublic:\\n    string predictPartyVictory(string senate) {\\n        int count = 0, len = 0;\\n        // When the length of senate doesn't decrease, the game is over.\\n        while (senate.size() != len) {\\n            string s;\\n            len = senate.size();\\n            for (int i = 0; i < len; i++) {\\n                if (senate[i] == 'R') {\\n                    if (count++ >= 0) s += 'R';\\n                }\\n                else if (senate[i] == 'D') {\\n                    if (count-- <= 0) s += 'D';\\n                }\\n            }  \\n            swap(s, senate);\\n        }\\n        if (senate[0] == 'R') \\n            return \"Radiant\";\\n        else \\n            return \"Dire\";\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"105882",
			"view":"168",
			"top":"4",
			"title":"Java, easy to understand with explanation, 18ms.",
			"vote":"2",
			"content":"To process the senator i, we need to know if  he/she/it has already been banned or not.\\n\\nIf is not banned, then he/she/it can ban an senator in another group, best choice is to ban the first one who hasn't voted in this round, otherwise one have already voted this round. \\n\\nBut it's not easy (is expensive) to find out which senator in the other group should be banned at this point, so we just use counter nToDelete to remember how many senator we need to ban for the other group. \\n\\nAnd when we process a senator in another group later (either in this round or next round), we can check this value, if it's not '0', we know it should be banned and can not vote anymore.\\n\\n```\\n    public String predictPartyVictory(String senate) {\\n        if (senate == null || senate.length() == 0) return null;\\n        int[] nLeft = new int[2]; // number of R, D groups still have right to vote \\n        int[] nToDelete = new int[2]; // number of R, D groups have been banned but not yet removed\\n        Character res = null;\\n        for(int i =0 ; i < senate.length(); i++){\\n            if(senate.charAt(i) == 'R') nLeft[0]++;\\n            else nLeft[1]++;\\n        }        \\n        while (res == null) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i =0; i<senate.length(); i++){\\n                char ch = senate.charAt(i);\\n                int idx = ch == 'R' ? 0 : 1;\\n                if ( (nLeft[0] == 0 || nLeft[1] ==0) && nToDelete[idx] ==0) { //Have winner, make sure current senator is not banned, so he can announce\\n                    res = ch;\\n                    break;\\n                }\\n                if (nToDelete[idx] != 0) nToDelete[idx]--; //Current senator need to be banned, Do not add to sb for next round\\n                else {\\n                    nLeft[1-idx]--; //ban one senator in another group\\n                    nToDelete[1-idx]++;\\n                    sb.append(ch); \\n                }\\n            }\\n            senate = sb.toString(); // Senators left to process in the next round\\n        }\\n        return res == 'R' ? \"Radiant\" : \"Dire\";\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"105886",
			"view":"246",
			"top":"5",
			"title":"Very easy to understand. Different than other solutions.",
			"vote":"2",
			"content":"Steps:\\n1) Put the string to a list of characters.\\n2) Traverse over the list.\\n3) Suppose we saw 'R', we need to find the next 'D' to remove, so we find it using FindNext() method, which tries to go to the end of the list from current point, and if couldn't find a D, starts from 0 and stops after checking each character once. If couldn't find any D (return -1), it means R is already winner.\\n4) If found the next 'D', just simply remove it from the list and move index forward, or 0, if we are at the end of the list.\\n5) if we saw 'D', same exact conditions in steps 3 and 4, by swapping R and D.\\n\\n```\\n   public string PredictPartyVictory(string senate)\\n    {\\n        List<char> list = senate.ToList<char>();\\n        int index = 0;\\n        while(true)\\n        {\\n            if (list[index] == 'R')\\n            {\\n                int nextD = FindNext('D', index, list);\\n                if (nextD == -1) return \"Radiant\";\\n                list.RemoveAt(nextD);\\n            }\\n            else //found D\\n            {\\n                int NextR = FindNext('R', index, list);\\n                if (NextR == -1) return \"Dire\";\\n                list.RemoveAt(NextR);\\n            }\\n            index = (index >= list.Count - 1) ? 0 : index + 1;\\n        }\\n    }\\n\\n    private static int FindNext(char c, int index, List<char> list)\\n    {\\n        int count = list.Count;\\n        while(count>0)\\n        {\\n            if (list[index] == c)\\n                return index;\\n            else\\n            {\\n                index = (index >= list.Count - 1) ? 0 : index+1;\\n            }\\n            count--;\\n        }\\n        return -1; //not found;\\n    }\\n```"
		},
		{
			"lc_ans_id":"105870",
			"view":"766",
			"top":"6",
			"title":"Confusion about the logic",
			"vote":"2",
			"content":"I just wonder why the output of \"DRRDRDRDRDDRDRDR\" is R?\\nAs my understanding, the sequence processing (each senator comes in) as:\\nD, D, R, D, R, D, R, D, R, D, DD, DD, DDD, DDD, DDDD, DDDD? where am i wrong. Thanks."
		},
		{
			"lc_ans_id":"105869",
			"view":"54",
			"top":"7",
			"title":"[JAVA] Simple Solution with Explanation",
			"vote":"1",
			"content":"(Before posting this, I've checked many other JAVA solutions. In most posts, this solution was called \"Greedy Method\". I'm not sure about its \"greediness\", rather, I think this is the strategy the two parties should adopt to win the vote. My solution coincides with many others, to make this post more useful for others, I'll try to present more explanations on the strategy part. )\\n\\nFirst, let's learn the strategy by example before coding.\\n**Example 1**\\nindex:    0  1   2   3\\nval:        R  D  R  D\\nSol: #0 R has to disable #1 D in order to win, otherwise, #1 D can disable #2 R, #3 D can disable #0 R, then only D remains. By contrast, if #0 R does disable #1 D, then #2 R can disable #3 D.\\n**what do we learn from Example 1?**\\nOne should always disable the closest following senator of the opposite party (let's call it closest enemy), so that one can prevent this closest enemy from disabling senators from his own party along the cycle. \\n\\n**Example 2**\\nIf we are told that the total # of D = 2, and the total # of R =4, can we know which party will win for sure?\\nSol: Yes. The best scenario of D party is as follows, in which D party can maximize its ability to disable their enemies (#0 D and #1 D can disable #2 and #3 R). However, given that the number of remained active R = 4-2, which is large enough to disable all the D's.\\nindex : 0  1   2   3   4   5\\nval:      D  D  R  R   R  R\\n**what do we learn from Example 2?**\\nThere's early ending condition. If total#D >= 2* total#R, we are sure party D will win, and vice versa.\\n\\nNow we can implement the above strategy in code now!\\n**Some highlights**\\n* I use array died to record all the disabled senators, so that we know whom should skip when moving along the cycle;\\n* I use variable killedR/killedD to count the number of R/D senators to be killed. So that if we see a R with killedR > 0, we shall put this R into died array, and do killedR--; if we see R with killedR == 0, however, we shall do killdD++ as this R is able to kill one closest enemy.\\n\\n```\\npublic class Solution {\\n    public String predictPartyVictory(String senate) {\\n        \\n        int r = 0;\\n        int d = 0;\\n        \\n        final String R_WIN = \"Radiant\";\\n        \\n        final String D_WIN = \"Dire\";\\n        \\n        for (int i=0; i < senate.length(); i ++ ) {\\n            char ch = senate.charAt(i);\\n            if (ch == 'R') {\\n                r ++;\\n            } else {\\n                d ++;\\n            }\\n        }\\n        \\n        int killedR = 0;\\n        int killedD = 0;\\n        \\n        int[] died = new int[senate.length()];\\n        \\n        int i=0;\\n        while( r != 0 || d != 0) {\\n            \\n            i = i % senate.length();\\n            \\n            if (r >= 2 * d) {\\n                d = 0;\\n                break;\\n            }\\n            \\n            if (d >= 2*r) {\\n                // System.out.println(\"r: \" + r + \", d: \" + d);\\n                r = 0;\\n                break;\\n            }\\n            \\n            if (died[i] == 1) {\\n                i ++;\\n                continue;\\n            }\\n            \\n            char ch = senate.charAt(i);\\n            \\n            if (ch == 'R') {\\n                if (killedR > 0) {\\n                    killedR --;\\n                    died[i] = 1;\\n                } else {\\n                    killedD ++;\\n                    d --;\\n                }\\n                // System.out.println(\"it's R, now we have r: \" + r + \", d: \" + d);\\n            } else {\\n                if (killedD > 0) {\\n                    died[i] = 1;\\n                    killedD --;\\n                } else {\\n                    killedR ++;\\n                    r --;\\n                }\\n                // System.out.println(\"it's D, now we have r: \" + r + \", d: \" + d);\\n            }\\n            i ++;\\n        }\\n        \\n        // System.out.println(\"r: \" + r + \", d: \" + d);\\n        return r > 0 ? R_WIN : D_WIN;\\n        \\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"105861",
			"view":"102",
			"top":"8",
			"title":"Straightforward and Simple Python",
			"vote":"1",
			"content":"Record the position of two parties, each party will ban its upcoming opponent.\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def predictPartyVictory(self, senate):\\n        \"\"\"\\n        :type senate: str\\n        :rtype: str\\n        \"\"\"\\n        n = len(senate)\\n        pos = collections.defaultdict(deque)\\n        for i in range(n):\\n        \\tpos[senate[i]].append(i)\\n\\n        while pos['R'] and pos['D']:\\n        \\tif pos['R'][0] < pos['D'][0]:\\n        \\t\\tpos['R'].append(pos['R'].popleft() + n)\\n        \\t\\tpos['D'].popleft()\\n        \\telse:\\n        \\t\\tpos['D'].append(pos['D'].popleft() + n)\\n        \\t\\tpos['R'].popleft()\\n\\n        return 'Radiant' if pos['R'] else 'Dire'\\n```"
		},
		{
			"lc_ans_id":"105859",
			"view":"18",
			"top":"9",
			"title":"Easy and concise solution [Python]",
			"vote":"0",
			"content":"I used ```countD``` to count the occurrence of \"D\".\\nIf I meet \"D\", ```countD++```\\nif I meet, ```countD--```\\n\\n```countD``` also means the number of \"R\" to ban. \\nIf ```countD<0```, it means the number of \"D\" to ban. \\n \\n```\\ndef predictPartyVictory(self, senate):\\n        n = len(senate)\\n        countD = 0\\n        senate = [1 if i==\"D\" else -1 for i in senate]\\n        for i in senate:\\n            countD += i\\n            if countD * i > 0:\\n                senate.append(i)\\n            if abs(countD) > n:\\n                return \"Dire\" if countD > 0  else \"Radiant\""
		}
	],
	"id":"626",
	"title":"Dota2 Senate",
	"content":"<p>\r\nIn the world of Dota2, there are two parties: the <code>Radiant</code> and the <code>Dire</code>.\r\n</p>\r\n\r\n<p>\r\nThe Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise <code>one</code> of the two rights:\r\n<ol>\r\n<li><code>Ban one senator's right</code>: <br/>A senator can make another senator lose <b>all his rights</b> in this and all the following rounds.</li>\r\n<li><code>Announce the victory</code>: <br/>If this senator found the senators who still have rights to vote are all from <b>the same party</b>, he can announce the victory and make the decision about the change in the game.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nGiven a string representing each senator's party belonging. The character 'R' and 'D' represent the <code>Radiant</code> party and the <code>Dire</code> party respectively. Then if there are <code>n</code> senators, the size of the given string will be <code>n</code>.\r\n</p>\r\n\r\n<p>\r\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\r\n</p>\r\n\r\n<p>\r\nSuppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be <code>Radiant</code> or <code>Dire</code>.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \"RD\"\r\n<b>Output:</b> \"Radiant\"\r\n<b>Explanation:</b> The first senator comes from Radiant and he can just ban the next senator's right in the round 1. <br/>And the second senator can't exercise any rights any more since his right has been banned. <br/>And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \"RDD\"\r\n<b>Output:</b> \"Dire\"\r\n<b>Explanation:</b> \r\nThe first senator comes from Radiant and he can just ban the next senator's right in the round 1. <br/>And the second senator can't exercise any rights anymore since his right has been banned. <br/>And the third senator comes from Dire and he can ban the first senator's right in the round 1. <br/>And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of the given string will in the range [1, 10,000].</li>\r\n</ol>\r\n</p>",
	"frequency":"29",
	"ac_num":"4254"
}