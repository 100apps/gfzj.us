{
	"difficulty":"2",
	"submit_num":"27717",
	"show_id":"652",
	"leetcode_id":"652",
	"answers":[
		{
			"lc_ans_id":"106011",
			"view":"12310",
			"top":"0",
			"title":"Java Concise Postorder Traversal Solution",
			"vote":"49",
			"content":"```\\npublic List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n    List<TreeNode> res = new LinkedList<>();\\n    postorder(root, new HashMap<>(), res);\\n    return res;\\n}\\n\\npublic String postorder(TreeNode cur, Map<String, Integer> map, List<TreeNode> res) {\\n    if (cur == null) return \"#\";  \\n    String serial = cur.val + \",\" + postorder(cur.left, map, res) + \",\" + postorder(cur.right, map, res);\\n    if (map.getOrDefault(serial, 0) == 1) res.add(cur);\\n    map.put(serial, map.getOrDefault(serial, 0) + 1);\\n    return serial;\\n}\\n```"
		},
		{
			"lc_ans_id":"106016",
			"view":"4335",
			"top":"1",
			"title":"O(n) time and space, lots of analysis",
			"vote":"27",
			"content":"First the basic version, which is O(n<sup>2</sup>) time and gets accepted in about 150 ms:\\n\\n    def findDuplicateSubtrees(self, root):\\n        def tuplify(root):\\n            if root:\\n                tuple = root.val, tuplify(root.left), tuplify(root.right)\\n                trees[tuple].append(root)\\n                return tuple\\n        trees = collections.defaultdict(list)\\n        tuplify(root)\\n        return [roots[0] for roots in trees.values() if roots[1:]]\\n\\nI convert the entire tree of nested `TreeNode`s to a tree of nested `tuple`s. Those have the advantage that they already support hashing and deep comparison (for the very unlikely cases of hash collisions). So then I can just use each subtree's `tuple` version as a key in my dictionary. And equal subtrees have the same key and thus get collected in the same list.\\n\\nOverall this costs only O(n) memory (where n is the number of nodes in the given tree). The string serialization I've seen in other posted solutions costs O(n^2) memory (and thus also at least that much time).\\n\\n<br>\\n\\n# So far only O(n<sup>2</sup>) time\\n\\nUnfortunately, tuples don't cache their own hash value (see [this](https://mail.python.org/pipermail/python-dev/2003-August/037424.html) for a reason). So if I use a tuple as key and thus it gets asked for its hash value, it will compute it again. Which entails asking its content elements for *their* hashes. And if they're tuples, then they'll do the same and ask *their* elements for *their* hashes. And so on. So asking a tuple tree root for its hash traverses the entire tree. Which makes the above solution only O(n^2) time, as the following test demonstrates. It tests linear trees, and doubling the height quadruples the run time, exactly what's expected from a quadratic time algorithm.\\n\\nThe code:\\n```\\nfrom timeit import timeit\\nimport sys\\nsys.setrecursionlimit(5000)\\n\\ndef tree(height):\\n    if height:\\n        root = TreeNode(0)\\n        root.right = tree(height - 1)\\n        return root\\n\\nsolution = Solution().findDuplicateSubtrees\\nfor e in range(5, 12):\\n    root = tree(2**e)\\n    print(timeit(lambda: solution(root), number=1000))\\n```\\nThe printed times:\\n```\\n0.0661657641567657\\n0.08246562780375502\\n0.23728608832718473\\n0.779312441896731\\n2.909226393471882\\n10.919695348072757\\n43.52919811329259\\n```\\n\\n<br>\\n\\n# Caching hashes\\n\\nThere's an easy way to add caching, though. Simply wrap each tuple in a `frozenset`, which *does* cache its hash value:\\n\\n    def findDuplicateSubtrees(self, root):\\n        def convert(root):\\n            if root:\\n                result = frozenset([(root.val, convert(root.left), convert(root.right))])\\n                trees[result].append(root)\\n                return result\\n        trees = collections.defaultdict(list)\\n        convert(root)\\n        return [roots[0] for roots in trees.values() if roots[1:]]\\n\\nRunning the above test again now shows O(n) behaviour as expected, doubling of size causing doubling of run time:\\n```\\n0.06577755770063994\\n0.056785410167764075\\n0.14042076531958228\\n0.22786156533737006\\n0.4496169916643781\\n0.932876339417438\\n1.8611131309331435\\n```\\nAnd it's much faster than the original version using only tuples. That said, both solutions get accepted by LeetCode in about 150 ms, since the test suite's trees are sadly pretty small and simple.\\n\\n---\\n\\nThat of course doesn't mean that the solution is now O(n) time. Only that it's apparently O(n) time for such linear trees. But there's a catch. If two subtrees have the same hash value, then they'll still get fully compared. There are two cases:\\n1. **Different trees having the same hash value**, i.e., hash collisions. LeetCode uses 64-bit Python and thus hash collisions are very unlikely unless you have a huge number of subtrees. The largest tree in the test suite has 5841 subtrees. The probability of having no collisions for 5841 different values is about 99.9999999999078%:\\n    ```\\n    >>> reduce(lambda p, i: p * (2**64 - i) / 2**64, range(5841), 1.0)\\n    0.999999999999078\\n    ```\\n    Even if all 5841 subtrees were different and all of the test suite's 167 test cases were like that, then we'd still have about a 99.99999998460193% chance to not have any hash collisions anywhere:\\n    ```\\n    >>> 0.999999999999078**167\\n    0.9999999998460193\\n    ```\\n    Also, I could of course use a stronger hashing algorithm, like SHA256.\\n\\n2. **Equal trees having the same hash value**. Well duh, obviously equal trees have the same hash value. So how big of a problem is that? How many equal trees can we have, and of what sizes? In the above case of the whole tree being linear, there are *no* equal subtrees at all (except for the trivial empty subtrees, but they don't matter). So let's go to the other extreme end, a [perfect tree](https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees). Then there are *lots* of equal trees. There are n subtrees but only about log<sup>2</sup>(n) *different* subtrees, one for each height. Subtrees of the same height are all equal. So pretty much *every* subtree is a duplicate and thus shares the hash with a previous subtree and thus will get completely compared to the previous one. So how costly is it to traverse all subtrees completely (in separate traversals)? The whole tree has n nodes. Its two subtrees have about n/2 nodes each, so about n nodes together (actually n-1 because they don't contain the root). The next level has 4 trees with about n/4 nodes each, again adding n nodes overall. And so on. We have log<sub>2</sub>(n) levels, so overall this takes O(n log n) time. We can again test this, doubling the size of a tree makes the run time a bit worse than double:\\n    ```\\n    def tree(height):\\n        if height:\\n            root = TreeNode(0)\\n            root.left = tree(height - 1)\\n            root.right = tree(height - 1)\\n            return root\\n\\n    solution = Solution().findDuplicateSubtrees\\n    for e in range(10, 17):\\n        root = tree(e)\\n        print(timeit(lambda: solution(root), number=100))\\n    ```\\n    The printed times:\\n    ```\\n    0.10957473965829807\\n    0.22831256388730117\\n    0.48625792412907487\\n    1.010916041039311\\n    2.131317089557299\\n    4.5137782403671025\\n    9.616743290368206\\n    ```\\n    The last two trees have 15 and 16 levels, respectively. If the solution does take &Theta;(n log n) time for perfect trees, then we expect it to take 2 * 16/15 as long for the tree with 16 levels as for the tree with 15 levels. And it did: 4.51 * 2 * 16/15 is about 9.62. (If you find that suspiciously accurate, you're right: I actually ran the whole test 50 times and used the averages).\\n\\n    So is the `frozenset` solution O(n log n) time? Nope. Sadly not. It's still only O(n<sup>2</sup>). Remember how the original tuple solution took O(n<sup>2</sup>) time for linear trees? And how caching the hashes improved that to O(n), because there were no duplicate subtrees whose equal hashes would cause expensive deep comparison? Well, all we have to do to create the same nightmare scenario again is to have *two* such linear subtrees under a common root node. Then while the left subtree only takes O(n), the right subtree takes O(n<sup>2</sup>). Demonstration again:\\n    ```\\n    def tree(height):\\n        if height:\\n            root = TreeNode(0)\\n            root.right = tree(height - 1)\\n            return root\\n\\n    solution = Solution().findDuplicateSubtrees\\n    for e in range(5, 12):\\n        root = TreeNode(0)\\n        root.left = tree(2**e)\\n        root.right = tree(2**e)\\n        print(timeit(lambda: solution(root), number=1000))\\n    ```\\n    The printed times:\\n    ```\\n    0.1138048859928981\\n    0.19950686963173872\\n    0.5518468952197122\\n    1.8595846431294971\\n    6.7689327267056605\\n    26.291197508748162\\n    106.77212851917264\\n    ```\\n<br>\\n\\n# O(n) time and space\\n\\nFortunately, @Danile showed an [O(n) time solution](https://discuss.leetcode.com/topic/97790/no-string-hash-python-code-o-n-time-and-space) and it's pretty simple. Here's my implementation using their idea:\\n\\n    def findDuplicateSubtrees(self, root, heights=[]):\\n        def getid(root):\\n            if root:\\n                id = treeid[root.val, getid(root.left), getid(root.right)]\\n                trees[id].append(root)\\n                return id\\n        trees = collections.defaultdict(list)\\n        treeid = collections.defaultdict()\\n        treeid.default_factory = treeid.__len__\\n        getid(root)\\n        return [roots[0] for roots in trees.values() if roots[1:]]\\n\\nThe idea is the same as Danile's: Identify trees by numbering them. The first unique subtree gets id 0, the next unique subtree gets id 1, the next gets 2, etc. Now the dictionary keys aren't deep nested structures anymore but just ints and triples of ints.\\n\\nRunning the \"perfect trees\" test again:\\n```\\n0.05069159040252735\\n0.09899985757750773\\n0.19695348072759256\\n0.39157652084085726\\n0.7962228593508778\\n1.5419999122629369\\n3.160187444826308\\n```\\nAnd the \"linear trees\" test again:\\n```\\n0.034597848759331834\\n0.05386034062412301\\n0.12324202869723078\\n0.22538750035305155\\n0.46485619835306713\\n0.8654176554613617\\n1.7437530910788834\\n```\\nAnd the \"two parallel linear trees\" test again:\\n```\\n0.05274439729745809\\n0.0894428275852537\\n0.18871220620853896\\n0.3264557892339413\\n0.7091321061762685\\n1.3789991725072908\\n2.7934804751983546\\n```\\nAll three tests now show nice doubling of the times, as expected from O(n).\\n\\nThis solution gets accepted in about 100 ms, and the best time I got from a handful of submissions was 92 ms.\\n\\n<br>\\n\\n# Revisiting the probability calculation for hash collisions\\n\\nAbove I calculated the probability 99.9999999999078% using *floats*. Which of course have rounding errors. So can we trust that calculation? Especially since we're multiplying so many special factors, all being close to 1? Turns out that yes, that's pretty accurate.\\n\\nWe can do the calculation using integers, which only round down. Just scale the \"probability\" by 10<sup>30</sup> or so:\\n```\\n>>> p = 10**30\\n>>> for i in range(5841):\\n        p = p * (2**64 - i) // 2**64\\n\\n>>> p\\n999999999999075407566135201054\\n```\\nSince those divisions round down, this gives us a lower bound for the true value. And if we instead work with *negative* numbers, then the divisions effectively round *up* and we get an *upper* bound for the true value:\\n```\\n>>> p = -10**30\\n>>> for i in range(5841):\\n        p = p * (2**64 - i) // 2**64\\n\\n>>> -p\\n999999999999075407566135206894\\n```\\nComparing those two bounds we can see that the true probability is 99.999999999907540756613520...%. So of the previous result 99.9999999999078% using floats, only that last digit was wrong.\\n\\nUsing this value in the subsequent calculation again, we get a 99.99999998455928% chance for not having any collisions anywhere even if all 167 test cases had 5841 subtrees without duplicates:\\n```\\n>>> 0.99999999999907540756613520**167\\n0.9999999998455928\\n```"
		},
		{
			"lc_ans_id":"106055",
			"view":"4065",
			"top":"2",
			"title":"[C++] [Java] Clean Code",
			"vote":"26",
			"content":"**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        unordered_map<string, vector<TreeNode*>> map;\\n        vector<TreeNode*> dups;\\n        serialize(root, map);\\n        for (auto it = map.begin(); it != map.end(); it++)\\n            if (it->second.size() > 1) dups.push_back(it->second[0]);\\n        return dups;\\n    }\\nprivate:\\n    string serialize(TreeNode* node, unordered_map<string, vector<TreeNode*>>& map) {\\n        if (!node) return \"\";\\n        string s = \"(\" + serialize(node->left, map) + to_string(node->val) + serialize(node->right, map) + \")\";\\n        map[s].push_back(node);\\n        return s;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        Map<String, List<TreeNode>> map = new HashMap<String, List<TreeNode>>();\\n        List<TreeNode> dups = new ArrayList<TreeNode>();\\n        serialize(root, map);\\n        for (List<TreeNode> group : map.values())\\n            if (group.size() > 1) dups.add(group.get(0));\\n        return dups;\\n    }\\n\\n    private String serialize(TreeNode node, Map<String, List<TreeNode>> map) {\\n        if (node == null) return \"\";\\n        String s = \"(\" + serialize(node.left, map) + node.val + serialize(node.right, map) + \")\";\\n        if (!map.containsKey(s)) map.put(s, new ArrayList<TreeNode>());\\n        map.get(s).add(node);\\n        return s;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"106020",
			"view":"1576",
			"top":"3",
			"title":"Python easy understand solution",
			"vote":"8",
			"content":"`````\\ndef findDuplicateSubtrees(self, root):\\n        def trv(root):\\n            if not root: return \"null\"\\n            struct = \"%s,%s,%s\" % (str(root.val), trv(root.left), trv(root.right))\\n            nodes[struct].append(root)\\n            return struct\\n        \\n        nodes = collections.defaultdict(list)\\n        trv(root)\\n        return [nodes[struct][0] for struct in nodes if len(nodes[struct]) > 1]"
		},
		{
			"lc_ans_id":"106022",
			"view":"797",
			"top":"4",
			"title":"No string hash, Python code, O(n) time and space",
			"vote":"6",
			"content":"```\\n    def findDuplicateSubtrees(self, root):\\n        self.type_id_gen = 0\\n        duplicated_subtrees = []\\n        type_to_freq = defaultdict(int)\\n        type_to_id = {}\\n        \\n        def dfs(node):\\n            if not node:\\n                return -1\\n            type_id_left, type_id_right = (dfs(ch) for ch in (node.left, node.right))\\n            tree_type = (node.val, type_id_left, type_id_right)\\n            freq = type_to_freq[tree_type]\\n            if freq == 0:\\n                type_id = self.type_id_gen\\n                self.type_id_gen += 1\\n                type_to_id[tree_type] = type_id\\n            elif freq == 1:\\n                type_id = type_to_id[tree_type]\\n                duplicated_subtrees.append(node)\\n            else:\\n                type_id = type_to_id[tree_type] \\n            type_to_freq[tree_type] += 1\\n            return type_id\\n            \\n        dfs(root)\\n        return duplicated_subtrees  \\n```\\n@StefanPochmann, I'm not sure about the time complexity of string or your tuple hash. For each time we wanna get the hash value of a string, should we regard the action as O(1) or O(length of string)? If it is the latter, then the total time complexity would be O(n ^ 2), given tree is a linked list, which conflicts with the time of actual execution of those solutions; otherwise, in what way that Python makes the operation of string with different length has the same time complexity? Thanks!"
		},
		{
			"lc_ans_id":"106030",
			"view":"1756",
			"top":"5",
			"title":"Python, O(N) Merkle Hashing Approach",
			"vote":"6",
			"content":"We'll assign every subtree a unique *merkle* hash.  You can find more information about Merkle tree hashing here:  https://discuss.leetcode.com/topic/88520/python-straightforward-with-explanation-o-st-and-o-s-t-approaches\\n\\n```\\ndef findDuplicateSubtrees(self, root):\\n    from hashlib import sha256\\n    def hash_(x):\\n        S = sha256()\\n        S.update(x)\\n        return S.hexdigest()\\n\\n    def merkle(node):\\n        if not node:\\n            return '#'\\n        m_left = merkle(node.left)\\n        m_right = merkle(node.right)\\n        node.merkle = hash_(m_left + str(node.val) + m_right)\\n        count[node.merkle].append(node)\\n        return node.merkle\\n\\n    count = collections.defaultdict(list)\\n    merkle(root)\\n    return [nodes.pop() for nodes in count.values() if len(nodes) >= 2]\\n```"
		},
		{
			"lc_ans_id":"106021",
			"view":"1585",
			"top":"6",
			"title":"Verbose Java solution, tree traversal",
			"vote":"5",
			"content":"Idea is to traverse the tree and serialize each sub-tree to a string and put them into a HashMap. The first time we put ```null``` as the value and later we put the real node as the value. Then at last, every entry in the map with not null value, is an answer.\\nAn optimization is to start searching from the ```first possible``` start node which has both left and right sub-trees. Think about why tree node with only one sub-tree can't be a valid start point?\\n```\\npublic class Solution {\\n    Map<String, TreeNode> map = new HashMap<>();\\n    \\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        List<TreeNode> result = new ArrayList<>();\\n        if (root == null) return result;\\n        \\n        traverse(first(root));\\n        \\n        for (TreeNode node : map.values()) {\\n            if (node != null) {\\n                result.add(node);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private TreeNode first(TreeNode root) {\\n        if (root == null) return null;\\n        if (root.left != null && root.right != null) return root;\\n        if (root.left != null) return first(root.left);\\n        return first(root.right);\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) return;\\n        \\n        String s = path(root);\\n        if (map.containsKey(s)) {\\n            map.put(s, root);\\n        }\\n        else {\\n            map.put(s, null);\\n        }\\n        \\n        traverse(root.left);\\n        traverse(root.right);\\n    }\\n    \\n    private String path(TreeNode root) {\\n        if (root == null) return \"#\";\\n        return root.val + \",\" + path(root.left) + \",\" + path(root.right);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"106041",
			"view":"291",
			"top":"7",
			"title":"C++, 19 ms, O(n^2), sort by subtree height",
			"vote":"2",
			"content":"If two subtrees are the same, they have to have same height. The idea is to sort subtrees by its height using post order traversal, and then to work on each group with the same height. \\n\\nThe run time is O(n^2), the same as the string serialization solution. The analysis is as below. It takes O(n) time to sort subtrees into groups. It takes O(m) time to check whether two trees are the same, with m is the total node number in the tree. For a group with the same height, there are O(k^2) same tree comparisons, and k is the number of subtrees in the group. For height i, assuming there are ki subtrees, so there are about n/ki nodes in each subtree. The run time for this group is O(ki^2) x O(n/ki) = O(nki). The sum of all ki, i.e. all nodes, is n, so the total run time is O(n^2).  \\n\\nI have tried to incorporate the total nodes for each subtree, because the same subtree will also have the same amount of nodes, however it didn't improve the run time due to performance of hash table. The comparison to check whether it is the same tree is still potentially time consuming. If anyone have good optimization, please leave a comment. Thanks!\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        if (root == NULL) return ans;\\n        vector<vector<TreeNode*>> height(1, vector<TreeNode*>());\\n        find_height(height, root);\\n        for (int i = 1; i < height.size(); i++) {\\n            for (int j = 0; j < height[i].size(); j++) {\\n                if (height[i][j] == NULL) continue;\\n                bool exist = false;\\n                for (int k = j+1; k < height[i].size(); k++) {\\n                    if (sametree(height[i][j], height[i][k])) {\\n                        height[i][k] = NULL;\\n                        exist = true;\\n                    }\\n                }\\n                if (exist) ans.push_back(height[i][j]);\\n            }   \\n        }\\n        return ans;\\n    }\\nprivate:\\n    int find_height(vector<vector<TreeNode*>>& height, TreeNode* p) {\\n        if (p == NULL) return 0;\\n        int left = find_height(height, p->left), right = find_height(height, p->right), h = max(left, right)+1;\\n        if (h == height.size()) \\n            height.push_back({p});\\n        else \\n            height[h].push_back(p);\\n        return h;\\n    }\\n    bool sametree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL) return true;\\n        if (p == NULL || q == NULL) return false;\\n        if (p->val != q->val) return false;\\n        return sametree(p->left, q->left) && sametree(p->right, q->right);\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"106026",
			"view":"164",
			"top":"8",
			"title":"C++ Postorder traversal without serialization with explaination beat 95%",
			"vote":"1",
			"content":"We can solve this problem if each subtree can be assign a unique key and a global integer id incrementing from 0. The unique key of subtree can be represent as a tuple:\\n(root->val, left subtree id, right subtree id).\\n\\t1. For empty tree, the unique id is 0 and the key is something that can never be found in a real tree like (INT_MAX,INT_MAX,INT_MAX) as it is almost impossible to have any subtree whose id is INT_MAX\\n\\t2. For leaf node, the key is just the (root->val, 0, 0) as both of its children are empty tree\\n\\t3. For other nodes, if we do a post-order traversal of the tree, we can always know the id of their children and therefore can form their key tuple. We can use this key tuple to find whether the subtree has already been found, otherwise assign a new id to it.\\n\\n```\\nstruct Subtree {\\n    int v;\\n    int lid; // id for left subtree\\n    int rid; // id for right subtree\\n    Subtree(int x, int l, int r) : v(x), lid(l), rid(r) {}\\n    bool operator==(const Subtree &r) const {\\n        return v==r.v && lid==r.lid && rid==r.rid;\\n    }\\n};\\nstruct Hasher {\\n    size_t operator() (const Subtree& k) const{\\n        size_t key=k.v;\\n        return (key<<32)+(k.lid^k.rid);\\n    }\\n  };   \\nstruct Comp {\\n    bool operator() (const Subtree& l, const Subtree& r) const {\\n        return l.v==r.v && l.lid==r.lid && l.rid==r.rid;\\n    }\\n  };\\n\\nclass Solution {\\npublic:     \\n    unordered_map<Subtree, int, Hasher, Comp> fmap; // Subtree=>Subtree id map\\n    vector<int> count; // id => count map\\n    vector<TreeNode*> rmap; // subtree id => real root map\\n    int PostTraverse(TreeNode* root) {\\n        if (root==NULL)\\n            return 0;\\n        int lid = PostTraverse(root->left);\\n        int rid = PostTraverse(root->right);\\n        Subtree st(root->val, lid, rid);\\n        if (fmap.find(st)==fmap.end()) {\\n            // a new subtree is found\\n            int newid = count.size(); // new id is always the number of all subtrees traversed\\n            fmap[st] = newid;\\n            count.push_back(1);\\n            rmap.push_back(root);\\n        } else {\\n            // this subtree has been found\\n            count[fmap[st]]++;\\n        }\\n        return fmap[st];\\n    }\\n\\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {       \\n        fmap[Subtree(INT_MAX,INT_MAX,INT_MAX)] = 0; // id 0 indicates a NULL tree\\n        count.push_back(1); // count[0] = 1;\\n        rmap.push_back(NULL); // id 0 indicate null tree\\n        PostTraverse(root);\\n        vector<TreeNode*> res;\\n        for (int i=0; i<count.size(); ++i)\\n            if (count[i]>1)\\n                res.push_back(rmap[i]);\\n        return res;   \\n    }\\n};\\n\\n```"
		},
		{
			"lc_ans_id":"106035",
			"view":"117",
			"top":"9",
			"title":"Java HashCode Solution to avoid most equals comparison",
			"vote":"1",
			"content":"\\n    private boolean sameNode(TreeNode a, TreeNode b){\\n        if(a == null && b == null)\\n            return true;\\n        if(a == null && b != null || a != null && b == null)\\n            return false;\\n        return a.val == b.val && sameNode(a.left, b.left) && sameNode(a.right, b.right);\\n        \\n    }\\n\\n    private class Entry{\\n        int hash_code;\\n        TreeNode node;\\n        Entry(int h, TreeNode n){\\n            hash_code = h;\\n            node = n;\\n        }\\n        public int hashCode(){\\n            return hash_code;\\n        }\\n        public boolean equals(Object e){\\n            return sameNode(node, ((Entry)e).node);\\n        }\\n    }\\n    List<Entry> list = new ArrayList<>();\\n    private int getEntry(TreeNode root){\\n        if(root == null)\\n            return 1;\\n        int left = getEntry(root.left);\\n        int right = getEntry(root.right);\\n        int code = left * 100007 + right * 700001 + root.val;\\n        list.add(new Entry(code, root));\\n        return code;\\n    }\\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\\n        getEntry(root);\\n        Map<Entry, Integer> map = new HashMap<>();\\n        for(Entry e : list){\\n            if(map.containsKey(e))\\n                map.put(e, map.get(e) + 1);\\n            else\\n                map.put(e, 1);\\n        }\\n        List<TreeNode> ans = new LinkedList<>();\\n        for(Entry key : map.keySet())\\n            if(map.get(key) > 1)\\n                ans.add(key.node);\\n        return ans;\\n    }"
		}
	],
	"id":"629",
	"title":"Find Duplicate Subtrees",
	"content":"<p>\r\nGiven a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any <b>one</b> of them. </p>\r\n\r\n<p>\r\nTwo trees are duplicate if they have the same structure with same node values.\r\n</p>\r\n\r\n<p><b>Example 1: </b><br>\r\n<pre>\r\n        1\r\n       / \\\r\n      2   3\r\n     /   / \\\r\n    4   2   4\r\n       /\r\n      4\r\n</pre>\r\nThe following are two duplicate subtrees:\r\n<pre>\r\n      2\r\n     /\r\n    4\r\n</pre>\r\nand\r\n<pre>\r\n    4\r\n</pre>\r\nTherefore, you need to return above trees' root in the form of a list.\r\n</p>\r\n\r\n",
	"frequency":"200",
	"ac_num":"10301"
}