{
	"difficulty":"2",
	"submit_num":"14603",
	"show_id":"655",
	"leetcode_id":"655",
	"answers":[
		{
			"lc_ans_id":"106239",
			"view":"3603",
			"top":"0",
			"title":"Java Recursive Solution",
			"vote":"11",
			"content":"```\\npublic List<List<String>> printTree(TreeNode root) {\\n    List<List<String>> res = new LinkedList<>();\\n    int height = root == null ? 1 : getHeight(root);\\n    int rows = height, columns = (int) (Math.pow(2, height) - 1);\\n    List<String> row = new ArrayList<>();\\n    for(int i = 0; i < columns; i++)  row.add(\"\");\\n    for(int i = 0; i < rows; i++)  res.add(new ArrayList<>(row));\\n    populateRes(root, res, 0, rows, 0, columns - 1);\\n    return res;\\n}\\n\\npublic void populateRes(TreeNode root, List<List<String>> res, int row, int totalRows, int i, int j) {\\n    if (row == totalRows || root == null) return;\\n    res.get(row).set((i+j)/2, Integer.toString(root.val));\\n    populateRes(root.left, res, row+1, totalRows, i, (i+j)/2 - 1);\\n    populateRes(root.right, res, row+1, totalRows, (i+j)/2+1, j);\\n}\\n\\npublic int getHeight(TreeNode root) {\\n     if (root == null) return 0;\\n     return 1 + Math.max(getHeight(root.left), getHeight(root.right));\\n}\\n```"
		},
		{
			"lc_ans_id":"106273",
			"view":"231",
			"top":"1",
			"title":"Simple Python with thorough explanation",
			"vote":"6",
			"content":"This question involves quite a bit of math. It would help if you are familiar with the math involved for Binary Trees. Let's recap some of the formulas involved:\\n\\nGiven a Binary Tree of height `H`:\\n\\n- The maximum total number of nodes is = `2^H - 1`\\n- Number of nodes at each level, L (0-indexed) = `2^L`\\n\\nWe can view the final output as a 2-D matrix, where the number of rows is the height of the tree and the number of columns will be the `2^H - 1`.\\n\\nTaking this tree as example:\\n\\n```\\n        1\\n      /   \\\\\\n    2      3\\n   /  \\\\    / \\\\\\n  4   5   6   7\\n / \\\\\\n8   9\\n```\\n\\nOur final matrix should look like this:\\n\\n```\\n.......1....... <- Level 0, Left padding: 7, Spacing: 15\\n...2.......3... <- Level 1, Left padding: 3, Spacing: 7\\n.4...5...6...7. <- Level 2, Left padding: 1, Spacing: 3\\n8.9............ <- Level 3, Left padding: 0, Spacing: 1\\n```\\n\\nThe height is 4 and based on our calculations, the number of `rows = 4`, number of `cols = 2^4 - 1 = 15`. So we can directly initialize a 2-D matrix of size `4 x 15`. We can observe that for each row, the first node has a `left padding = 2^(H-L-1) - 1` and the space between each node is `2^(H-L) - 1`.\\n\\nWith these formulas derived, the next task is to calculate the position of node in each row and we can do that as we traverse the tree. The position of each node in its own row can be represented by a number in its binary form, which can be obtained from the left/right paths taken from the root. Taking the node 6 in the tree above, 6 is found via `root->right->left`. The root node has number of 0. Each time we move to a left child, append 0 to the binary representation (multiply the number by 2). Each time we move to a right child, append 1 to the binary representation (multiply the number by 2 and add 1). Let's have a look at some examples:\\n\\nNode 6 is `root->right->left` = `0b10` and its position within row = `(0*2+1)*2 = 2`\\nNode 7 is `root->right->right` = `0b11` and its position within row = `((0*2+1)*2+1) = 3`\\nNode 9 is `root->left->left->right` = `0b001` and its position within row = `(((0*2)*2)*2+1) = 1`\\n\\nRepresenting the above tree in its binary form:\\n\\n```\\n         0\\n       /    \\\\\\n      0      1\\n    /  \\\\    / \\\\\\n   00  01  10  11\\n  /  \\\\\\n000   001\\n```\\n\\nNodes 6 and 7 are index 2 and 3 in their rows.\\n\\nAs we traverse the tree, we will have the row and the position in the row of each node. Hence we can fill in the matrix with the node values based on the left padding and spacing in each row.\\n\\n*- Yangshun*\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def printTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        def get_height(node):\\n            if not node:\\n                return 0\\n            return 1 + max(get_height(node.left), get_height(node.right))\\n\\n        rows = get_height(root)\\n        cols = 2 ** rows - 1\\n        res = [['' for _ in range(cols)] for _ in range(rows)]\\n\\n        def traverse(node, level, pos):\\n            if not node:\\n                return\\n            left_padding, spacing = 2 ** (rows - level - 1) - 1, 2 ** (rows - level) - 1\\n            index = left_padding + pos * (spacing + 1)\\n            print(level, index, node.val)\\n            res[level][index] = str(node.val)\\n            traverse(node.left, level + 1, pos << 1)\\n            traverse(node.right, level + 1, (pos << 1) + 1)\\n        traverse(root, 0, 0)\\n        return res\\n```"
		},
		{
			"lc_ans_id":"106246",
			"view":"1859",
			"top":"2",
			"title":"C++, O(N), DFS/preorder traversal",
			"vote":"4",
			"content":"We can easily get the dimensions of the ans, which is height and width of the tree, by DFS. The remaining work is to recursively preorder or other traversal of the tree.\\n\\nNote a big number \"1234567\" takes the same space as \"1\". I misunderstood the question and came into a bit more complex problem.\\n\\nExcept initializing the answer of m row and n column, the run time is O(N). Here m is the height of the tree, n = 2^m-1, and N is how many nodes of the tree. In the worst case, for example, a tree with only left child, we have m = N, so the initialization is O(N x 2^N). Fortunately, m <= 10, so initialization is O(10000). When m is a big number, this can be an issue and we will have memory error as well.\\n\\nHere I assume initialization using empty string is very fast. I did a test by adding the code below to show initialization is not the limiting factor.\\n```\\nvector<vector<string>> ans;\\nint k = 1000;\\nfor (int i = 0; i < k; i++)\\n       ans = vector<vector<string>>(h, vector<string>(w, \"\"));\\n```\\nk = 1,           3 ms;\\nk = 10,         3 ms;\\nk = 100,  9-12 ms;\\nk = 1000, ~70 ms;\\nSo initialization seems huge, but only takes about 6-7% of total run time.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> printTree(TreeNode* root) {\\n        int h = get_height(root), w = get_width(root);\\n        vector<vector<string>> ans(h, vector<string>(w, \"\"));\\n        helper(ans, root, 0, 0, w-1);\\n        return ans;\\n    }\\nprivate:\\n    int get_height(TreeNode* p) {\\n        if (!p) return 0;\\n        int left = get_height(p->left), right = get_height(p->right);\\n        return max(left, right)+1;\\n    }\\n    // width is the max(left, right)*2+1\\n    int get_width(TreeNode* p) {\\n        if (!p) return 0;\\n        int left = get_width(p->left), right = get_width(p->right);\\n        return max(left, right)*2+1;\\n    }\\n    // always put the value in the middle of the range.\\n    void helper(vector<vector<string>>& ans, TreeNode* p, int level, int l, int r) {\\n        if (!p) return;\\n        int mid = l+(r-l)/2;\\n        ans[level][mid] = to_string(p->val);\\n        helper(ans, p->left, level+1, l, mid-1);\\n        helper(ans, p->right, level+1, mid+1, r);\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"106269",
			"view":"637",
			"top":"3",
			"title":"Java Iterative Level Order Traversal with Queue",
			"vote":"3",
			"content":"It could be fairly easy when we made our first observation on the problem. For the output matrix, the number of rows is **height of the tree**. What about the number of columns?\\n\\n- `row = 1 => col = 1 = 2^1 - 1`\\n- `row = 2 => col = 3 = 2^2 - 1`\\n- `row = 3 => col = 7 = 2^3 - 1`\\n- `row = 4 => col = 15 = 2^4 - 1`\\n`...`\\n- `row = m => col = 2^m - 1`\\n\\nThis can be derived from the number of leaves of a full tree (i.e `2^(height - 1)`) with spaces joined (i.e `2^(height - 1) - 1`).\\n\\nThen we can fill the node in level by level. Another observation is **we always print a node at the center of its subtree index range**. What I mean is for the left or right child of a `node`, the subtree rooted at the child will use half of the indices of the `node`.\\n\\n- `root` is at the center of `left` and `right`, say `mid`\\n- `root.left` (if not null) is at the center of `left` and `mid - 1`\\n- `root.right` (if not null) is at the center of `mid + 1` and `right`\\n\\nThen we can easily have our solution as we always keep track of the `left` and `right` of the node.\\n\\n```\\npublic class Solution {\\n    public List<List<String>> printTree(TreeNode root) {\\n        List<List<String>> res = new ArrayList<>();\\n        if (root == null) {\\n            return res;\\n        }\\n        \\n        int rows = getHeight(root);\\n        int cols = (int)Math.pow(2, rows) - 1;\\n        for (int i = 0; i < rows; i++) {\\n            List<String> row = new ArrayList<>();\\n            for (int j = 0; j < cols; j++) {\\n                row.add(\"\");\\n            }\\n            res.add(row);\\n        }\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<int[]> indexQ = new LinkedList<>();\\n        queue.offer(root);\\n        indexQ.offer(new int[] { 0, cols - 1 });\\n        int row = -1;\\n        while (!queue.isEmpty()) {\\n            row++;\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode cur = queue.poll();\\n                int[] indices = indexQ.poll();\\n                \\n                if (cur == null) {\\n                    continue;\\n                }\\n                \\n                int left = indices[0];\\n                int right = indices[1];\\n                int mid = left + (right - left) / 2;\\n                res.get(row).set(mid, String.valueOf(cur.val));\\n                \\n                queue.offer(cur.left);\\n                queue.offer(cur.right);\\n                indexQ.offer(new int[] { left, mid - 1 });\\n                indexQ.offer(new int[] { mid + 1, right });\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int getHeight(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        return Math.max(getHeight(root.left), getHeight(root.right)) + 1;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"106274",
			"view":"712",
			"top":"4",
			"title":"Java solution, two times traversal",
			"vote":"2",
			"content":"First traversal measures height and width of final output. Second traversal record where should we put each node by using a HashMap.\\n```\\npublic class Solution {\\n    int height = 0, width = 0;\\n    Map<String, String> map = new HashMap<>();\\n    \\n    public List<List<String>> printTree(TreeNode root) {\\n        List<List<String>> res = new ArrayList<List<String>>();\\n        if (root == null) return res;\\n        \\n        measure(root, 0);\\n        mark(root, 0, 0, width - 1);\\n        \\n        for (int i = 0; i < height; i++) {\\n            List<String> row = new ArrayList<>();\\n            for (int j = 0; j < width; j++) {\\n                if (map.containsKey(i + \",\" + j)) {\\n                    row.add(map.get(i + \",\" + j));\\n                }\\n                else {\\n                    row.add(\"\");\\n                }\\n            }\\n            res.add(row);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int measure(TreeNode root, int h) {\\n        if (root == null) return 0;\\n        \\n        height = Math.max(height, h + 1);\\n        \\n        int w = Math.max(measure(root.left, h + 1), measure(root.right, h + 1)) * 2 + 1;\\n        width = Math.max(width, w);\\n        \\n        return w;\\n    }\\n    \\n    private void mark(TreeNode root, int y, int l, int r) {\\n        if (root == null) return;\\n        \\n        int x = (r + l) / 2;\\n        map.put(y + \",\" + x, root.val + \"\");\\n        \\n        mark(root.left, y + 1, l, x - 1);\\n        mark(root.right, y + 1, x + 1, r);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"106250",
			"view":"1111",
			"top":"5",
			"title":"Python Straight Forward Solution",
			"vote":"2",
			"content":"`````\\ndef printTree(self, root):\\n        if not root: return [\"\"]\\n\\n        def depth(root):\\n            if not root: return 0\\n            return max(depth(root.left), depth(root.right)) + 1\\n\\n        d = depth(root)\\n        self.res = [[\"\"] * (2**d - 1) for _ in xrange(d)]\\n\\n        def helper(node, d, pos):\\n            self.res[-d - 1][pos] = str(node.val)\\n            if node.left: helper(node.left, d - 1, pos - 2**(d - 1))\\n            if node.right: helper(node.right, d - 1, pos + 2**(d - 1))\\n\\n        helper(root, d - 1, 2**(d - 1) - 1)\\n        return self.res"
		},
		{
			"lc_ans_id":"106240",
			"view":"96",
			"top":"6",
			"title":"Python recursive solution, easy to understand",
			"vote":"1",
			"content":"```\\nclass Solution(object):\\n    def printTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        def get_height(node):\\n            return 0 if not node else 1 + max(get_height(node.left), get_height(node.right))\\n        \\n        def update_output(node, row, left, right):\\n            if not node:\\n                return\\n            mid = (left + right) / 2\\n            self.output[row][mid] = str(node.val)\\n            update_output(node.left, row + 1 , left, mid - 1)\\n            update_output(node.right, row + 1 , mid + 1, right)\\n            \\n        height = get_height(root)\\n        width = 2 ** height - 1\\n        self.output = [[''] * width for i in xrange(height)]\\n        update_output(node=root, row=0, left=0, right=width - 1)\\n        return self.output\\n```"
		},
		{
			"lc_ans_id":"106267",
			"view":"125",
			"top":"7",
			"title":"Simple Java solution (Easy for sure)",
			"vote":"1",
			"content":"```\\n   \\n   public List<List<String>> printTree(TreeNode root) {\\n        int height = height(root);\\n        int wide = wide(root);\\n        List<List<String>> result = new ArrayList<>();\\n        for (int i = 0; i < height; i++) {\\n            List<String> list = new ArrayList<>();\\n            for (int j = 0; j < wide; j++) {\\n                list.add(\"\");\\n            }\\n            result.add(list);\\n        }\\n        print(result, root, 0, 0, wide - 1);\\n        return result;\\n    }\\n\\n    private void print(List<List<String>> result, TreeNode root, int row, int left, int right) {\\n        if (root == null) return;\\n        int center = (left + right) / 2;\\n        result.get(row).set(center, String.valueOf(root.val));\\n        print(result, root.left, row + 1, left,center);\\n        print(result, root.right, row + 1, center + 1, right);\\n    }\\n\\n    private int height(TreeNode node) {\\n        if (node == null) return 0;\\n        return 1 + Math.max(height(node.left), height(node.right));\\n    }\\n\\n    private int wide(TreeNode node) {\\n        if (node == null) return 0;\\n        return 1 + 2 * Math.max(wide(node.left), wide(node.right));\\n    }\\n\\n``"
		},
		{
			"lc_ans_id":"106270",
			"view":"273",
			"top":"8",
			"title":"C++ 8 lines O(n)",
			"vote":"1",
			"content":"The width of the tree is 2 ^ n - 1, where n is the depth. Here I need to traverse the tree twice - one to get the depth, another - to populate the array. I am wondering if we can solve it with just one pass...\\n```\\nint depth(TreeNode* r, int d) { return r == nullptr ? d : max(depth(r->left, d + 1), depth(r->right, d + 1)); }    \\nvoid printTree(TreeNode* r, int st, int end, int d, vector<vector<string>>& v) {\\n    v[d][st + (end - st) / 2] = to_string(r->val);\\n    if (r->left != nullptr) printTree(r->left, st, st + (end - st) / 2, d + 1, v);\\n    if (r->right != nullptr) printTree(r->right, st + (end - st) / 2 + 1, end, d + 1, v);\\n}\\nvector<vector<string>> printTree(TreeNode* root) {\\n    auto d = depth(root, 0);\\n    vector<vector<string>> v(d, vector<string>((1 << d) - 1, \"\"));\\n    printTree(root, 0, v[0].size() - 1, 0, v);\\n    return v;\\n}\\n```"
		},
		{
			"lc_ans_id":"106247",
			"view":"189",
			"top":"9",
			"title":"Java BFS Solution",
			"vote":"1",
			"content":"```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public List<List<String>> printTree(TreeNode root) {\\n        List<List<String>> res = new ArrayList<>();\\n        if(root==null) {\\n            return res;\\n        }\\n        \\n        int depth = maxDepth(root);\\n        System.out.println(depth);\\n        \\n        Queue<TreeNode> nodeQ = new LinkedList<>();\\n        nodeQ.offer(root);\\n        Queue<Integer> levelQ = new LinkedList<>();\\n        levelQ.offer(0);\\n        List<String> t = new ArrayList<>();\\n        t.add(String.valueOf(root.val));\\n        res.add(t);\\n        int lev = 0;\\n        \\n        \\n        while(!nodeQ.isEmpty()) {\\n            System.out.println(res);\\n            int size = nodeQ.size();\\n            int pos = 0;\\n            System.out.println(\"size: \"+size);\\n            if(lev+1 != depth) {\\n                List<String> temp = new ArrayList<>();\\n                for(int i=0; i<res.get(lev).size(); i++) {\\n                    temp.add(\"\");\\n                }\\n                res.add(temp);\\n            }\\n            for(int i=0;i<size;i++) {\\n                int level = levelQ.poll();\\n                TreeNode node = nodeQ.poll();\\n                lev = level+1;\\n                \\n                if(node==null) {\\n                    if(lev != depth) {\\n                        nodeQ.offer(null);\\n                        levelQ.offer(lev);\\n                        for(int j=0;j<res.size();j++) {\\n                            res.get(j).add(pos, \"\");\\n                        }\\n                        pos += 2;\\n                        nodeQ.offer(null);\\n                        levelQ.offer(lev);\\n                        for(int j=0;j<res.size();j++) {\\n                            res.get(j).add(pos, \"\");\\n                        }\\n                        pos += 2;\\n                    }\\n                    continue;\\n                }\\n                \\n                if(node.left!=null && lev!=depth) {\\n                    nodeQ.offer(node.left);\\n                    levelQ.offer(lev);\\n                    \\n                    for(int j=0;j<res.size();j++) {\\n                        if(j==lev) {\\n                            res.get(j).add(pos, String.valueOf(node.left.val));\\n                        }\\n                        else {\\n                            res.get(j).add(pos, \"\");\\n                        }\\n                    }\\n                    pos += 2;\\n                }\\n                \\n                if(node.left==null && lev!=depth) {\\n                    nodeQ.offer(node.left);\\n                    levelQ.offer(lev);\\n                    for(int j=0;j<res.size();j++) {\\n                        res.get(j).add(pos, \"\");\\n                    }\\n                    pos += 2;\\n                }\\n                \\n                if(node.right!=null && lev!=depth) {\\n                    nodeQ.offer(node.right);\\n                    levelQ.offer(level + 1);\\n                    \\n                    for(int j=0;j<res.size();j++) {\\n                        if(j==level+1) {\\n                            res.get(j).add(pos, String.valueOf(node.right.val));\\n                        }\\n                        else {\\n                            res.get(j).add(pos, \"\");\\n                        }\\n                    }\\n                    pos += 2;\\n                }\\n                \\n                if(node.right==null && lev!=depth) {\\n                    nodeQ.offer(node.right);\\n                    levelQ.offer(lev);\\n                    for(int j=0;j<res.size();j++) {\\n                        res.get(j).add(pos, \"\");\\n                    }\\n                    pos += 2;\\n                }\\n            }\\n            System.out.println(res);\\n        }\\n        return res;\\n    }\\n    \\n    private int maxDepth(TreeNode root) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        \\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\\n    }\\n}\\n```"
		}
	],
	"id":"632",
	"title":"Print Binary Tree",
	"content":"<p>Print a binary tree in an m*n 2D string array following these rules: </p>\r\n\r\n<ol>\r\n<li>The row number <code>m</code> should be equal to the height of the given binary tree.</li>\r\n<li>The column number <code>n</code> should always be an odd number.</li>\r\n<li>The root node's value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (<b>left-bottom part and right-bottom part</b>). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don't need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don't need to leave space for both of them. </li>\r\n<li>Each unused space should contain an empty string <code>\"\"</code>.</li>\r\n<li>Print the subtrees following the same rules.</li>\r\n</ol>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n     1\r\n    /\r\n   2\r\n<b>Output:</b>\r\n[[\"\", \"1\", \"\"],\r\n [\"2\", \"\", \"\"]]\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n     1\r\n    / \\\r\n   2   3\r\n    \\\r\n     4\r\n<b>Output:</b>\r\n[[\"\", \"\", \"\", \"1\", \"\", \"\", \"\"],\r\n [\"\", \"2\", \"\", \"\", \"\", \"3\", \"\"],\r\n [\"\", \"\", \"4\", \"\", \"\", \"\", \"\"]]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\n      1\r\n     / \\\r\n    2   5\r\n   / \r\n  3 \r\n / \r\n4 \r\n<b>Output:</b>\r\n\r\n[[\"\",  \"\",  \"\", \"\",  \"\", \"\", \"\", \"1\", \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]\r\n [\"\",  \"\",  \"\", \"2\", \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"5\", \"\", \"\", \"\"]\r\n [\"\",  \"3\", \"\", \"\",  \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]\r\n [\"4\", \"\",  \"\", \"\",  \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]]\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe height of binary tree is in the range of [1, 10].\r\n</p>",
	"frequency":"233",
	"ac_num":"7270"
}