{
	"difficulty":"3",
	"submit_num":"13363",
	"show_id":"656",
	"leetcode_id":"656",
	"answers":[
		{
			"lc_ans_id":"106291",
			"view":"1892",
			"top":"0",
			"title":"Java 22 lines solution with proof",
			"vote":"18",
			"content":"The following solution is based on that:\\n\\n**If there are two path to reach `n`, and they have the same optimal cost, then the longer path is lexicographically smaller**.\\n\\n**Proof by contradiction**:\\nAssume path `P` and `Q` have the same cost, and `P` is strictly shorter and `P` is lexicographically smaller. \\nSince `P` is lexicographically smaller, `P` and `Q` must start to differ at some point.\\nIn other words, there must be `i` in `P` and `j` in `Q` such that `i < j` and `len([1...i]) == len([1...j])`\\n`P = [1...i...n]`\\n`Q = [1...j...n]`\\nSince `i` is further away from `n` there need to be no less steps taken to jump from `i` to `n` **unless `j` to `n` is not optimal**\\nSo `len([i...n]) >= len([j...n])`\\nSo `len(P) >= len(Q)` which contradicts the assumption that `P` is strictly shorter.\\n\\nFor example:\\nInput: `[1, 4, 2, 2, 0], 2`\\nPath `P = [1, 2, 5]`\\nPath `Q = [1, 3, 4, 5]`\\nThey both have the same cost `4` to reach `n`\\nThey differ at `i = 2` in `P` and `j = 3` in `Q`\\nHere `Q` is longer but not lexicographically smaller.\\nWhy? Because `j = 3` to `n = 5` is not optimal.\\nThe optimal path should be `[1, 3, 5]` where the cost is only `2`\\n\\n```\\n    public List<Integer> cheapestJump(int[] A, int B) {\\n        int n = A.length;\\n        int[] c = new int[n]; // cost\\n        int[] p = new int[n]; // previous index\\n        int[] l = new int[n]; // length\\n        Arrays.fill(c, Integer.MAX_VALUE);\\n        Arrays.fill(p, -1);\\n        c[0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (A[i] == -1) continue;\\n            for (int j = Math.max(0, i - B); j < i; j++) {\\n                if (A[j] == -1) continue;\\n                int alt = c[j] + A[i];\\n                if (alt < c[i] || alt == c[i] && l[i] < l[j] + 1) {\\n                    c[i] = alt;\\n                    p[i] = j;\\n                    l[i] = l[j] + 1;\\n                }\\n            }\\n        }\\n        List<Integer> path = new ArrayList<>();\\n        for (int cur = n - 1; cur >= 0; cur = p[cur]) path.add(0, cur + 1);\\n        return path.get(0) != 1 ? Collections.emptyList() : path;\\n    }\\n```"
		},
		{
			"lc_ans_id":"106295",
			"view":"1852",
			"top":"1",
			"title":"C++, DP, O(nB) time O(n) space",
			"vote":"13",
			"content":"This is a classic DP problem. dp[k] (starting from k = 0) is the minimum coins from A*k+1* to A*n*, and pos[k] is the next place to jump from A*k+1*.\\n\\nIf working backward from dp[n-1] to dp[0], and considering smaller index first, i.e. i+1 to i+B, there is no need to worry about lexicographical order. I argue pos[k] always holds the lexicographically smallest path from k to n-1, i.e. from A*k+1* to A*n*. The prove is as below. \\n\\nClearly, when k = n-1, it is true because there is only 1 possible path, which is [n]. When k = i and i < n-1, we search for an index j, which has smallest cost or smallest j if the same cost. If there are >= 2 paths having the same minimum cost, for example,\\nP = [k+1, j+1, ..., n]\\nQ = [k+1, m+1, ..., n] (m > j)\\nThe path P with smaller index j is always the lexicographically smaller path. \\nSo the argument is true by induction.    \\n```\\nclass Solution {\\npublic:\\n    vector<int> cheapestJump(vector<int>& A, int B) {\\n        vector<int> ans;\\n        if (A.empty() || A.back() == -1) return ans;\\n        int n = A.size();\\n        vector<int> dp(n, INT_MAX), pos(n, -1);\\n        dp[n-1] = A[n-1];\\n        // working backward\\n        for (int i = n-2; i >= 0; i--) {\\n            if (A[i] == -1) continue;\\n            for (int j = i+1; j <= min(i+B, n-1); j++) {\\n                if (dp[j] == INT_MAX) continue;\\n                if (A[i]+dp[j] < dp[i]) {\\n                    dp[i] = A[i]+dp[j];\\n                    pos[i] = j;\\n                }\\n            }\\n        }\\n        // cannot jump to An\\n        if (dp[0] == INT_MAX) return ans;\\n        int k = 0;\\n        while (k != -1) {\\n            ans.push_back(k+1);\\n            k = pos[k];\\n        }\\n        return ans;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"106312",
			"view":"622",
			"top":"2",
			"title":"Java O(n^2) Time O(n) Space DP Solution",
			"vote":"2",
			"content":"```\\npublic List<Integer> cheapestJump(int[] A, int B) {\\n\\n    int n = A.length;\\n    int[] dp = new int[n], decisions = new int[n];\\n    dp[n-1] = A[n-1];\\n    decisions[n-1] = A[n-1] == -1 ? -2 : -1;\\n    for (int i=n-2;i>=0;i--) {            \\n        int minHopValue = Integer.MAX_VALUE, minHopIndex = -2;\\n        for (int j=i+1;j<Math.min(n, i+B+1);j++) {\\n            if (dp[j] < minHopValue && decisions[j] != -2) {\\n                minHopValue = dp[j];\\n                minHopIndex = j;\\n            }\\n        }\\n        dp[i] = A[i] + minHopValue;\\n        decisions[i] = A[i] == -1 ? -2 : minHopIndex;\\n    }\\n\\n    // Construct Path\\n    List<Integer> res = new LinkedList<>();\\n    if (decisions[0] == -2) return res;\\n    int k = 0;\\n    while (k != -1) {\\n        res.add(k+1);\\n        k = decisions[k];\\n    } \\n\\n    return res;\\n\\n}\\n```"
		},
		{
			"lc_ans_id":"106289",
			"view":"74",
			"top":"3",
			"title":"Always pay attention to \"lexicographically smaller\"",
			"vote":"1",
			"content":"Given input [0,0,0,0,0,0] 3, the expected output is [1,2,3,4,5,6], not [1, 3, 6] although the latter is shorter. \\nYou can use this as example to decide how to do DP. \\n\\nMy first attempt was like this: define DP[i] to be smallest cost to reach index i. In DFS in each index i, we examine (do DFS) for all the B indexes before him, from the smallest index to biggest index. Apparently this will lead to the latter output as above. This is because, when we iterate the B possible choices, the first 1 always has higher priority, and it is used as the prev element in the path for current index. \\n\\nThink it in another way. Suppose we are at index 1 and can reach index 2 and 3, If both index 2 and 3 can reach the last index with same cost, then we use 2 instead of 3. So, we need to first calculate the cost from 2 to end and the cost from 3 to end. This suggests we do DP/DFS in another direction. Or, we may use https://discuss.leetcode.com/topic/98399/c-dp-o-nb-time-o-n-space to actually move from right to left. \\n\\n```\\nvoid DFS(vector<int> &A, vector<int> &DP, vector<int> &next, int B, int index){\\n        //want to populate DP[index], the minimum u need to pay to get from index to end.\\n        if(DP[index] != INT_MAX || A[index] == -1) //already visited or can never reach it. \\n            return;\\n        for(int i=index+1; i<=min((int)(index+B), (int)(A.size()-1)); i++){\\n            DFS(A, DP, next, B, i);\\n            if(DP[i] != INT_MAX && DP[i] + A[index] < DP[index]){\\n                DP[index] = DP[i] + A[index];\\n                next[index] = i;\\n            }\\n        }\\n    }\\n    vector<int> cheapestJump(vector<int>& A, int B) {\\n        vector<int> retV;\\n        int n=A.size();\\n        if(A[n-1] == -1)\\n            return retV;\\n        \\n        vector<int> next(n, INT_MAX);\\n        vector<int> DP(n, INT_MAX);\\n\\n        DP[n-1] = A[n-1];\\n        next[n-1] = -1;\\n        DFS(A, DP, next, B, 0);\\n        \\n        if(DP[0] == INT_MAX)\\n            return retV;\\n        int cur = 0;\\n        while(cur != -1){\\n            retV.push_back(cur+1);\\n            cur = next[cur];\\n        }\\n        return retV;\\n    }\\n```"
		},
		{
			"lc_ans_id":"106300",
			"view":"145",
			"top":"4",
			"title":"C++ O(n) time",
			"vote":"1",
			"content":"\\nBasic idea is to use a window (implemented with <code>deque</code>) to maintain the candidate points of next jump\\n\\nEach points will be only pushed into deque for once and there is no comparison in determine next stop.\\n\\nHowever, I hate people when they say \"lexicographically\". This evil word ruin my morning.\\n\\n<code>\\n\\nstatic const int MAXN = 1010;\\n\\nclass Solution {   \\n    \\npublic:\\n    vector<int> cheapestJump(vector<int>& A, int B) {\\n        \\n        int next_stop[MAXN];\\n        int payment[MAXN];\\n        \\n        \\n        int i = A.size() - 1;\\n        deque <int> dq;\\n        next_stop[i] = 0;\\n        payment[i] = A[i];\\n        //int start = 0;\\n        \\n        vector <int > ret;\\n        if (A[i] == -1){return ret;}\\n        \\n        dq.push_back(i);\\n        while(i >= 0){\\n            \\n            if( A[i] != -1 ){\\n                while (!dq.empty() && dq.back() > i + B ){\\n                    dq.pop_back();\\n                }\\n                \\n                if (!dq.empty()){\\n                    next_stop[i] = dq.back();\\n                    payment[i] = payment[next_stop[i]] + A[i];\\n                    \\n                    if (A[i] == 0 ){\\n                        dq.clear(); // dump all\\n                    }\\n                    \\n                    while (!dq.empty() && \\n                           payment[i] <= payment[dq.front()] \\n                            ){\\n                        dq.pop_front();   \\n                    }\\n                    dq.push_front(i);\\n                    \\n                }else{\\n                    return ret;\\n                }\\n            }\\n            i--;\\n        }\\n        \\n        i = 0;\\n        while(i != A.size() - 1){\\n            ret.push_back(i + 1);\\n            i = next_stop[i];\\n        }\\n        ret.push_back(A.size() );\\n        return ret;\\n    }\\n};\\n</code>"
		},
		{
			"lc_ans_id":"106287",
			"view":"647",
			"top":"5",
			"title":"Python Straight Forward Solution",
			"vote":"1",
			"content":"I used DP. dp[i] represent the best path found to get to the place indexed ````i + 1```` and ````dp[i][0]```` is the cost of the path.\\n````dp[0]```` is initialized as ````[A[0], 1]```` and the others are initialized as ````[infinity]````.\\n````\\ndef cheapestJump(self, A, B):\\n        if not A or A[0] == -1: return []\\n        dp = [[float('inf')] for _ in A]\\n        dp[0] = [A[0], 1]\\n        for j in range(1, len(A)):\\n            if A[j] == -1: continue\\n            dp[j] = min([dp[i][0] + A[j]] + dp[i][1:] + [j + 1] for i in range(max(0, j - B), j))\\n        return dp[-1][1:] if dp[-1][0] < float('inf') else []"
		},
		{
			"lc_ans_id":"106284",
			"view":"13",
			"top":"6",
			"title":"Forward DP, O(nB), with a (hopefully correct) proof. Implementation in C++.",
			"vote":"0",
			"content":"When writing down the suboptimal structure, one must understand the cost is not the only discriminator: \\n> If there are multiple paths with the same cost, return the lexicographically smallest such path.\\n> Path Pa1, Pa2, ..., Pan is lexicographically smaller than Pb1, Pb2, ..., Pbm, if and only if at the first i where Pai and Pbi differ, Pai < Pbi; when no such i exists, then n < m.\\n\\nLet dp[i] represent the solution to position i with the lexicographically smallest solution.\\nLet prev[i] be the previous hop before i in the optimal solution dp[i];\\nLet [i, j] denote the subproblem of subarray from i to j(inclusive), and i -> j denote an optimal solution.\\nThis requires that, if dp[j] and dp[k] has the same cost when computing dp[i], one must pick between j and k as prev[i] to achieve a lexicographically smaller solution for dp[i].\\nThe trick is, if there are two path from k -> n having the same optimal cost, the longer one must be lexicographically smaller.\\n\\nRational: \\nTheorem: if i < j, then len(i -> n) >= len(j -> n)\\nLemma 1:\\nIf there is a node 0 in the path which is neither the start/end. The node must be in the optimal path.\\nLemma 2:\\nGiven a starting point and an end point, the optimal path of the subproblem is unique.\\nLemma 3:\\nIf l->j is an optimal path, j -> k is an optimal path, then l->j->k is the optimal path (DP).\\n\\nTo prove by contradiction, we assume len(i -> n) < len(j -> n). \\n\\nBy Lemma 1 and 2, we can assume all the nodes are either strictly greater than 0 or all 0.\\n\\nIf all nodes are all 0, the contradiction is trivial.\\n\\nOtherwise, assume i -> n is of the form:\\n(A greek letter is a subpath with cost >= 0 (0 means the subpath is empty)).\\n            i -> alpha -> beta; \\nwhere beta is the subpath in the range [j, n]. This set is not empty because we have n.\\n\\nj -> n is of the form:\\n              j -> gamma;\\n\\nNow, as len(i->n) < len(j -> n), we conclude:\\ncost(alpha) + cost(beta) <= cost(gamma) ******* (1)\\n\\nConsider another valid path j -> beta as a non-optimal solution j -> n\\n(this path is valid becase i < j, and there exists a node before j in subpath i -> alpha, and such node can reach the first node in beta implies j can also reach the first node in beta).\\nwe have cost(j) + cost(beta) >= cost(j) + cost(gamma) \\n                => cost(gamma) <= cost(beta) ******** (2)\\n\\n(1) and (2) implies alpha is empty, and cost(beta) = cost(gamma).\\n\\nAs gamma and beta are non-empty. Let l be the first node in beta, k be the first node in gamma.\\nWe have arrived at one of the three contradictions:\\n1) if l < k, then we found a lexicographically smaller solution j -> beta n for [j, n]\\n2) if l > k, then we found a lexicographically smaller solution i -> alpha -> gamma for [i, n]\\n3) if l = k, then len(i -> n) = len(j -> n) as len(alpha) = 0 and Lemma 2.\\n\\nTherefore, if you have two path leads to n with the same smallest cost, pick the longer one.\\nBecause to see a contradiction, let i and j be the first nodes the two paths differ and path with i is lexicographically smaller, and path with i is shorter. \\nSince i -> n is an optimal of [i, n], j -> n is an optimal of [j, n]. Now, as assuming path with i is shorter, then len(i -> n) < len(j -> n) (path with i is shorter) and i < j(path with i lexicographically smaller). Contradiction to the above theorem.  \\n\\nThis completes the proof.\\n\\nImplementation:\\n```\\nclass Solution {\\npublic:\\n    vector<int> cheapestJump(const vector<int>& A, int B) {\\n        int maxInt = numeric_limits<int>::max();\\n        vector<int> dp(A.size(), -1);\\n        vector<int> prev(A.size(), -1);\\n        vector<int> pathLength(A.size(), 0);\\n\\n        if(A.empty()) {\\n          return {};\\n        }\\n\\n        dp[0] = A[0];\\n        pathLength[0] = 1;\\n        for(int i = 1; i < A.size(); ++i) {\\n          if(A[i] == -1) continue;\\n          int cur = maxInt;\\n\\n          for (int j = max(0, i - B); j < i; ++j) {\\n              if(dp[j] == -1) {continue;}\\n              if (dp[j] < cur) {\\n                cur = dp[j];\\n                prev[i] = j;\\n                pathLength[i] = pathLength[j] + 1;\\n                continue;\\n              }\\n\\n              if (dp[j] == cur && (pathLength[i] < pathLength[j] + 1)) {\\n                prev[i] = j;\\n                pathLength[i] = pathLength[j] + 1;\\n                continue;\\n              }\\n          }\\n          if (cur != maxInt) {\\n            dp[i] = cur + A[i];\\n          }\\n        }\\n        if (prev[A.size() - 1] != -1) {\\n          vector<int> ret;\\n          for (int i = A.size() - 1; i >= 0; i = prev[i]) {\\n            ret.push_back(i + 1);\\n          }\\n          reverse(ret.begin(), ret.end());\\n          return ret;\\n        }\\n        return {};\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"106285",
			"view":"17",
			"top":"7",
			"title":"Top down with memoization",
			"vote":"0",
			"content":"```\\nclass Solution {\\npublic:\\n    \\n    vector<int> A, path;\\n    int dp[1001] = {0};\\n    \\n    int n, b;\\n    \\n    int go(int pos)\\n    {\\n        int &best_cost = dp[pos];\\n        \\n        if (best_cost)\\n            return best_cost;\\n        \\n        if (pos == n - 1 && A[n - 1] != -1)\\n            return A[n - 1];\\n        \\n        best_cost = 1e9;\\n        for (int new_pos = pos + 1; new_pos <= pos + b && new_pos < n; new_pos++)\\n        {\\n            if (A[new_pos] == -1)\\n                continue;\\n            \\n            int curr_cost = A[pos] + go(new_pos);\\n            if (curr_cost < best_cost)\\n            {\\n                path[pos] = new_pos;\\n                best_cost = curr_cost;\\n            }\\n        }\\n        \\n        return best_cost;\\n    }\\n    \\n    vector<int> cheapestJump(vector<int>& A, int B) \\n    {\\n        \\n        this->n = A.size();\\n        this->b = B;\\n        this->A = A;\\n        \\n        path.assign(n, -1);\\n        vector<int> ans;\\n        \\n        if (go(0) == 1e9)\\n            return ans;\\n        \\n        for (int i = 0; i < n && i != -1; i = path[i])\\n            ans.push_back(i + 1);\\n        \\n        return ans;\\n    }\\n};\\n\\n```"
		},
		{
			"lc_ans_id":"106286",
			"view":"18",
			"top":"8",
			"title":"O(n) sliding window solution using a queue that supports getMin() in O(1)",
			"vote":"0",
			"content":"```\\n// Problem statement:\\n// https://leetcode.com/problems/coin-path/description/\\n\\nconst int oo = INT_MAX / 2; // half to avoid overflow.\\n\\n// This is a normal queue extended to allow querying for the minimum element inside it in O(1) time.\\ntemplate <class T>\\nstruct MinQueue {\\n    deque<pair<T, int>> data;\\n    int in, out;\\n    MinQueue() : in(0), out(0) {};\\n\\n    // Amortized O(1) because each element is pushed and popped from the queue exactly once.\\n    void push(const T& t) {\\n        pair<T, int> next = make_pair(t, in++);\\n        while (data.size() > 0 and next < data.front()) {\\n            data.pop_front();\\n        }\\n        data.push_front(next);\\n    }\\n\\n    // O(1)\\n    void pop() {\\n        if (data.back().second == out++) {\\n            data.pop_back();\\n        }\\n    }\\n\\n    // O(1)\\n    T min() {\\n        return data.back().first;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> cheapestJump(vector<int>& a, int b) {\\n        int n = a.size();\\n        assert(n > 0);\\n        // Degenerate case.\\n        if (n == 1) {\\n            return a[0] == -1 ? ans : vector<int>({1});\\n        }\\n        // Replace -1's with infinity just to simplify the logic below.\\n        for (int i = 0; i < n; ++i) {\\n            if (a[i] == -1) {\\n                a[i] = oo;\\n            }\\n        }\\n\\n        vector<int> next(n, -1); // To reconstruct the actual path.\\n        MinQueue<pair<int, int>> q;\\n        q.push(make_pair(a[n - 1], n - 1));\\n        for (int i = n - 2; i >= 0; --i) {\\n            // Invariant: at the start of the loop, the queue contains all elements in range\\n            // [i + 1, i + b].\\n            pair<int, int> best = q.min();\\n            int w = min(best.first + a[i], oo);\\n            if (w < oo) {\\n                next[i] = best.second;\\n            }\\n\\n            // Update queue so invariant is true for next iteration.\\n            q.push(make_pair(w, i));\\n            if (i + b < n) {\\n                q.pop();\\n            }\\n        }\\n        vector<int> ans;\\n        for (int at = 0; at != -1; at = next[at]) {\\n            ans.push_back(at + 1);\\n        }\\n        if (ans.back() == n) {\\n            return ans;\\n        }\\n        return {};\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"106288",
			"view":"44",
			"top":"9",
			"title":"Python O(n) Time & O(n) Space - Beat 100%",
			"vote":"0",
			"content":"The key to get O(n) time complexity other than O(nB) is to find the next jump with a O(1) operation.\\n```python\\n    def cheapestJump(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if A[-1] == -1: return []\\n        dp = [None] * len(A)\\n        dp[-1] = (A[-1], len(A))\\n        window = collections.deque()\\n        window.append((A[-1], len(A)-1))\\n        i = len(A) - 2\\n        while i >= 0:\\n            if not window: break\\n            if A[i] != -1:\\n                cost = A[i] + window[-1][0]\\n                to = window[-1][1]\\n                dp[i] = (cost, to)\\n                while window and window[0][0] >= cost:\\n                    window.popleft()\\n                window.appendleft((cost, i))\\n            if i + B == window[-1][1]:\\n                window.pop()\\n            i -= 1\\n        if not dp[0]:\\n            return []\\n        i = 0\\n        result = []\\n        while i != len(A):\\n            result.append(i + 1)\\n            i = dp[i][1]\\n        return result\\n```"
		}
	],
	"id":"633",
	"title":"Coin Path",
	"content":"<p>\nGiven an array <code>A</code> (index starts at <code>1</code>) consisting of N integers: A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub> and an integer <code>B</code>. The integer <code>B</code> denotes that from any place (suppose the index is <code>i</code>) in the array <code>A</code>, you can jump to any one of the place in the array <code>A</code> indexed <code>i+1</code>, <code>i+2</code>, …, <code>i+B</code> if this place can be jumped to. Also, if you step on the index <code>i</code>, you have to pay A<sub>i</sub> coins. If A<sub>i</sub> is -1, it means you can’t jump to the place indexed <code>i</code> in the array.\n</p>\n\n<p>\nNow, you start from the place indexed <code>1</code> in the array <code>A</code>, and your aim is to reach the place indexed <code>N</code> using the minimum coins. You need to return the path of indexes (starting from 1 to N) in the array you should take to get to the place indexed <code>N</code> using minimum coins.\n</p>\n\n<p>\nIf there are multiple paths with the same cost, return the lexicographically smallest such path.\n</p>\n<p>\nIf it's not possible to reach the place indexed N then you need to return an empty array.\n</p>\n\n<p><b>Example 1:</b><br />\n<pre>\n<b>Input:</b> [1,2,4,-1,2], 2\n<b>Output:</b> [1,3,5]\n</pre>\n</p>\n\n<p><b>Example 2:</b><br />\n<pre>\n<b>Input:</b> [1,2,4,-1,2], 1\n<b>Output:</b> []\n</pre>\n</p>\n\n<p><b>Note:</b><br>\n<ol>\n<li>Path Pa<sub>1</sub>, Pa<sub>2</sub>, ..., Pa<sub>n</sub> is lexicographically smaller than Pb<sub>1</sub>, Pb<sub>2</sub>, ..., Pb<sub>m</sub>, if and only if at the first <code>i</code> where Pa<sub>i</sub> and Pb<sub>i</sub> differ, Pa<sub>i</sub> < Pb<sub>i</sub>; when no such <code>i</code> exists, then <code>n</code> < <code>m</code>.</li>\n<li>A<sub>1</sub> >= 0. A<sub>2</sub>, ..., A<sub>N</sub> (if exist) will in the range of [-1, 100]. </li>\n<li>Length of A is in the range of [1, 1000].</li>\n<li>B is in the range of [1, 100].</li>\n</ol>\n</p>",
	"frequency":"4",
	"ac_num":"3436"
}