{
	"difficulty":"2",
	"submit_num":"27451",
	"show_id":"662",
	"leetcode_id":"662",
	"answers":[
		{
			"lc_ans_id":"106654",
			"view":"8390",
			"top":"0",
			"title":"[Java/C++] Very simple dfs solution",
			"vote":"31",
			"content":"We know that  a binary tree can be represented by an array  (assume the root begins from the position with  index ```1``` in the array). If the index of a node is ```i```, the indices of its two children are ```2*i ``` and ```2*i + 1```. The idea is to use two arrays (```start[]``` and ```end[]```) to record the the indices of the leftmost node and rightmost node in each level, respectively. For each level of the tree, the width is  ```end[level] - start[level] + 1```. Then, we just need to find the maximum width.\\n\\nJava version:\\n```\\n    public int widthOfBinaryTree(TreeNode root) {\\n        return dfs(root, 0, 1, new ArrayList<Integer>(), new ArrayList<Integer>());\\n    }\\n    \\n    public int dfs(TreeNode root, int level, int order, List<Integer> start, List<Integer> end){\\n        if(root == null)return 0;\\n        if(start.size() == level){\\n            start.add(order); end.add(order);\\n        }\\n        else end.set(level, order);\\n        int cur = end.get(level) - start.get(level) + 1;\\n        int left = dfs(root.left, level + 1, 2*order, start, end);\\n        int right = dfs(root.right, level + 1, 2*order + 1, start, end);\\n        return Math.max(cur, Math.max(left, right));\\n    }\\n```\\n\\nC++ version (use ```vector<pair<int,int>>``` to replace the arrays ```start``` and ```end``` in Java ):\\n```\\n   int widthOfBinaryTree(TreeNode* root) {\\n        return dfs(root, 0, 1, vector<pair<int, int>>() = {});\\n    }\\n    \\n    int dfs(TreeNode* root, int level, int order, vector<pair<int, int>>& vec){\\n        if(root == NULL)return 0;\\n        if(vec.size() == level)vec.push_back({order, order});\\n        else vec[level].second = order;\\n        return max({vec[level].second - vec[level].first + 1, dfs(root->left, level + 1, 2*order, vec), dfs(root->right, level + 1, 2*order + 1, vec)});\\n    }\\n```"
		},
		{
			"lc_ans_id":"106645",
			"view":"4295",
			"top":"1",
			"title":"[C++/Java] * [BFS/DFS/3liner] Clean Code  With Explanation",
			"vote":"20",
			"content":"The idea is to use heap indexing:\\n```\\n        1\\n   2         3\\n 4   5     6   7\\n8 9 x 11  x 13 x 15\\n```\\nRegardless whether these nodes exist:\\n- Always make the id of left child as `parent_id * 2`;\\n- Always make the id of right child as `parent_id * 2 + 1`;\\n\\nSo we can just:\\n1. Record the `id` of `left most node` when first time at each level of the tree during an pre-order run.(you can tell by check the size of the container to hold the first nodes);\\n2. At each node, compare the `distance` from it the left most node with the current `max width`;\\n\\n**DFS - Return Value**\\nC++\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        vector<int> lefts; // left most nodes at each level;\\n        return dfs(root, 1, 0, lefts);\\n    }\\nprivate:\\n    int dfs(TreeNode* n, int id, int d, vector<int>& lefts) { // d : depth\\n        if (!n) return 0;\\n        if (d >= lefts.size()) lefts.push_back(id);  // add left most node\\n        return max({id + 1 - lefts[d], dfs(n->left, id * 2, d + 1, lefts), dfs(n->right, id * 2 + 1, d + 1, lefts)});\\n    }\\n};\\n```\\n3 liner\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        unordered_map<int, vector<int>> m;\\n        function<int(TreeNode*, int, int)> dfs = [&](TreeNode* n, int id, int d){ return n ? m[d].push_back(id), max({id+1-m[d][0], dfs(n->left, id*2, d+1), dfs(n->right, id*2+1, d+1)}) : 0; };\\n        return dfs(root, 1, 0);\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        List<Integer> lefts = new ArrayList<Integer>(); // left most nodes at each level;\\n        return dfs(root, 1, 0, lefts);\\n    }\\n\\n    private int dfs(TreeNode n, int id, int d, List<Integer> lefts) { // d : depth\\n        if (n == null) return 0;\\n        if (d >= lefts.size()) lefts.add(id);   // add left most node\\n        return Math.max(id + 1 - lefts.get(d), Math.max(dfs(n.left, id*2, d+1, lefts), dfs(n.right, id*2+1, d+1, lefts)));\\n    }\\n}\\n```\\n**DFS - Side Effect**\\nC++\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        vector<int> lefts; // left most nodes at each level;\\n        int maxwidth = 0;\\n        dfs(root, 1, 0, lefts, maxwidth);\\n        return maxwidth;\\n    }\\nprivate:\\n    void dfs(TreeNode* node, int id, int depth, vector<int>& lefts, int& maxwidth) {\\n        if (!node) return;\\n        if (depth >= lefts.size()) lefts.push_back(id);  // add left most node\\n        maxwidth = max(maxwidth, id + 1 - lefts[depth]);\\n        dfs(node->left, id * 2, depth + 1, lefts, maxwidth);\\n        dfs(node->right, id * 2 + 1, depth + 1, lefts, maxwidth);\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        List<Integer> lefts = new ArrayList<Integer>(); // left most nodes at each level;\\n        int[] res = new int[1]; // max width\\n        dfs(root, 1, 0, lefts, res);\\n        return res[0];\\n    }\\n    private void dfs(TreeNode node, int id, int depth, List<Integer> lefts, int[] res) {\\n        if (node == null) return;\\n        if (depth >= lefts.size()) lefts.add(id);   // add left most node\\n        res[0] = Integer.max(res[0], id + 1 - lefts.get(depth));\\n        dfs(node.left,  id * 2,     depth + 1, lefts, res);\\n        dfs(node.right, id * 2 + 1, depth + 1, lefts, res);\\n    }\\n}\\n```\\n**BFS**\\nC++\\n```\\nclass Solution {\\npublic:\\n    int widthOfBinaryTree(TreeNode* root) {\\n        if (!root) return 0;\\n        int max = 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push(pair<TreeNode*, int>(root, 1));\\n        while (!q.empty()) {\\n            int l = q.front().second, r = l; // right started same as left\\n            for (int i = 0, n = q.size(); i < n; i++) {\\n                TreeNode* node = q.front().first;\\n                r = q.front().second;\\n                q.pop();\\n                if (node->left) q.push(pair<TreeNode*, int>(node->left, r * 2));\\n                if (node->right) q.push(pair<TreeNode*, int>(node->right, r * 2 + 1));\\n            }\\n            max = std::max(max, r + 1 - l);\\n        }\\n        return max;\\n    }\\n};\\n```\\nJava\\n```\\nimport java.util.AbstractMap;\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        int max = 0;\\n        Queue<Map.Entry<TreeNode, Integer>> q = new LinkedList<Map.Entry<TreeNode, Integer>>();\\n        q.offer(new AbstractMap.SimpleEntry(root, 1));\\n\\n        while (!q.isEmpty()) {\\n            int l = q.peek().getValue(), r = l; // right started same as left\\n            for (int i = 0, n = q.size(); i < n; i++) {\\n                TreeNode node = q.peek().getKey();\\n                r = q.poll().getValue();\\n                if (node.left != null) q.offer(new AbstractMap.SimpleEntry(node.left, r * 2));\\n                if (node.right != null) q.offer(new AbstractMap.SimpleEntry(node.right, r * 2 + 1));\\n            }\\n            max = Math.max(max, r + 1 - l);\\n        }\\n\\n        return maxwidth;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"106707",
			"view":"1554",
			"top":"2",
			"title":"Python, Straightforward BFS and DFS solutions",
			"vote":"11",
			"content":"The main idea with this question is we will give each node a position value.  If we go down the left neighbor, then position -> position * 2; and if we go down the right neighbor, then position -> position * 2 + 1.  This makes it so that when we look at the position values L and R of two nodes with the same depth, the width will be R - L + 1.\\n\\nFrom there, we have two choices for traversals: BFS or DFS.  In a BFS, all the nodes with the same depth are searched adjacent to each other, so we only need to remember the first and last positions seen for each depth.\\n\\n```\\ndef widthOfBinaryTree(self, root):\\n    queue = [(root, 0, 0)]\\n    cur_depth = left = ans = 0\\n    for node, depth, pos in queue:\\n        if node:\\n            queue.append((node.left, depth+1, pos*2))\\n            queue.append((node.right, depth+1, pos*2 + 1))\\n            if cur_depth != depth:\\n                cur_depth = depth\\n                left = pos\\n            ans = max(pos - left + 1, ans)\\n\\n    return ans\\n```\\n\\nIt might be more natural to attempt a DFS.  Here, we create a dfs iterator that yields the depth and position of each node.\\n\\nAfter, we need to know for each depth, what was the leftmost position left[depth] and the rightmost position right[depth].  We'll remember the largest width as we iterate through the nodes.\\n\\n```\\ndef widthOfBinaryTree(self, root):\\n    def dfs(node, depth = 0, pos = 0):\\n        if node:\\n            yield depth, pos\\n            yield from dfs(node.left, depth + 1, pos * 2)\\n            yield from dfs(node.right, depth + 1, pos * 2 + 1)\\n\\n    left = {}\\n    right = {}\\n    ans = 0\\n    for depth, pos in dfs(root):\\n        left[depth] = min(left.get(depth, pos), pos)\\n        right[depth] = max(right.get(depth, pos), pos)\\n        ans = max(ans, right[depth] - left[depth] + 1)\\n\\n    return ans\\n```"
		},
		{
			"lc_ans_id":"106653",
			"view":"1065",
			"top":"3",
			"title":"Java One Queue Solution with HashMap",
			"vote":"10",
			"content":"The idea is to traverse all the node in the tree in level order(Here I use one Queue to store each level's nodes. The time I traverse each level is the queue's size(the number of nodes from upper level)). Each time a node is traversed, the position of the node(as it is in a full binary tree) is stored in the HashMap. If the position of the parent node is 'n', then the left child is '2 * n' and the right child is '2 * n + 1'. The width of each level is the last node's position in this level subtracts the first node's position in this level plus 1.\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null) return 0;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        Map<TreeNode, Integer> m = new HashMap<TreeNode, Integer>();\\n        q.offer(root);\\n        m.put(root, 1);\\n        int curW = 0;\\n        int maxW = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int start = 0;\\n            int end = 0;\\n            for(int i = 0; i < size; i++){\\n                TreeNode node = q.poll();\\n                if(i == 0) start = m.get(node);\\n                if(i == size - 1) end = m.get(node);\\n                if(node.left != null){\\n                    m.put(node.left, m.get(node) * 2);\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null){\\n                    m.put(node.right, m.get(node) * 2 + 1);\\n                    q.offer(node.right);\\n                }\\n            }\\n            curW = end - start + 1;\\n            maxW = Math.max(curW, maxW);\\n        }\\n        return maxW;\\n    }\\n}"
		},
		{
			"lc_ans_id":"106648",
			"view":"2659",
			"top":"4",
			"title":"JAVA\\uff0cLevel Traversal,Using Two Queue",
			"vote":"8",
			"content":" It's easy to use a travel traversal template, use another queue to keep the index of each level nodes. left node index = this node index * 2, right = this node index*2 + 1. the width should be the last node index - first node index + 1\\n```java\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if(root == null) return 0;\\n        ArrayDeque<TreeNode> queue = new ArrayDeque<>();\\n        ArrayDeque<Integer>  count = new ArrayDeque<>();\\n        queue.offer(root);\\n        count.offer(0);\\n        int max = 1;\\n        \\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            int left = 0;\\n            int right = 0;\\n            for(int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                int index = count.poll();\\n                if(i == 0)  left = index;\\n                if(i == size-1)  right = index;\\n                if(node.left != null) {\\n                    queue.offer(node.left);\\n                    count.offer(index*2);\\n                }\\n                if(node.right != null) {\\n                    queue.offer(node.right);\\n                    count.offer(index*2 + 1);\\n                }\\n            }\\n            max = Math.max(max,right - left + 1);\\n        }\\n        return max;\\n    }\\n```"
		},
		{
			"lc_ans_id":"106650",
			"view":"408",
			"top":"5",
			"title":"Python...",
			"vote":"6",
			"content":"    def widthOfBinaryTree(self, root):\\n        width = 0\\n        level = [(1, root)]\\n        while level:\\n            width = max(width, level[-1][0] - level[0][0] + 1)\\n            level = [kid\\n                     for number, node in level\\n                     for kid in enumerate((node.left, node.right), 2 * number)\\n                     if kid[1]]\\n        return width\\n\\nThat's numbering nodes (and nulls) like this:\\n\\n                      1\\n              2               3\\n          4       5       6       7\\n        8   9   ..."
		},
		{
			"lc_ans_id":"106655",
			"view":"1098",
			"top":"6",
			"title":"Java solution, node position of binary tree.",
			"vote":"6",
			"content":"```\\nclass Solution {\\n    Map<Integer, int[]> map = new HashMap<>();\\n    \\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        findMax(root, 0, 0);\\n        \\n        int res = 1;\\n        for (int[] rec : map.values()) {\\n            res = Math.max(res, rec[1] - rec[0] + 1);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void findMax(TreeNode root, int level, int pos) {\\n        if (root == null) return;\\n        \\n        int[] rec = map.get(level);\\n        if (rec == null) {\\n            rec = new int[2];\\n            rec[0] = Integer.MAX_VALUE;\\n            rec[1] = Integer.MIN_VALUE;\\n        }\\n\\n        rec[0] = Math.min(rec[0], pos);\\n        rec[1] = Math.max(rec[1], pos);\\n        map.put(level, rec);\\n        \\n        findMax(root.left, level + 1, 2 * pos);\\n        findMax(root.right, level + 1, 2 * pos + 1);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"106702",
			"view":"765",
			"top":"7",
			"title":"BFS - Clean Accepted Solution - With Explanation",
			"vote":"2",
			"content":"After creating the queue, for each level we will do below steps:\\n- Count `null` nodes, only if we've already visited at least one node which is not null. (`pendingNullCount`). Also, if this situation is true (`notNullSeen==true`), add two null nodes to be counted in the next iteration.\\n- When you visit a node which is not null, increment the actual number of the nodes in current level by number of null nodes that we have already counted `actualLevelCount += pendingNullCount + 1`. (+1 for the current node).\\n- At end of each level, if all we have visited in current level are `null` nodes, it means these null nodes are all remaining from previous level. So there is no more actual nodes remaining. Otherwise, check update `max`.\\n\\n```\\n    public int WidthOfBinaryTree(TreeNode root)\\n    {\\n        if (root == null) return 0;\\n        Queue<TreeNode> Q = new Queue<TreeNode>();\\n        int max = 0;\\n\\n        Q.Enqueue(root);\\n\\n        while(Q.Any()) //while Q is not empty\\n        {\\n            int currLevelCount= Q.Count;\\n            int pendingNullCount = 0;\\n            int actualLevelCount = 0;\\n            bool notNullSeen = false;\\n\\n            while (currLevelCount > 0)\\n            {\\n                TreeNode currNode = Q.Dequeue();\\n\\n                if (currNode == null)\\n                {\\n                    if (notNullSeen == true)\\n                    {\\n                        pendingNullCount++;\\n                        Q.Enqueue(null);\\n                        Q.Enqueue(null);\\n                    }\\n                }\\n                else\\n                {\\n                    notNullSeen = true;\\n                    actualLevelCount += pendingNullCount + 1;\\n                    pendingNullCount = 0;\\n\\n                    Q.Enqueue(currNode.left);\\n                    Q.Enqueue(currNode.right);\\n                }\\n                currLevelCount--;\\n            }\\n            if (notNullSeen == false) break;\\n            max = Math.Max(actualLevelCount, max);\\n        }\\n        return max;\\n    }\\n```"
		},
		{
			"lc_ans_id":"106663",
			"view":"131",
			"top":"8",
			"title":"Java O(n) BFS one queue clean solution",
			"vote":"1",
			"content":"change the val of node to be the index to save space. The value is useless. All we need is just the index.\\n```\\nclass Solution {\\n    public int widthOfBinaryTree(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        LinkedList<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        root.val = 0;\\n        int max = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            max = Math.max(max, queue.peekLast().val - queue.peekFirst().val + 1);\\n            for (int i = 0; i < size; i++) {\\n                root = queue.poll();\\n                if (root.left != null) {\\n                    root.left.val = root.val * 2;\\n                    queue.offer(root.left);\\n                }\\n                if (root.right != null) {\\n                    root.right.val = root.val * 2 + 1;\\n                    queue.offer(root.right);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}"
		},
		{
			"lc_ans_id":"106666",
			"view":"81",
			"top":"9",
			"title":"My Accepted Java Solution using Deque",
			"vote":"1",
			"content":"```\\npublic int widthOfBinaryTree(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        Deque<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        int max=0;\\n        while(!q.isEmpty()){\\n            int count=0;\\n            max=Math.max(max,q.size());\\n            int size=q.size();\\n            while(count<size){\\n                TreeNode node=q.poll();\\n                if(node==null){\\n                    q.add(null);q.add(null);\\n                }else{\\n                    q.add(node.left);q.add(node.right);\\n                }\\n                count++;\\n            }\\n            while(!q.isEmpty()&&q.peekFirst()==null)\\n                q.pollFirst();\\n            while(!q.isEmpty()&&q.peekLast()==null)\\n                q.pollLast();\\n        }\\n        return max;\\n    }\\n```"
		}
	],
	"id":"639",
	"title":"Maximum Width of Binary Tree",
	"content":"<p>Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a <b>full binary tree</b>, but some nodes are null. </p>\r\n\r\n<p>The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the <code>null</code> nodes between the end-nodes are also counted into the length calculation.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n\r\n           1\r\n         /   \\\r\n        3     2\r\n       / \\     \\  \r\n      5   3     9 \r\n\r\n<b>Output:</b> 4\r\n<b>Explanation:</b> The maximum width existing in the third level with the length 4 (5,3,null,9).\r\n</pre>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n\r\n          1\r\n         /  \r\n        3    \r\n       / \\       \r\n      5   3     \r\n\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> The maximum width existing in the third level with the length 2 (5,3).\r\n</pre>\r\n\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n\r\n          1\r\n         / \\\r\n        3   2 \r\n       /        \r\n      5      \r\n\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> The maximum width existing in the second level with the length 2 (3,2).\r\n</pre>\r\n\r\n<p><b>Example 4:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n\r\n          1\r\n         / \\\r\n        3   2\r\n       /     \\  \r\n      5       9 \r\n     /         \\\r\n    6           7\r\n<b>Output:</b> 8\r\n<b>Explanation:</b>The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).\r\n\r\n\r\n</pre>\r\n\r\n<p><b>Note:</b>\r\nAnswer will in the range of 32-bit signed integer.\r\n</p>",
	"frequency":"127",
	"ac_num":"10446"
}