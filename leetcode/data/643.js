{
	"difficulty":"2",
	"submit_num":"7760",
	"show_id":"666",
	"leetcode_id":"666",
	"answers":[
		{
			"lc_ans_id":"106892",
			"view":"2482",
			"top":"0",
			"title":"Java solution, Represent tree using HashMap",
			"vote":"22",
			"content":"How do we solve problem like this if we were given a normal tree? Yes, traverse it, keep a root to leaf running sum. If we see a leaf node (node.left == null && node.right == null), we add the running sum to the final result.\\n\\nNow each tree node is represented by a number. 1st digits is the ```level```, 2nd is the ```position``` in that ```level``` (note that it starts from ```1``` instead of ```0```). 3rd digit is the value. We need to find a way to traverse this ```tree``` and get the sum.\\n\\nThe idea is, we can form a ```tree``` using a HashMap. The ```key``` is first two digits which marks the position of a node in the tree. The ```value``` is value of that node. Thus, we can easily find a node's left and right children using math. \\nFormula: For node ```xy?``` its left child is ```(x+1)(y*2-1)?``` and right child is ```(x+1)(y*2)?```\\n\\nGiven above HashMap and formula, we can traverse the ```tree```. Problem is solved!\\n```\\nclass Solution {\\n    int sum = 0;\\n    Map<Integer, Integer> tree = new HashMap<>();\\n    \\n    public int pathSum(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        \\n        for (int num : nums) {\\n            int key = num / 10;\\n            int value = num % 10;\\n            tree.put(key, value);\\n        }\\n        \\n        traverse(nums[0] / 10, 0);\\n        \\n        return sum;\\n    }\\n    \\n    private void traverse(int root, int preSum) {\\n        int level = root / 10;\\n        int pos = root % 10;\\n        int left = (level + 1) * 10 + pos * 2 - 1;\\n        int right = (level + 1) * 10 + pos * 2;\\n        \\n        int curSum = preSum + tree.get(root);\\n        \\n        if (!tree.containsKey(left) && !tree.containsKey(right)) {\\n            sum += curSum;\\n            return;\\n        }\\n        \\n        if (tree.containsKey(left)) traverse(left, curSum);\\n        if (tree.containsKey(right)) traverse(right, curSum);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"106887",
			"view":"1280",
			"top":"1",
			"title":"[C++] [Java] Clean Code",
			"vote":"13",
			"content":"```\\n         0\\n     0       1\\n  0   1     2   3\\n0 1  2 3   4 5  6 7\\n```\\nRegardless whether these nodes exist:\\n\\nthe position of left child is always `parent_pos * 2`;\\nthe position of right child is always` parent_pos * 2 + 1`;\\nthe position of parent is always `child_pos / 2`;\\n\\n**Solution C++ Array**\\n```\\nclass Solution {\\npublic:\\n    int pathSum(vector<int>& nums) {\\n        int m[5][8] = {};\\n        for (int n : nums) {\\n            int i = n / 100; // i is 1 based index;\\n            int j = (n % 100) / 10 - 1; // j used 0 based index;\\n            int v = n % 10;\\n            m[i][j] = m[i - 1][j / 2] + v;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 1; i < 5; i++) {\\n            for (int j = 0; j < 8; j++) {\\n                if (i == 4 || m[i][j] && !m[i + 1][j * 2] && !m[i + 1][j * 2 + 1]){\\n                    sum += m[i][j];\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n**Solution C++ map**\\nIf we use map, we don't need to do the boundary check at little extra cost of memory.\\n```\\nclass Solution {\\npublic:\\n    int pathSum(vector<int>& nums) {\\n        map<int, map<int, int>> m;\\n        for (int n : nums) {\\n            int i = n / 100 - 1; // i is 0 based index;\\n            int j = (n % 100) / 10 - 1; // j used 0 based index;\\n            int v = n % 10;\\n            m[i][j] = m[i - 1][j / 2] + v;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 8; j++) {\\n                sum += m[i][j] && !m[i + 1][j * 2] && !m[i + 1][j * 2 + 1] ? m[i][j] : 0;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n**Solution C++ - queue**\\n```\\nclass Solution {\\npublic:\\n    int pathSum(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int sum = 0;\\n        queue<info> q;\\n        info dummy(0);\\n        info* p = &dummy; // parent start with dummy info, root have no real parent;\\n        for (int n : nums) {\\n            info c(n); // child;\\n            while (!p->isparent(c) && !q.empty()) {\\n                sum += p->leaf ? p->v : 0;\\n                p = &q.front();\\n                q.pop();\\n            }\\n            p->leaf = false;\\n            c.v += p->v;\\n            q.push(c);\\n        }\\n        while (!q.empty()) {\\n            sum += q.front().v;\\n            q.pop();\\n        }\\n        return sum;\\n    }\\nprivate:\\n    struct info {\\n        int i, j, v;\\n        bool leaf;\\n        info(int n) : i(n / 100 - 1), j((n % 100) / 10 - 1), v(n % 10), leaf(true) {};\\n        bool isparent(info other) { return i == other.i - 1 && j == other.j / 2;};\\n    };\\n};\\n```\\n**Solution Java**\\n```\\nclass Solution {\\n    public int pathSum(int[] nums) {\\n        int[][] m = new int[5][8];\\n        for (int n : nums) {\\n            int i = n / 100; // i is 1 based index;\\n            int j = (n % 100) / 10 - 1; // j used 0 based index;\\n            int v = n % 10;\\n            m[i][j] = m[i - 1][j / 2] + v;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 1; i < 5; i++) {\\n            for (int j = 0; j < 8; j++) {\\n                if (i == 4 || m[i][j] != 0 && m[i + 1][j * 2] == 0 && m[i + 1][j * 2 + 1] == 0){\\n                    sum += m[i][j];\\n                }\\n            }\\n        }\\n        return sum;        \\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"106934",
			"view":"377",
			"top":"2",
			"title":"Python Straight Forward Solution",
			"vote":"3",
			"content":"v is path sum, nc is the number of leaves\\n````\\ndef pathSum(self, nums):\\n        s = {}\\n        l = {}\\n        for i in nums[::-1]:\\n            a, b, c = i / 100, i / 10 % 10, i % 10\\n            l[a, b] = max(1, l.get((a + 1, b * 2 - 1), 0) + l.get((a + 1, b * 2), 0))\\n            s[a, b] = s.get((a + 1, b * 2 - 1), 0) + s.get((a + 1, b * 2), 0) + l[a, b] * c\\n        return s.get((1, 1), 0)"
		},
		{
			"lc_ans_id":"106940",
			"view":"623",
			"top":"3",
			"title":"Short Java 8 and dfs solution",
			"vote":"3",
			"content":"The idea is to first represent the tree as a map,  that contains the tree in the form of \\nNode position number --> Node value , where the Node number is the position of the node in a complete tree.\\n\\nThen, we just do a dfs on the above tree to accumulate all the root to leaf path sums.\\n\\n```\\nLets take a tree example\\n                                          10\\n                                         /  \\\\\\n                                       20     30\\n                                      / \\\\     / \\\\\\n                                    40  50  60   70\\n```\\nFor the above tree,\\nthe node positions are as follows,\\nroot's position = 1, \\nleft child position =  parent_position * 2\\nright child position =  parent_position * 2 + 1\\nBased on the above complete tree positions, the map generated for the above example would be\\n1 --> 10\\n2 --> 20\\n3 --> 30\\n4 --> 40\\n5 --> 50\\n6 --> 60\\n7 --> 70\\n\\nTo generate these positions from the given input,\\nif the input number is 314\\nwe extract the digits to level = 3, positionInLevel = 1, value = 4\\nand the formula I arrived at to get the node's position in complete tree = [2 ^ (level-1)] + positionInLevel - 1\\n\\nNow that we have the above map generated,\\nwe do a simple dfs starting from the root, and keep accumulating the sum, once we reach a leaf, we add the accumulated sum to the result.\\n\\n```\\n    public int pathSum(int[] nums) {\\n        Map<Integer, Integer> positionToNodeMap = new HashMap<>();\\n        Arrays.stream(nums).forEach( num -> {\\n            int[] digits = IntStream.range(0, 3).map(i -> (num + \"\").charAt(i) - '0').toArray();\\n            positionToNodeMap.put((int)Math.pow(2, digits[0] - 1) - 1 + digits[1], digits[2]);\\n        });\\n        int[] res = new int[1];\\n        dfs(1, 0, res, positionToNodeMap);\\n        return res[0];\\n    }\\n\\n   private void dfs(int cur, int sum, int[] res, Map<Integer, Integer> map) {\\n        if(!map.containsKey(cur)) return;\\n        int left = cur * 2, right = cur * 2 + 1, totalSum = sum + map.get(cur);\\n        if(!map.containsKey(left) && !map.containsKey(right)) { res[0] += totalSum; return; } // Leaf node\\n        dfs(left, totalSum, res, map);\\n        dfs(right, totalSum, res, map);\\n    }\\n```"
		},
		{
			"lc_ans_id":"106929",
			"view":"202",
			"top":"4",
			"title":"Python Easy to Understand",
			"vote":"2",
			"content":"```\\nclass Solution(object):\\n    def pathSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total, nodes_map = 0, {}\\n        def num_to_tuple(num, i):\\n            # The node 113 becomes a tuple of (0, 0, 3).\\n            depth, pos, value = int(str(num)[0]) - 1, int(str(num)[1]) - 1, int(str(num)[2])\\n            if depth not in nodes_map:\\n                nodes_map[depth] = {}\\n            nodes_map[depth][pos] = i\\n            return (depth, pos, value)\\n        # Convert numbers to tuples.\\n        nodes = [num_to_tuple(num, i) for i, num in enumerate(nums)]\\n        path_sums = [0] * len(nodes)\\n\\n        for index, node in enumerate(nodes):\\n            depth, pos, value = node\\n            path_sums[index] = value\\n            # Look up the dictionary for the node's parent.\\n            if depth - 1 in nodes_map and (pos // 2) in nodes_map[depth - 1]:\\n                # If node has a parent, add the parent's value to the path sum.\\n                path_sums[index] += path_sums[nodes_map[depth - 1][pos // 2]]\\n            # Look up the dictionary for the node's children.\\n            if not (depth + 1 in nodes_map and ((pos * 2) in nodes_map[depth + 1] or (pos * 2 + 1) in nodes_map[depth + 1])):\\n                # If there are no children, it is a leaf. Add the path sum to the total.\\n                total += path_sums[index]\\n        return total\\n```\\n\\n*- Yangshun*"
		},
		{
			"lc_ans_id":"106907",
			"view":"67",
			"top":"5",
			"title":"Swift 3 Iterative Method by Level",
			"vote":"1",
			"content":"```\\nfunc pathSum(_ nums: [Int]) -> Int {\\n    var hash = [Int: Int]()\\n    for i in stride(from: nums.count - 1, through: 0, by: -1) {\\n        let level = nums[i] / 100, pos = nums[i] / 10 % 10\\n        let index = Int(pow(2.0, Double(level) - 1.0)) - 1 + pos\\n        // leaf node\\n        if hash[index] == nil {\\n            hash[index] = 1\\n        }\\n        // child node's parent node\\n        if hash[index / 2] == nil {\\n            hash[index / 2] = 0\\n        }\\n        // adding child notes' number of child notes together\\n        hash[index / 2] = hash[index / 2]! + hash[index]!\\n    }\\n    var sum = 0\\n    for i in 0..<nums.count {\\n        let level = nums[i] / 100, pos = nums[i] / 10 % 10, val = nums[i] % 10\\n        // calculate\\n        let index = Int(pow(2.0, Double(level) - 1.0)) - 1 + pos\\n        sum += hash[index]! * val\\n    }\\n    return sum\\n}\\n\\n```"
		},
		{
			"lc_ans_id":"106933",
			"view":"128",
			"top":"6",
			"title":"Java DFS, with explanation",
			"vote":"1",
			"content":"Find the left child and right child based on the first two digits;\\n\\n[abc] 's left child = [(a+1)(b*2-1)(...)]\\n\\n[abc]'s right child = [(a+1)(b*2)(...)]\\n\\ndfs, when current node is a leaf, add the sum of path to totalSum\\n\\n```\\nclass Solution {\\n    \\n    int totalSum;\\n    public int pathSum(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        totalSum = 0;\\n        dfs(nums, 0, 0);\\n        return totalSum;\\n    }\\n    \\n    private void dfs(int[] nums, int i, int sum){\\n        int n = nums[i];\\n        int v = n%10; //value\\n        int idx = (n/10)%10; //index\\n        int d = n/100; //depth\\n        sum += v;\\n        int left = (d+1)*10+idx*2-1; //left child's depth and index\\n        int right = (d+1)*10+idx*2; //right child's depth and index\\n        boolean foundLeft = false, foundRight = false;\\n        for(int j = i+1; j<nums.length; j++){\\n            int tmp = nums[j]/10;\\n            if (tmp > right) break;\\n            if (tmp == left) {\\n                foundLeft = true;\\n                dfs(nums, j, sum);\\n            }\\n            if (tmp == right) {\\n                foundRight = true;\\n                dfs(nums, j, sum);\\n            }\\n        }\\n        if (!foundLeft && !foundRight) \\n            totalSum+=sum; //if is leaf, add the sum of the path to total sum;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"106886",
			"view":"25",
			"top":"7",
			"title":"One Pass, Bottom Up, No Tree Constructed, Using Hash Map, C++",
			"vote":"0",
			"content":"```\\n/*\\nO(n) time, O(n) space (map), traverse once\\nno tree constructed and no recursion\\n*/\\n\\nclass Solution {\\npublic:\\n    int pathSum(vector<int>& nums) {\\n        int sum = 0;\\n        unordered_map<int, int> map;    // unordered_map<node, times>\\n        int numsSize = static_cast<int>(nums.size());    // cast size_type to int\\n        for (int i = numsSize - 1; i >= 0; i --) {\\n            int currentValue = nums[i] % 10;\\n            int currentPosition = nums[i] % 100 / 10;\\n            int currentLevel = nums[i] / 100;\\n            int current = currentLevel * 10 + currentPosition;\\n            int parent = (currentLevel - 1) * 10 + (currentPosition - 1) / 2 + 1;\\n            \\n            /*since the input is in ascending order, and we are iterating from back to front\\n              parent will always comes later than its children, therefore\\n              if count is 0, means is a leaf, initialize to 1\\n              if count is 1, means is not a leaf, leave it as it is */\\n            if (map.count(current) == 0) {\\n                map[current] = 1;\\n            }\\n            // initialize parent to zero if first time\\n            if (map.count(parent) == 0) {\\n                map[parent] = 0;\\n            }\\n            map[parent] += map[current];\\n            sum += (map[current] * currentValue);\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\nNote that after iteration (except the case nums is empty), the hash map will contain a key-value pair for \"the parent of root\", which is a meaningless pair. This pair is not used anywhere in the algorithm, so it's fine to quietly reside in there."
		},
		{
			"lc_ans_id":"106888",
			"view":"21",
			"top":"8",
			"title":"Java Recursion Without Rebuilding the Tree",
			"vote":"0",
			"content":"    private class Pair {\\n        int sum;\\n        int leafCount;\\n        private Pair(int sum, int leafCount) {\\n            this.sum = sum;\\n            this.leafCount = leafCount;\\n        }\\n    }\\n    \\n    public int pathSum(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return 0;\\n        return scan(nums, 0).sum;\\n    }\\n    \\n    private Pair scan(int[] nums, int i) {\\n        if (i == -1)\\n            return new Pair(0, 0);\\n        int val = nums[i]%10;\\n        int lv = nums[i]/100;\\n        int p = nums[i]/10%10;\\n        Pair lp = scan(nums, findChild(nums, lv+1, 2*p-1, i));\\n        Pair rp = scan(nums, findChild(nums, lv+1, 2*p, i));\\n        int leafCount = Math.max(1, lp.leafCount+rp.leafCount);\\n        return new Pair(lp.sum+rp.sum+val*leafCount, leafCount); \\n    }\\n    \\n    private int findChild(int[] nums, int lv, int p, int start) {\\n        for (int i = start; i < nums.length && nums[i]/100 <= lv; i++) {\\n            if (nums[i]/100 == lv && nums[i]/10%10 == p)\\n                return i;\\n        }\\n        return -1;\\n    }"
		},
		{
			"lc_ans_id":"106889",
			"view":"24",
			"top":"9",
			"title":"Java Easy to Understand. Using Array.",
			"vote":"0",
			"content":"We can index tree as the parent node is *i* and two child nodes are *2i* and *2i+1*.\\n```   \\n       i\\n2*i       2*i+1\\n```\\nSince the depth of the tree is less than 5, we can create an array of 32.\\nWe can assign the value of each node to the corresponding position in the array by doing an easy calculation. Remember that the root node is 1.\\n```\\n\\nfor(int n : nums) {\\n     int i = n % 10;\\n     int j = n/10 % 10;\\n     int k = n/100;\\n     arr[(1 << (k-1)) + (j-1)] = i;\\n}\\n```\\nWhen calculating the path, we can go through the array in reverse order and check whether the node is the leaf node. The code is as below:\\n```\\n    public int pathSum(int[] nums) {\\n        int[] arr = new int[32];\\n        Arrays.fill(arr, -1);\\n        for(int n : nums) {\\n            int i = n % 10;\\n            int j = n/10 % 10;\\n            int k = n/100;\\n            arr[(1 << (k-1)) + (j-1)] = i;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = arr.length-1; i >= 0; i--) {\\n            if(arr[i] != -1 && (i >= arr.length/2 || (i < arr.length/2 && arr[i*2] == -1 && arr[i*2+1] == -1))) {\\n                int n = i;\\n                while(n > 0) {\\n                    sum += arr[n];\\n                    n /= 2;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n```"
		}
	],
	"id":"643",
	"title":"Path Sum IV",
	"content":"<p>\r\nIf the depth of a tree is smaller than <code>5</code>, then this tree can be represented by a list of three-digits integers.\r\n</p>\r\n\r\n<p>\r\nFor each integer in this list:<br/>\r\n<ol>\r\n<li>The hundreds digit represents the depth <code>D</code> of this node, <code>1 <= D <= 4.</code></li>\r\n<li>The tens digit represents the position <code>P</code> of this node in the level it belongs to, <code>1 <= P <= 8</code>. The position is the same as that in a full binary tree. </li>\r\n<li>The units digit represents the value <code>V</code> of this node, <code>0 <= V <= 9.</code></li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nGiven a list of <code>ascending</code> three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [113, 215, 221]\r\n<b>Output:</b> 12\r\n<b>Explanation:</b> \r\nThe tree that the list represents is:\r\n    3\r\n   / \\\r\n  5   1\r\n\r\nThe path sum is (3 + 5) + (3 + 1) = 12.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [113, 221]\r\n<b>Output:</b> 4\r\n<b>Explanation:</b> \r\nThe tree that the list represents is: \r\n    3\r\n     \\\r\n      1\r\n\r\nThe path sum is (3 + 1) = 4.\r\n</pre>\r\n</p>",
	"frequency":"18",
	"ac_num":"3881"
}