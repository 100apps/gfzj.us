{
	"difficulty":"2",
	"submit_num":"41863",
	"show_id":"670",
	"leetcode_id":"670",
	"answers":[
		{
			"lc_ans_id":"107068",
			"view":"9239",
			"top":"0",
			"title":"Java simple solution, O(n) time",
			"vote":"56",
			"content":"Use buckets to record the last position of digit 0 ~ 9 in this num.\\n\\nLoop through the num array from left to right. For each position, we check whether there exists a larger digit in this num (start from 9 to current digit). We also need to make sure the position of this larger digit is behind the current one. If we find it, simply swap these two digits and return the result.\\n\\n```\\nclass Solution {\\n    public int maximumSwap(int num) {\\n        char[] digits = Integer.toString(num).toCharArray();\\n        \\n        int[] buckets = new int[10];\\n        for (int i = 0; i < digits.length; i++) {\\n            buckets[digits[i] - '0'] = i;\\n        }\\n        \\n        for (int i = 0; i < digits.length; i++) {\\n            for (int k = 9; k > digits[i] - '0'; k--) {\\n                if (buckets[k] > i) {\\n                    char tmp = digits[i];\\n                    digits[i] = digits[buckets[k]];\\n                    digits[buckets[k]] = tmp;\\n                    return Integer.valueOf(new String(digits));\\n                }\\n            }\\n        }\\n        \\n        return num;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"107084",
			"view":"2776",
			"top":"1",
			"title":"[C++] 3ms, O(n) time, O(n) space, DP solution",
			"vote":"13",
			"content":"We only need to record a position array (pos[i]) which represent the largest number index form the i position.\\n\\nFor instance,\\ninput         9 8 6 3 8\\npos         0 4 4 4 4\\ninput[pos] 9 8 8 8 8\\n\\nTherefore, we only need to find the first input[i] != input[pos[i]]\\nand swap it.\\n\\nAnother example\\ninput         5 4 3 1 2\\npos           0 1 2 4 4\\ninput[pos] 5 4 3 2 2\\n\\n```\\nint maximumSwap(int num) {\\n    string numString = to_string(num);\\n    int n = numString.length();\\n    vector<int> dpPosition(n, -1);\\n        \\n    int curMaxPos = n - 1;\\n    for (int i = n - 1; i >= 0; i--) {\\n        if (numString[i] > numString[curMaxPos]) {\\n            curMaxPos = i;\\n        }\\n        dpPosition[i] = curMaxPos;\\n    }\\n        \\n    for (int i = 0; i < n; i++) {\\n        if(numString[dpPosition[i]] != numString[i]) {\\n            swap(numString[i], numString[dpPosition[i]]);\\n            break;\\n        }\\n    }\\n        \\n    return stoi(numString);\\n}\\n```"
		},
		{
			"lc_ans_id":"107102",
			"view":"1575",
			"top":"2",
			"title":"Simple AC O(n) java solution with ex",
			"vote":"8",
			"content":"Very similar to LeetCode 31. Next Permutation\\n1. Search from the left end and find the position where the reversed list was not satisfied. **(example. in number 54367, we will find the position of 6.)** Then we cut the original digits array to two parts, the first part was reversely sorted which means no swap needed within it and the second part.\\n2. Find and record the max value and max value position in the second part. **( example, digit 7 in 54367)**\\n3. Swap the max value in the second part to the first number in first part that smaller than that max value. **(Example, swap 7 with 5 in 54367)**\\nTime Complexity is O(n) \\n\\n\\n    public int maximumSwap(int num) {\\n        char[] digits = (\"\"+num).toCharArray();\\n        int frist_greater = 0; //find the first digit greater than previous\\n        while(++frist_greater<digits.length&&digits[frist_greater-1]>=digits[frist_greater]);\\n        if(frist_greater==digits.length) return num; //all digits are reversed sorted, no swap needed\\n        \\n        char max = '0';               \\n        int max_position=frist_greater;    \\n        for(int i=frist_greater;i<digits.length;i++)//find max digit in remain digits\\n            if(max<=digits[i]){\\n                max = digits[i];\\n                max_position = i;\\n            }\\n        \\n        for(int i=0;i<frist_greater;i++)  //find first digit that smaller than max digit in the second part\\n            if(max>digits[i]){\\n                StringBuilder s = new StringBuilder(String.valueOf(digits));\\n                s.setCharAt(max_position,digits[i]);\\n                s.setCharAt(i,max);\\n                return Integer.parseInt(s.toString());  //no need to check overflow since max value is 10^8\\n            }\\n        return num;\\n    }"
		},
		{
			"lc_ans_id":"107073",
			"view":"335",
			"top":"3",
			"title":"C++ one-pass simple & fast solution: 1-3ms, O(n) time",
			"vote":"7",
			"content":"Actually this problem can be easily solved by only one pass from backward. During the scan, we only need to do 2 things:\\n1. record the largest digit (maxdigit) and its corresponding index (maxidx);\\n2. if the current digit is smaller than the largest digit, this digit and the largest digit are the best candidate for max swap so far. In this case, this digit pair is recorded (leftidx and rightidx).\\n\\n```\\n\\n    int maximumSwap(int num) {\\n        string numstr = std::to_string(num);\\n\\n        int maxidx = -1; int maxdigit = -1;\\n        int leftidx = -1; int rightidx = -1;        \\n\\n        for (int i = numstr.size() - 1; i >= 0; --i) {\\n            // current digit is the largest by far\\n            if (numstr[i] > maxdigit) {\\n                maxdigit = numstr[i];\\n                maxidx = i;\\n                continue;\\n            }\\n\\n            // best candidate for max swap if there is no more \\n            // such situation on the left side\\n            if (numstr[i] < maxdigit) {\\n                leftidx = i;\\n                rightidx = maxidx;\\n            }\\n        }\\n\\n        // num is already in order\\n        if (leftidx == -1) return num;\\n\\n        std::swap(numstr[leftidx], numstr[rightidx]);\\n\\n        return std::stoi(numstr);\\n    }\\n```"
		},
		{
			"lc_ans_id":"107076",
			"view":"2491",
			"top":"4",
			"title":"Fastest O(n) time java solution w/ detailed explanation. Intuitive and easy to understand.",
			"vote":"7",
			"content":"The below algo runs in O(n) time. The performance is pretty good.\\n\\nLogic :-\\n1) We keep neglecting the digits until they are decreasing in value because there are no 2 digits we can find in this subset which we can swap to get a greater number than original. For ex. 9631.\\n\\n2) While iterating through the digits if we find the current > next digit, we store current as min and its index as minIndex. If we reach the end of the array which means that all the digits followed a decreasing trend, then there is nothing to swap and we return the original number.\\n\\n3) From the minIndex, we start our search for the greatest digit in the remaining digits. This will be our max and its index, maxIndex. The max is the digit we want to swap, but whom to swap with? The minIndex? That would be incorrect, as seen in this ex. 97482, where the min is 4 and max is 8. \\n (correct answer -> 98472)\\n\\n4) There could be a digit < max whose index < minIndex. For the above ex., it is the digit 7. Hence we'll iterate through the digits from beginning till minIndex to find a digit that satisfies the above criteria. The index of that digit would be swapIndex and we want to swap the maxIndex with swapIndex to get the maximum number possible.\\n\\n\\nIn all, steps 1,2, and 3 take one pass through the digits that requires O(n) time. Step 4, in worst case will require another pass, taking O(n) time.\\n\\n```\\nclass Solution {\\n    public int maximumSwap(int num) {          \\n        String temp = Integer.toString(num);     //Convert to int array (num -> digits[])\\n        int[] digits = new int[temp.length()];\\n        for (int i = 0; i < temp.length(); i++){\\n            digits[i] = temp.charAt(i) - '0';\\n        }                                       //Ignore all digits until decreasing, until (next digit > prev). store the min and minindex\\n        int min = digits[0], minIndex = 0;\\n        for (int i = 0; i < digits.length - 1; i++){\\n            if (digits[i + 1] > digits[i]) {\\n                minIndex = i;\\n                min = digits[i];\\n                break;\\n            } else if (i == digits.length - 2)  //Reached end. Nothing to swap. Return original number.           \\n                return num;\\n        }                                       //Starting from minindex find the largest digit in the remaining digits.\\n        int max = min, maxIndex = -1;\\n        for (int j = minIndex; j < digits.length; j++){\\n            if (digits[j] >= max) {\\n                max = digits[j];\\n                maxIndex = j;\\n            }\\n        }                                       //Iterate through the array till minIndex to find any digit that might be lesser than max \\n        int result = 0, swapindex = minIndex;\\n        for (int i = 0; i <= minIndex; i++){\\n            if (digits[i] < max) {\\n                swapindex = i;\\n                break;\\n            }\\n        }                                       //Swap the maxIndex digit with swapIndex\\n        int tmp = digits[swapindex];\\n        digits[swapindex] = digits[maxIndex];\\n        digits[maxIndex] = tmp;\\n                                                //Convert the result into integer(digits -> result) \\n        for (int i = digits.length - 1, j = 0; i >= 0; i--) {\\n            result = result + (digits[j] * ((int) Math.pow(10, i)));\\n            j++;\\n        }\\n        return result;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"107066",
			"view":"1569",
			"top":"5",
			"title":"Python, Straightforward with Explanation",
			"vote":"6",
			"content":"The number only has 8 digits, so there are only 8 choose 2 = 28 available swaps.  Brute force them all for an `O(N^2)` solution which passes.\\n\\nWe will store the candidates as lists of length `len(num)`.  For each candidate swap with positions `(i, j)`, we swap the number and record if the candidate is larger than the current answer, then swap back to restore the original number.  The only detail is possibly to check that we didn't introduce a leading zero.  We don't actually need to check it, because our original number doesn't have one.\\n\\n```python\\ndef maximumSwap(self, num):\\n    A = list(str(num))\\n    ans = A[:]\\n    for i in xrange(len(A)):\\n        for j in xrange(i+1, len(A)):\\n            A[i], A[j] = A[j], A[i]\\n            if A > ans: ans = A[:]\\n            A[i], A[j] = A[j], A[i]\\n\\n    return int(\"\".join(ans))\\n```\\n\\n---\\n\\nWe can also get an `O(N)` solution.  At each digit, if there is a larger digit that occurs later, we want the swap it with the largest such digit that occurs the latest.\\n\\n```python\\ndef maximumSwap(self, num):\\n    A = map(int, str(num))\\n    last = {x: i for i, x in enumerate(A)}\\n    for i, x in enumerate(A):\\n        for d in xrange(9, x, -1):\\n            if last.get(d, None) > i:\\n                A[i], A[last[d]] = A[last[d]], A[i]\\n                return int(\"\".join(map(str, A)))\\n    return num\\n```"
		},
		{
			"lc_ans_id":"107115",
			"view":"694",
			"top":"6",
			"title":"Does \"O(n)\" make sense?",
			"vote":"3",
			"content":"I've seen many people say their solution is O(n). I don't think that makes sense. Either you do consider that the number of digits is bounded by a constant and then you'd say O(1), or you really consider the general case of n digits (i.e., something like BigInteger), and then it's not O(n) because of your translation to string and back (or however else you're extracting and recombining the digits). Saying \"O(n)\" looks like a nonsensical mix of both viewpoints to me."
		},
		{
			"lc_ans_id":"107137",
			"view":"309",
			"top":"7",
			"title":"3-5 lines, Python/C++/Java/Ruby",
			"vote":"3",
			"content":"Python:\\n\\n    def maximumSwap(self, num):\\n        places = [10**i for i in range(len(str(num)))]\\n        return max(num + num/p%10*(q-p) + num/q%10*(p-q)\\n                   for p in places for q in places)\\n\\nC++:\\n\\n    int maximumSwap(int num) {\\n        int maxi = 0;\\n        for (int p=1; p<=num; p*=10)\\n            for (int q=p; q<=num; q*=10)\\n                maxi = max(maxi, num + num/p%10*(q-p) + num/q%10*(p-q));\\n        return maxi;\\n    }\\n\\nJava:\\n\\n    public int maximumSwap(int num) {\\n        int max = 0;\\n        for (int p=1; p<=num; p*=10)\\n            for (int q=p; q<=num; q*=10)\\n                max = Math.max(max, num + num/p%10*(q-p) + num/q%10*(p-q));\\n        return max;\\n    }\\n\\nRuby:\\n```\\ndef maximum_swap(num)\\n  num.to_s.size\\n    .times.map { |i| 10**i }.repeated_combination(2)\\n    .map { |p, q| num + num/p%10*(q-p) + num/q%10*(p-q) }\\n    .max\\nend\\n```\\nThere are so very few possibilities that I just try them all, swapping between any two places p and q (where places are 1, 10, 100, 1000, etc, i.e., the \"ones place\", \"tens place\", \"hundreds place\", etc). With `num/p%10` I get the digit at place p, and multiplying it with `(q-p)` takes it out of place p and puts it into place q. And move the digit from place q to place p the same way."
		},
		{
			"lc_ans_id":"107146",
			"view":"765",
			"top":"8",
			"title":"Java O(n) time O(n) space w/ Explanation",
			"vote":"3",
			"content":"_Before I start my explanation, it is important to note the greedy algorithm at play here. If there is a less significant digit bigger than a more significant digit, the number always increases by switching them. To achieve the maximum number after a swap, you have to swap with the most significant digit possible. Additionally, you want to make sure that the digit you swap with that more significant number is as big as possible._\\n\\n**The algorithm is as follows:**\\n\\n1) Traverse num from the least significant digit to the most significant digit, making sure to store the numbers as you go (I store the numbers I see in a List). While traversing, keep track of the maximum number seen so far. \\n\\n2) If the current number is smaller than the maximum number you have seen so far, I set the swap indices to those two indices (indices of max, less significant digit and more significant, smaller digit). Otherwise, if the current number is bigger than max, reset the max. \\n\\n3) At the end, swap the designated swap indices in the List, then convert the List back to a number for returning.\\n\\n*My variable naming conventions:*\\n\\n_**maxSeen**_ holds the maximum number I have seen, _**maxIdx**_ holds the index for that max number, _**power**_ holds the index of the currently visiting number, and the _**swapIdx's**_ hold the indices to be swapped.\\n\\n```\\nclass Solution {\\n    public int maximumSwap(int num) {\\n        int maxSeen = 0, maxIdx = -1, power = 0, swapIdx1 = 0, swapIdx2 = 0;\\n        List<Integer> list = new ArrayList<>();\\n        while(num > 0){\\n            int digit = num % 10;\\n            list.add(digit);\\n            if(maxSeen > digit){\\n                swapIdx1 = power;\\n                swapIdx2 = maxIdx;\\n            }\\n            else if(digit > maxSeen){\\n                maxSeen = digit;\\n                maxIdx = power;\\n            }\\n            num = num/10;\\n            power++;\\n        }\\n        \\n        Collections.swap(list, swapIdx1, swapIdx2);\\n\\n        int result = 0;\\n        for(int i = 0; i < list.size(); i++){\\n            result += (int)(Math.pow(10, i) * list.get(i));\\n        }\\n        return result;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"107157",
			"view":"286",
			"top":"9",
			"title":"Java solution based on sorting and finding indices to swap",
			"vote":"3",
			"content":"The idea is to convert the string to character array and sort the digits in reverse order.\\nWe need to find two indices i and j, that can be interchanged to get the max number in one swap.\\n\\nThe first position of digit mismatch between the sorted array and the original array gives the index i that needs to be interchanged. \\nAt index i, in the original array, we have the smaller number.\\nAt inded i, in the sorted array, we have the larger number.\\n\\nBecause, the larger number can occur in multiple positions in the original array, to find the correct position of j in the original array, find the last position of the larger number in the original array.\\n\\nAs an example, \\n\\nlets take                           \"927367\"\\nthe sorted digits are now \"977632\"\\n\\nThe first position of mismatch occurs at i = 1.\\nAt index 1, in the original number we have the smaller number 2 to be interchanged.\\nAt index 1, in the sorted number we have the larger number 7 to be interchanged.\\n\\nBut 7 also occurs at multiple positions in the original array. Becuse we are going to substitute the larger number with a smaller number, it makes sense to introduce the smaller number in the least possible poisiton from the right. Interchanging the smaller number 2 with the last 7 found in 927367, gives the correct answer = 977362.\\n\\n```\\npublic static int maximumSwap(int num) {\\n        String str = \"\"+num;\\n        char[] originalString = str.toCharArray();\\n        char[] sortedString = str.toCharArray();\\n        // Sort the digits in reverse order\\n        Arrays.sort(sortedString);\\n        sortedString = new StringBuilder(new String(sortedString)).reverse().toString().toCharArray();\\n\\n        int i; // Find the position of mismatch between the original and sorted string\\n        for(i = 0; i < str.length(); i++) {\\n            if(originalString[i] != sortedString[i]) break;\\n        }\\n\\n        if(i == str.length()) return num; // if no mismatch, no swap needed, return the original number\\n        int j = str.lastIndexOf(sortedString[i]); // find the last position of the mismatching digit in the original string\\n\\n        // Interchange digits in position i and j\\n        char temp = originalString[i];\\n        originalString[i] = originalString[j];\\n        originalString[j] = temp;\\n        \\n        return Integer.parseInt(new String(originalString));\\n    }\\n```"
		}
	],
	"id":"647",
	"title":"Maximum Swap",
	"content":"<p>\r\nGiven a non-negative integer, you could swap two digits <b>at most</b> once to get the maximum valued number. Return the maximum valued number you could get.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> 2736\r\n<b>Output:</b> 7236\r\n<b>Explanation:</b> Swap the number 2 and the number 7.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> 9973\r\n<b>Output:</b> 9973\r\n<b>Explanation:</b> No swap.\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The given number is in the range [0, 10<sup>8</sup>]</li>\r\n</ol>\r\n</p>",
	"frequency":"195",
	"ac_num":"16157"
}