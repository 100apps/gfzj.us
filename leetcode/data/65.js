{
	"difficulty":"3",
	"submit_num":"614811",
	"show_id":"65",
	"leetcode_id":"65",
	"answers":[
		{
			"lc_ans_id":"23741",
			"view":"34949",
			"top":"0",
			"title":"The worst problem i have ever met in this oj",
			"vote":"316",
			"content":"The description do not give a clear explantion of the definition of a valid Number,  we just use more and more trick to get the right solution. It's too bad, it's waste of my time"
		},
		{
			"lc_ans_id":"23738",
			"view":"24760",
			"top":"1",
			"title":"Clear Java solution with ifs",
			"vote":"172",
			"content":"All we need is to have a couple of flags so we can process the string in linear time:\\n\\n    public boolean isNumber(String s) {\\n        s = s.trim();\\n        \\n        boolean pointSeen = false;\\n        boolean eSeen = false;\\n        boolean numberSeen = false;\\n        boolean numberAfterE = true;\\n        for(int i=0; i<s.length(); i++) {\\n            if('0' <= s.charAt(i) && s.charAt(i) <= '9') {\\n                numberSeen = true;\\n                numberAfterE = true;\\n            } else if(s.charAt(i) == '.') {\\n                if(eSeen || pointSeen) {\\n                    return false;\\n                }\\n                pointSeen = true;\\n            } else if(s.charAt(i) == 'e') {\\n                if(eSeen || !numberSeen) {\\n                    return false;\\n                }\\n                numberAfterE = false;\\n                eSeen = true;\\n            } else if(s.charAt(i) == '-' || s.charAt(i) == '+') {\\n                if(i != 0 && s.charAt(i-1) != 'e') {\\n                    return false;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return numberSeen && numberAfterE;\\n    }\\n\\nWe start with trimming.\\n\\n - If we see `[0-9]` we reset the number flags.\\n - We can only see `.` if we didn't see `e` or `.`. \\n - We can only see `e` if we didn't see `e` but we did see a number. We reset numberAfterE flag.\\n - We can only see `+` and `-` in the beginning and after an `e`\\n - any other character break the validation.\\n\\nAt the and it is only valid if there was at least 1 number and if we did see an `e` then a number after it as well.\\n\\nSo basically the number should match this regular expression:\\n\\n`[-+]?(([0-9]+(.[0-9]*)?)|.[0-9]+)(e[-+]?[0-9]+)?`"
		},
		{
			"lc_ans_id":"23762",
			"view":"13536",
			"top":"2",
			"title":"A simple solution in cpp",
			"vote":"76",
			"content":"The idea is pretty straightforward. A valid number is composed of the significand and the exponent (which is optional). As we go through the string, do the following things one by one:\\n\\n 1. skip the leading whitespaces;\\n 3. check if the significand is valid. To do so, simply skip the leading sign and count the number of digits and the number of points. A valid significand has no more than one point and at least one digit. \\n 4. check if the exponent part is valid. We do this if the significand is followed by 'e'. Simply skip the leading sign and count the number of digits. A valid exponent contain at least one digit.\\n 5. skip the trailing whitespaces. We must reach the ending 0 if the string is a valid number. \\n \\n=======================================================\\n\\n    bool isNumber(const char *s) \\n    {\\n        int i = 0;\\n        \\n        // skip the whilespaces\\n        for(; s[i] == ' '; i++) {}\\n        \\n        // check the significand\\n        if(s[i] == '+' || s[i] == '-') i++; // skip the sign if exist\\n        \\n        int n_nm, n_pt;\\n        for(n_nm=0, n_pt=0; (s[i]<='9' && s[i]>='0') || s[i]=='.'; i++)\\n            s[i] == '.' ? n_pt++:n_nm++;       \\n        if(n_pt>1 || n_nm<1) // no more than one point, at least one digit\\n            return false;\\n        \\n        // check the exponent if exist\\n        if(s[i] == 'e') {\\n            i++;\\n            if(s[i] == '+' || s[i] == '-') i++; // skip the sign\\n            \\n            int n_nm = 0;\\n            for(; s[i]>='0' && s[i]<='9'; i++, n_nm++) {}\\n            if(n_nm<1)\\n                return false;\\n        }\\n        \\n        // skip the trailing whitespaces\\n        for(; s[i] == ' '; i++) {}\\n        \\n        return s[i]==0;  // must reach the ending 0 of the string\\n    }"
		},
		{
			"lc_ans_id":"23728",
			"view":"9312",
			"top":"3",
			"title":"A simple solution in Python based on DFA",
			"vote":"63",
			"content":"I was asked in the interview of linkedIn, writing it directly can be extremely complicated, for there are many special cases we have to deal with, and the code I wrote was messy. Then I failed to pass the interview. \\n\\nHere's a clear solution. With DFA we can easily get our idea into shape and then debug, and the source code is clear and simple.\\n\\n```\\nclass Solution(object):\\n  def isNumber(self, s):\\n      \"\"\"\\n      :type s: str\\n      :rtype: bool\\n      \"\"\"\\n      #define a DFA\\n      state = [{}, \\n              {'blank': 1, 'sign': 2, 'digit':3, '.':4}, \\n              {'digit':3, '.':4},\\n              {'digit':3, '.':5, 'e':6, 'blank':9},\\n              {'digit':5},\\n              {'digit':5, 'e':6, 'blank':9},\\n              {'sign':7, 'digit':8},\\n              {'digit':8},\\n              {'digit':8, 'blank':9},\\n              {'blank':9}]\\n      currentState = 1\\n      for c in s:\\n          if c >= '0' and c <= '9':\\n              c = 'digit'\\n          if c == ' ':\\n              c = 'blank'\\n          if c in ['+', '-']:\\n              c = 'sign'\\n          if c not in state[currentState].keys():\\n              return False\\n          currentState = state[currentState][c]\\n      if currentState not in [3,5,8,9]:\\n          return False\\n      return True\\n```\\n\\n\\n![enter image description here][1]\\n\\n\\n  [1]: http://normanyahq.github.io/static/files/valid_number_dfa.svg"
		},
		{
			"lc_ans_id":"23725",
			"view":"8723",
			"top":"4",
			"title":"[C++] My thought with DFA",
			"vote":"44",
			"content":"Code first\\n\\n    class Solution {\\n    public:\\n        bool isNumber(string str) {\\n            int state=0, flag=0; // flag to judge the special case \".\"\\n            while(str[0]==' ')  str.erase(0,1);//delete the  prefix whitespace \\n            while(str[str.length()-1]==' ') str.erase(str.length()-1, 1);//delete the suffix whitespace\\n            for(int i=0; i<str.length(); i++){\\n                if('0'<=str[i] && str[i]<='9'){\\n                    flag=1;\\n                    if(state<=2) state=2;\\n                    else state=(state<=5)?5:7;\\n                }\\n                else if('+'==str[i] || '-'==str[i]){\\n                    if(state==0 || state==3) state++;\\n                    else return false;\\n                }\\n                else if('.'==str[i]){\\n                    if(state<=2) state=6;\\n                    else return false;\\n                }\\n                else if('e'==str[i]){\\n                    if(flag&&(state==2 || state==6 || state==7)) state=3;\\n                    else return false;\\n                }\\n                else return false;\\n            }\\n            return (state==2 || state==5 || (flag&&state==6) || state==7);\\n        }\\n    };\\n\\n\\n**DFA**\\n\\n**Thank [@unknowcs][3], he came up with a brilliant provement in comments that making this a perfect DFA\\uff01**\\n\\nIt's just some states changes depend on inputs only.\\n\\nThere 8 state in my states in my DFA. \\nBelow is my **DFA transition diagram**.\\n\\n![DFA transition diagram][1]\\n\\n\\nor click picture here\\n[DFA transition diagram][2]\\n\\nThere are **5** kind of inputs in my DFA:\\n\\ndigit : number **0-9** for\\n\\n+,- : operator **+** or **-**(negative or positive)\\n\\nexp: **e**\\n\\ndot: **.** \\n\\nother: you can return **false** Immediately\\n\\n\\n**4 final States**  in my DFA transition diagram : **s2, s6, s7, s8**\\n\\n**If the state change to final state at last,  return true.**\\n\\ns2 can accept digits only :    +1  -23432  123 and etc\\n\\ns5 can accept exp expression: +2.4e+12   3e9  and etc\\n\\ns6 can accept decimals end with dot:  1.  -42.  and etc\\n(careful, what if there exist only one dot \".\"\\n**** I use a variable flag judging weather there existing numbers. cause 0. and .0 is valid and . is invalid ****\\n)\\n\\ns7 can accept decimals: +12.23, 87., 132\\n\\nIt is clear how DFA works in my pictures. We just need to handle the inputs, and update the state according to DFA.\\n\\n\\n  [1]: http://postimg.org/image/n7lsslmgz/\\n  [2]: http://postimg.org/image/n7lsslmgz\\n  [3]: https://oj.leetcode.com/discuss/user/uknowcs"
		},
		{
			"lc_ans_id":"23977",
			"view":"3357",
			"top":"5",
			"title":"A clean design solution By using design pattern",
			"vote":"40",
			"content":"This problem give me a good chance to convey the importance of good design. The problem is very vogue. The point here is not how you design a algorithm, it is how you handle all cases well. There is no a clear standard for whether is a number valid, is it  .50 ,  39.  a legal float point number? Are there only valid  formats given by the example? Is hex format such as 0x12ab legal? How about if we need to add another format such as roman number like \"I, II , IV\" as legal format. I found all solution are just plug logic into one function, there are lots of switch case, if else in there.  It is problematic, easy for bugs, difficult to add new features, and of course, in-reusable, and here I propose a design to handle this problem easily and nicely.\\n\\nFirst we we can give out an interface for this problem:\\n\\n    interface NumberValidate {\\n    \\n    \\tboolean validate(String s);\\n    }\\n\\nfor any string, we call validate and it return whether the given string is a valid number. Follow we can create concrete implementation for this interface, such as IntegeValidator, FloatValidator, ScienceValidator. and then using chain of responsibility design patter (from book of GOF) , chain all those validator  into a list, and feed the string to each one, if there is one validator return true, then the string is a valid number.\\n\\nThe design has two advantages, one is easy to fix, for any corner cases or bug, we can locate the problem to specific validator, the effect of changing one validator will not sprint out to the all system, we call this as \"encapsulation\".\\n\\nSecond is easy to extend, if we need to verify hex format or roman number format , we just need to create new validator and add to the chain, we call this advantage as \"close for modification open for extension\".\\n\\nFollow is code for the passed design:\\n\\n    interface NumberValidate {\\n    \\n    \\tboolean validate(String s);\\n    }\\n    \\n    abstract class  NumberValidateTemplate implements NumberValidate{\\n    \\n    public boolean validate(String s)\\n    \\t{\\n    \\t\\tif (checkStringEmpty(s))\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\ts = checkAndProcessHeader(s);\\n    \\t\\t\\n    \\t\\tif (s.length() == 0)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn doValidate(s);\\n    \\t}\\n    \\t\\n    \\tprivate boolean checkStringEmpty(String s)\\n    \\t{\\n    \\t\\tif (s.equals(\"\"))\\n    \\t\\t{\\n    \\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn false;\\n    \\t}\\n    \\t\\n    \\tprivate String checkAndProcessHeader(String value)\\n    \\t{\\n    \\t    value = value.trim();\\n    \\t    \\n    \\t\\tif (value.startsWith(\"+\") || value.startsWith(\"-\"))\\n    \\t\\t{\\n    \\t\\t\\tvalue = value.substring(1);\\n    \\t\\t}\\n    \\t\\n    \\t\\n    \\t\\treturn value;\\n    \\t}\\n    \\t\\n    \\t\\n    \\t\\n    \\tprotected abstract boolean doValidate(String s);\\n    }\\n    \\n    class NumberValidator implements NumberValidate {\\n    \\t\\n    \\tprivate ArrayList<NumberValidate> validators = new ArrayList<NumberValidate>();\\n    \\t\\n    \\tpublic NumberValidator()\\n    \\t{\\n    \\t\\taddValidators();\\n    \\t}\\n    \\n    \\tprivate  void addValidators()\\n    \\t{\\n    \\t\\tNumberValidate nv = new IntegerValidate();\\n    \\t\\tvalidators.add(nv);\\n    \\t\\t\\n    \\t\\tnv = new FloatValidate();\\n    \\t\\tvalidators.add(nv);\\n    \\t\\t\\n    \\t\\tnv = new HexValidate();\\n    \\t\\tvalidators.add(nv);\\n    \\t\\t\\n    \\t\\tnv = new SienceFormatValidate();\\n    \\t\\tvalidators.add(nv);\\n    \\t}\\n    \\t\\n    \\t@Override\\n    \\tpublic boolean validate(String s)\\n    \\t{\\n    \\t\\tfor (NumberValidate nv : validators)\\n    \\t\\t{\\n    \\t\\t\\tif (nv.validate(s) == true)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn false;\\n    \\t}\\n    \\n    \\t\\n    }\\n    \\n    class IntegerValidate extends NumberValidateTemplate{\\n    \\t\\n    \\tprotected boolean doValidate(String integer)\\n    \\t{\\n    \\t\\tfor (int i = 0; i < integer.length(); i++)\\n    \\t\\t{\\n    \\t\\t\\tif(Character.isDigit(integer.charAt(i)) == false)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn true;\\n    \\t}\\n    }\\n    \\n    class HexValidate extends NumberValidateTemplate{\\n    \\n    \\tprivate char[] valids = new char[] {'a', 'b', 'c', 'd', 'e', 'f'};\\n    \\tprotected boolean doValidate(String hex)\\n    \\t{\\n    \\t\\thex = hex.toLowerCase();\\n    \\t\\tif (hex.startsWith(\"0x\"))\\n    \\t\\t{\\n    \\t\\t\\thex = hex.substring(2);\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t    return false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor (int i = 0; i < hex.length(); i++)\\n    \\t\\t{\\n    \\t\\t\\tif (Character.isDigit(hex.charAt(i)) != true && isValidChar(hex.charAt(i)) != true)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn true;\\n    \\t}\\n    \\t\\n    \\tprivate boolean isValidChar(char c)\\n    \\t{\\n    \\t\\tfor (int i = 0; i < valids.length; i++)\\n    \\t\\t{\\n    \\t\\t\\tif (c == valids[i])\\n    \\t\\t\\t{\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn false;\\n    \\t}\\n    }\\n    \\n    class SienceFormatValidate extends NumberValidateTemplate{\\n    \\n    protected boolean doValidate(String s)\\n    \\t{\\n    \\t\\ts = s.toLowerCase();\\n    \\t\\tint pos = s.indexOf(\"e\");\\n    \\t\\tif (pos == -1)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif (s.length() == 1)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tString first = s.substring(0, pos);\\n    \\t\\tString second = s.substring(pos+1, s.length());\\n    \\t\\t\\n    \\t\\tif (validatePartBeforeE(first) == false || validatePartAfterE(second) == false)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\t\\n    \\t\\treturn true;\\n    \\t}\\n    \\t\\n    \\tprivate boolean validatePartBeforeE(String first)\\n    \\t{\\n    \\t\\tif (first.equals(\"\") == true)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif (checkHeadAndEndForSpace(first) == false)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tNumberValidate integerValidate = new IntegerValidate();\\n    \\t\\tNumberValidate floatValidate = new FloatValidate();\\n    \\t\\tif (integerValidate.validate(first) == false && floatValidate.validate(first) == false)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn true;\\n    \\t}\\n    \\t\\n    private boolean checkHeadAndEndForSpace(String part)\\n    \\t{\\n    \\t\\t\\n    \\t\\tif (part.startsWith(\" \") ||\\n    \\t\\t\\t\\tpart.endsWith(\" \"))\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn true;\\n    \\t}\\n    \\t\\n    \\tprivate boolean validatePartAfterE(String second)\\n    \\t{\\n    \\t\\tif (second.equals(\"\") == true)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif (checkHeadAndEndForSpace(second) == false)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tNumberValidate integerValidate = new IntegerValidate();\\n    \\t\\tif (integerValidate.validate(second) == false)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn true;\\n    \\t}\\n    }\\n    \\n    class FloatValidate extends NumberValidateTemplate{\\n    \\t\\n       protected boolean doValidate(String floatVal)\\n    \\t{\\n    \\t\\tint pos = floatVal.indexOf(\".\");\\n    \\t\\tif (pos == -1)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif (floatVal.length() == 1)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tNumberValidate nv = new IntegerValidate();\\n    \\t\\tString first = floatVal.substring(0, pos);\\n    \\t\\tString second = floatVal.substring(pos + 1, floatVal.length());\\n    \\t\\t\\n    \\t\\tif (checkFirstPart(first) == true && checkFirstPart(second) == true)\\n    \\t\\t{\\n    \\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn false;\\n    \\t}\\n    \\t\\n    \\tprivate boolean checkFirstPart(String first)\\n    \\t{\\n    \\t    if (first.equals(\"\") == false && checkPart(first) == false)\\n    \\t    {\\n    \\t    \\treturn false;\\n    \\t    }\\n    \\t    \\n    \\t    return true;\\n    \\t}\\n    \\t\\n    \\tprivate boolean checkPart(String part)\\n    \\t{\\n    \\t   if (Character.isDigit(part.charAt(0)) == false ||\\n    \\t\\t\\t\\tCharacter.isDigit(part.charAt(part.length() - 1)) == false)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tNumberValidate nv = new IntegerValidate();\\n    \\t\\tif (nv.validate(part) == false)\\n    \\t\\t{\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn true;\\n    \\t}\\n    }\\n    \\n    public class Solution {\\n        public boolean isNumber(String s) {\\n            NumberValidate nv = new NumberValidator();\\n    \\n    \\t    return nv.validate(s);\\n        }\\n    }"
		},
		{
			"lc_ans_id":"23785",
			"view":"3391",
			"top":"6",
			"title":"Java logically simple, flexible and clear solution including rules of a valid number",
			"vote":"24",
			"content":"The idea is to identify the rules of a valid number first, then set boolean variables to mark key characters and judge the validity. \\n\\nThis solution is logically simple and easy to understand, and moreover, it is flexible to extend to the cases where a string of a valid number can accept any space appears anywhere, or/and the exponent can be a decimal number.\\n\\n\\n    public boolean isNumber(String s) {\\n\\t\\t\\t/**\\n\\t\\t\\t * isNumber(s)==true if and only if s=s1 or s1+'e'+s2, where s1, s2\\n\\t\\t\\t * are valid strings of a number without the char 'e', and s2 is an\\n\\t\\t\\t * integer.\\n\\t\\t\\t * \\n\\t\\t\\t * 'e' : valid_count=0~1; [boolean hasE]\\n\\t\\t\\t * \\n\\t\\t\\t * Valid chars in a string of a number without 'e':\\n\\t\\t\\t * \\n\\t\\t\\t * ' ' : valid_count=0~n; must appear at two ends\\n\\t\\t\\t * \\n\\t\\t\\t * '+/-' : valid_count=0~1; must be the first non-space valid char;\\n\\t\\t\\t * [boolean hasFirst]\\n\\t\\t\\t * \\n\\t\\t\\t * '.' : valid_count=0~1; cannot appear after 'e'; [boolean hasDot]\\n\\t\\t\\t * \\n\\t\\t\\t * '0~9' : valid_count=1~n; [boolean hasDigit]\\n\\t\\t\\t */\\n\\n\\t\\t\\ts = s.trim();\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tif (n == 0)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tboolean hasE, hasFirst, hasDot, hasDigit;\\n\\t\\t\\thasE = hasFirst = hasDot = hasDigit = false;\\n\\n\\t\\t\\tchar c;\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tc = s.charAt(i);\\n\\n\\t\\t\\t\\tif (c >= '0' && c <= '9') {\\n\\t\\t\\t\\t\\thasFirst = hasDigit = true;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t * case ' ': continue;\\n\\t\\t\\t\\t */ // extend to accept any space everywhere\\n\\t\\t\\t\\tcase 'e':\\n\\t\\t\\t\\t\\t// already has 'e' or no digit before 'e'\\n\\t\\t\\t\\t\\tif (hasE || !hasDigit)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\thasE = true;\\n\\n\\t\\t\\t\\t\\t// reset for the exponential number\\n\\t\\t\\t\\t\\thasFirst = hasDigit = false;\\n\\t\\t\\t\\t\\thasDot = true; // the exponent must be an integer, hence\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// regard as if a dot exists already. Set\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// hasDot = false extending to accept any\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// (decimal) number as an exponent.\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tcase '+':\\n\\t\\t\\t\\tcase '-':\\n\\t\\t\\t\\t\\tif (hasFirst)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\thasFirst = true;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tcase '.':\\n\\t\\t\\t\\t\\tif (hasDot)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\thasFirst = hasDot = true;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn hasDigit;\\n\\t\\t}"
		},
		{
			"lc_ans_id":"23942",
			"view":"1497",
			"top":"7",
			"title":"AC Java solution with clear explanation",
			"vote":"18",
			"content":"    public class Solution {\\n        public boolean isNumber(String s) {\\n            if (s == null) return false;\\n            \\n            s = s.trim();\\n            int n = s.length();\\n            \\n            if (n == 0) return false;\\n            \\n            // flags\\n            int signCount = 0;\\n            boolean hasE = false;\\n            boolean hasNum = false;\\n            boolean hasPoint = false;\\n            \\n            for (int i = 0; i < n; i++) {\\n                char c = s.charAt(i);\\n                \\n                // invalid character\\n                if (!isValid(c)) return false;\\n                \\n                // digit is always fine\\n                if (c >= '0' && c <= '9') hasNum = true;\\n                \\n                // e or E\\n                if (c == 'e' || c == 'E') {\\n                    // e cannot appear twice and digits must be in front of it\\n                    if (hasE || !hasNum) return false;\\n                    // e cannot be the last one\\n                    if (i == n - 1) return false;\\n                    \\n                    hasE = true;\\n                }\\n                \\n                // decimal place\\n                if (c == '.') {\\n                    // . cannot appear twice and it cannot appear after e\\n                    if (hasPoint || hasE) return false;\\n                    // if . is the last one, digits must be in front of it, e.g. \"7.\"\\n                    if (i == n - 1 && !hasNum) return false;\\n                    \\n                    hasPoint = true;\\n                }\\n                \\n                // signs\\n                if (c == '+' || c == '-') {\\n                    // no more than 2 signs\\n                    if (signCount == 2) return false;\\n                    // sign cannot be the last one\\n                    if (i == n - 1) return false;\\n                    // sign can appear in the middle only when e appears in front\\n                    if (i > 0 && !hasE) return false;\\n                    \\n                    signCount++;\\n                }\\n            }\\n            \\n            return true;\\n        }\\n        \\n        boolean isValid(char c) {\\n            return c == '.' || c == '+' || c == '-' || c == 'e' || c == 'E' || c >= '0' && c <= '9';\\n        }\\n    }"
		},
		{
			"lc_ans_id":"24046",
			"view":"3414",
			"top":"8",
			"title":"Java solution with one line",
			"vote":"18",
			"content":"return s.matches(\"(\\\\\\\\\\\\s\\\\*)[+-]?((\\\\\\\\\\\\\\\\.[0-9]+)|([0-9]+(\\\\\\\\\\\\\\\\.[0-9]*)?))(e[+-]?[0-9]+)?(\\\\\\\\\\\\s\\\\*)\");"
		},
		{
			"lc_ans_id":"23723",
			"view":"1571",
			"top":"9",
			"title":"C++ 12 ms,Give some invalid examples,easily understand",
			"vote":"17",
			"content":"    class Solution {\\n    public:\\n        bool isNumber(string s) {\\n            //\"1 1\"is not valid, \"0x11\" is not valid, \".\" is not valid, \"2e3.1\" is not valid, \"2e\" is not valid,\"1a\" is not valid,\"++1\" is not valid\\n            int n = s.size();\\n            if(n == 0) return false;\\n            int i = 0;\\n            int count_num = 0,count_point = 0;\\n            while(s[i] == ' ') i++;\\n            if(s[i] == '+' || s[i] == '-') i++;\\n            while(isdigit(s[i]) || s[i] == '.') s[i++] == '.'?count_point++:count_num++;\\n            if(count_point > 1 || count_num < 1) return false;\\n            if(s[i] == 'e'){\\n                i++;\\n                count_num = 0;count_point = 0;\\n                if(s[i] == '+' || s[i] == '-') i++;\\n                while(isdigit(s[i]) || s[i] == '.') s[i++] == '.'?count_point++:count_num++;\\n                if(count_point > 0 || count_num < 1) return false;\\n            }\\n            while(s[i] == ' ') i++;\\n            return i == n;\\n        }\\n    };"
		}
	],
	"id":"65",
	"title":"Valid Number",
	"content":"<p>Validate if a given string is numeric.</p>\r\n\r\n<p>\r\nSome examples:<br />\r\n<code>\"0\"</code> => <code>true</code><br />\r\n<code>\"   0.1  \"</code> => <code>true</code><br />\r\n<code>\"abc\"</code> => <code>false</code><br />\r\n<code>\"1 a\"</code> => <code>false</code><br />\r\n<code>\"2e10\"</code> => <code>true</code><br />\r\n</p>\r\n\r\n<p><b>Note:</b> It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.\r\n</p>\r\n\r\n<p>\r\n<b><font color=\"red\">Update (2015-02-10):</font></b><br>\r\nThe signature of the <code>C++</code> function had been updated. If you still see your function signature accepts a <code>const char *</code> argument, please click the reload button <span class=\"glyphicon glyphicon-refresh\"></span> to reset your code definition.\r\n</p>",
	"frequency":"438",
	"ac_num":"79531"
}