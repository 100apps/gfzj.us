{
	"difficulty":"3",
	"submit_num":"16842",
	"show_id":"675",
	"leetcode_id":"675",
	"answers":[
		{
			"lc_ans_id":"107404",
			"view":"5096",
			"top":"0",
			"title":"Java solution, PriorityQueue + BFS",
			"vote":"28",
			"content":"1. Since we have to cut trees in order of their height, we first put trees (int[] {row, col, height}) into a priority queue and sort by height.\\n2. Poll each tree from the queue and use BFS to find out steps needed.\\n\\nThe worst case time complexity could be O(m^2 * n^2) (m = number of rows, n = number of columns) since there are m * n trees and for each BFS worst case time complexity is O(m * n) too.\\n```\\nclass Solution {\\n    static int[][] dir = {{0,1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if (forest == null || forest.size() == 0) return 0;\\n        int m = forest.size(), n = forest.get(0).size();\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (forest.get(i).get(j) > 1) {\\n                    pq.add(new int[] {i, j, forest.get(i).get(j)});\\n                }\\n            }\\n        }\\n\\n        int[] start = new int[2];\\n        int sum = 0;\\n        while (!pq.isEmpty()) {\\n            int[] tree = pq.poll();\\n            int step = minStep(forest, start, tree, m, n);\\n\\n            if (step < 0) return -1;\\n            sum += step;\\n\\n            start[0] = tree[0];\\n            start[1] = tree[1];\\n        }\\n\\n        return sum;\\n    }\\n\\n    private int minStep(List<List<Integer>> forest, int[] start, int[] tree, int m, int n) {\\n        int step = 0;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(start);\\n        visited[start[0]][start[1]] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] curr = queue.poll();\\n                if (curr[0] == tree[0] && curr[1] == tree[1]) return step;\\n\\n                for (int[] d : dir) {\\n                    int nr = curr[0] + d[0];\\n                    int nc = curr[1] + d[1];\\n                    if (nr < 0 || nr >= m || nc < 0 || nc >= n \\n                        || forest.get(nr).get(nc) == 0 || visited[nr][nc]) continue;\\n                    queue.add(new int[] {nr, nc});\\n                    visited[nr][nc] = true;\\n                }\\n            }\\n            step++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"107416",
			"view":"2805",
			"top":"1",
			"title":"Very simple Python BFS,  But Why TLE??",
			"vote":"16",
			"content":"I thought it is a straightforward BFS search, so I write it like the following. \\nActually, I have the same question with `Number of Island` problem:\\nhttps://discuss.leetcode.com/topic/88586/why-python-bfs-get-time-exceed-error\\n\\n\\n```\\nimport collections\\nclass Solution(object):\\n    def cutOffTree(self, G):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not G or not G[0]: return -1\\n        m, n = len(G), len(G[0])\\n        trees = []\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if G[i][j] > 1:\\n                    trees.append((G[i][j], i, j))\\n        trees = sorted(trees)\\n        count = 0\\n        cx, cy = 0, 0\\n        for h, x, y in trees:\\n            step = self.BFS(G, cx, cy, x, y)\\n            if step == -1:\\n                return -1\\n            else:\\n                count += step\\n                G[x][y] = 1\\n                cx, cy = x, y\\n        return count\\n\\n    def BFS(self, G, cx, cy, tx, ty):\\n        m, n = len(G), len(G[0])\\n        visited = [[False for j in xrange(n)] for i in xrange(m)]\\n        Q = collections.deque()\\n        step = -1\\n        Q.append((cx, cy))\\n        while len(Q) > 0:\\n            size = len(Q)\\n            step += 1\\n            for i in xrange(size):\\n                x, y = Q.popleft()\\n                visited[x][y] = True\\n                if x == tx and y == ty:\\n                    return step\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y-1), (x, y + 1)]:\\n                    if nx < 0 or nx >= m or ny < 0 or ny >= n or G[nx][ny] == 0 or visited[nx][ny]:\\n                        continue\\n                    Q.append((nx, ny))\\n        return -1\\n```"
		},
		{
			"lc_ans_id":"107396",
			"view":"1101",
			"top":"2",
			"title":"Python solution based on wufangjie's (Hadlock's algorithm?)",
			"vote":"11",
			"content":"Just my own very similar implementation of @wufangjie's [solution](https://discuss.leetcode.com/topic/103532/my-python-solution-inspired-by-a-algorithm) (and some terminology from the Hadlock algorithm which @awice mentioned to me), with some more explanation. Gets accepted in about 700 ms.\\n\\nBasically find the trees, sort them by order, find the distance from each tree to the next, and sum those distances. But how to find the distance from one cell to some other cell? BFS is far to slow for the current test suite. Instead use what's apparently known as \"Hadlock's Algorithm\" (though I've only seen high-level descriptions of that). First try paths with no detour (only try steps in the direction towards the goal), then if necessary try paths with one detour step, then paths with two detour steps, etc. The distance then is the Manhattan distance plus twice the number of detour steps (twice because you'll have to make up for a detour step with a later step back towards the goal).\\n\\nHow to implement that?\\n- Round 1: Run a DFS only on cells that you can reach from the start cell with no detour towards the goal, i.e., only walking in the direction towards the goal. If this reaches the goal, we're done. Otherwise...\\n- Round 2: Try again, but this time try starting from all those cells reachable with one detour step. Collect these in round 1.\\n- Round 3: If round 2 fails, try again but start from all those cells reachable with two detour steps. Collect these in round 2.\\n- And so on...\\n\\nIf there are no obstacles, then this directly walks a shortest path towards the goal, which is of course very fast. Much better than BFS which would waste time looking in all directions. With only a few obstacles, it's still close to optimal.\\n\\nMy `distance` function does this searching algorithm. I keep the current to-be-searched cells in my `now` stack. When I move to a neighbor that's closer to the goal, I also put it in `now`. If it's not closer, then that's a detour step so I just remember it on my `soon` stack for the next round.\\n\\n    def cutOffTree(self, forest):\\n\\n        # Add sentinels (a border of zeros) so we don't need index-checks later on.\\n        forest.append([0] * len(forest[0]))\\n        for row in forest:\\n            row.append(0)\\n\\n        # Find the trees.\\n        trees = [(height, i, j)\\n                 for i, row in enumerate(forest)\\n                 for j, height in enumerate(row)\\n                 if height > 1]\\n\\n        # Can we reach every tree? If not, return -1 right away.\\n        queue = [(0, 0)]\\n        reached = set()\\n        for i, j in queue:\\n            if (i, j) not in reached and forest[i][j]:\\n                reached.add((i, j))\\n                queue += (i+1, j), (i-1, j), (i, j+1), (i, j-1)\\n        if not all((i, j) in reached for (_, i, j) in trees):\\n            return -1\\n\\n        # Distance from (i, j) to (I, J).\\n        def distance(i, j, I, J):\\n            now, soon = [(i, j)], []\\n            expanded = set()\\n            manhattan = abs(i - I) + abs(j - J)\\n            detours = 0\\n            while True:\\n                if not now:\\n                    now, soon = soon, []\\n                    detours += 1\\n                i, j = now.pop()\\n                if (i, j) == (I, J):\\n                    return manhattan + 2 * detours\\n                if (i, j) not in expanded:\\n                    expanded.add((i, j))\\n                    for i, j, closer in (i+1, j, i < I), (i-1, j, i > I), (i, j+1, j < J), (i, j-1, j > J):\\n                        if forest[i][j]:\\n                            (now if closer else soon).append((i, j))\\n\\n        # Sum the distances from one tree to the next (sorted by height).\\n        trees.sort()\\n        return sum(distance(i, j, I, J) for (_, i, j), (_, I, J) in zip([(0, 0, 0)] + trees, trees))"
		},
		{
			"lc_ans_id":"107415",
			"view":"1240",
			"top":"3",
			"title":"my python solution, inspired by A* algorithm",
			"vote":"8",
			"content":"The expected min distance between p1 and p2 is d = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]). \\nFrom p1 (or the following positions), we may have two choices, move a step towards p2 or a step far away from p2 (if we do this, the min distance we can expect is d + 2, so we needn't think about them until all the expected min distance way are blocked). \\nAnd I use stack to find the possible way greedily. \\nHere is my code:\\n```\\nclass Solution(object):\\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        nrow, ncol = len(forest), len(forest[0])\\n        forest.append([0] * ncol)\\n        for row in forest:\\n            row.append(0)\\n\\n        trees = {(i, j) for i in range(nrow) for j in range(ncol)\\n                 if forest[i][j] > 1}\\n\\n        canReach = {(0, 0)}\\n        stack = [(0, 0)]\\n        while stack:\\n            i, j = stack.pop()\\n            for i2, j2 in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                if forest[i2][j2] != 0 and (i2, j2) not in canReach:\\n                    canReach.add((i2, j2))\\n                    stack.append((i2, j2))\\n\\n        if trees.difference(canReach):\\n            return -1\\n\\n        def get_sp(p1, p2):\\n            theMin = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\\n            stack1, stack2 = [p1], []\\n            used, visited = {p1}, {p1}\\n\\n            while 1:\\n                if not stack1:\\n                    stack1, stack2 = stack2, stack1\\n                    used.update(stack1)\\n                    theMin += 2\\n\\n                p = stack1.pop()\\n                if p == p2:\\n                    break\\n\\n                i, j = p\\n                add1, add2 = [], []\\n\\n                if i == p2[0]:\\n                    add2.append((i - 1, j))\\n                    add2.append((i + 1, j))\\n                elif i < p2[0]:\\n                    add2.append((i - 1, j))\\n                    add1.append((i + 1, j))\\n                else:\\n                    add1.append((i - 1, j))\\n                    add2.append((i + 1, j))\\n\\n                if j == p2[1]:\\n                    add2.append((i, j - 1))\\n                    add2.append((i, j + 1))\\n                elif j < p2[1]:\\n                    add2.append((i, j - 1))\\n                    add1.append((i, j + 1))\\n                else:\\n                    add1.append((i, j - 1))\\n                    add2.append((i, j + 1))\\n\\n                for v in add1:\\n                    if forest[v[0]][v[1]] != 0 and v not in used:\\n                        visited.add(v)\\n                        used.add(v)\\n                        stack1.append(v)\\n                for v in add2:\\n                    if forest[v[0]][v[1]] != 0 and v not in visited:\\n                        visited.add(v)\\n                        stack2.append(v)\\n\\n            return theMin\\n\\n        seq = sorted(trees, key=lambda x: forest[x[0]][x[1]])\\n        if seq[0] != (0, 0):\\n            seq.insert(0, (0, 0))\\n        return sum(get_sp(seq[i], seq[i + 1]) for i in range(len(seq) - 1))\\n```"
		},
		{
			"lc_ans_id":"107403",
			"view":"1115",
			"top":"4",
			"title":"C++, Sort + BFS with explanation",
			"vote":"4",
			"content":"The solution has two steps:\\n```\\n1) Sort tree positions based on tree height; \\n2) BFS to find shortest path between two points; \\n```\\nThe end point of current path is the starting point of next path. Priority_queue also works, but may be slower than simple sort due to both push and pop operations.\\n\\nThe run time is up to O(m^2 n^2) where m and n is the matrix size. \\n```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        if (forest.empty() || forest[0].empty()) return 0;\\n        int m = forest.size(), n = forest[0].size();\\n        vector<vector<int>> trees;\\n        // get all the tree positions and sort based on height\\n        // trees[i][0] is height. The default comparison of vector compare first element before other elements.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (forest[i][j] > 1) trees.push_back({forest[i][j], i, j});\\n            }\\n        }\\n        sort(trees.begin(), trees.end());\\n        int ans = 0;\\n        // accumulate all the paths\\n        for (int i = 0, cur_row = 0, cur_col = 0; i < trees.size(); i++) {\\n            int step = next_step(forest, cur_row, cur_col, trees[i][1], trees[i][2]);\\n            // if next tree cannot be reached, step = -1;\\n            if (step == -1) return -1;\\n            ans += step;\\n            cur_row = trees[i][1];\\n            cur_col = trees[i][2];\\n        }\\n        return ans;\\n    }\\nprivate:\\n    // BFS to find shortest path to next tree; if cannot reach next tree, return -1\\n    int next_step(vector<vector<int>>& forest, int sr, int sc, int er, int ec) {\\n        if (sr == er && sc == ec) return 0;\\n        int m = forest.size(), n = forest[0].size();\\n        queue<pair<int, int>> myq;\\n        myq.push({sr, sc}); \\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        visited[sr][sc] = 1;\\n        int step = 0;\\n        vector<int> dir = {-1, 0, 1, 0, -1};\\n        while (!myq.empty()) {\\n            step++;\\n            int sz = myq.size();\\n            for (int i = 0; i < sz; i++) {\\n                int row = myq.front().first, col = myq.front().second;\\n                myq.pop();\\n                for (int i = 0; i < 4; i++) {\\n                    int r = row + dir[i], c = col + dir[i+1];\\n                    if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c] == 1 || forest[r][c] == 0) continue;\\n                    if (r == er && c == ec) return step;\\n                    visited[r][c] = 1;\\n                    myq.push({r, c});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"107398",
			"view":"1141",
			"top":"5",
			"title":"[Java/C++] Straightforward solution - sorted array + BFS",
			"vote":"2",
			"content":"My idea to solve this problem is by two steps:\\n1. Save each ```{tree height, tree position}``` into an array ```heights```, and then sort this array based on  its ```tree height```. (You can also do this by using ```TreeMap``` or  ```PriorityQueue```);\\n2. Accumulate the shortest steps between each two adajacent points in ```heights[]```.\\n\\nJava version:\\n```\\nclass Solution {\\n    int[][] dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int cutOffTree(List<List<Integer>> forest) {\\n        if (forest == null || forest.size() == 0) return -1;\\n        int m = forest.size(), n = forest.get(0).size(), res = 0;\\n        //first step: sort the tree position based on its height\\n        List<int[]> heights = new ArrayList<>();\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(forest.get(i).get(j) > 1)heights.add( new int[]{forest.get(i).get(j), i, j} );\\n            }\\n        }\\n        Collections.sort(heights, new Comparator<int[]>() {\\n            public int compare(int[] arr1, int[] arr2) {\\n                return Integer.compare(arr1[0], arr2[0]);\\n            }\\n        });\\n        //second step: accumulate the shortest steps between each two adajacent points in heights[].\\n        int start_x = 0, start_y = 0; \\n        for(int i = 0; i<heights.size(); i++){\\n            int cnt_steps = BFS(forest, m, n, start_x, start_y, heights.get(i)[1], heights.get(i)[2]); \\n            if(cnt_steps == -1)return -1;\\n            res += cnt_steps;\\n            start_x = heights.get(i)[1]; \\n            start_y = heights.get(i)[2];\\n        }\\n        return res;\\n    }\\n    \\n    public int BFS(List<List<Integer>> forest, int m, int n, int start_x, int start_y, int des_x, int des_y){\\n        if(start_x == des_x && start_y == des_y)return 0;\\n        int steps = 0;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{start_x, start_y});\\n        int[][] visited = new int[m][n];\\n        visited[start_x][start_y] = 1;\\n        while(!q.isEmpty()){\\n            int qsize = q.size();\\n            steps++;\\n            while(qsize-- >0 ){\\n                int[] cur = q.poll();\\n                int cur_x = cur[0], cur_y = cur[1];\\n                for(int k = 0; k<4; k++){\\n                    int x = cur_x + dir[k][0], y = cur_y + dir[k][1];\\n                    if(x>=0 && x<m && y>=0 && y<n && forest.get(x).get(y) > 0 && visited[x][y] == 0){\\n                        if(x == des_x && y == des_y)return steps;\\n                        visited[x][y] = 1;\\n                        q.add(new int[]{x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nC++ version:\\n```\\nclass Solution {\\npublic:    \\n    vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        int m = forest.size(), n , res = 0;\\n        if(m == 0)return -1;\\n        n = forest[0].size();\\n        //first step: sort the tree position based on its height\\n        vector<vector<int>> heights;\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(forest[i][j] > 1)heights.push_back({forest[i][j], i, j});\\n            }\\n        }\\n        sort(heights.begin(), heights.end());\\n        //second step: accumulate the shortest steps between each two adajacent points in heights[].\\n        int start_x = 0, start_y = 0; \\n        for(int i = 0; i<heights.size(); i++){\\n            int cnt_steps = BFS(forest, m, n, start_x, start_y, heights[i][1], heights[i][2]); \\n            if(cnt_steps == -1)return -1;\\n            res += cnt_steps;\\n            start_x = heights[i][1], start_y = heights[i][2];\\n        }\\n        return res;\\n    }\\n    \\n    int BFS(vector<vector<int>>& forest, int m, int n, int start_x, int start_y, int des_x, int des_y){\\n        if(start_x == des_x && start_y == des_y)return 0;\\n        int steps = 0;\\n        queue<pair<int, int>> q;\\n        q.push({start_x, start_y});\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        visited[start_x][start_y] = 1;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            steps++;\\n            while(qsize-- >0 ){\\n                int cur_x = q.front().first, cur_y = q.front().second;\\n                q.pop();\\n                for(int k = 0; k<4; k++){\\n                    int x = cur_x + dir[k][0], y = cur_y + dir[k][1];\\n                    if(x>=0 && x<m && y>=0 && y<n && forest[x][y] > 0 && visited[x][y] == 0){\\n                        if(x == des_x && y == des_y)return steps;\\n                        visited[x][y] = 1;\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"107414",
			"view":"345",
			"top":"6",
			"title":"2D Array is faster than original List<List<>>(JAVA)",
			"vote":"1",
			"content":"I have tried to convert the original List to a 2D Array, finding that the speed of BFS is much faster than using original List.\\n\\nHope you guys know this."
		},
		{
			"lc_ans_id":"107418",
			"view":"280",
			"top":"7",
			"title":"Python solution with detailed explanation",
			"vote":"1",
			"content":"**Cut Off Trees for Golf Event** https://leetcode.com/problems/cut-off-trees-for-golf-event/description/\\n\\n**BFS based solution (in Python gives TLE)**\\n* Use a priority queue to arrange all trees in ascending height order.\\n* Then simply use BFS to find the minimum steps between consecutive trees.\\n* Time complexity: O(m^2 * n^2)\\n```\\nfrom heapq import heappop, heappush\\nfrom collections import deque\\n\\nclass Solution:\\n    def build_pq(self, forest):\\n        pq = []\\n        for i in range(len(forest)):\\n            for j in range(len(forest[0])):\\n                if forest[i][j] > 1:\\n                    heappush(pq, (forest[i][j], i, j))\\n        return pq\\n    \\n    def process_level(self, forest, dq, seen, xdest, ydest):\\n        M,N = len(forest), len(forest[0])\\n        for _ in range(len(dq)):\\n            x2, y2 = dq.popleft()\\n            if x2 == xdest and y2 == ydest:\\n                return True\\n            for xn,yn in ((x2-1,y2),(x2+1,y2),(x2,y2-1),(x2,y2+1)):\\n                if 0<=xn<M and 0<=yn<N and forest[xn][yn] != 0 and (xn,yn) not in seen:\\n                    dq.append((xn,yn))\\n                    seen.add((xn,yn))\\n        return False\\n    \\n    def find_steps_bfs(self, forest, start, dest):\\n        dq = deque()\\n        dq.append((start[0], start[1]))\\n        seen = set()\\n        steps = 0\\n        while dq:\\n            found = self.process_level(forest, dq, seen, dest[0], dest[1])\\n            if found:\\n                break\\n            else:\\n                steps += 1\\n        return steps if found else -1\\n    \\n    def cutOffTree(self, forest):\\n        \"\"\"\\n        :type forest: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        pq = self.build_pq(forest)\\n        xstart, ystart, steps = 0, 0, 0\\n        while pq:\\n            ht, xdest, ydest = heappop(pq)\\n            curr_step = self.find_steps_bfs(forest, (xstart, ystart), (xdest, ydest))\\n            if curr_step == -1:\\n                return -1\\n            else:\\n                steps += curr_step\\n            xstart, ystart = xdest, ydest\\n        return steps    \\n```"
		},
		{
			"lc_ans_id":"107427",
			"view":"227",
			"top":"8",
			"title":"C++ BFS with optimization, 86ms beats 100%",
			"vote":"1",
			"content":"If you are going from (x1,y1) to (x2,y2), instead of doing 4-direction (up,down,left,right) BFS, we can first do 2-direction BFS to see if there exists a shortest path from source to destination.\\n\\ne.g. going from S(x1,y1) to T(x2,y2) we know we have to take lower-right direction, that is, either go right or down. ```'X'``` is obstacle, ```'*'``` is current layer, shortest length = 5, going step by step as follow:\\n```\\n[S, , , ]     [ ,*, , ]    [ , ,*, ]    [ , , ,*]    [ , , , ]    [ , , , ]\\n[ , ,X, ] ->  [*, ,X, ] -> [ ,*,X, ] -> [ , ,X, ] -> [ , ,X,*] -> [ , ,X, ]\\n[X, , ,T]     [X, , ,T]    [X, , , ]    [X,*, , ]    [X, ,*, ]    [X, , ,*]     \\n```\\nIf there is no shortest path available and have to make a detour, then we have to do conventional BFS.\\ne.g.\\n```\\n[ ,X, , , ]\\n[ ,S, ,X, ]\\n[ , , ,X, ] \\n[ , ,X, ,T]     \\n[X, , , , ] \\n```\\nThis is very efficient if obstacle is sparse in the forest.\\n```\\nclass Solution {\\npublic:\\n    int cutOffTree(vector<vector<int>>& forest) {\\n        vector<vector<int>> trees; //vector<[height,i,j]>\\n        for(int i=0; i<forest.size(); ++i)\\n            for(int j=0; j<forest[0].size(); ++j)\\n                if(forest[i][j]>1)\\n                    trees.push_back(vector<int>({forest[i][j],i,j}));\\n        sort(trees.begin(),trees.end(),[](vector<int>& a, vector<int>& b){\\n            return a[0]<b[0]; //sort by tree's height\\n        });\\n        \\n        //doing DFS to see if every tree is available from (0,0)\\n        int tree_available = 0;\\n        vector<vector<bool>> visited(forest.size(),vector<bool>(forest[0].size(),false));\\n        DFS(0,0,visited,forest,tree_available);\\n        if(tree_available != trees.size())   return -1; //some trees are not available from (0,0)\\n        \\n        int step = 0;\\n        int si=0, sj=0;\\n        for(int i=0; i<trees.size(); ++i){\\n            // optimization here, if there are no obstacles blocking the shortest path, return the shortest length \\n            // no need to do the 4-direction BFS\\n            if(ShortestPathAvailable(si,sj,trees[i][1],trees[i][2],forest))\\n                step += abs(si-trees[i][1])+abs(sj-trees[i][2]);\\n            else\\n                step += BFS(si,sj,trees[i][1],trees[i][2],forest);\\n            si = trees[i][1];\\n            sj = trees[i][2];\\n        }\\n        \\n        return step;\\n    }\\n    \\n    void DFS(int i, int j, vector<vector<bool>>& visited, const vector<vector<int>>& forest, int& count){\\n        if(i<0 || i>=forest.size() || j<0 || j>=forest[0].size() || visited[i][j] || forest[i][j]==0)  return;\\n        visited[i][j] = true;\\n        if(forest[i][j]>1)  count++;\\n        DFS(i+1,j,visited,forest,count);\\n        DFS(i-1,j,visited,forest,count);\\n        DFS(i,j+1,visited,forest,count);\\n        DFS(i,j-1,visited,forest,count);\\n    }\\n    \\n    //return the minimum step from (si,sj) to (ti,tj)\\n    int BFS(int si, int sj, int ti, int tj, const vector<vector<int>>& forest){\\n        vector<vector<bool>> visited(forest.size(),vector<bool>(forest[0].size(),false));\\n        visited[si][sj] = true;\\n        queue<pair<int,int>> q({make_pair(si,sj)});\\n        int len = 0;\\n        int di[4] = {1,0,-1,0};\\n        int dj[4] = {0,1,0,-1};\\n        while(true){\\n            int qsize = q.size();\\n            while(qsize--){\\n                if(q.front().first==ti && q.front().second==tj) //the function stops here\\n                    return len; \\n                for(int k=0; k<4; ++k){\\n                    int i=q.front().first+di[k];\\n                    int j=q.front().second+dj[k];\\n                    if(i>=0 && i<forest.size() && j>=0 && j<forest[0].size() && !visited[i][j] && forest[i][j]>0){\\n                        visited[i][j] = true;\\n                        q.push(make_pair(i,j));\\n                    }\\n                }\\n                q.pop();\\n            }\\n            ++len;\\n        }\\n        return -999999; //redundancy, never goes this line\\n    }\\n    \\n    // check if there exists a shortest path avail from (x1,y1) to (x2,y2) going one out of 4 directions :\\n    // upper-left , upper-right , lower-left , lower-right\\n    /*  e.g. going from S(x1,y1) to T(x2,y2), 'X' is obstacle, '*' is current layer\\n        lower-right direction, minumum step = 5, going step by step as follow\\n        [S, , , ]     [ ,*, , ]    [ , ,*, ]    [ , , ,*]    [ , , , ]    [ , , , ]\\n        [ , ,X, ] ->  [*, ,X, ] -> [ ,*,X, ] -> [ , ,X, ] -> [ , ,X,*] -> [ , ,X, ]\\n        [X, , ,T]     [X, , , ]    [X, , , ]    [X,*, , ]    [X, ,*, ]    [X, , ,*]     \\n                        step 1       step 2       step 3       step 4       step 5\\n    */\\n    bool ShortestPathAvailable(int x1, int y1, int x2, int y2, const vector<vector<int>>& forest){\\n        int dx = (x2>x1)? 1 : -1;\\n        int dy = (y2>y1)? 1 : -1;\\n        int minstep = abs(x1-x2)+abs(y1-y2);\\n        queue<pair<int,int>> q({make_pair(x1,y1)});\\n        while(minstep--){\\n            int qsize = q.size();\\n            if(qsize==0) \\n                return false; //haven't gone minstep yet, but no path available\\n            while(qsize--){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                if(x!=x2 && forest[x+dx][y]>0 && ((x+dx)!=q.back().first || y!=q.back().second))\\n                    q.push(make_pair(x+dx,y));\\n                if(y!=y2 && forest[x][y+dy]>0 && (x!=q.back().first || (y+dy)!=q.back().second))\\n                    q.push(make_pair(x,y+dy));\\n            }\\n        }\\n        return q.size()==1; //if true return, only destination [x2,y2] is in the queue\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"107397",
			"view":"19",
			"top":"9",
			"title":"[Java]Typical use of BFS, a straight forward solution",
			"vote":"0",
			"content":"**Target:** find the shortest path from the lowest tree to the highest tree, and go through all the trees.\\n**solution:** divide this problem into small parts, that is to find the shortest path between two adjacent trees\\n\\n1\\u3001put all the trees into ```PriorityQueue```(increasing order)\\n2\\u3001use BFS to find the shortest path length between two adjacent elements in the queue.\\n3\\u3001add up all the lengths we get in method **2**\\n\\nthis solution faster than 80-90% solutions, easy to understand, but need further optimization. \\n\\n```\\nclass Solution {\\n    int[][] direction = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};\\n\\n    public int cutOffTree(List<List<Integer>> forest) {\\n        int m = forest.size();\\n        int n = forest.get(0).size();\\n        int[][] forestArr = new int[m][n];\\n        PriorityQueue<Tree> priorityQueue = new PriorityQueue<>();\\n        //change the input into array and a priorityQueue with increasing height\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                forestArr[i][j] = forest.get(i).get(j);\\n                if (forestArr[i][j] > 1) {\\n                    priorityQueue.add(new Tree(i, j, forestArr[i][j]));\\n                }\\n            }\\n        }\\n        return bfs(priorityQueue, forestArr);\\n    }\\n\\n    public int bfs(Queue<Tree> queue, int[][] arr) {\\n        //find the shortest path between adjacent elements by bfs.\\n        int count = 0;\\n        int n = queue.size();\\n        int curRow = 0;\\n        int curCol = 0;\\n        int nextRow = 0;\\n        int nextCol = 0;\\n        for (int i = 0; i < n; i++) {\\n            //the first location is [0,0]\\n            //find the path the path between last Tree and the Tree poll from the queue\\n            if (i != 0) {\\n                curRow = nextRow;\\n                curCol = nextCol;\\n            }\\n            Tree nextTree = queue.poll();\\n            nextRow = nextTree.row;\\n            nextCol = nextTree.col;\\n            int result = findPathBetweenTwoTree(curRow, curCol, nextRow, nextCol, arr);\\n            if (result == -1) {\\n                return -1;\\n            } else {\\n                count = count + result;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    /**\\n     * this is the normal bfs, to find the shortest path between two tree\\n     */\\n    public int findPathBetweenTwoTree(int curX, int curY, int desX, int desY, int[][] arr) {\\n        if (curX == desX && curY == desY) {\\n            return 0;\\n        }\\n        //an array to record visitation\\n        int[][] book = new int[arr.length][arr[0].length];\\n        Queue<Tree> queue = new LinkedList<>();\\n        Tree tree = new Tree(curX, curY, arr[curX][curY]);\\n        tree.level = 0;\\n        queue.add(tree);\\n        book[curX][curY] = 1;\\n        while (!queue.isEmpty()) {\\n            Tree cur = queue.poll();\\n            for (int i = 0; i < 4; i++) {\\n                int nextRow = cur.row + direction[i][0];\\n                int nextCol = cur.col + direction[i][1];\\n                if (nextRow < 0 || nextRow >= arr.length || nextCol < 0 || nextCol >= arr[0].length || arr[nextRow][nextCol] == 0 || book[nextRow][nextCol] == 1) {\\n                    continue;\\n                }\\n                if (nextRow == desX && nextCol == desY) {\\n                    return cur.level + 1;\\n                } else {\\n                    Tree nextTree = new Tree(nextRow, nextCol, arr[nextRow][nextCol]);\\n                    nextTree.level = cur.level + 1;\\n                    queue.add(nextTree);\\n                    book[nextRow][nextCol] = 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    class Tree implements Comparable<Tree> {\\n        int row;\\n        int col;\\n        int height;\\n        int level;\\n\\n        Tree(int row, int col, int height) {\\n            this.row = row;\\n            this.col = col;\\n            this.height = height;\\n        }\\n\\n        @Override\\n        public int compareTo(Tree tree) {\\n            return height - tree.height;\\n        }\\n    }\\n\\n}\\n```"
		}
	],
	"id":"652",
	"title":"Cut Off Trees for Golf Event",
	"content":"<p>\r\nYou are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:\r\n<ol>\r\n<li><code>0</code> represents the <code>obstacle</code> can't be reached.</li>\r\n<li><code>1</code> represents the <code>ground</code> can be walked through.</li>\r\n<li><code>The place with number bigger than 1</code> represents a <code>tree</code> can be walked through, and this positive number represents the tree's height.</li>\r\n</ol>\r\n</p>\r\n\r\n<p>\r\nYou are asked to cut off <b>all</b> the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \r\n</p>\r\n\r\n<p>\r\nYou will start from the point (0, 0) and you should output the minimum steps <b>you need to walk</b> to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.\r\n</p>\r\n\r\n<p>\r\nYou are guaranteed that no two <code>trees</code> have the same height and there is at least one tree needs to be cut off.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n[\r\n [1,2,3],\r\n [0,0,4],\r\n [7,6,5]\r\n]\r\n<b>Output:</b> 6\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n[\r\n [1,2,3],\r\n [0,0,0],\r\n [7,6,5]\r\n]\r\n<b>Output:</b> -1\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\n[\r\n [2,3,4],\r\n [0,0,5],\r\n [8,7,6]\r\n]\r\n<b>Output:</b> 6\r\n<b>Explanation:</b> You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.\r\n</pre>\r\n</p>\r\n\r\n<p>\r\n<b>Hint</b>: size of the given matrix will not exceed 50x50.\r\n</p>",
	"frequency":"121",
	"ac_num":"4557"
}