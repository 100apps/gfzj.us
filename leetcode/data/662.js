{
	"difficulty":"3",
	"submit_num":"13912",
	"show_id":"685",
	"leetcode_id":"685",
	"answers":[
		{
			"lc_ans_id":"108045",
			"view":"5033",
			"top":"0",
			"title":"C++/Java, Union Find with explanation, O(n)",
			"vote":"37",
			"content":"This problem is very similar to \"Redundant Connection\". But the description on the parent/child relationships is much better clarified. \\n```\\nThere are two cases for the tree structure to be invalid.\\n1) A node having two parents;\\n   including corner case: e.g. [[4,2],[1,5],[5,2],[5,3],[2,4]]\\n2) A circle exists\\n```\\nIf we can remove exactly 1 edge to achieve the tree structure, a single node can have at most two parents. So my solution works in two steps.\\n```\\n1) Check whether there is a node having two parents. \\n    If so, store them as candidates A and B, and set the second edge invalid. \\n2) Perform normal union find. \\n    If the tree is now valid \\n           simply return candidate B\\n    else if candidates not existing \\n           we find a circle, return current edge; \\n    else \\n           remove candidate A instead of B.\\n```\\nIf you like this solution, please help upvote so more people can see.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        int n = edges.size();\\n        vector<int> parent(n+1, 0), candA, candB;\\n        // step 1, check whether there is a node with two parents\\n        for (auto &edge:edges) {\\n            if (parent[edge[1]] == 0)\\n                parent[edge[1]] = edge[0]; \\n            else {\\n                candA = {parent[edge[1]], edge[1]};\\n                candB = edge;\\n                edge[1] = 0;\\n            }\\n        } \\n        // step 2, union find\\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n        for (auto &edge:edges) {\\n            if (edge[1] == 0) continue;\\n            int u = edge[0], v = edge[1], pu = root(parent, u);\\n            // Now every node only has 1 parent, so root of v is implicitly v\\n            if (pu == v) {\\n                if (candA.empty()) return edge;\\n                return candA;\\n            }\\n            parent[v] = pu;\\n        }\\n        return candB;\\n    }\\nprivate:\\n    int root(vector<int>& parent, int k) {\\n        if (parent[k] != k) \\n            parent[k] = root(parent, parent[k]);\\n        return parent[k];\\n    }\\n};\\n```\\nJava version by MichaelLeo \\n```\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int[] can1 = {-1, -1};\\n        int[] can2 = {-1, -1};\\n        int[] parent = new int[edges.length + 1];\\n        for (int i = 0; i < edges.length; i++) {\\n            if (parent[edges[i][1]] == 0) {\\n                parent[edges[i][1]] = edges[i][0];\\n            } else {\\n                can2 = new int[] {edges[i][0], edges[i][1]};\\n                can1 = new int[] {parent[edges[i][1]], edges[i][1]};\\n                edges[i][1] = 0;\\n            }\\n        }\\n        for (int i = 0; i < edges.length; i++) {\\n            parent[i] = i;\\n        }\\n        for (int i = 0; i < edges.length; i++) {\\n            if (edges[i][1] == 0) {\\n                continue;\\n            }\\n            int child = edges[i][1], father = edges[i][0];\\n            if (root(parent, father) == child) {\\n                if (can1[0] == -1) {\\n                    return edges[i];\\n                }\\n                return can1;\\n            }\\n            parent[child] = father;\\n        }\\n        return can2;\\n    }\\n    \\n    int root(int[] parent, int i) {\\n        while (i != parent[i]) {\\n            parent[i] = parent[parent[i]];\\n            i = parent[i];\\n        }   \\n        return i;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"108073",
			"view":"2178",
			"top":"1",
			"title":"Share my solution, C++",
			"vote":"13",
			"content":"This problem is limited to a graph with N nodes and N edges. No node is singled out if a edge is removed. For example, [[1,2],[2,4],[3,4]], 4 nodes 3 edges, is not applicable to this problem. You cannot remove [3,4] to single out node 3.\\n\\nThere are 3 cases:\\n  1. No loop, but there is one node who has 2 parents.\\n  2. A loop, and there is one node who has 2 parents, that node must be inside the loop.\\n  3. A loop, and every node has only 1 parent.\\n    \\nCase 1: e.g. ```[[1,2],[1,3],[2,3]]``` ,node 3 has 2 parents ([1,3] and [2,3]). Return the edge that occurs last that is, return [2,3].\\nCase 2: e.g. ```[[1,2],[2,3],[3,1],[4,1]]``` , {1->2->3->1} is a loop, node 1 has 2 parents ([4,1] and  [3,1]). Return the edge that is inside the loop, that is, return [3,1].\\nCase 3: e.g. ```[[1,2],[2,3],[3,1],[1,4]]``` , {1->2->3->1} is a loop, you can remove any edge in a loop, the graph is still valid. Thus, return the one that occurs last, that is, return [3,1].\\n\\n```\\nclass Solution {\\nprivate:\\n    struct Node{\\n        vector<int> from; //parent(s), at most one node has 2 parents in a graph\\n        vector<int> to; //children, can have many children\\n    };\\n    unordered_map<int,Node> getNode;\\n    unordered_map<int,unordered_map<int,int>> edgeOrder;\\n    \\npublic:\\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\\n        //construct the graph, and record the node which has 2 parents if possible\\n        int N = edges.size();\\n        for(int n=1; n<=N; ++n)\\n            getNode[n] = Node();\\n        int node2parents = -1;\\n        for(int i=0; i<N; ++i){\\n            int p = edges[i][0];\\n            int c = edges[i][1];\\n            edgeOrder[p][c] = i;\\n            getNode[p].to.push_back(c);\\n            getNode[c].from.push_back(p);\\n            if(getNode[c].from.size()==2) //we find a node with 2 parents\\n                node2parents = c;\\n        }\\n        \\n        //doing DFS to find the loop if loop exists\\n        vector<int> status(N+1,0); // status 0,1,2 ==> 0:unvisited, 1:visiting, 2:visited\\n        stack<int> loop;\\n        bool loopfound = false;\\n        for(int i=1; i<=N; ++i){\\n            if(loopfound)   break;\\n            if(status[i] == 0){ //DFS started with node i\\n                status[i] = 1;\\n                stack<int> stk({i});\\n                DFS(stk,status,loopfound,loop);\\n                status[i] = 2;\\n            }\\n        }\\n        \\n        if(!loopfound){ // Case 1\\n            int parent1 = getNode[node2parents].from[0];\\n            int parent2 = getNode[node2parents].from[1];\\n            return (edgeOrder[parent1][node2parents] > edgeOrder[parent2][node2parents]) ?\\n                    vector<int>({parent1,node2parents}) : vector<int>({parent2,node2parents});\\n        }\\n        \\n        int last_occur_order = 0;\\n        vector<int> last_occur_edge;\\n        int begin = loop.top();\\n        while(!loop.empty()){\\n            int child = loop.top();\\n            loop.pop();\\n            int parent = loop.top();\\n            if(node2parents != -1 && child == node2parents) // Case 2\\n                return vector<int>({parent,child});\\n            int order = edgeOrder[parent][child];\\n            if(order > last_occur_order){\\n                last_occur_order = order;\\n                last_occur_edge = vector<int>({parent,child});\\n            }\\n            if(parent == begin)\\n                break; //loop ends\\n        }\\n        \\n        return last_occur_edge; // Case 3\\n    }\\n    \\n    void DFS(stack<int>& stk, vector<int>& status, bool& flag, stack<int>& loop){\\n        for(int c : getNode[stk.top()].to){\\n            if(flag)   return;\\n            if(status[c] == 1){\\n                stk.push(c);\\n                loop = stk;\\n                flag = true;\\n                return;\\n            }\\n            else if(status[c] == 0){\\n                stk.push(c);\\n                status[c] = 1;\\n                DFS(stk,status,flag,loop);\\n                status[c] = 2;\\n                stk.pop();\\n            }\\n        }\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"108046",
			"view":"3115",
			"top":"2",
			"title":"most posted answers are wrong",
			"vote":"12",
			"content":"We can not simply apply the code from REDUNDANT CONNECTION I, and add codes checking duplicated-parent only. \\nHere are 2 sample failed test cases:\\n```[[4,2],[1,5],[5,2],[5,3],[2,4]]```\\ngot ```[5,2]``` but ```[4,2]``` expected\\nand\\n```[[2,1],[3,1],[4,2],[1,4]]```\\ngot ```[3,1]``` but ```[2,1]``` expected\\n(Thanks @niwota and @wzypangpang )\\nThe problem is we can not consider the two conditions separately, I mean the duplicated-parents and cycle.\\nThis problem should be discussed and solved by checking 3 different situations:\\n1) No-Cycle, but 2 parents pointed to one same child\\n2) No dup parents but with Cycle \\n3) Possessing Cycle and dup-parents\\n\\nThose 2 failed test cases are all in situation 3), where we can not return immediately current edge when we found something  against the tree's requirements.  \\nThe correct solution is detecting and recording the whole cycle, then check edges in that cycle by reverse order to find the one with the same child as the duplicated one we found. \\nA more clear explanation and code have been posted by @niwota \\nhttps://discuss.leetcode.com/topic/105087/share-my-solution-c"
		},
		{
			"lc_ans_id":"108058",
			"view":"646",
			"top":"3",
			"title":"one pass disjoint set solution with explain",
			"vote":"4",
			"content":"This problem is tricky and interesting. It took me quite a few hours to figure it out. My first working solution was based on DFS, but I feel there might be better solutions. By spending whole night thinking deeply, I finally cracked it using Disjoint Set (also known as Union Find?). I want to share what I got here.\\n\\nAssumption before we start: input \"**edges**\" contains a directed tree with one and only one extra edge. If we remove the extra edge, the remaining graph should make a directed tree - a tree which has one root and from the root you can visit all other nodes by following directed edges. It has features:\\n1. one and only one root, and root does not have parent;\\n2. each non-root node has exactly one parent;\\n3. there is no cycle, which means any path will reach the end by moving at most (n-1) steps along the path.\\n\\nBy adding one edge ***(parent->child)*** to the tree:\\n1. every node including root has exactly one parent, if ***child*** is root;\\n2. root does not have parent, one node (***child***) has 2 parents, and all other nodes have exactly 1 parent, if ***child*** is not root.\\n\\nLet's check cycles. By adding one edge ***(a->b)*** to the tree, the tree will have:\\n1. a cycle, if there exists a path from ***(b->...->a)***; in particularly, if ***b == root***, (in other word, add an edge from a node to root) it will make a cycle since there must be a path ***(root->...->a)***.\\n2. no cycle, if there is no such a path ***(b->...->a)***.\\n\\nAfter adding the extra edge, the graph can be generalized in 3 different cases:\\n![0_1507232871672_Screen Shot 2017-10-05 at 2.25.34 PM.png](/assets/uploads/files/1507232873325-screen-shot-2017-10-05-at-2.25.34-pm-resized.png) \\n\\n```Case 1```: \"c\" is the only node which has 2 parents and there is not path (c->...->b) which means no cycle. In this case, removing either \"e1\" or \"e2\" will make the tree valid. According to the description of the problem, whichever edge added later is the answer.\\n\\n```Case 2```: \"c\" is the only node which has 2 parents and there is a path(c->...->b) which means there is a cycle. In this case, \"e2\" is the only edge that should be removed. Removing \"e1\" will make the tree in 2 separated groups. Note, in input `edges`, \"e1\" may come after \"e2\".\\n\\n```Case 3```: this is how it looks like if edge ***(a->root)*** is added to the tree. Removing any of the edges along the cycle will make the tree valid. But according to the description of the problem, the last edge added to complete the cycle is the answer. Note: edge \"e2\" (an edge pointing from a node outside of the cycle to a node on the cycle) can never happen in this case, because every node including root has exactly one parent. If \"e2\" happens, that make a node on cycle have 2 parents. That is impossible.\\n\\nAs we can see from the pictures, the answer must be:\\n1. one of the 2 edges that pointing to the same node in ``case 1`` and ``case 2``; there is one and only one such node which has 2 parents.\\n2. the last edge added to complete the cycle in ``case 3``.\\n\\nNote: both ``case 2`` and ``case 3`` have cycle, but in ``case 2``, \"e2\" may not be the last edge added to complete the cycle.\\n\\nNow, we can apply Disjoint Set (DS) to build the tree in the order the edges are given. We define ``ds[i]`` as the parent or ancestor of node ``i``. It will become the root of the whole tree eventually if `edges` does not have extra edge. When given an edge (a->b), we find node ``a``'s ancestor and assign it to `ds[b]`. Note, in typical DS, we also need to find node `b`'s ancestor and assign `a`'s ancestor as the ancestor of `b`'s ancestor. But in this case, we don't have to, since we skip the second parent edge (see below), it is guaranteed `a` is the only parent of `b`.\\n\\nIf we find an edge pointing to a node that already has a parent, we simply skip it. The edge skipped can be \"e1\" or \"e2\" in ``case 1`` and ``case 2``. In ``case 1``, removing either \"e1\" or \"e2\" will make the tree valid. In ``case 3``, removing \"e2\" will make the tree valid, but removing \"e1\" will make the tree in 2 separated groups and one of the groups has a cycle. In ```case 3```, none of the edges will be skipped because there is no 2 edges pointing to the same node. The result is a graph with cycle and \"n\" edges.\\n\\n**How to detect cycle by using Disjoint Set (Union Find)?**\\nWhen we join 2 nodes by edge (a->b), we check `a`'s ancestor, if it is b, we find a cycle! When we find a cycle, we don't assign `a`'s ancestor as `b`'s ancestor. That will trap our code in endless loop. We need to save the edge though since it might be the answer in `case 3`.\\n\\nNow the code. We define two variables (`first` and `second`) to store the 2 edges that point to the same node if there is any (there may not be such edges, see `case 3`). We skip adding `second` to tree. `first` and `second` hold the values of the original index in input `edges` of the 2 edges respectively. Variable `last` is the edge added to complete a cycle if there is any (there may not be a cycle, see `case 1` and removing \"e2\" in `case 2`). And it too hold the original index in input `edges`.\\n\\nAfter adding all except at most one edges to the tree, we end up with 4 different scenario:\\n1. `case 1` with either \"e1\" or \"e2\" removed. Either way, the result tree is valid. The answer is the edge being removed or skipped (a.k.a. `second`)\\n2. `case 2` with \"e2\" removed. The result tree is valid. The answer is the edge being removed or skipped (a.k.a. `second`)\\n3. `case 2` with \"e1\" removed. The result tree is invalid with a cycle in one of the groups. The answer is the other edge (`first`) that points to the same node as `second`. \\n4. `case 3` with no edge removed. The result tree is invalid with a cycle. The answer is the `last` edge added to complete the cycle.\\n\\nIn the following code,\\n`last == -1` means \"no cycle found\" which is scenario 1 or 2\\n`second != -1 && last != -1` means \"one edge removed and the result tree has cycle\" which is scenario 3\\n`second == -1` means \"no edge skipped or removed\" which is scenario 4\\n\\n``` \\n   public int[] findRedundantDirectedConnection(int[][] edges) {\\n        int n = edges.length;\\n        int[] parent = new int[n+1], ds = new int[n+1];\\n        Arrays.fill(parent, -1);\\n        int first = -1, second = -1, last = -1;\\n        for(int i = 0; i < n; i++) {\\n            int p = edges[i][0], c = edges[i][1];\\n            if (parent[c] != -1) {\\n                first = parent[c];\\n                second = i;\\n                continue;\\n            }\\n            parent[c] = i;\\n            \\n            int p1 = find(ds, p);\\n            if (p1 == c) last = i;\\n            else ds[c] = p1;\\n        }\\n\\n        if (last == -1) return edges[second]; // no cycle found by removing second\\n        if (second == -1) return edges[last]; // no edge removed\\n        return edges[first];\\n    }\\n    \\n    private int find(int[] ds, int i) {\\n        return ds[i] == 0 ? i : (ds[i] = find(ds, ds[i]));\\n    }\\n```\\nThis solution past all these test cases and ACed.\\nTest case:\\n[[1,2],[1,3],[2,3]]\\n[[1,2], [2,3], [3,4], [4,1], [1,5]]\\n[[4,2],[1,5],[5,2],[5,3],[2,4]]\\n[[2,1],[3,1],[4,2],[1,4]]\\n[[4,1],[1,2],[1,3],[4,5],[5,6],[6,5]]\\n[[2,3], [3,4], [4,1], [1,5], [1,2]]\\n[[3,1],[1,4],[3,5],[1,2],[1,5]]\\n[[1,2],[2,3],[3,1]]\\n\\nexpected output:\\n[2,3]\\n[4,1]\\n[4,2]\\n[2,1]\\n[6,5]\\n[1,2]\\n[1,5]\\n[3,1]"
		},
		{
			"lc_ans_id":"108070",
			"view":"363",
			"top":"4",
			"title":"Python O(N) concise solution with detailed explanation, passed updated testcases",
			"vote":"4",
			"content":"In this problem, you need to deal with 3 cases:\\n1. There is a loop in the graph, and no vertex has more than 1 parent.\\nExample:\\nInput: [[1,2], [2,3], [3,4], [4,1], [1,5]]\\nOutput: [4,1]\\n![0_1506493498612_drawing2.jpg](/assets/uploads/files/1506493500257-drawing2.jpg) \\nIn this case, you can simply output the edge in the loop that occurs last.\\nUnion-find can be used to check whether an directed graph contains a cycle or not. At first, every vertex is an independent subset. For each edge, join the subsets that are on both sides of the edge. If both the vertices are in the same subset, a cycle is found.\\n\\n2. A vertex has more than 1 parent, but there isn't a loop in the graph.\\nExample:\\nInput: [[1,2], [1,3], [2,3]]\\nOutput: [2,3]\\n![0_1506493289378_drawing 1.jpg](/assets/uploads/files/1506493291084-drawing-1.jpg) \\nThis case is also easy. You can just return the last edge that changes the tree into a graph. You can use an array of booleans to indicate whether a vertex has already got a parent.\\n\\n3. A vertex has more than 1 parent, and is part of a loop.\\nExample:\\nInput: [[2,1], [3,1], [4,2], [1,4]]\\nOutput: [2,1]\\n![0_1506494193813_drawing3.jpg](/assets/uploads/files/1506494195441-drawing3.jpg) \\nCase 3 is a mixture of case 1 and case 2. If you detect both cases, do the following:\\na. Find the vertex that has multiple parents. It is obvious that this vertex is also in the loop. In the example above, node 1 is what we are looking for.\\nb. Starting from this vertex, use DFS to find the last edge that forms the cycle.\\nc. Return this edge. In the example above, it is (2, 1).\\n\\n```\\nclass Solution(object):\\n    def union(self, a, b):\\n        self.uf[self.find(b)] = self.find(a)\\n\\n    def find(self, a):\\n        while self.uf[a] != a:\\n            a = self.uf[a]\\n        return a\\n    \\n    def detectCycle(self, V):\\n        self.visited[V] = True\\n        for i in range(len(self.adjList[V])):\\n            nextV = self.adjList[V][i]\\n            if self.visited[nextV]:\\n                return (V, nextV)\\n            ret = self.detectCycle(nextV)\\n            if ret[0]:\\n                return ret\\n        return (None, None)\\n    \\n    def findRedundantDirectedConnection(self, edges):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        self.uf = [0] + [i + 1 for i in range(len(edges))]\\n        self.adjList = [[] for i in range(len(edges) + 1)]      # Adjancency List\\n        hasFather = [False] * (len(edges) + 1)                  # Whether a vertex has already got a parent\\n        criticalEdge = None\\n\\n        for i, edge in enumerate(edges):\\n            w, v = edge[0], edge[1]\\n            self.adjList[w].append(v)\\n            if hasFather[v]:\\n                criticalEdge = (w, v)                           # If a vertex has more than one parent, record the last edge\\n            hasFather[v] = True\\n            if self.find(w) == self.find(v):                    # If a loop is found, record the edge that occurs last\\n                cycleEdge = (w, v)\\n            self.union(w, v)\\n\\n        if not criticalEdge:                                    # Case 1\\n            return cycleEdge\\n        self.visited = [False] * (len(edges) + 1)\\n        (w, v) = self.detectCycle(criticalEdge[1])\\n        return (w, v) if w else criticalEdge                    # Case 2 and 3\\n\\n````"
		},
		{
			"lc_ans_id":"108053",
			"view":"559",
			"top":"5",
			"title":"Test Case not clear",
			"vote":"3",
			"content":"Can somebody please elaborate the following test case.\\nInput : [[2,1],[3,1],[4,2],[1,4]]\\nOutput: [2,1]\\n\\nA/c to my interpretation, shouldn't the answer be [1,4] as it  is the edge that is added last and it's removal will make graph an n rooted tree."
		},
		{
			"lc_ans_id":"108043",
			"view":"89",
			"top":"6",
			"title":"Python O(n) BFS undirected SCC",
			"vote":"1",
			"content":"If there is a cycle in the undirected graph, the redundant connection will be on it.\\n\\n```\\nclass Solution:\\n    def findRedundantDirectedConnection(self, edges):\\n        n = len(edges) \\n        adj = [[] for _ in range(n+1)]\\n        ind = [0 for _ in range(n+1)]                \\n        for p, q in edges:\\n            adj[p].append(q)\\n            adj[q].append(p)\\n            ind[q] += 1\\n                    \\n        scc = [1 for _ in range(n+1)]\\n        leaves = [v for v in range(1,n+1) if (len(adj[v]) == 1)]\\n        while leaves:\\n            p = leaves.pop()\\n            scc[p] = 0\\n            for q in adj[p]:\\n                adj[q].remove(p)\\n                if len(adj[q]) == 1:\\n                    leaves.append(q)\\n\\n        nocycles = all(not incycle for incycle in scc[1:])\\n        nojoin = all (d == 1 for d in ind[1:])\\n        for p, q in edges[::-1]:\\n            if ((nojoin or ind[q] > 1) and\\n                (nocycles or (scc[p] and scc[q]))):\\n                return [p, q]\\n        return []\\n```"
		},
		{
			"lc_ans_id":"108044",
			"view":"14",
			"top":"7",
			"title":"My accepted Java solution",
			"vote":"0",
			"content":"My solution is just to use loop() and find() to check two situations: loop() to check whether there exists a loop, if true, return the last edge in the loop; find() to start from the node that has two parent nodes, go up the tree, and if it enters a loop, that means the starting edge is invalid and it should go with the other parent, then return the starting edge of this loop.\\n\\n```\\n\\nclass Solution {\\n    public int[] findRedundantDirectedConnection(int[][] edges) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        int twice = 0;\\n        for(int[] edge: edges) {\\n            if(set.contains(edge[1])) {\\n                twice = edge[1];\\n                break;\\n            }\\n            set.add(edge[1]);\\n        }\\n        Set<Integer> parents = new HashSet<Integer>();\\n        for(int i = 0; i <= edges.length - 1; i ++) {\\n            if(edges[i][1] == twice) {\\n                List<Integer> children = new ArrayList<Integer>();\\n                children.add(edges[i][1]);\\n                int parent = edges[i][0];\\n                boolean circledOrDuplicate = find(edges[i][0], edges, children, parent, parents);\\n                if(circledOrDuplicate) return edges[i];\\n            }\\n        }\\n        for(int i = 0; i <= edges.length - 1; i ++) {\\n            List<Integer> exist = new ArrayList<Integer>();\\n            exist.add(edges[i][0]);\\n            int[] remove = loop(edges, exist, edges[i][1]);\\n            if(remove != new int[2]) return remove;\\n        }\\n        return new int[2];     \\n    }\\n    public boolean find(int root, int[][] edges, List<Integer> children, int parent, Set<Integer> parents) {\\n        for(int i = 0; i <= edges.length - 1; i ++) {\\n            if(edges[i][1] == root) {\\n                children.add(root);\\n                parent = edges[i][0];\\n                if(children.contains(edges[i][0])) return true;\\n                if(find(edges[i][0], edges, children, parent, parents)) return true;\\n                parents.remove(parent);\\n            }\\n        }\\n        if(parents.contains(parent)) return true;\\n        parents.add(parent);\\n        return false;\\n    }\\n    public int[] loop(int[][] edges, List<Integer> exist, int parent) {\\n        for(int[] edge: edges) {\\n            if(edge[0] == parent) {\\n                if(exist.contains(edge[1])) return edge;\\n                exist.add(edge[1]);\\n                int[] remove = loop(edges, exist, edge[1]);\\n                return remove;\\n            }\\n        }\\n        return new int[2];\\n    } \\n}\\n\\n```"
		},
		{
			"lc_ans_id":"108047",
			"view":"18",
			"top":"8",
			"title":"Python solution 52ms",
			"vote":"0",
			"content":"```\\nclass Solution(object):\\n    def findRedundantDirectedConnection(self, edges):\\n\\n        nodes = set()\\n        parent = collections.defaultdict(list)\\n        for node, child in edges:\\n            nodes.add(node)\\n            nodes.add(child)\\n            parent[child].append(node)\\n        \\n        # there is a root node, means some node has 2 parents\\n        if nodes - set(parent.keys()):\\n            for child, parents in parent.items():\\n                if len(parents) == 2:\\n                    break\\n            # there is no circle, break edge to second parent\\n            res = [parents[1], child]\\n            for p in parents:\\n                node = p\\n                while parent[node] and node != child:\\n                    node = parent[node][0]\\n                # there is circle, break edge that creates cirle\\n                if node == child:\\n                    res = [p, child]\\n            return res\\n        \\n        # ther is no root node, break circle to create one\\n        else:\\n            seen = []\\n            while node not in seen:\\n                seen.append(node)\\n                node = parent[node][0]\\n\\n            circle = set(seen[seen.index(node):])\\n            for a, b in reversed(edges):\\n                if a in circle and b in circle:\\n                    return [a, b]\\n                \\n        ```"
		},
		{
			"lc_ans_id":"108048",
			"view":"26",
			"top":"9",
			"title":"Python union find solution",
			"vote":"0",
			"content":"Idea coming from [C++/Java, Union Find with explanation, O(n)](https://discuss.leetcode.com/topic/105108/c-java-union-find-with-explanation-o-n)\\n\\n    class Solution(object):\\n\\n    def findRedundantDirectedConnection(self, edges):\\n        if not edges:\\n            return []\\n        \\n        parent = [-1] * (len(edges) + 1)\\n        candidate_one, candidate_two = [-1, -1], [-1, -1]\\n        for edge in edges:\\n            if parent[edge[1]] != -1:\\n                candidate_one = [parent[edge[1]], edge[1]]\\n                candidate_two = [edge[0], edge[1]]\\n            else:\\n                parent[edge[1]] = edge[0]\\n        parent = range(len(edges) + 1)\\n        \\n        for edge in edges:\\n            if edge[0] == candidate_two[0] and edge[1] == candidate_two[1]:\\n                continue\\n            x, y = edge[0], edge[1]\\n            x_parent = self.find(parent, x)\\n            y_parent = self.find(parent, y)\\n            if x_parent == y_parent:\\n                if candidate_one[0] == -1:\\n                    return edge\\n                return candidate_one\\n            parent[x_parent] = y_parent \\n        return candidate_two\\n        \\n    def find(self, parent, x):\\n        while parent[x] != x:\\n            parent[x] = parent[parent[x]]\\n            x = parent[x]\\n        return x"
		}
	],
	"id":"662",
	"title":"Redundant Connection II",
	"content":"<p>\r\nIn this problem, a rooted tree is a <b>directed</b> graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\r\n</p><p>\r\nThe given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\r\n</p><p>\r\nThe resulting graph is given as a 2D-array of <code>edges</code>.  Each element of <code>edges</code> is a pair <code>[u, v]</code> that represents a <b>directed</b> edge connecting nodes <code>u</code> and <code>v</code>, where <code>u</code> is a parent of child <code>v</code>.\r\n</p><p>\r\nReturn an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.\r\n</p><p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1,2], [1,3], [2,3]]\r\n<b>Output:</b> [2,3]\r\n<b>Explanation:</b> The given directed graph will be like this:\r\n  1\r\n / \\\r\nv   v\r\n2-->3\r\n</pre>\r\n</p>\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1,2], [2,3], [3,4], [4,1], [1,5]]\r\n<b>Output:</b> [4,1]\r\n<b>Explanation:</b> The given directed graph will be like this:\r\n5 <- 1 -> 2\r\n     ^    |\r\n     |    v\r\n     4 <- 3\r\n</pre>\r\n</p>\r\n<p><b>Note:</b><br />\r\n<li>The size of the input 2D-array will be between 3 and 1000.</li>\r\n<li>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</li>\r\n</p>",
	"frequency":"92",
	"ac_num":"3957"
}