{
	"difficulty":"3",
	"submit_num":"7720",
	"show_id":"699",
	"leetcode_id":"699",
	"answers":[
		{
			"lc_ans_id":"108766",
			"view":"1824",
			"top":"0",
			"title":"Easy Understood O(n^2) Solution with explanation",
			"vote":"12",
			"content":"The idea is quite simple, we use intervals to represent the square. the initial height we set to the square `cur` is `pos[1]`. That means we assume that all the square will fall down to the land. we iterate the previous squares, check is there any square `i` beneath my `cur` square. If we found that we have squares `i` intersect with us, which means my current square will go above to that square `i`. My target is to find the highest square and put square `cur` onto square `i`, and set the height of the square `cur` as \\n```java\\ncur.height = cur.height + previousMaxHeight;\\n``` \\nActually, you do not need to use the interval class to be faster, I just use it to make my code cleaner\\n\\n```java\\nclass Solution {\\n    private class Interval {\\n        int start, end, height;\\n        public Interval(int start, int end, int height) {\\n            this.start = start;\\n            this.end = end;\\n            this.height = height;\\n        }\\n    }\\n    public List<Integer> fallingSquares(int[][] positions) {\\n        List<Interval> intervals = new ArrayList<>();\\n        List<Integer> res = new ArrayList<>();\\n        int h = 0;\\n        for (int[] pos : positions) {\\n            Interval cur = new Interval(pos[0], pos[0] + pos[1] - 1, pos[1]);\\n            h = Math.max(h, getHeight(intervals, cur));\\n            res.add(h);\\n        }\\n        return res;\\n    }\\n    private int getHeight(List<Interval> intervals, Interval cur) {\\n        int preMaxHeight = 0;\\n        for (Interval i : intervals) {\\n            // Interval i does not intersect with cur\\n            if (i.end < cur.start) continue;\\n            if (i.start > cur.end) continue;\\n            // find the max height beneath cur\\n            preMaxHeight = Math.max(preMaxHeight, i.height);\\n        }\\n        cur.height += preMaxHeight;\\n        intervals.add(cur);\\n        return cur.height;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"108779",
			"view":"69",
			"top":"1",
			"title":"Python with dict, O(N^2) solution with comments",
			"vote":"3",
			"content":"```\\nclass Solution:\\n    def fallingSquares(self, positions):\\n        \"\"\"\\n        :type positions: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = []\\n        heights = {}\\n        for pos, side in positions:\\n            # finds nearby positions, if any\\n            left, right = pos, pos+side-1\\n            # compare to see if this block overlaps with L/R boundaries of existing blocks\\n            nearby = [key for key in heights.keys() if not (key[1] < pos or key[0] > right)]\\n            # finds height of block based on heights of existing and overlapping blocks\\n            if len(nearby) > 0:\\n                h = max(heights[key] for key in nearby) + side\\n            else:\\n                h = side\\n            # update the heights for left and right boundaries\\n            heights[(pos,right)] = h\\n            # add height to ans\\n            if len(ans) == 0:\\n                ans.append(h)\\n            else:\\n                ans.append(max(h,ans[-1]))\\n        return ans\\n```"
		},
		{
			"lc_ans_id":"108769",
			"view":"219",
			"top":"2",
			"title":"C++ O(nlogn)",
			"vote":"3",
			"content":"Similar to skyline concept, going from left to right the path is decomposed to consecutive segments, and each segment has a height. Each time we drop a new square, then update the level map by erasing & creating some new segments with possibly new height. There are at most 2n segments that are created / removed throughout the process, and the time complexity for each add/remove operation is O(log(n)).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fallingSquares(vector<pair<int, int>>& p) {\\n        map<pair<int,int>, int> mp;\\n        mp[{0,1000000000}] = 0;\\n        vector<int> ans;\\n        int mx = 0;\\n        for (auto &v:p) {\\n            vector<vector<int>> toAdd;\\n            cout << endl;\\n            int len = v.second, a = v.first, b =v.first + v.second, h = 0;\\n            auto it = mp.upper_bound({a,a});\\n            if (it != mp.begin() && (--it)->first.second <= a) ++it;\\n            while (it != mp.end() && it->first.first <b) {\\n                if (a > it->first.first) toAdd.push_back({it->first.first,a,it->second});\\n                if (b < it->first.second) toAdd.push_back({b,it->first.second,it->second});\\n                h = max(h, it->second);\\n                it = mp.erase(it);\\n            }\\n            mp[{a,b}] = h + len;\\n            for (auto &t:toAdd) mp[{t[0],t[1]}] = t[2];\\n            mx = max(mx, h + len);\\n            ans.push_back(mx);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"108783",
			"view":"734",
			"top":"3",
			"title":"c++, map based short solution",
			"vote":"3",
			"content":"The running time complexity should be O(n\\xb2), since the bottleneck is given by finding the maxHeight in certain range.\\nIdea is simple, we use a map, and ```map[i] = h``` means, from ```i``` to next adjacent x-coordinate, inside this range, the height is ```h```.\\nTo handle edge cases like adjacent squares, I applied STL functions, for left bound, we call ```upper_bound``` while for right bound, we call ```lower_bound```.\\nSpecial thanks to @storypku for pointing out bad test cases like [[1,2],[2,3],[6,1],[3,3],[6,20]]\\n\\n```\\n    vector<int> fallingSquares(vector<pair<int, int>>& positions) {\\n        map<int,int> mp = {{0,0}, {INT_MAX,0}};\\n        vector<int> res;\\n        int cur = 0;\\n        for(auto &p : positions){\\n            int l = p.first, r = p.first + p.second, h = p.second, maxH = 0;\\n            auto ptri = mp.upper_bound(l), ptrj = mp.lower_bound(r);        // find range\\n            int tmp = ptrj->first == r? ptrj->second : (--ptrj)++->second;  // tmp will be applied by new right bound \\n            for(auto i = --ptri; i != ptrj; ++i)\\n                maxH = max(maxH, i->second);                                // find biggest height\\n            mp.erase(++ptri, ptrj);                                         // erase range\\n            mp[l] = h+maxH;                                                 // new left bound\\n            mp[r] = tmp;                                                    // new right bound\\n            cur = max(cur, mp[l]);\\n            res.push_back(cur);\\n        }\\n        return res;\\n    }\\n```"
		},
		{
			"lc_ans_id":"108770",
			"view":"80",
			"top":"4",
			"title":"O(nlogn) C++ Segment Tree",
			"vote":"2",
			"content":"```\\nclass Solution {\\npublic:\\n  int n;\\n  vector<int> height, lazy;\\n\\n  void push_up(int i) {\\n    height[i] = max(height[i*2], height[i*2+1]);\\n  }\\n\\n  void push_down(int i) {\\n    if (lazy[i]) {\\n        lazy[i*2] = lazy[i*2+1] = lazy[i];\\n        height[i*2] = height[i*2+1] = lazy[i];\\n        lazy[i] = 0;\\n    }\\n  }\\n\\n  void update(int i, int l, int r, int L, int R, int val) {\\n    if (L <= l && r <= R) {\\n      height[i] = val;\\n      lazy[i] = val;\\n      return;\\n    }\\n    push_down(i);\\n    int mid = l + (r-l)/2;\\n    if (L < mid) update(i*2, l, mid, L, R, val);\\n    if (R > mid) update(i*2+1, mid, r, L, R, val);\\n    push_up(i);\\n  }\\n\\n  int query(int i, int l, int r, int L, int R) {\\n    if (L <= l && r <= R) return height[i];\\n    push_down(i);\\n    int res = 0;;\\n    int mid = l + (r-l)/2;\\n    if (L < mid) res = max(res, query(i*2, l, mid, L, R));\\n    if (R > mid) res = max(res, query(i*2+1, mid, r, L, R));\\n    return res;\\n  }\\n\\n  vector<int> fallingSquares(vector<pair<int, int>>& positions) {\\n    vector<int> a;\\n    for (auto& p : positions) {\\n      a.push_back(p.first);\\n      a.push_back(p.first+p.second);\\n    }\\n    sort(a.begin(), a.end());\\n    n = unique(a.begin(), a.end()) - a.begin();\\n    a.resize(n);\\n    \\n    height.resize(n<<2, 0);\\n    lazy.resize(n<<2, 0);\\n    vector<int> res;\\n    for (auto& p : positions) {\\n      int l = lower_bound(a.begin(), a.end(), p.first) - a.begin();\\n      int r = lower_bound(a.begin(), a.end(), p.first+p.second) - a.begin();\\n      int maxh = query(1, 0, n, l, r);\\n      update(1, 0, n, l, r, maxh+p.second);\\n      res.push_back(query(1, 0, n, 0, n));\\n    }\\n    return res;\\n  }\\n};\\n```"
		},
		{
			"lc_ans_id":"108775",
			"view":"180",
			"top":"5",
			"title":"Easy Understood TreeMap Solution",
			"vote":"2",
			"content":"The squares divide the number line into many segments with different heights. Therefore we can use a TreeMap to store the number line. The key is the starting point of each segment and the value is the height of the segment. For every new falling square (s, l), we update those segments between s and s + l.\\n```\\nclass Solution {\\n    public List<Integer> fallingSquares(int[][] positions) {\\n        List<Integer> list = new ArrayList<>();\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        // at first, there is only one segment starting from 0 with height 0\\n        map.put(0, 0);\\n        \\n        // The global max height is 0\\n        int max = 0;\\n\\n        for(int[] position : positions) {\\n\\n            // the new segment \\n            int start = position[0], end = start + position[1];\\n\\n            // find the height among this range\\n            Integer key = map.floorKey(start);\\n            int h = map.get(key);\\n            key = map.higherKey(key);\\n            while(key != null && key < end) {\\n                h = Math.max(h, map.get(key));\\n                key = map.higherKey(key);\\n            }\\n            h += position[1];\\n\\n            // update global max height\\n            max = Math.max(max, h);\\n            list.add(max);\\n\\n            // update new segment and delete previous segments among the range\\n            int tail = map.floorEntry(end).getValue();\\n            map.put(start, h);\\n            map.put(end, tail);\\n            key = map.higherKey(start);\\n            while(key != null && key < end) {\\n                map.remove(key);\\n                key = map.higherKey(key);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"108768",
			"view":"223",
			"top":"6",
			"title":"C++ O(n(log(n)) time O(n) space",
			"vote":"2",
			"content":"Similar to skyline concept, going from left to right the path is decomposed to consecutive segments, and each segment has a height. Each time we drop a new square, then update the level map by erasing & creating some new segments with possibly new height. There are at most 2n segments that are created / removed throughout the process, and the time complexity for each add/remove operation is O(log(n)).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fallingSquares(vector<pair<int, int>>& p) {\\n        map<pair<int,int>, int> mp;\\n        mp[{0,1000000000}] = 0;\\n        vector<int> ans;\\n        int mx = 0;\\n        for (auto &v:p) {\\n            vector<vector<int>> toAdd;\\n            cout << endl;\\n            int len = v.second, a = v.first, b =v.first + v.second, h = 0;\\n            auto it = mp.upper_bound({a,a});\\n            if (it != mp.begin() && (--it)->first.second <= a) ++it;\\n            while (it != mp.end() && it->first.first <b) {\\n                if (a > it->first.first) toAdd.push_back({it->first.first,a,it->second});\\n                if (b < it->first.second) toAdd.push_back({b,it->first.second,it->second});\\n                h = max(h, it->second);\\n                it = mp.erase(it);\\n            }\\n            mp[{a,b}] = h + len;\\n            for (auto &t:toAdd) mp[{t[0],t[1]}] = t[2];\\n            mx = max(mx, h + len);\\n            ans.push_back(mx);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"108780",
			"view":"552",
			"top":"7",
			"title":"Java segment tree O(position.length * log(max_range))",
			"vote":"2",
			"content":"My first segment tree ever.\\n```\\n\\n    class SegNode {\\n        int left, mid, right;\\n        int max;\\n        boolean modified;\\n        SegNode leftChild, rightChild;\\n        SegNode(int left, int right, int max){\\n            this.left=left;\\n            this.right=right;\\n            this.mid=left+(right-left)/2;\\n            this.max=max;\\n        }\\n        int query(int left, int right){\\n            int ans;\\n            if ((left<=this.left&&right>=this.right)||this.leftChild==null){\\n                ans=this.max;\\n            }\\n            else {\\n                pushdown();\\n                ans = Integer.MIN_VALUE;\\n                if (left <= this.mid && this.leftChild != null)\\n                    ans = Math.max(ans, leftChild.query(left, Math.min(this.mid, right)));\\n                if (right > this.mid && this.rightChild != null)\\n                    ans = Math.max(ans, rightChild.query(Math.max(this.mid + 1, left), right));\\n            }\\n//            log.info(\"query on ({},{}) is {}, this.left, right, max: ({}, {}, {})\", left, right, ans, this.left,this.right,this.max);\\n            return ans;\\n        }\\n        void pushdown(){\\n            if (this.leftChild!=null){\\n                if (this.modified) {\\n                    this.leftChild.modified=true;\\n                    this.leftChild.max=max;\\n                    this.rightChild.modified=true;\\n                    this.rightChild.max=max;\\n                }\\n            } else {\\n                this.leftChild=new SegNode(left, mid, max);\\n                this.rightChild=new SegNode(mid+1,right, max);\\n\\n            }\\n        }\\n\\n        void insert(int left, int right, int value){\\n\\n//            log.info(\"insert {}, {}, {} on ({}, {})\", left, right, value, this.left, this.right);\\n            if (left<=this.left && right>=this.right){\\n                if (value>this.max) {\\n                    this.max = Math.max(this.max, value);\\n                    modified=true;\\n                }\\n\\n            } else {\\n                pushdown();\\n                if (left<=mid) this.leftChild.insert(left, Math.min(mid, right), value);\\n                if (right>mid)this.rightChild.insert(Math.max(mid+1, left), right, value);\\n                this.max=Math.max(this.leftChild.max, this.rightChild.max);\\n                modified=false;\\n            }\\n        }\\n    }\\n\\n    public List<Integer> fallingSquares(int[][] positions) {\\n        List<Integer> ans=new ArrayList<>();\\n        int left=0, right=1_000_000_000;\\n        if (positions.length==0)return ans;\\n        SegNode root=new SegNode(left, right, 0);\\n        int oldPeek=0;\\n        for (int[] rec: positions){\\n            int curMax=root.query(rec[0], rec[0]+rec[1]-1);\\n//            log.info(\"curMax on ({},{}): {}\", rec[0], rec[0]+rec[1]-1, curMax);\\n\\n            int newMax=curMax+rec[1];\\n            oldPeek=Math.max(oldPeek, newMax);\\n            ans.add(oldPeek);\\n            root.insert(rec[0], rec[0]+rec[1]-1, newMax);\\n        }\\n        return ans;\\n\\n    }\\n```"
		},
		{
			"lc_ans_id":"108792",
			"view":"343",
			"top":"8",
			"title":"O(n^2) solution with explanation",
			"vote":"2",
			"content":"The height of the base of each box is the highest top of any other box already dropped that overlaps along the x-axis.\\n\\nSo for each box, we iterate over all previously dropped boxes to find the base_height of the new box. The default is zero (ground level) if no overlaps are found.\\nIf there is no overlap between a box and a previous box, then they are separate and will not stick, so the new box will not go on top of the previous box.\\nIf there is overlap then the base_height of the new box will be the max of the previous base_height and height of the top of the previous box.\\n\\nStore the height of the new box as being base_height + side_length. Then append to the result the higher of the previous maximum height and this new box height. \\n\\n```\\nclass Solution(object):\\n    def fallingSquares(self, positions):\\n        \"\"\"\\n        :type positions: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        heights, result = [], []    # heights is the top edge height for each box dropped\\n        highest = 0                 # greatest height so far\\n        \\n        for i, position in enumerate(positions):\\n\\n            left, side_length = position[0], position[1]\\n            \\n            base_height = 0         # default if no overlap with any boxes\\n            for j in range(i):      # loop over all previously dropped boxes\\n                                \\n                prev_left, prev_side = positions[j][0], positions[j][1]  \\n                if (left + side_length <= prev_left) or (left >= prev_left + prev_side):\\n                    continue        # no overlap between this box and previous box\\n                base_height = max(base_height, heights[j])\\n            \\n            heights.append(base_height + side_length)\\n            highest = max(highest, heights[-1])\\n            result.append(highest)\\n        \\n        return result"
		},
		{
			"lc_ans_id":"108764",
			"view":"383",
			"top":"9",
			"title":"Easy and Concise Python Solution (97%)",
			"vote":"2",
			"content":"I used two list to take note of the current state.\\nIf you read question **218. The Skyline Problem**, you will easily understand how I do this.\\n\\n```pos``` tracks the x-coordinate of start points.\\n```height``` tracks the y-coordinate of lines.\\n\\n![0_1508239910449_skyline.png](/assets/uploads/files/1508239911437-skyline.png) \\n\\n````\\ndef fallingSquares(self, positions):\\n        height = [0]\\n        pos = [0]\\n        res = []\\n        max_h = 0\\n        for left, side in positions:\\n            i = bisect.bisect_right(pos, left)\\n            j = bisect.bisect_left(pos, left + side)\\n            high = max(height[i - 1:j] or [0]) + side\\n            pos[i:j] = [left, left + side]\\n            height[i:j] = [high, height[j - 1]]\\n            max_h = max(max_h, high)\\n            res.append(max_h)\\n        return res"
		}
	],
	"id":"676",
	"title":"Falling Squares",
	"content":"<p>On an infinite number line (x-axis), we drop given squares in the order they are given.</p>\r\n<p>The <code>i</code>-th square dropped (<code>positions[i] = (left, side_length)</code>) is a square with the left-most point being <code>positions[i][0]</code> and sidelength <code>positions[i][1]</code>.</p>\r\n<p>The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next.</p>\r\n<p>The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.</p>\r\n\r\n<br>\r\n<p>Return a list <code>ans</code> of heights.  Each height <code>ans[i]</code> represents the current highest height of any square we have dropped, after dropping squares represented by <code>positions[0], positions[1], ..., positions[i]</code>.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1, 2], [2, 3], [6, 1]]\r\n<b>Output:</b> [2, 5, 5]\r\n<b>Explanation:</b>\r\n<p>\r\nAfter the first drop of <code>positions[0] = [1, 2]:\r\n_aa\r\n_aa\r\n-------\r\n</code>The maximum height of any square is 2.\r\n</p><p>\r\nAfter the second drop of <code>positions[1] = [2, 3]:\r\n__aaa\r\n__aaa\r\n__aaa\r\n_aa__\r\n_aa__\r\n--------------\r\n</code>The maximum height of any square is 5.  \r\nThe larger square stays on top of the smaller square despite where its center\r\nof gravity is, because squares are infinitely sticky on their bottom edge.\r\n</p><p>\r\nAfter the third drop of <code>positions[1] = [6, 1]:\r\n__aaa\r\n__aaa\r\n__aaa\r\n_aa\r\n_aa___a\r\n--------------\r\n</code>The maximum height of any square is still 5.\r\n\r\nThus, we return an answer of <code>[2, 5, 5]</code>.\r\n</pre>\r\n</p>\r\n\r\n<br>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [[100, 100], [200, 100]]\r\n<b>Output:</b> [100, 100]\r\n<b>Explanation:</b> Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>1 <= positions.length <= 1000</code>.</li>\r\n<li><code>1 <= positions[i][0] <= 10^8</code>.</li>\r\n<li><code>1 <= positions[i][1] <= 10^6</code>.</li>\r\n</p>",
	"frequency":"25",
	"ac_num":"2895"
}