{
	"difficulty":"3",
	"submit_num":"2281",
	"show_id":"711",
	"leetcode_id":"711",
	"answers":[
		{
			"lc_ans_id":"108794",
			"view":"2191",
			"top":"0",
			"title":"Consise C++ solution, using DFS +sorting to find canonical representation for each island",
			"vote":"15",
			"content":"After we get coordinates for an island, compute all possible rotations/reflections (https://en.wikipedia.org/wiki/Dihedral_group)  of it and then sort them using the default comparison. The first representation in this order is then the canonical one.\\n\\n```\\nclass Solution {\\npublic:\\n    map<int, vector<pair<int,int>>> mp;\\n    \\n    void dfs(int r, int c, vector<vector<int>> &g, int cnt) {\\n        if ( r < 0 || c < 0 || r >= g.size() || c >= g[0].size()) return;\\n        if (g[r][c] != 1) return;\\n        g[r][c] = cnt;\\n        mp[cnt].push_back({r,c});\\n        dfs(r+1,c,g,cnt);\\n        dfs(r-1,c,g,cnt);\\n        dfs(r,c+1,g,cnt);\\n        dfs(r,c-1,g,cnt);\\n    }\\n    \\n    vector<pair<int,int>> norm(vector<pair<int,int>> v) {\\n        vector<vector<pair<int,int>>> s(8);\\n        // compute rotations/reflections.\\n        for (auto p:v) {\\n            int x = p.first, y = p.second;\\n            s[0].push_back({x,y});\\n            s[1].push_back({x,-y});\\n            s[2].push_back({-x,y});\\n            s[3].push_back({-x,-y});\\n            s[4].push_back({y,-x});\\n            s[5].push_back({-y,x});\\n            s[6].push_back({-y,-x});\\n            s[7].push_back({y,x});\\n        }\\n        for (auto &l:s) sort(l.begin(),l.end());\\n        for (auto &l:s) {\\n            for (int i = 1; i < v.size(); ++i) \\n                l[i] = {l[i].first-l[0].first, l[i].second - l[0].second};\\n            l[0] = {0,0};\\n        }\\n        sort(s.begin(),s.end());\\n        return s[0];\\n    }\\n    \\n    int numDistinctIslands2(vector<vector<int>>& g) {\\n        int cnt = 1;\\n        set<vector<pair<int,int>>> s;\\n        for (int i = 0; i < g.size(); ++i) for (int j = 0; j < g[i].size(); ++j) if (g[i][j] == 1) {\\n            dfs(i,j,g, ++cnt);\\n            s.insert(norm(mp[cnt]));\\n        }\\n        \\n        return s.size();\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"108803",
			"view":"1249",
			"top":"1",
			"title":"Accepted DFS C++ Solution",
			"vote":"3",
			"content":"By using the same DFS approach as in \"[Number of Distinct Island](https://leetcode.com/problems/number-of-distinct-islands/)\", we can calculate the number of \"distinct\" islands by hashing. The DFS part is trivial, the real challenge is how to calculate (hash) the \"Shape\" of an island.\\n\\nHere is my AC C++ implementation using primes as parameters when calculating the hash.\\n\\nThe parameters were carefully chosen as some islands of distinct shapes will collapse into the same hash value If we change some parameter ... :-(\\n\\nPoint it out if you find it fails on certain test cases.\\n\\n\\n\\n**Updated** \\nA better compute_hash function was given below in the same thread.\\n\\n\\n\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    int numDistinctIslands2(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        if (m == 0) return 0;\\n        int n = grid[0].size();\\n        if (n == 0) return 0;\\n        \\n        std::unordered_set<int> signatures;\\n        for (int r = 0; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                if (grid[r][c]) {\\n                    vector<pair<int, int>> pts;\\n                    visit(grid, m, n, r, c, pts);\\n                    int hash = compute_hash(pts);\\n                    signatures.insert(hash);\\n                }\\n            }\\n        }\\n        \\n        return signatures.size();\\n    }\\n    \\nprivate:\\n    int compute_hash(vector<pair<int, int>>& pts) {\\n        int n = pts.size();\\n        int hash = 0;\\n        int xmin = INT_MAX, ymin = INT_MAX, xmax = INT_MIN, ymax = INT_MIN;\\n        for (int i = 0; i < n; ++i) {\\n            const auto& pt1 = pts[i];\\n            xmin = std::min(xmin, pt1.first);\\n            ymin = std::min(ymin, pt1.second);\\n            xmax = std::max(xmax, pt1.first);\\n            ymax = std::max(ymax, pt1.second);\\n            for (int j = i + 1; j < n; ++j) {\\n                const auto& pt2 = pts[j];\\n                int delta_x = pt1.first - pt2.first;\\n                int delta_y = pt1.second - pt2.second;\\n                if (delta_x == 0 || delta_y == 0) {\\n                    hash += 19 * (delta_x * delta_x + delta_y * delta_y);\\n                } else {\\n                    hash += 31 * (delta_x * delta_x + delta_y * delta_y);\\n                }\\n                \\n            }\\n        }\\n\\n        \\n        int delta_x = xmax - xmin, delta_y = ymax - ymin;\\n        hash += 193 * (delta_x * delta_x + delta_y * delta_y) + 97 * delta_x * delta_y;\\n        return hash;\\n    }\\n    \\n    int compute_hash_improved(vector<pair<int, int>>& pts) {\\n        int n = pts.size();\\n        int hash = 0;\\n        std::unordered_map<int, int> stats1, stats2;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            const auto& pt1 = pts[i];\\n            stats1[pt1.first]++;\\n            stats2[pt1.second]++;\\n            for (int j = i + 1; j < n; ++j) {\\n                const auto& pt2 = pts[j];\\n                int delta_x = pt1.first - pt2.first;\\n                int delta_y = pt1.second - pt2.second;\\n                if (delta_x == 0 || delta_y == 0) {\\n                    hash += 19 * (delta_x * delta_x + delta_y * delta_y);\\n                } else {\\n                    hash += 31 * (delta_x * delta_x + delta_y * delta_y);\\n                } \\n            }\\n        }\\n        \\n        for (auto& kv : stats1) {\\n            hash += 73 * kv.second * kv.second;\\n        }\\n        for (auto& kv : stats2) {\\n            hash += 73 * kv.second * kv.second;\\n        }\\n        \\n        int delta_x = stats1.size(), delta_y = stats2.size();\\n        hash += 193 * (delta_x * delta_x + delta_y * delta_y) + 97 * delta_x * delta_y;\\n        return hash;\\n    }\\n\\n    void visit(vector<vector<int>>& grid, int m, int n, int r, int c,\\n               vector<pair<int, int>>& pts) {\\n        bool outOfBound = (r < 0 || r >= m || c < 0 || c >= n);\\n        if (outOfBound || grid[r][c] == 0) return;\\n        \\n        grid[r][c] = 0;\\n        pts.emplace_back(r, c);\\n        visit(grid, m, n, r - 1, c, pts);\\n        visit(grid, m, n, r + 1, c, pts);\\n        visit(grid, m, n, r, c - 1, pts);\\n        visit(grid, m, n, r, c + 1, pts);\\n    }    \\n};\\n```"
		},
		{
			"lc_ans_id":"108798",
			"view":"357",
			"top":"2",
			"title":"Detailed Explanation, Python beat 100% (~350ms)",
			"vote":"2",
			"content":"First of all, please look at my solution to another problem ([#694 Number of Distinct Islands](https://discuss.leetcode.com/topic/106556/clean-python-97-bfs))\\n\\n**Similar to its sister problem, the basic idea is simple:**\\n1. Scan the matrix, each time when 1 is found, search the nearby 1, push them inside a queue and mark them as -1.\\n\\n2. It is important to use the information inside the queue. As we know, the queue stands for a specific shape of an island.\\n\\n    i. Push the island to the left upper corner by subtracting the original data with its minimum axis value.\\n    ii. Sort the queue and tuple it to avoid redundancy.\\n    iii. Find its x-axis mirror: (x,y) --> (-x,y)\\n    iv. Find its y-axis mirror: (x,y) --> (x,-y)\\n    v. Find its origin mirror: (x,y) --> (-x,-y)\\n    vi. Find its diagonal mirror: (x,y) --> (y,x)\\n    vii. Repeat 2.3, 2.4, and 2.5 on the diagonal mirror island.\\n    viii. Add all these 8 islands into the pool\\n\\n\\n**There are several tricks are used here:**\\n* Augment the original matrix (grid) with a row of zeros and a column of zeros. This is to avoid the check of index every single time\\n\\n* Instead of using another matrix to store the visited element, I directly change the value in place. -1 indicates visited. You can use a deep copy if you do not like change value in place.\\n\\n* The element in the queue is centered by subtracting the minimum x and minimum y and then sorted, so that this shape of island will be unique. \\n\\n\\n```\\nclass Solution(object):\\n    def numDistinctIslands2(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]: return 0\\n        m,n=len(grid),len(grid[0])\\n\\n        # augment matrix to void length check\\n        grid.append([0]*n)\\n        for row in grid: row.append(0)\\n\\n        self.pool=set()\\n        self.res=0\\n\\n        def bfs(i0,j0):\\n            grid[i0][j0]=-1\\n            q=[(i0,j0)]\\n            for i,j in q:\\n                for I,J in (i-1,j),(i+1,j),(i,j-1),(i,j+1):\\n                    if grid[I][J]==1:\\n                        grid[I][J]=-1\\n                        q.append([I,J])\\n            self.addisland(q)\\n       \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1: bfs(i,j)\\n\\n        return self.res\\n\\n    def addisland(self,q):\\n            Imin=min(x for x,y in q)\\n            Jmin=min(y for x,y in q)\\n            island1=tuple(sorted((x-Imin,y-Jmin) for x,y in q)) # original island\\n           \\n            if island1 in self.pool: return None\\n            self.res+=1\\n\\n            Imax=max(x for x,y in island1)\\n            Jmax=max(y for x,y in island1)\\n\\n            island2=tuple(sorted((-x+Imax,y) for x,y in island1)) # x axis mirror\\n            island3=tuple(sorted((x,-y+Jmax) for x,y in island1)) # y axis mirror\\n            island4=tuple(sorted((-x+Imax,-y+Jmax) for x,y in island1)) # origin mirror\\n\\n            island5=tuple(sorted((y,x) for x,y in island1)) # diagonal mirror\\n            island6=tuple(sorted((-x+Jmax,y) for x,y in island5))\\n            island7=tuple(sorted((x,-y+Imax) for x,y in island5))\\n            island8=tuple(sorted((-x+Jmax,-y+Imax) for x,y in island5))\\n\\n            self.pool|=set([island1,island2,island3,island4,island5,island6,island7,island8])"
		},
		{
			"lc_ans_id":"108801",
			"view":"392",
			"top":"3",
			"title":"Python solution using set",
			"vote":"2",
			"content":"Find every island by running ```dfs()``` to every cell and assign each island a unique ```ID```.\\nThis also takes care of the \"mark visited\" operation for us (and that's why the ```ID``` should begin with 2 instead of 1).\\nWe also want to know the minimum rectangle that wraps the island; that's what the ```boarder``` variable does. \\nWith ```boarder``` and ```ID```, we can extract the island (marking the island body as 1). It's possible other island might be partially or totally included within current boarder so make sure we ignore them when the ```ID``` mismatched.\\nBy using the hashable tuple in Python, there's no need to manually do hash code calculation. All we need is a ```set()``` to allow constant time existence checking.\\nFor each extracted island, try every possible rotation and reflection. Early return in case of existence, otherwise it's an unseen island shape and we want to add it to our ```set```.\\nThe answer is the size of this ```set```.\\n```\\nclass Solution(object):\\n    def numDistinctIslands2(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        def dfs(i, j, ID, boarder):\\n            grid[i][j] = ID\\n            boarder[0] = min(boarder[0], i)\\n            boarder[1] = max(boarder[1], i)\\n            boarder[2] = min(boarder[2], j)\\n            boarder[3] = max(boarder[3], j)\\n            for k, d in enumerate([(-1, 0), (1, 0), (0, -1), (0, 1)]):\\n                if 0 <= i+d[0] < m and 0 <= j+d[1] < n and grid[i+d[0]][j+d[1]] == 1:\\n                    dfs(i+d[0], j+d[1], ID, boarder)\\n        \\n        def extract(ID, bi, ei, bj, ej):\\n            return tuple(tuple(map(lambda x: '1' if x == ID else ' ', grid[k][bj:ej+1])) for k in xrange(bi, ei+1))\\n        \\n        def rotate(t):\\n            t = t[::-1]\\n            return tuple(zip(*t))\\n        \\n        def addToSet(t):\\n            for i in xrange(4):\\n                t = rotate(t)\\n                # Left/Right mirror\\n                lrm = tuple(tuple(r[::-1]) for r in t)\\n                # Up/Down mirror\\n                udm = tuple(tuple(t[i]) for i in xrange(len(t)-1, -1, -1))\\n                if t in self.ans or lrm in self.ans or udm in self.ans:\\n                    return\\n            self.ans.add(t)\\n                       \\n        ID = 2\\n        self.ans = set()\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == 1:\\n                    boarder = [i, i, j, j]\\n                    dfs(i, j, ID, boarder)\\n                    t = extract(ID, *boarder)\\n                    addToSet(t)\\n                    ID += 1\\n        \\n        return len(self.ans)\\n        \\n```"
		},
		{
			"lc_ans_id":"108797",
			"view":"115",
			"top":"4",
			"title":"after rotation or/A~~~N~~~D~~~ reflection!",
			"vote":"1",
			"content":"after rotation or reflection\\nis different from \\nafter rotation or/and reflection\\n!!!"
		},
		{
			"lc_ans_id":"108802",
			"view":"953",
			"top":"5",
			"title":"brain dead, no hash, straightforward solution",
			"vote":"1",
			"content":"A straightforward solution, note isReflection() and is90()\\n```c++\\nclass Solution {\\n    struct point {\\n        int x, y;\\n        point(int x_, int y_) :x(x_), y(y_) {;}\\n        bool operator<(const point& other) const {\\n            if (other.y == y) {\\n                return other.x < x;\\n            }\\n            return other.y < y;\\n        }\\n\\n        bool operator!=(const point& other) const {\\n            return x != other.x || y != other.y; // or !(*this < other) && !(*this > other)\\n        }\\n\\n        bool operator==(const point& other) const {\\n            return !(*this != other);\\n        }\\n    };\\n\\n    int n, m;\\n\\n    const vector<int> dx {-1, 0, 1, 0};\\n    const vector<int> dy {0, 1, 0, -1};\\n\\n    point getNext(int i, int x, int y) {\\n        return point{x + dx[i], y + dy[i]};\\n    }\\n\\n    bool inBound(point& p) {\\n        return p.x >= 0 && p.x < n && p.y >= 0 && p.y <m;\\n    }\\n\\n    void collector(vector<point>& points, int x, int y, vector<vector<int>>& grid) {\\n        deque<point> q;\\n        q.emplace_back(x, y);\\n        int minx = x, miny = y;\\n        while(!q.empty()) {\\n            auto top = q.front();\\n            q.pop_front();\\n            points.push_back(top);\\n            for (int i = 0; i < 4; ++i) {\\n                auto next = getNext(i, top.x, top.y);\\n                if (inBound(next) && grid[next.x][next.y]) {\\n                    grid[next.x][next.y] = 0;\\n                    q.emplace_back(next.x, next.y);\\n                    minx = min(minx, next.x);\\n                    miny = min(miny, next.y);\\n                }\\n            }\\n        }\\n        for (auto& p: points) {\\n            p.x -= minx;\\n            p.y -= miny;\\n        }\\n        sort(points.begin(), points.end());\\n    }\\n\\n    bool isReflection(vector<point>& l, vector<point> r) {\\n        if (l.size() != r.size()) return false;\\n        int minx = INT_MAX;\\n        for (int i = 0; i < r.size(); ++i) {\\n            r[i].x = -r[i].x;\\n            minx = min(minx, r[i].x);\\n        }\\n\\n        for (int i = 0; i < r.size(); ++i) {\\n            r[i].x -= minx;\\n        }\\n\\n        sort(r.begin(), r.end());\\n        return l == r;\\n    }\\n\\n    // rotate r\\n    bool is90(vector<point>& l, vector<point>& r) {\\n        if (l.size() != r.size()) return false;\\n        int minx = INT_MAX, miny = INT_MAX;\\n        for (int i = 0; i < r.size(); ++i) {\\n            int oldx = r[i].x, oldy = r[i].y;\\n            r[i].x = oldy; r[i].y = -oldx;\\n            minx = min(minx, r[i].x);\\n            miny = min(miny, r[i].y);\\n        }\\n\\n        for (int i = 0; i < r.size(); ++i) {\\n            r[i].x -= minx; r[i].y -= miny;\\n        }\\n\\n        sort(r.begin(), r.end());\\n        return l == r;\\n    }\\n\\npublic:\\n    int numDistinctIslands2(vector<vector<int>>& grid) {\\n        vector<vector<point>> islands;\\n        unordered_set<int> index;\\n        n = grid.size();\\n        if (0 == n) return 0;\\n        m = grid[0].size();\\n        for (int x = 0; x < n; ++x) {\\n            for (int y = 0; y < m; ++y) {\\n                if (1 == grid[x][y]) {\\n                    grid[x][y] = 0;\\n                    islands.emplace_back();\\n                    index.insert(islands.size() - 1);\\n                    collector(islands.back(), x, y, grid);\\n                }\\n            }\\n        }\\n        auto cur = index.begin();\\n        while (cur != index.end()) {\\n            auto itor = std::next(cur);\\n            while (itor != index.end()) {\\n                bool eq = false;\\n                for (auto r : {90, 180, 270, 360}) {\\n                    if (is90(islands[*cur], islands[*itor]) ||\\n                        isReflection(islands[*cur], islands[*itor])) {\\n                        itor = index.erase(itor);\\n                        eq = true;\\n                        break;\\n                    }\\n                }\\n\\n                if (!eq) {\\n                    itor++;\\n                }\\n            }\\n            cur++;\\n        }\\n        return index.size();\\n    }\\n};\\n```\\nPost here for reference, but a hashed version would be much better in terms of runtime though."
		},
		{
			"lc_ans_id":"108796",
			"view":"59",
			"top":"6",
			"title":"Straightforward C++ solution, using DFS and generate all possible shapes for islands.",
			"vote":"0",
			"content":"The solution takes the idea that every island is located in one rectangle, so when find the matrix that exactly contains the island, we could use a string consists of 0s and 1s to represent the shape of the island. For example:\\n01\\n11\\nso we first have \"01*11*\"(at end of line add a unique character to indicate the end), then we could generate other shapes after some rotation or reflection and store all the unique shapes. The island with the same string must have the same shape. \\nAnd to generate all the possible strings of shapes after rotation or reflection, it's the different ways of traversing the matrix.  Start from each corner of the matrix, we have two directions, therefore in total we will have at most 8 different strings of shapes.\\n\\nOverall, this solution is pretty straightforward, using the hash one will be more efficient both for time and space.\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<int> dirs = {0, 1, 0, -1, 0};\\n    set<string> rec; // record of all possible island shapes\\n    \\n    int numDistinctIslands2(vector<vector<int>>& grid) {\\n        m = grid.size(), n = m > 0 ? grid[0].size() : 0;\\n        if(m == 0 || n == 0) return 0;\\n        int count = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(grid[i][j] == 1) {\\n                    bool found = getShape(grid, i, j);\\n                    if(found) ++count;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    bool getShape(vector<vector<int>>& grid, int x, int y) {\\n        queue<pair<int, int>> que;\\n        que.push({x, y});\\n        grid[x][y] = 2;\\n        int li = x, lj = y, ri = x, rj = y;\\n        while(!que.empty()) {\\n            auto p = que.front();\\n            que.pop();\\n            for(int k = 0; k < 4; ++k) {\\n                int i = p.first + dirs[k];\\n                int j = p.second + dirs[k+1];\\n                if(i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1) {\\n                    que.push({i, j});\\n                    grid[i][j] = 2;\\n                    li = min(li, i);\\n                    lj = min(lj, j);\\n                    ri = max(ri, i);\\n                    rj = max(rj, j);\\n                }\\n            }\\n        }\\n        string s1 = \"\"; // original\\n        for(int i = li; i <= ri; ++i) {\\n            for(int j = lj; j <= rj; ++j) {\\n                if(grid[i][j] == 2) s1 += \"1\";\\n                else s1 += \"0\";\\n            }\\n            s1 += \"*\";\\n        }\\n        if(rec.find(s1) != rec.end()) { restore(grid, li, lj, ri, rj); return false;}\\n        \\n        string s2 = \"\"; // rotate 90 degree\\n        for(int j = lj; j <= rj; ++j) {\\n            for(int i = ri; i >= li; --i) {\\n                if(grid[i][j] == 2) s2 += \"1\";\\n                else s2 += \"0\";\\n            }\\n            s2 += \"*\";\\n        }\\n        if(rec.find(s2) != rec.end()) { restore(grid, li, lj, ri, rj); return false;}\\n        \\n        string s3 = \"\"; // rotate 180 degree\\n        for(int i = ri; i >= li; --i) {\\n            for(int j = rj; j >= lj; --j) {\\n                if(grid[i][j] == 2) s3 += \"1\";\\n                else s3 += \"0\";\\n            }\\n            s3 += \"*\";\\n        }\\n        if(rec.find(s3) != rec.end()) { restore(grid, li, lj, ri, rj); return false;}\\n        \\n        string s4 = \"\"; // rotate 270 degree\\n        for(int j = rj; j >= lj; --j) {\\n            for(int i = li; i <= ri; ++i) {\\n                if(grid[i][j] == 2) s4 += \"1\";\\n                else s4 += \"0\";\\n            }\\n            s4 += \"*\";\\n        }\\n        if(rec.find(s4) != rec.end()) { restore(grid, li, lj, ri, rj); return false;}\\n        \\n        string s5 = \"\"; // up/down reflection\\n        for(int i = ri; i >= li; --i) {\\n            for(int j = lj; j <= rj; ++j) {\\n                if(grid[i][j] == 2) s5 += \"1\";\\n                else s5 += \"0\";\\n            }\\n            s5 += \"*\";\\n        }\\n        if(rec.find(s5) != rec.end()) { restore(grid, li, lj, ri, rj); return false;}\\n        \\n        string s6 = \"\"; // up/down reflection\\n        for(int j = rj; j >= lj; --j) {\\n            for(int i = ri; i >= li; --i) {\\n                if(grid[i][j] == 2) s6 += \"1\";\\n                else s6 += \"0\";\\n            }\\n            s6 += \"*\";\\n        }\\n        if(rec.find(s6) != rec.end()) { restore(grid, li, lj, ri, rj); return false;}\\n        \\n        string s7 = \"\"; // left/right reflection\\n        for(int i = li; i <= ri; ++i) {\\n            for(int j = rj; j >= lj; --j) {\\n                if(grid[i][j] == 2) s7 += \"1\";\\n                else s7 += \"0\";\\n            }\\n            s7 += \"*\";\\n        }\\n        if(rec.find(s7) != rec.end()) { restore(grid, li, lj, ri, rj); return false;}\\n        \\n        string s8 = \"\"; // left/right reflection\\n        for(int j = lj; j <= rj; ++j) {\\n            for(int i = li; i <= ri; ++i) {\\n                if(grid[i][j] == 2) s8 += \"1\";\\n                else s8 += \"0\";\\n            }\\n            s8 += \"*\";\\n        }\\n        if(rec.find(s8) != rec.end()) { restore(grid, li, lj, ri, rj); return false;}\\n        restore(grid, li, lj, ri, rj);\\n        rec.insert(s1);rec.insert(s2);rec.insert(s3);rec.insert(s4);\\n        rec.insert(s5);rec.insert(s6);rec.insert(s7);rec.insert(s8);\\n        return true;\\n    }\\n    \\n    void restore(vector<vector<int>>& grid, int li, int lj, int ri, int rj) {\\n        for(int j = lj; j <= rj; ++j) {\\n            for(int i = li; i <= ri; ++i) {\\n                if(grid[i][j] == 2) grid[i][j] = 0;\\n            }\\n        }\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"108799",
			"view":"270",
			"top":"7",
			"title":"Java version, time complexity worst case O(n^2 log(n^2))",
			"vote":"0",
			"content":"Record all the points along the path during DFS. Then add all the eight combinations of `reflection, rotation` into a array of points. From their, sort each list `where time complexity would be O(n^2 * log(n^2))`. Substract the first point's x and y value from all the points in the list, which identifies a shape uniquely. \\n\\nIn Java, HashSet only compares `hashCode()` and `equals()` function so we have to convert the shape into a String and we only need to take the smallest string out of the eight combinations for uniqueness comparison.\\n```\\nclass Solution {\\n    private final int[] dir = {-1, 0, 1, 0, -1};\\n    private final int[][] refl = {{1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\\n    public int numDistinctIslands2(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        Set<String> set = new HashSet<>();\\n\\n        List<Point> list = new ArrayList<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                dfs(grid, i, j, list);\\n                if (list.size() > 0) {\\n                    set.add(norm(list));\\n                    list.clear();\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n    \\n    private void dfs(int[][] grid, int row, int col, List<Point> list) {\\n        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] != 1) return;\\n        grid[row][col] = 2;\\n        list.add(new Point(row, col));\\n        for (int i = 0; i < 4; i++) {\\n            dfs(grid, row + dir[i], col + dir[i+1], list);\\n        }\\n    }\\n    \\n    @SuppressWarnings(\"unchecked\")\\n\\tprivate String norm(List<Point> list) {\\n        List<Point>[] comb = new List[8];\\n        \\n        for (int i = 0; i < 4; i++) {\\n            comb[i] = new ArrayList<Point>();\\n            comb[i+4] = new ArrayList<Point>();\\n            for (Point p : list) {\\n                comb[i].add(new Point(p.x * refl[i][0], p.y * refl[i][1]));\\n                comb[i+4].add(new Point(p.y * refl[i][1], p.x * refl[i][0]));\\n            }\\n        }\\n        \\n        for (int i = 0; i < 8; i++) {\\n        \\tCollections.sort(comb[i]);\\n        }\\n        String[] s = new String[8];\\n        for (int i = 0; i < 8; i++) {\\n           \\tStringBuilder sb = new StringBuilder();\\n            int x0 = comb[i].get(0).x, y0 = comb[i].get(0).y;\\n        \\tfor (Point p : comb[i]) {\\n        \\t\\tsb.append(p.x - x0);\\n                sb.append(',');\\n                sb.append(p.y - y0);\\n                sb.append('!');\\n        \\t}\\n        \\ts[i] = sb.toString();\\n        }\\n        Arrays.sort(s);\\n        return s[0];\\n    }\\n    \\n    public static class Point implements Comparable<Point> {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int compareTo(Point p) {\\n            return this.x - p.x == 0 ? this.y - p.y : this.x - p.x;\\n        }\\n        @Override\\n        public String toString() {\\n            return String.format(\"(%d,%d)\", this.x, this.y);\\n        }\\n    }\\n}\\n```\\nBFS version attached, DFS was tricky dealing with the worst test case.\\n```\\n    private final int[] dir = {-1, 0, 1, 0, -1};\\n    private final int[][] refl = {{1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\\n    public int numDistinctIslands2(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        Set<String> set = new HashSet<>();\\n\\n        List<Point> list = new ArrayList<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) bfs(grid, i, j, list);\\n                if (list.size() > 0) {\\n                    set.add(norm(list));\\n                    list.clear();\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n    \\n    private void bfs(int[][] grid, int row, int col, List<Point> list) {\\n        Queue<Point> queue = new ArrayDeque<>();\\n        Point start = new Point(row, col);\\n        queue.add(start);\\n        list.add(start);\\n        grid[row][col] = 2;\\n        while (!queue.isEmpty()) {\\n            Point p = queue.poll();\\n            for (int i = 0; i < 4; i++) {\\n                int r = p.x + dir[i], c = p.y + dir[i+1];\\n                if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] != 1) continue;\\n                grid[r][c] = 2;\\n                Point next = new Point(r, c);\\n                list.add(next);\\n                queue.add(next);\\n            }\\n        }\\n    }\\n    \\n    @SuppressWarnings(\"unchecked\")\\n\\tprivate String norm(List<Point> list) {\\n        List<Point>[] comb = new List[8];\\n        \\n        for (int i = 0; i < 4; i++) {\\n            comb[i] = new ArrayList<Point>();\\n            comb[i+4] = new ArrayList<Point>();\\n            for (Point p : list) {\\n                comb[i].add(new Point(p.x * refl[i][0], p.y * refl[i][1]));\\n                comb[i+4].add(new Point(p.y * refl[i][1], p.x * refl[i][0]));\\n            }\\n        }\\n        \\n        for (int i = 0; i < 8; i++) {\\n        \\tCollections.sort(comb[i]);\\n        }\\n        String[] s = new String[8];\\n        for (int i = 0; i < 8; i++) {\\n           \\tStringBuilder sb = new StringBuilder();\\n            int x0 = comb[i].get(0).x, y0 = comb[i].get(0).y;\\n        \\tfor (Point p : comb[i]) {\\n        \\t\\tsb.append(p.x - x0);\\n                sb.append(',');\\n                sb.append(p.y - y0);\\n                sb.append('!');\\n        \\t}\\n        \\ts[i] = sb.toString();\\n        }\\n        Arrays.sort(s);\\n        return s[0];\\n    }\\n    \\n    public static class Point implements Comparable<Point> {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int compareTo(Point p) {\\n            return this.x - p.x == 0 ? this.y - p.y : this.x - p.x;\\n        }\\n    }\\n```"
		},
		{
			"lc_ans_id":"108795",
			"view":"264",
			"top":"8",
			"title":"C++ DFS + Rotate Function, Easy to understand",
			"vote":"0",
			"content":"```\\nusing pii = pair<int, int>;\\nclass Solution {\\n    int n,m;\\n    int cnt;\\n    vector<vector<bool>> vis;\\n    int dir[8] = {0, 1, 0, -1, -1, 0, 1, 0};\\n    vector<vector<int>> grid;\\n    \\n    //find each island, store the position array\\n    void dfs(int x, int y, vector<pii>& t) {\\n        vis[x][y] = true;\\n        t.push_back({x, y});\\n        for (int k = 0; k < 8;) {\\n            int dx = x + dir[k++];\\n            int dy = y + dir[k++];\\n            if (dx < 0 || dx >= n || dy < 0 || dy >= m) continue;\\n            if (vis[dx][dy] || grid[dx][dy] == 0) continue;\\n            dfs(dx, dy, t);\\n        }\\n    }\\n\\n\\n    vector<vector<pii>> islands;\\n\\n    //generate position string\\n    string get(int x, int y) {\\n        return to_string(x) + \",\" + to_string(y) + \",\";\\n    }\\n    \\n    //calculate the position after rotate\\n    //0 : original\\n    //1 : rotate clockwise 90\\n    //2 : rotate clockwise 180\\n    //3 : rotate clockwise 270\\n    //4 : reflection left and right\\n    //5 : reflection up and down\\n    \\n    \\n    //e.g. in original grid, there is a position p(x, y)\\n    //      (Y , m columns)\\n    //         y \\n    //   -------------------->   \\n    //   |     | \\n    //   |     |\\n    // x |-----p\\n    //   |\\n    //   |\\n    //   V\\n    // (X , n rows)\\n    \\n    \\n    //   let's rotate the whole grid clockwise 90 degree\\n    //   (X , n columns)\\n    //                  x     \\n    //   <--------------------   \\n    //                  |    |\\n    //                  |    |  \\n    //                  p----| y   (Y , m rows)  \\n    //                       | \\n    //                       |  \\n    //                       V  \\n    //                    \\n    // if we put this p(x, y) to the original grid, the position should be (y, n - 1 - x)\\n    \\n    pii rotate(int x, int y, int type) {\\n        if (type == 0) {\\n            return {x, y};\\n        } else if (type == 1) {\\n            return {y, n - 1 - x};\\n        } else if (type == 2) {\\n            return {n - 1 - x, m - 1 - y};\\n        } else if (type == 3) {\\n            return {m - 1 - y, x};\\n        } else if (type == 4) {\\n            return {n - 1 - x, y};\\n        } else if (type == 5) {\\n            return {x, m - 1 - y};\\n        }\\n    }\\npublic:\\n    int numDistinctIslands2(vector<vector<int>>& grid) {\\n        this->grid = grid;\\n        n = grid.size(), m = n ? grid[0].size() : 0;\\n        if (!n || !m) return 0;\\n        cnt = 0;\\n        vis.resize(n, vector<bool>(m, false));\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (!vis[i][j] && grid[i][j] == 1) {\\n                    vector<pii> t;\\n                    dfs(i, j, t);\\n                    islands.push_back(t);\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        unordered_set<string> S;\\n        for (int i = 0; i < islands.size(); i++) {\\n            vector<pii> cur = islands[i];\\n            vector<string> tmp;\\n            \\n            // calculate 6 circumstances positions array\\n            for (int j = 0; j < 6; j ++) {\\n                vector<pii> t;\\n                for (auto p : cur) {\\n                    t.push_back(rotate(p.first, p.second, j));\\n                }\\n                sort(t.begin(), t.end());\\n                auto start = t[0];\\n                string s = \"\";\\n                \\n                //all positions should be relative to the first position\\n                for (int i = 0; i < t.size(); i++) {\\n                    int x = t[i].first - start.first;\\n                    int y = t[i].second - start.second;\\n                    s += get(x, y);\\n                }\\n                tmp.push_back(s);\\n            }\\n            int find = 0;\\n            for (auto s : tmp) {\\n                if (S.find(s) != S.end()) find++;\\n            }\\n            \\n            // if all 6 circumstances are not existed before, we find a new distinct island\\n            if (find == 0) res++;\\n\\n            for (auto s : tmp) {\\n                S.insert(s);\\n            }\\n\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n\\n\\n```"
		},
		{
			"lc_ans_id":"108800",
			"view":"741",
			"top":"9",
			"title":"Java Version, compute Hash",
			"vote":"0",
			"content":"class Solution {\\n    static final int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    public int numDistinctIslands2(int[][] grid) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    List<int[]> tuple = new ArrayList<>();\\n                    dfs(i, j, grid, tuple);\\n                    int hash = computeHash(tuple);\\n                    set.add(hash);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n    public int computeHash(List<int[]> tuple){\\n        int n = tuple.size();\\n        int hash = 0;\\n        HashMap<Integer, Integer> stats1 = new HashMap();\\n        HashMap<Integer, Integer> stats2 = new HashMap();\\n        for (int i = 0; i < n; ++i) {\\n           int[] pt1 = tuple.get(i);\\n            stats1.put(pt1[0], stats1.getOrDefault(pt1[0], 0) + 1);\\n            stats2.put(pt1[1], stats2.getOrDefault(pt1[1], 0) + 1);\\n            for (int j = i + 1; j < n; ++j) {\\n                int[] pt2 = tuple.get(j);\\n                int delta_x = pt1[0] - pt2[0];\\n                int delta_y = pt1[1] - pt2[1];\\n                if (delta_x == 0 || delta_y == 0) {\\n                    hash += 19 * (delta_x * delta_x + delta_y * delta_y);\\n                } else {\\n                    hash += 31 * (delta_x * delta_x + delta_y * delta_y);\\n                } \\n            }\\n        }\\n        \\n        for (int kv : stats1.keySet()) {\\n            hash += 73 * stats1.get(kv) * stats1.get(kv);\\n        }\\n        for (int kv : stats2.keySet()) {\\n            hash += 73 * stats2.get(kv) * stats2.get(kv);\\n        }\\n        \\n        int delta_x = stats1.size(), delta_y = stats2.size();\\n        hash += 193 * (delta_x * delta_x + delta_y * delta_y) + 97 * delta_x * delta_y;\\n        return hash;\\n    }\\n    public void dfs(int row, int col, int[][] grid, List<int[]> tuple){\\n        if(row < 0 || col < 0 || row >= grid.length || col >= grid[0].length) return;\\n        if(grid[row][col] == 0) return;\\n        \\n        grid[row][col] = 0;\\n        tuple.add(new int[]{row, col});\\n        for(int dir[] : dirs){\\n            dfs(row + dir[0], col + dir[1], grid, tuple);\\n        }\\n    }\\n}"
		}
	],
	"id":"677",
	"title":"Number of Distinct Islands II",
	"content":"<p>Given a non-empty 2D array <code>grid</code> of 0's and 1's, an <b>island</b> is a group of <code>1</code>'s (representing land) connected 4-directionally (horizontal or vertical.)  You may assume all four edges of the grid are surrounded by water.</p>\r\n\r\n<p>Count the number of <b>distinct</b> islands.  An island is considered to be the same as another if they have the same shape, or have the same shape after <b>rotation</b> (90, 180, or 270 degrees only) or <b>reflection</b> (left/right direction or up/down direction).</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n11000\r\n10000\r\n00001\r\n00011\r\n</pre>\r\nGiven the above grid map, return <code>1</code>.\r\n<br><br>\r\nNotice that:\r\n<pre>\r\n11\r\n1\r\n</pre>\r\nand\r\n<pre>\r\n 1\r\n11\r\n</pre>\r\nare considered <b>same</b> island shapes. Because if we make a 180 degrees clockwise rotation on the first island, then two islands will have the same shapes.\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n11100\r\n10001\r\n01001\r\n01110</pre>\r\nGiven the above grid map, return <code>2</code>.<br />\r\n<br>\r\nHere are the two distinct islands:\r\n<pre>\r\n111\r\n1\r\n</pre>\r\nand\r\n<pre>\r\n1\r\n1\r\n</pre>\r\n<br />\r\nNotice that:\r\n<pre>\r\n111\r\n1\r\n</pre>\r\nand\r\n<pre>\r\n1\r\n111\r\n</pre>\r\nare considered <b>same</b> island shapes. Because if we flip the first array in the up/down direction, then they have the same shapes.\r\n</p>\r\n\r\n<p><b>Note:</b>\r\nThe length of each dimension in the given <code>grid</code> does not exceed 50.\r\n</p>",
	"frequency":"88",
	"ac_num":"984"
}