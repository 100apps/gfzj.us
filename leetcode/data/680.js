{
	"difficulty":"2",
	"submit_num":"22603",
	"show_id":"714",
	"leetcode_id":"714",
	"answers":[
		{
			"lc_ans_id":"108870",
			"view":"9515",
			"top":"0",
			"title":"Most consistent ways of dealing with the series of stock problems",
			"vote":"178",
			"content":"Note: this is a repost of my original post [here](https://discuss.leetcode.com/topic/97310/most-consistent-ways-of-dealing-with-the-series-of-stock-problems) with updated solutions for this problem ([714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)). If you are only looking for solutions, you can go directly to each section in part **`II -- Applications to specific cases`**.\\n\\n---\\nUp to this point, I believe you have finished the following series of stock problems: \\n1. [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/#/description)\\n2. [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/#/description)\\n3. [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/#/description)\\n4. [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/#/description)\\n5. [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/#/description)\\n6. [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)\\n\\nFor each problem, we've got a couple of excellent posts explaining how to approach it. However, most of the posts failed to identify the connections among these problems and made it hard to develop a consistent way of dealing with this series of problems. Here I will introduce the most generalized solution applicable to all of these problems, and its specialization to each of the six problems above.\\n \\n---\\n**`I -- General cases`**\\n\\nThe idea begins with the following question: **Given an array representing the price of stock on each day, what determines the maximum profit we can obtain?**\\n\\nMost of you can quickly come up with answers like \"it depends on which day we are and how many transactions we are allowed to complete\". Sure, those are important factors as they manifest themselves in the problem descriptions. However, there is a hidden factor that is not so obvious but vital in determining the maximum profit, which is elaborated below.\\n\\nFirst let's spell out the notations to streamline our analyses. Let `prices` be the stock price array with length `n`, `i` denote the `i-th` day (`i` will go from `0` to `n-1`), `k` denote the maximum number of transactions allowed to complete, `T[i][k]` be the maximum profit that could be gained at the end of the `i-th` day with at most `k` transactions. Apparently we have base cases: `T[-1][k] = T[i][0] = 0`, that is, no stock or no transaction yield no profit (note the first day has `i = 0` so `i = -1` means no stock). Now if we can somehow relate `T[i][k]` to its subproblems like `T[i-1][k], T[i][k-1], T[i-1][k-1], ...`, we will have a working recurrence relation and the problem can be solved recursively. So how do we achieve that?\\n\\nThe most straightforward way would be looking at actions taken on the `i-th` day. How many options do we have? The answer is three: **buy**, **sell**, **rest**. Which one should we take? The answer is: we don't really know, but to find out which one is easy. We can try each option and then choose the one that maximizes our profit, provided there are no other restrictions. However, we do have an extra restriction saying no multiple transactions are allowed at the same time, meaning if we decide to **buy** on the `i-th` day, there should be `0` stock held in our hand; if we decide to **sell** on the `i-th` day, there should be exactly `1` stock held in our hand. The number of stocks held in our hand is the hidden factor mentioned above that will affect the action on the `i-th` day and thus affect the maximum profit.\\n\\nTherefore our definition of `T[i][k]` should really be split into two: `T[i][k][0]` and `T[i][k][1]`, where the **former** denotes the maximum profit at the end of the `i-th` day with at most `k` transactions and with `0` stock in our hand AFTER taking the action, while the **latter** denotes the maximum profit at the end of the `i-th` day with at most `k` transactions and with `1` stock in our hand AFTER taking the action. Now the base cases and the recurrence relations can be written as:\\n\\n1. Base cases:\\n`T[-1][k][0] = 0, T[-1][k][1] = -Infinity`\\n`T[i][0][0] = 0, T[i][0][1] = -Infinity`\\n\\n2. Recurrence relation:\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i])`\\n\\nFor the base cases, `T[-1][k][0] = T[i][0][0] = 0` has the same meaning as before while `T[-1][k][1] = T[i][0][1] = -Infinity` emphasizes the fact that it is impossible for us to have `1` stock in hand if there is no stock available or no transactions are allowed.\\n\\nFor `T[i][k][0]` in the recurrence relations, the actions taken on the `i-th` day can only be **rest** and **sell**, since we have `0` stock in our hand at the end of the day. `T[i-1][k][0]` is the maximum profit if action **rest** is taken, while `T[i-1][k][1] + prices[i]` is the maximum profit if action **sell** is taken. Note that the maximum number of allowable transactions remains the same, due to the fact that a transaction consists of two actions coming as a pair -- **buy** and **sell**. Only action **buy** will change the maximum number of transactions allowed (well, there is actually an alternative interpretation, see my [comment](https://discuss.leetcode.com/topic/107998/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/18) below).\\n\\nFor `T[i][k][1]` in the recurrence relations, the actions taken on the `i-th` day can only be **rest** and **buy**, since we have `1` stock in our hand at the end of the day. `T[i-1][k][1]` is the maximum profit if action **rest** is taken, while `T[i-1][k-1][0] - prices[i]` is the maximum profit if action **buy** is taken. Note that the maximum number of allowable transactions decreases by one, since buying on the `i-th` day will use one transaction, as explained above.\\n\\nTo find the maximum profit at the end of the last day, we can simply loop through the `prices` array and update `T[i][k][0]` and `T[i][k][1]` according to the recurrence relations above. The final answer will be `T[i][k][0]` (we always have larger profit if we end up with `0` stock in hand).\\n\\n---\\n**`II -- Applications to specific cases`**\\n\\nThe aforementioned six stock problems are classified by the value of `k`, which is the maximum number of allowable transactions (the last two also have additional requirements such as \"cooldown\" or \"transaction fee\"). I will apply the general solution to each of them one by one.\\n\\n**Case I: `k = 1`**\\n\\nFor this case, we really have two unknown variables on each day: `T[i][1][0]` and `T[i][1][1]`, and the recurrence relations say:\\n\\n`T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])`\\n`T[i][1][1] = max(T[i-1][1][1], T[i-1][0][0] - prices[i]) = max(T[i-1][1][1], -prices[i])`\\n\\nwhere we have taken advantage of the base case`T[i][0][0] = 0` for the second equation.\\n\\nIt is straightforward to write the `O(n)` time and `O(n)` space solution, based on the two equations above. However, if you notice that the maximum profits on the `i-th` day actually only depend on those on the `(i-1)-th` day, the space can be cut down to `O(1)`. Here is the space-optimized solution:\\n\\n```\\npublic int maxProfit(int[] prices) {\\n    int T_i10 = 0, T_i11 = Integer.MIN_VALUE;\\n        \\n    for (int price : prices) {\\n        T_i10 = Math.max(T_i10, T_i11 + price);\\n        T_i11 = Math.max(T_i11, -price);\\n    }\\n        \\n    return T_i10;\\n}\\n```\\nNow let's try to gain some insight of the solution above. If we examine the part inside the loop more carefully, `T_i11` really just represents the maximum value of the negative of all stock prices up to the `i-th` day, or equivalently the minimum value of all the stock prices. As for `T_i10`, we just need to decide which action yields a higher profit, sell or rest. And if action sell is taken, the price at which we bought the stock is `T_i11`, i.e., the minimum value before the `i-th` day. This is exactly what we would do in reality if we want to gain maximum profit. I should point out that this is not the only way of solving the problem for this case. You may find some other nice solutions [here](https://discuss.leetcode.com/topic/19853/kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input).\\n\\n**Case II: `k = +Infinity`**\\n\\nIf `k` is positive infinity, then there isn't really any difference between `k` and `k - 1` (wonder why? see my [comment](https://discuss.leetcode.com/topic/107998/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/9) below), which implies `T[i-1][k-1][0] = T[i-1][k][0]` and `T[i-1][k-1][1] = T[i-1][k][1]`. Therefore, we still have two unknown variables on each day: `T[i][k][0]` and `T[i][k][1]` with `k = +Infinity`, and the recurrence relations say:\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i]) = max(T[i-1][k][1], T[i-1][k][0] - prices[i])`\\n\\nwhere we have taken advantage of the fact that `T[i-1][k-1][0] = T[i-1][k][0]` for the second equation. The `O(n)` time and `O(1)` space solution is as follows:\\n\\n```\\npublic int maxProfit(int[] prices) {\\n    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n    }\\n    \\n    return T_ik0;\\n}\\n```\\n(**Note**: The caching of the old values of `T_ik0`, that is, the variable `T_ik0_old`, is [unnecessary](https://discuss.leetcode.com/topic/107998/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/24). Special thanks to [0x0101](https://discuss.leetcode.com/user/0x0101) and [elvina](https://discuss.leetcode.com/user/elvina) for clarifying this.)\\n\\nThis solution suggests a greedy strategy of gaining maximum profit: as long as possible, buy stock at each local minimum and sell at the immediately followed local maximum. This is equivalent to finding increasing subarrays in `prices` (the stock price array), and buying at the beginning price of each subarray while selling at its end price. It's easy to show that this is the same as accumulating profits as long as it is profitable to do so, as demonstrated in this [post](https://discuss.leetcode.com/topic/726/is-this-question-a-joke).\\n\\n**Case III: `k = 2`**\\n\\nSimilar to the case where `k = 1`, except now we have four variables instead of two on each day: `T[i][1][0]`, `T[i][1][1]`, `T[i][2][0]`, `T[i][2][1]`, and the recurrence relations are:\\n\\n`T[i][2][0] = max(T[i-1][2][0], T[i-1][2][1] + prices[i])`\\n`T[i][2][1] = max(T[i-1][2][1], T[i-1][1][0] - prices[i])`\\n`T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])`\\n`T[i][1][1] = max(T[i-1][1][1], -prices[i])`\\n\\nwhere again we have taken advantage of the base case`T[i][0][0] = 0` for the last equation. The `O(n)` time and `O(1)` space solution is as follows:\\n\\n```\\npublic int maxProfit(int[] prices) {\\n    int T_i10 = 0, T_i11 = Integer.MIN_VALUE, T_i20 = 0, T_i21 = Integer.MIN_VALUE;\\n        \\n    for (int price : prices) {\\n        T_i20 = Math.max(T_i20, T_i21 + price);\\n        T_i21 = Math.max(T_i21, T_i10 - price);\\n        T_i10 = Math.max(T_i10, T_i11 + price);\\n        T_i11 = Math.max(T_i11, -price);\\n    }\\n        \\n    return T_i20;\\n}\\n```\\nwhich is essentially the same as the one given [here](https://discuss.leetcode.com/topic/5934/is-it-best-solution-with-o-n-o-1).\\n\\n**Case IV: `k is arbitrary`**\\n\\nThis is the most general case so on each day we need to update all the maximum profits with different `k` values corresponding to `0` or `1` stocks in hand at the end of the day. However, there is a minor optimization we can do if `k` exceeds some critical value, beyond which the maximum profit will no long depend on the number of allowable transactions but instead will be bound by the number of available stocks (length of the `prices` array). Let's figure out what this critical value will be.\\n\\nA profitable transaction takes at least two days (buy at one day and sell at the other, provided the buying price is less than the selling price). If the length of the `prices` array is `n`, the maximum number of profitable transactions is `n/2` (integer division). After that no profitable transaction is possible, which implies the maximum profit will stay the same. Therefore the critical value of `k` is `n/2`. If the given `k` is no less than this value, i.e., `k >= n/2`, we can extend `k` to positive infinity and the problem is equivalent to **`Case II`**.\\n\\nThe following is the `O(kn)` time and `O(k)` space solution. Without the optimization, the code will be met with TLE for large `k` values.\\n\\n```\\npublic int maxProfit(int k, int[] prices) {\\n    if (k >= prices.length >>> 1) {\\n        int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n        for (int price : prices) {\\n            int T_ik0_old = T_ik0;\\n            T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n            T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n        }\\n        \\n        return T_ik0;\\n    }\\n        \\n    int[] T_ik0 = new int[k + 1];\\n    int[] T_ik1 = new int[k + 1];\\n    Arrays.fill(T_ik1, Integer.MIN_VALUE);\\n        \\n    for (int price : prices) {\\n        for (int j = k; j > 0; j--) {\\n            T_ik0[j] = Math.max(T_ik0[j], T_ik1[j] + price);\\n            T_ik1[j] = Math.max(T_ik1[j], T_ik0[j - 1] - price);\\n        }\\n    }\\n        \\n    return T_ik0[k];\\n}\\n```\\n\\nThe solution is similar to the one found in this [post](https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java). Here I used backward looping for the `T` array to avoid using temporary variables. It turns out that it is [possible](https://discuss.leetcode.com/topic/107998/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/26) to do forward looping without temporary variables, too.\\n\\n**Case V: `k = +Infinity but with cooldown`**\\n\\nThis case resembles **`Case II`** very much due to the fact that they have the same `k` value, except now the recurrence relations have to be modified slightly to account for the \"**cooldown**\" requirement. The original recurrence relations for **`Case II`** are given by\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])`\\n\\nBut with \"cooldown\", we cannot buy on the `i-th` day if a stock is sold on the `(i-1)-th` day. Therefore, in the second equation above, instead of `T[i-1][k][0]`, we should actually use `T[i-2][k][0]` if we intend to buy on the `i-th` day. Everything else remains the same and the new recurrence relations are\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i])`\\n\\nAnd here is the `O(n)` time and `O(1)` space solution:\\n\\n```\\npublic int maxProfit(int[] prices) {\\n    int T_ik0_pre = 0, T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_pre - price);\\n        T_ik0_pre = T_ik0_old;\\n    }\\n    \\n    return T_ik0;\\n}\\n```\\n\\n[dietpepsi](https://discuss.leetcode.com/user/dietpepsi) shared a very nice solution [here](https://discuss.leetcode.com/topic/30421/share-my-thinking-process) with thinking process, which turns out to be the same as the one above.\\n\\n**Case VI: `k = +Infinity but with transaction fee`**\\n\\nAgain this case resembles **`Case II`** very much as they have the same `k` value, except now the recurrence relations need to be modified slightly to account for the \"**transaction fee**\" requirement. The original recurrence relations for **`Case II`** are given by\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])`\\n\\nSince now we need to pay some fee (denoted as `fee`) for each transaction made, the profit after buying or selling the stock on the `i-th` day should be subtracted by this amount, therefore the new recurrence relations will be either\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i] - fee)`\\n\\nor\\n\\n`T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i] - fee)`\\n`T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i])`\\n\\nNote we have two options as for when to subtract the `fee`. This is because (as I mentioned above) each transaction is characterized by two actions coming as a pair -- **buy** and **sell**. The fee can be paid either when we buy the stock (corresponds to the first set of equations) or when we sell it (corresponds to the second set of equations). The following are the `O(n)` time and `O(1)` space solutions corresponding to these two options, where for the second solution we need to pay attention to possible overflows.\\n\\n\\n**Solution I** -- pay the fee when buying the stock:\\n```\\npublic int maxProfit(int[] prices, int fee) {\\n    int T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        int T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price - fee);\\n    }\\n        \\n    return T_ik0;\\n}\\n```\\n\\n**Solution II** -- pay the fee when selling the stock:\\n \\n```\\npublic int maxProfit(int[] prices, int fee) {\\n    long T_ik0 = 0, T_ik1 = Integer.MIN_VALUE;\\n    \\n    for (int price : prices) {\\n        long T_ik0_old = T_ik0;\\n        T_ik0 = Math.max(T_ik0, T_ik1 + price - fee);\\n        T_ik1 = Math.max(T_ik1, T_ik0_old - price);\\n    }\\n        \\n    return (int)T_ik0;\\n}\\n```\\n---\\n**`III -- Summary`**\\n\\nIn summary, the most general case of the stock problem can be characterized by three factors, the ordinal of the day `i`, the maximum number of allowable transactions `k` and the number of stocks in our hand at the end of the day. I have shown the recurrence relations for the maximum profits and their termination conditions, which leads to the `O(nk)` time and `O(k)` space solution. The results are then applied to each of the six cases, with the last two using slightly modified recurrence relations due to the additional requirements. I should mention that [peterleetcode](https://discuss.leetcode.com/user/peterleetcode) also introduced a nice solution [here](https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions) which generalizes to arbitrary `k` values. If you have a taste, take a look.\\n\\nHope this helps and happy coding!"
		},
		{
			"lc_ans_id":"108867",
			"view":"3254",
			"top":"1",
			"title":"C++, concise solution, O(n) time O(1) space",
			"vote":"24",
			"content":"The solution maintains two states:\\n```\\ns0 = profit having no stock\\ns1 = profit having 1 stock\\n```\\nThe code iterates through the stock prices, and updates s0, s1 respectively. The run time is O(n).\\n```\\nupdate s0 by selling the stock from s1, so s0 = max(s0, s1+p);\\nupdate s1 by buying the stock from s0, so s1 = max(s1, s0-p-fee);\\n```\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int s0 = 0, s1 = INT_MIN; \\n        for(int p:prices) {\\n            int tmp = s0;\\n            s0 = max(s0, s1+p);\\n            s1 = max(s1, tmp-p-fee);\\n        }\\n        return s0;\\n    }\\n};"
		},
		{
			"lc_ans_id":"108868",
			"view":"3555",
			"top":"2",
			"title":"Java simple DP solutions. O(n)",
			"vote":"21",
			"content":"This problem is just like the other stock problems.\\nAt given day, we can do 1 out of 4 things: \\n\\n1. buy stock\\n2. hold stock\\n3. do nothing with empty portfolio\\n4. sell stock\\n\\nWe have 4 arrays with the length of # of the days, recording the max profit at given day if we do given operation. \\n\\nHere is the code: \\n```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        if(prices.length <= 1) return 0;\\n        int[] buy = new int[prices.length];\\n        int[] hold = new int[prices.length];\\n        int[] skip = new int[prices.length];\\n        int[] sell = new int[prices.length];\\n        // the moment we buy a stock, our balance should decrease\\n        buy[0] = 0 - prices[0]; \\n        // assume if we have stock in the first day, we are still in deficit\\n        hold[0] = 0 - prices[0];\\n        for(int i = 1; i < prices.length; i++){\\n            // We can only buy on today if we sold stock\\n            // or skipped with empty portfolio yesterday\\n            buy[i] = Math.max(skip[i-1], sell[i-1]) - prices[i]; \\n            // Can only hold if we bought or already holding stock yesterday\\n            hold[i] = Math.max(buy[i-1], hold[i-1]);\\n            // Can skip only if we skipped, or sold stock yesterday\\n            skip[i] = Math.max(skip[i-1], sell[i-1]);\\n            // Can sell only if we bought, or held stock yesterday\\n            sell[i] = Math.max(buy[i-1], hold[i-1]) + prices[i] - fee;\\n        }\\n        // Get the max of all the 4 actions on the last day.\\n        int max = Math.max(buy[prices.length - 1], hold[prices.length - 1]);\\n        max = Math.max(skip[prices.length - 1], max);\\n        max = Math.max(sell[prices.length - 1], max);\\n        return Math.max(max, 0);\\n    }\\n}\\n```\\n\\nNow, you guys believe I have a higher IQ than Rex right?"
		},
		{
			"lc_ans_id":"108892",
			"view":"1953",
			"top":"3",
			"title":"Java DP solution Easy Understand",
			"vote":"11",
			"content":"Define dp array:\\nhold[i] : The maximum profit of holding stock until day i;\\nnotHold[i] : The maximum profit of not hold stock until day i;\\n\\ndp transition function:\\nFor day i, we have two situations:\\n1. Hold stock: \\n    (1) We do nothing on day i: hold[i - 1];\\n    (2) We buy stock on day i: notHold[i - 1] - prices[i - 1] - fee;\\n\\n2. Not hold stock: \\n    (1) We do nothing on day i: notHold[i - 1];\\n    (2) We sell stock on day i: hold[i - 1] + prices[i - 1];\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        int l = prices.length;\\n        int[] hold = new int[l + 1]; //Hold the stock until day i;\\n        int[] notHold = new int[l + 1]; //Do not hold the stock until day i;\\n        hold[0] = Integer.MIN_VALUE;\\n        \\n        for (int i = 1; i <= l; i++) {\\n            hold[i] = Math.max(hold[i - 1], notHold[i - 1] - prices[i - 1] - fee);\\n            notHold[i] = Math.max(notHold[i - 1], hold[i - 1] + prices[i - 1]);\\n        }\\n        \\n        return notHold[l];\\n    }\\n}\\n````"
		},
		{
			"lc_ans_id":"108871",
			"view":"382",
			"top":"4",
			"title":"2 solutions, 2 states DP solutions, clear explanation!",
			"vote":"6",
			"content":"Given any <strong><code>day I</strong></code>, its max profit status boils down to one of the two status below:\\n\\n**(1) buy status**:\\n<strong><code>buy[i]</strong></code> represents the **max profit** at <strong><code>day i</strong></code> in **buy status**, given that **the last action you took is a buy action** at <strong><code>day K</strong></code>, where <strong><code>K<=i</strong></code>. **And you have the right to sell at <strong><code>day i+1</strong></code>, or do nothing.**\\n**(2) sell status**:\\n<strong><code>sell[i]</strong></code> represents the **max profit** at <strong><code>day i</strong></code> in **sell status**, given that **the last action you took is a sell action** at <strong><code>day K</strong></code>, where <strong><code>K<=i</strong></code>. **And you have the right to buy at <strong><code>day i+1</strong></code>, or do nothing.**\\n\\nLet's walk through from **base case**.\\n\\n**Base case:**\\nWe can start from **buy status**, which means we buy stock at <strong><code>day 0</strong></code>.\\n<strong><code>buy[0]=-prices[0]</strong></code>;\\nOr we can start from **sell status**, which means we sell stock at <strong><code>day 0</strong></code>. \\nGiven that we don't have any stock at hand in day 0, we set sell status to be 0.\\n<strong><code>sell[0]=0</strong></code>;\\t      \\n\\n**Status transformation:**\\nAt <strong><code>day i</strong></code>, we may **buy** stock (from **previous sell status**) or do nothing (from **previous buy status**):\\n<strong><code>buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i]);</strong></code>\\nOr\\nAt <strong><code>day i</strong></code>, we may **sell** stock (from previous **buy status**) or keep holding (from **previous buy status**):\\n<strong><code>sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]); </strong></code>\\n\\n**Finally:**\\nWe will return <strong><code>sell[last_day]</strong></code> as our result, which represents the max profit at the last day, given that you took sell action at any day before the last day.\\n\\n**We can apply transaction fee at either buy status or sell status.**  \\n\\n\\n\\n\\nSo here come our two solutions:\\n\\n**Solution I** -- pay the fee when buying the stock:\\n\\n    public int maxProfit(int[] prices, int fee) {\\n\\t        if (prices.length <= 1) return 0;\\n\\t        int days = prices.length, buy[] = new int[days], sell[] = new int[days];\\n\\t        buy[0]=-prices[0]-fee;\\n\\t        for (int i = 1; i<days; i++) {\\n\\t            buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i] - fee); // keep the same as day i-1, or buy from sell status at day i-1\\n\\t            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]); // keep the same as day i-1, or sell from buy status at day i-1\\n\\t        }\\n\\t        return sell[days - 1];\\n\\t    }\\n\\n**Solution II** -- pay the fee when selling the stock:\\n\\n        public int maxProfit(int[] prices, int fee) {\\n\\t        if (prices.length <= 1) return 0;\\n\\t        int days = prices.length, buy[] = new int[days], sell[] = new int[days];\\n\\t        buy[0]=-prices[0];\\n\\t        for (int i = 1; i<days; i++) {\\n\\t            buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i]); // keep the same as day i-1, or buy from sell status at day i-1\\n\\t            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i] - fee); // keep the same as day i-1, or sell from buy status at day i-1\\n\\t        }\\n\\t        return sell[days - 1];\\n\\t    }"
		},
		{
			"lc_ans_id":"108884",
			"view":"888",
			"top":"5",
			"title":"[Java/C++] Clean Code (DP/Greedy)",
			"vote":"4",
			"content":"**Java DP**\\n```\\nclass Solution {\\n    public int maxProfit(int[] p, int fee) {\\n        int n = p.length;\\n        if (n < 2) return 0;\\n        int[] hold = new int[n], sold = new int[n];\\n        hold[0] = -p[0];\\n        for (int i = 1; i < n; ++i) {\\n            hold[i] = Math.max(hold[i - 1], sold[i - 1] - p[i]);\\n            sold[i] = Math.max(sold[i - 1], hold[i - 1] + p[i] - fee);\\n        }\\n\\n        return sold[n - 1];\\n    }\\n}\\n```\\n**C++ DP**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p, int fee) {\\n        int n = p.size();\\n        if (n < 2) return 0;\\n        vector<int> hold(n, 0), sold(n, 0);\\n        hold[0] = -p[0];\\n        for (int i = 1; i < n; i++) {\\n            hold[i] = max(hold[i - 1], sold[i - 1] - p[i]);\\n            sold[i] = max(sold[i - 1], hold[i - 1] - fee + p[i]);\\n        }\\n\\n        return sold[n - 1];\\n    }\\n};\\n```\\n\\n**Java Greedy**\\n1.  buy in - when current price higher than previous lowest point by more than amount of transaction fee, and set current price as highest point;\\n2. sale out - when current price lower than prevous highest point by more than amount of transaction fee, and reset lowest, highest\\n3. update highest - only if highest is set;\\n4. update lowest - every day\\n```\\nclass Solution {\\n    public int maxProfit(int[] p, int fee) {\\n        int profit = 0;\\n        Integer lo = null, hi = null, n = p.length;\\n        for (int i = 0; i < n; i++) {\\n            if (lo != null && hi == null && p[i] - lo > fee) hi = p[i]; // buy in\\n            if (hi != null && p[i] > hi) hi = p[i]; // update highest\\n            if (hi != null && (hi - p[i] > fee || i == n - 1)) { // sale out\\n                profit += hi - lo - fee;\\n                hi = null;\\n                lo = null;\\n            }\\n\\n            lo = lo != null ? Math.min(lo, p[i]) : p[i]; // update lowest\\n        }\\n        return profit;      \\n    }\\n}\\n```\\n**C++ Greedy**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p, int fee) {\\n        int profit = 0;\\n        int* lo = nullptr, *hi = nullptr, n = p.size();\\n        for (int i = 0; i < n; i++) {\\n            if (lo && !hi && p[i] - *lo > fee) hi = &p[i]; // buy in\\n            if (hi && p[i] > *hi) hi = &p[i]; // update highest\\n            if (hi && (*hi - p[i] > fee || i == n - 1)) { // sale out\\n                profit += *hi - *lo - fee;\\n                hi = nullptr;\\n                lo = nullptr;\\n            }\\n\\n            if (!lo || p[i] < *lo) lo = &p[i]; // update lowest\\n        }\\n        return profit;\\n    }\\n```"
		},
		{
			"lc_ans_id":"108873",
			"view":"132",
			"top":"6",
			"title":"faster than the \"max\" solution and very clear answer",
			"vote":"3",
			"content":"```  python\\nclass Solution(object):\\n    def maxProfit(self, prices, fee):\\n        state = profit = 0 \\n        last_price = prices[0] \\n        for price in prices[1:]:                  \\n            state += price - last_price\\n            if state > fee:\\n                profit += state - fee\\n                state = fee\\n            else:\\n                if state < 0: state = 0\\n            last_price = price\\n        return profit\\n```\\nExplanation:\\n. state is a switch variable\\n. when state >= fee, all incoming positive price movement will become profit\\n. when state <= 0, that, all incoming negative  price movement will be discarded\\n\\n[python] best run : 149 ms, beats 98.92% at this time,  35%+ faster than the \"max\" solution.\\n[java] best run: 13ms, beats 97.42% at this time,  20%+ faster than the \"max\""
		},
		{
			"lc_ans_id":"108889",
			"view":"110",
			"top":"7",
			"title":"Clear Java DP solution O(n) time O(1) space",
			"vote":"2",
			"content":"You might either have sold your stock or not, we can get the best profit (by day i) on each case according to the relationship:\\n\\na. If you're holding your stock, the best profit you can get on day i is either the same with the previous day (if you didn't sell it) or you buy the stock on the price of day i.\\n\\n```\\nhold = max(preSold - prices[i], preHold);\\n```` \\n\\nb. If you have no stock, the best you can get is either the same with yesterday (you've already sold it) or you sell it on today's price.\\n\\n```\\nsold = max(preHold + prices[i] - fee, preSold);\\n````\\n\\nSince we have 0 profit at the very beginning and can't sell, the initial value is -prices[0], and 0. Finally, we have to end on \"sold\" to get the maximum profit.\\n\\n```\\n    public int maxProfit(int[] prices, int fee) {       \\n        int preHold= -prices[0];\\n        int preSold = 0;\\n        \\n        for(int i = 1; i < prices.length; i++) {\\n            int hold = Math.max(preSold- prices[i], preHold);\\n            int sold = Math.max(preHold+ prices[i] - fee, preSold);\\n            preHold = hold ;\\n            preSold = sold ;\\n        }\\n        return preSold;\\n    }\\n````"
		},
		{
			"lc_ans_id":"108901",
			"view":"83",
			"top":"8",
			"title":"C++ O(n) time O(1) space",
			"vote":"2",
			"content":"b is maximum value after  a series of alternating buy-sell actions, starting with a buy and ending with a buy.\\nc is maximum value after  a series of alternating buy-sell actions, starting with a buy and ending with a sell.\\nc is the answer to the problem.\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a, int f) {\\n        int n = a.size();\\n        int b = -a[0],c = 0;\\n        for (int i = 1; i < a.size(); ++i) {\\n            int nb = max(b, -a[i] + c);\\n            c = max(c, a[i] - f + b);\\n            b = nb;\\n        }\\n        return c;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"108878",
			"view":"60",
			"top":"9",
			"title":"Finally understood this type of problem",
			"vote":"1",
			"content":"# Lets start with the basics - trade once only.\\nThe idea is similar to maximum subarray problem. \\nTo express the problem in math terms: \\n0) Let's call ```[] A``` for maximum profit and ```A[i] ```represent obtainable profit up to ith index\\n1) Given ```[] p``` for prices\\n2) Find ```max{i,j} p[i] - p[j] ```for ```0<=j<=i```\\n3) Fix index i, largest possible obtainable profit at ith position becomes ```p[i] (known) - min{j} p[j] ```for``` 0<=j<=i```\\n4) Thus DP recurring solution is: ```A[i] = max( a[i-1], p[i] - current_min)``` , where ```current_min ``` is ```min(current_min, p[i])```\\n\\n# For two trades. \\nI thought pretty hard on this, how do you do two trades, like the one above?\\nI first came up with a recursion fashion to deal with this problem, too slow.\\nNow come to think about it, the DP structure is like this.\\nLets call```[] A``` maximum profit obtainable for one trade, and ```[]B``` maximum profit obtainable for two trades.\\nFor ```A``` it will be exactly as above, what about ```B```?\\nSame as before, the profit is always obtained in two ways: \\n1) Doing nothing, thus profit stays same\\n2) Do something, thus make a profit\\n```B[i] = max(B[i-1], A[k] + p[i] - p[k]) for 0<=k<=i```\\nThis basically says best profit obtainable at second trade is partly from A, and partly from p[i] and p[k]. \\n# For ```K``` number of trades\\nAnd suddenly it appeared pretty clear, that for ```K``` number of trades, the max profit will be:\\n```K[i] = max(K[i-1], J[m] + p[i] - p[m]) for 0<=m<=i```, where ```J``` is max obtainable profit for the ```K-1 ```number of trades.\\n\\n# For unlimited number of trades\\nEssentially this is asking for the \"MAX\" available profit obtainable.\\nThus, with similar set up as before,\\n```A[i] = max(A[i-1], A[k] + p[i] - p[k]) for 0<=k<=i```\\nThis will give maximum obtainable profit.\\n\\n# For trades with cool down\\nBasically same set up as before, \\n```A[i] = max(A[i-1], A[k-2] + p[i] - p[k]) for 0<=k<=i```\\nthe trick here is to realize ```A``` is non decreasing\\n\\n\\n# For this question\\nSame as above set up, but with each trade, a fee is built in.\\n```A[i] = max(A[i-1], A[k] + p[i] - p[k] - fee ) for 0<=k<=i```\\n\\nCode I used for this question:\\n```\\npublic int maxProfit( int[] p, int fee )\\n{\\n\\tint n = p.length, curmax = -p[0];\\n\\tint[] A = new int[n];\\n\\tfor ( int i = 1; i < n; i++ )\\n\\t{\\n\\t\\tA[i] = Math.max( A[i - 1], p[i] + curmax - fee );\\n\\t\\tcurmax = Math.max( curmax, A[i] - p[i] );\\n\\t}\\n\\treturn A[n - 1];\\n}\\n```"
		}
	],
	"id":"680",
	"title":"Best Time to Buy and Sell Stock with Transaction Fee",
	"content":"<p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>\r\n<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>\r\n<p>Return the maximum profit you can make.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> prices = [1, 3, 2, 8, 4, 9], fee = 2\r\n<b>Output:</b> 8\r\n<b>Explanation:</b> The maximum profit can be achieved by:\r\n<li>Buying at prices[0] = 1</li><li>Selling at prices[3] = 8</li><li>Buying at prices[4] = 4</li><li>Selling at prices[5] = 9</li>The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li><code>0 < prices.length <= 50000</code>.</li>\r\n<li><code>0 < prices[i] < 50000</code>.</li>\r\n<li><code>0 <= fee < 50000</code>.</li>\r\n</p>",
	"frequency":"165",
	"ac_num":"9964"
}