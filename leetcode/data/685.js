{
	"difficulty":"3",
	"submit_num":"17019",
	"show_id":"719",
	"leetcode_id":"719",
	"answers":[
		{
			"lc_ans_id":"109075",
			"view":"4181",
			"top":"0",
			"title":"Java solution, Binary Search",
			"vote":"17",
			"content":"```\\nclass Solution {\\n    // Returns number of pairs with absolute difference less than or equal to mid.\\n    private int countPairs(int[] a, int mid) {\\n        int n = a.length, res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int j = i;\\n            while (j < n && a[j] - a[i] <= mid) j++;\\n            res += j - i - 1;\\n        }\\n        return res;\\n    }\\n\\n    public int smallestDistancePair(int a[], int k) {\\n        int n = a.length;\\n        Arrays.sort(a);\\n\\n        // Minimum absolute difference\\n        int low = a[1] - a[0];\\n        for (int i = 1; i < n - 1; i++)\\n            low = Math.min(low, a[i + 1] - a[i]);\\n\\n        // Maximum absolute difference\\n        int high = a[n - 1] - a[0];\\n\\n        // Do binary search for k-th absolute difference\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (countPairs(a, mid) < k)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n\\n        return low;\\n    }\\n}\\n```\\nImproved countPairs to use binary search too:\\n```\\nclass Solution {\\n    // Returns index of first index of element which is greater than key\\n    private int upperBound(int[] a, int low, int high, int key) {\\n        if (a[high] <= key) return high + 1;\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (key >= a[mid]) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    // Returns number of pairs with absolute difference less than or equal to mid.\\n    private int countPairs(int[] a, int mid) {\\n        int n = a.length, res = 0;\\n        for (int i = 0; i < n; i++) {\\n            res += upperBound(a, i, n - 1, a[i] + mid) - i - 1;\\n        }\\n        return res;\\n    }\\n\\n    public int smallestDistancePair(int a[], int k) {\\n        int n = a.length;\\n        Arrays.sort(a);\\n\\n        // Minimum absolute difference\\n        int low = a[1] - a[0];\\n        for (int i = 1; i < n - 1; i++)\\n            low = Math.min(low, a[i + 1] - a[i]);\\n\\n        // Maximum absolute difference\\n        int high = a[n - 1] - a[0];\\n\\n        // Do binary search for k-th absolute difference\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (countPairs(a, mid) < k)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n\\n        return low;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"109077",
			"view":"1380",
			"top":"1",
			"title":"C++, counting sort O(n^2) and binary search O(nlogn)",
			"vote":"7",
			"content":"Bucket sort, O(n^2)\\n```\\nclass Solution {\\npublic:\\n    int smallestDistancePair(vector<int>& nums, int k) {\\n        int n = nums.size(), N = 1000000;\\n        vector<int> cnt(N, 0);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) \\n                cnt[abs(nums[i]-nums[j])]++;\\n        }\\n        for (int i = 0; i < N; i++) {\\n            if (cnt[i] >= k) return i;\\n            k -= cnt[i];\\n        }\\n        return 0;\\n    }\\n};\\n```\\nBinary search, O(nlogn)\\n```\\nclass Solution {\\npublic:\\n    int smallestDistancePair(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), low = 0, high = 1000000;\\n        while (low < high) {\\n            int mid = (low + high)/2, cnt = 0;\\n            for (int i = 0, j = 0; i < n; i++) {\\n                while (j < n && nums[j]-nums[i] <= mid) j++;\\n                cnt += j-i-1;\\n            }\\n            if (cnt < k) \\n                low = mid+1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109091",
			"view":"806",
			"top":"2",
			"title":"Simple O(Nlog(max(a[i]))) solution using binary search",
			"vote":"5",
			"content":"Find the smallest number ans such that ans is not smaller than at least k differences. For each test value of ans, counting the number of differences not more than ans is done in linear time using two pointer method.\\n\\n```\\nclass Solution {\\npublic:\\n    int smallestDistancePair(vector<int>& a, int k) {\\n        sort(a.begin(), a.end());\\n        int n = a.size(), lo = 0, hi = a[n-1] - a[0], ans = -1;\\n        while (lo <= hi) {\\n            int cnt = 0, j = 0, md = (lo + hi)/2;\\n            for (int i = 0; i < n; ++i) {\\n                while (j < n && a[j] - a[i] <= md) ++j;\\n                cnt += j - i-1;\\n            }\\n            if (cnt >= k) {\\n                ans = md;\\n                hi = md - 1;\\n            }\\n            else lo = md + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109094",
			"view":"993",
			"top":"3",
			"title":"Java very Easy and Short(15 lines Binary Search and Bucket Sort) solutions",
			"vote":"5",
			"content":"Bucket Sort Solution\\n```\\nclass Solution {\\n    public int smallestDistancePair(int[] nums, int k) {\\n        int len=nums.length;\\n        int len2=1000000;\\n        int[] dp= new int[len2];\\n        for(int i=1;i<len;i++){\\n            for(int j=0;j<i;j++){\\n             int dif= Math.abs(nums[i]-nums[j]);\\n               dp[dif]++;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<len2;i++){\\n            sum+=dp[i];\\n            if(sum>=k) return i;\\n        }\\n        return 0;\\n    }\\n     }\\n\\n```\\n\\nFollowing is the Binary Search Solution:\\n\\n```\\nclass Solution {\\n    public int smallestDistancePair(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length, low = 0, hi = nums[n-1] - nums[0];\\n        while (low < hi) {\\n            int cnt = 0, j = 0, mid = (low + hi)/2;\\n            for (int i = 0; i < n; ++i) {\\n                while (j < n && nums[j] - nums[i] <= mid) ++j;\\n                cnt += j - i-1;\\n            }\\n            if (cnt >= k) \\n                hi = mid;\\n            \\n            else low = mid + 1;\\n        }\\n        \\n        return low;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"109092",
			"view":"1009",
			"top":"4",
			"title":"\"1-liner\" and \"almost O(n)\"",
			"vote":"4",
			"content":"I reduce the problem to the old [Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/) problem. Explanation below the code.\\n\\n#### Ruby \"1-liner\" (as in, I just wrote one new line):\\n\\n```\\ndef smallest_distance_pair(nums, k)\\n  kth_smallest(nums.sort!.map { |x| -> j { x - nums[~j] } }, k + (1..nums.size).sum)\\nend\\n\\n# copy&paste old solution from https://discuss.leetcode.com/topic/52936/o-n-log-n-ruby-solution\\ndef kth_smallest(matrix, k)\\n  ...\\n```\\n\\n#### Python ~~O(n)~~ Edit: O(n log n)\\n\\n    def smallestDistancePair(self, nums, k):\\n        nums.sort()\\n        class Row(int):\\n            def __getitem__(self, j):\\n                return self - nums[~j]\\n        n = len(nums)\\n        return self.kthSmallest(map(Row, nums), k + n*(n+1)/2)\\n\\n    # copy&paste old solution from https://discuss.leetcode.com/topic/53126/o-n-from-paper-yes-o-rows\\n    def kthSmallest(self, matrix, k):\\n        ...\\n\\nEdit: Darn, I originally thought it's O(n), but I just realized that I forgot that I'm sorting the list. Everything else is only O(n), but that sorting makes it only O(n log n). Then again, it's the built-in sort function, so that's a very fast O(n log n). Probably faster than the O(n) of the rest of the code.\\n\\n#### Explanation\\n\\nI sort the input and then build a virtual sorted matrix of (non-absolute) differences, for example for [2, 4, 5, 9]:\\n```\\n  |  9  5  4  2\\n--+------------\\n2 | -7 -3 -2  0\\n4 | -5 -1  0  2\\n5 | -4  0  1  3\\n9 |  0  4  5  7\\n```\\nThe antidiagonal of zeros is from non-pairs (elements paired with themself) and the upper left triangle of negative numbers are \"wrong-order\" pairs. None of these interest us, so I increase the given `k` by how many of these there are (i.e., by sum(1..n) = n(n+1)/2)).\\n\\nOf course I'm not explicitly building that matrix. It can be 10000&times;10000 large. [Ain't Nobody Got Time for That](https://www.youtube.com/watch?v=bFEoMO0pc7k) (or Memory). I'm just building a *virtual* matrix. Each row is not an explicit array but just an object that allows access by index and computes the accessed values on-the-fly."
		},
		{
			"lc_ans_id":"109082",
			"view":"120",
			"top":"5",
			"title":"Approach the problem using the \"trial and error\" algorithm",
			"vote":"2",
			"content":"---\\nWell, normally we would refrain from using the naive [trial and error](https://en.wikipedia.org/wiki/Trial_and_error) algorithm for solving problems since it generally leads to bad time performance. However, there are situations where this naive algorithm may outperform other more sophisticated solutions, and LeetCode does have a few such problems (listed at the end of this post -- ironically they are all \"hard\" problems). So I figure it might be a good idea to bring it up and describe a general procedure for applying this algorithm.\\n\\nThe basic idea for the trial and error algorithm is actually very simple and summarized below:\\n\\n`Step 1`: Construct a candidate solution.\\n`Step 2`: Verify if it meets our requirements.\\n`Step 3`: If it does, accept the solution; else discard it and repeat from `Step 1`.\\n\\nHowever, to make this algorithm work efficiently, the following two conditions need to be true:\\n\\n**Condition 1**: We have an efficient verification algorithm in `Step 2`;\\n**Condition 2**: The search space formed by all candidate solutions is small or we have efficient ways to search this space if it is large.\\n\\nThe first condition ensures that each verification operation can be done quickly while the second condition limits the total number of such operations that need to be done. The two combined will guarantee that we have an efficient trial and error algorithm (which also means if any of them cannot be satisfied, you should probably not even consider this algorithm).\\n\\n---\\nNow let's look at this problem: `Find The K-th Smallest Pair Distance`, and see how we can apply the trial and error algorithm.\\n\\n`I -- Construct a candidate solution`\\n\\nTo construct a candidate solution, we need to understand first what the desired solution is. The problem description requires we output the `K-th` smallest pair distance, which is nothing more than a non-negative integer (since the input array `nums` is an integer array and pair distances are absolute values). Therefore our candidate solution should also be a non-negative integer.\\n\\n`II -- Search space formed by all the candidate solutions`\\n\\nLet `min` and `max` be the minimum and maximum numbers in the input array `nums`, and `d = max - min`, then any pair distance from `nums` must lie in the range `[0, d]`. As such, our desired solution is also within this range, which implies the search space will be `[0, d]` (any number outside this range can be ruled out immediately without further verification).\\n\\n`III -- Verify a given candidate solution`\\n\\nThis is the key part of this trial and error algorithm. So given a candidate integer, how do we determine if it is the `K-th` smallest pair distance?\\n\\nFirst, what does the `K-th` smallest pair distance really mean? By definition, if we compute all the pair distances and sort them in ascending order, then the `K-th` smallest pair distance will be the one at index `K - 1`. This is essentially the naive way for solving this problem (but will be rejected due to `MLE`, as expected).\\n\\nApparently the above definition cannot be used to do the verification, as it requires explicit computation of the pair distance array. Fortunately there is another way to define the `K-th` smallest pair distance: given an integer `num`, let `count(num)` denote the number of pair distances that are no greater than `num`, then the `K-th` smallest pair distance will be the smallest integer such that `count(num)  >= K`.\\n\\nHere is a quick justification of the alternative definition. Let `num_k` be the `K-th` pair distance in the sorted pair distance array with index `K - 1`, as specified in the first definition. Since all the pair distances up to index `K - 1` are no greater than `num_k`, we have `count(num_k) >= K`. Now suppose `num` is the smallest integer such that `count(num) >= K`, we show `num` must be equal to `num_k` as follows:\\n\\n1.  If `num_k < num`, since `count(num_k) >= K`, then `num` will not be the smallest integer such that `count(num) >= K`, which contradicts our assumption.\\n\\n2. If `num_k > num`, since `count(num) >= K`, by definition of the `count` function, there are at least `K` pair distances that are no greater than `num`, which implies there are at least `K` pair distances that are smaller than `num_k`. This means `num_k` cannot be the `K-th` pair distance, contradicting our assumption again.\\n\\nTaking advantage of this alternative definition of the `K-th` smallest pair distance, we can transform the verification process into a counting process. So how exactly do we do the counting?\\n\\n`IV -- Count the number of pair distances no greater than the given integer`\\n\\nAs I mentioned, we cannot use the pair distance arrays, which means the only option is the input array itself. If there is no order among its elements, we got no better way other than compute and test each pair distance one by one. This leads to a `O(n^2)` verification algorithm, which is as bad as, if not worse than, the aforementioned naive solution. So we need to impose some order to `nums`, which by default means sorting.\\n\\nNow suppose `nums` is sorted in ascending order, how do we proceed with the counting for a given number `num`? Note that each pair distance `d_ij` is characterized by a pair of indices `(i, j)` with `i < j`, that is `d_ij = nums[j] - nums[i]`. If we keep the first index `i` fixed, then `d_ij <= num` is equivalent to `nums[j] <= nums[i] + num`. This suggests that at least we can do a binary search to find the smallest index `j` such that `nums[j] > nums[i] + num` for each index `i`, then the count from index `i` will be `j - i - 1`, and in total we have an `O(nlogn)` verification algorithm.\\n\\nIt turns out the counting can be done in linear time using the classic two-pointer technique if we make use of the following property: assume we have two starting indices `i1` and `i2` with `i1 < i2`, let `j1` and `j2` be the smallest index such that `nums[j1] > nums[i1] + num` and `nums[j2] > nums[i2] + num`, respectively, then it must be true that `j2 >= j1`. The proof is straightforward: suppose `j2 < j1`, since `j1`is the smallest index such that `nums[j1] > nums[i1] + num`, we should have `nums[j2] <= nums[i1] + num`. On the other hand, `nums[j2] > nums[i2] + num >= nums[i1] + num`. The two inequalities contradict each other, thus validate our conclusion above.\\n\\n`V -- How to walk the search space efficiently`\\n\\nUp to this point, we know the search space, know how to construct the candidate solution and how to verify it by counting, we still need one last piece for the puzzle: how to walk the search space. \\n\\nOf course we can do the naive linear walk by trying each integer from `0` up to `d` and choose the first integer `num` such that `count(num) >= K`. The time complexity will be `O(nd)`. However, given that `d` can be much larger than `n`, this algorithm can be much worse than the naive `O(n^2)` solution mentioned before.\\n\\nThe key observation here is that the candidate solutions are ordered naturally in ascending order, so a binary search is possible. Another fact is the non-decreasing property of the `count` function: give two integers `num1` and `num2` such that `num1 < num2`, then `count(num1) <= count(num2)` (I will leave the verification to you). So a binary walk of the search space will look like this:\\n\\n1. Let `[l, r]` be the current search space, and initialize `l = 0`, `r = d`.\\n2. If `l < r`, compute the middle point `m = (l + r) / 2` and evaluate `count(m)`.\\n3. If `count(m) < K`, we throw away the left half of current search space and set `l = m + 1`; else if `count(m) >= K` we throw away the right half and set `r = m`.\\n\\nYou probably will wonder why we throw away the right half of the search space even if `count(m) == K`. Note that the `K-th` smallest pair distance `num_k` is the minimum integer such that `count(num_k) >= K`. If `count(m) == K`, then we know `num_k <= m` (but not `num_k == m`, think about it!) so it makes no sense keeping the right half.\\n\\n`VI -- Putting everything together, aka, solutions`\\n\\nDon't get scared by the above analyses. The final solution is much simpler to write once you understand it. Here is the Java program for the trial and error algorithm. The time complexity is `O(nlogd + nlogn)` (don't forget the sorting) and space complexity is `O(1)`.\\n\\n```\\npublic int smallestDistancePair(int[] nums, int k) {\\n    Arrays.sort(nums);\\n        \\n    int n = nums.length, l = 0, r = nums[n - 1] - nums[0];\\n        \\n    while (l < r) {\\n        int m = l + ((r - l) >> 1), cnt = 0;\\n            \\n        for (int i = 0, j = 0; i < n; i++) {\\n            while (j < n && nums[j] <= nums[i] + m) j++;\\n            cnt += j - i - 1;\\n        }\\n            \\n        if (cnt < k) {\\n            l = m + 1;\\n        } else {\\n            r = m;\\n        }\\n    }\\n        \\n    return l;\\n}\\n```\\n\\n---\\nLastly here is a list of LeetCode problems that can be solved using the trial and error algorithm (you're welcome to add more):\\n\\n1. [719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\\n\\n2. [668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\\n\\n3. [644. Maximum Average Subarray II](https://leetcode.com/articles/maximum-average-subarray-ii/)\\n\\nAnyway, this post is just a reminder to you that the trial and error algorithm is worth trying if you find all other common solutions suffer severely from bad time or space performance. Also it's always recommended to perform a quick evaluation of the search space size and potential verification algorithm to estimate the complexity before you are fully committed to this algorithm."
		},
		{
			"lc_ans_id":"109087",
			"view":"269",
			"top":"6",
			"title":"6 lines Ruby",
			"vote":"1",
			"content":"Same as my [\"1-liner\"](https://discuss.leetcode.com/topic/108811/1-liner-and-o-n-log-n) but rewriting the [old problem's solution](https://discuss.leetcode.com/topic/52936/o-n-log-n-ruby-solution) instead of reusing it verbatim.\\n```\\ndef smallest_distance_pair(nums, k)\\n  n = nums.sort!.size\\n  (0..nums[-1]-nums[0]).bsearch { |x|\\n    nums.map { |y|\\n      (0...n).bsearch { |j| y - nums[~j] > x } || n\\n    }.sum >= k + n*(n+1)/2\\n  }\\nend\\n```"
		},
		{
			"lc_ans_id":"109093",
			"view":"136",
			"top":"7",
			"title":"An O(NlogNlogN) time complexity algorithm(Using C++).",
			"vote":"1",
			"content":"```\\nclass Solution {\\npublic:\\n    int bsa(int x){\\n        return x < 0 ? -x : x;\\n    }\\n    int countLessThan(vector<int>& nums, int x){\\n        int size = nums.size();\\n        int low, high, mid;\\n        int cnt = 0;\\n        for(int i = 0;i < size;++i){\\n            low = i, high = size;\\n            while(low < high - 1){\\n                mid = (low + high) >> 1;\\n                if(bsa(nums[i] - nums[mid]) <= x)low = mid;\\n                else high = mid;\\n            }\\n            cnt += low - i;\\n        }\\n        return cnt;\\n    }\\n\\n    int smallestDistancePair(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int low = -2, high = 1 << 20, mid;\\n        while(low < high - 1){\\n            mid = (low + high) / 2;\\n            int cnt = countLessThan(nums, mid);\\n            if(cnt < k)low = mid;\\n            else high = mid;\\n        }\\n        return high;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109097",
			"view":"195",
			"top":"8",
			"title":"Python bucket sort TLE ?",
			"vote":"1",
			"content":"How can this be improved? Seems to be O(n^2) and accepted in other languages.\\n\\n```\\n    def smallestDistancePair(self, nums, k):\\n        diffs = [0 for _ in range(1000000)]\\n        \\n        for i, num in enumerate(nums):\\n            for num2 in nums[i + 1:]:\\n                diffs[abs(num - num2)] += 1\\n                \\n        for i, diff in enumerate(diffs):\\n            k -= diff\\n            if k <= 0:\\n                return i\\n```"
		},
		{
			"lc_ans_id":"109078",
			"view":"27",
			"top":"9",
			"title":"Solution with heap got TLE.",
			"vote":"0",
			"content":"```\\nclass Solution(object):\\n    def smallestDistancePair(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        # 1. sort\\n        nums.sort()  # O(NlogN) time\\n        heap = []\\n        # 2. initialize heap\\n        for i in xrange(len(nums) - 1):\\n            heap.append((nums[i + 1] - nums[i], i, i + 2))  # heap: (val, ind, nextInd)\\n        heapify(heap)   # O(N) time\\n        # O(klogN) time\\n        for i in xrange(k - 1):\\n            _, ind, nextInd = heappop(heap)\\n            if nextInd < len(nums):\\n                heappush(heap, (nums[nextInd] - nums[ind], ind, nextInd + 1))\\n        return heappop(heap)[0]\\n```"
		}
	],
	"id":"685",
	"title":"Find K-th Smallest Pair Distance",
	"content":"<p>Given an integer array, return the k-th smallest <b>distance</b> among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. </p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>\r\nnums = [1,3,1]\r\nk = 1\r\n<b>Output: 0</b> \r\n<b>Explanation:</b>\r\nHere are all the pairs:\r\n(1,3) -> 2\r\n(1,1) -> 0\r\n(3,1) -> 2\r\nThen the 1st smallest distance pair is (1,1), and its distance is 0.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li><code>2 <= len(nums) <= 10000</code>.</li>\r\n<li><code>0 <= nums[i] < 1000000</code>.</li>\r\n<li><code>1 <= k <= len(nums) * (len(nums) - 1) / 2</code>.</li>\r\n</ol>\r\n</p>",
	"frequency":"157",
	"ac_num":"4577"
}