{
	"difficulty":"2",
	"submit_num":"2854",
	"show_id":"723",
	"leetcode_id":"723",
	"answers":[
		{
			"lc_ans_id":"109221",
			"view":"687",
			"top":"0",
			"title":"AC JAVA Solution easy to understand",
			"vote":"6",
			"content":"The idea is not to count how many same \"candies\" are in a row or column, but to check if this candy is eligible for crushing. If any candy is eligible, store the corresponding coordinates in a HashSet. \\nAfter traversing the whole board, set the valid candies to \"0\" then crush (using 2-pointer method in a column).\\nHere goes the code:\\n```\\nclass Solution {\\n    public int[][] candyCrush(int[][] board) {\\n        Set<Coordinates> set = new HashSet<>();\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                int cur = board[i][j];\\n                if (cur == 0) continue;\\n                if ((i - 2 >= 0 && board[i - 1][j] == cur && board[i - 2][j] == cur) ||                                                 // check left 2 candies\\n                   (i + 2 <= board.length - 1 && board[i + 1][j] == cur && board[i + 2][j] == cur) ||                                   // check right 2 candies\\n                   (j - 2 >= 0 && board[i][j - 1] == cur && board[i][j - 2] == cur) ||                                                 // check 2 candies top\\n                   (j + 2 <= board[i].length - 1 && board[i][j + 1] == cur && board[i][j + 2] == cur) ||                               // check 2 candies below\\n                   (i - 1 >= 0 && i + 1 <= board.length - 1 && board[i - 1][j] == cur && board[i + 1][j] == cur) ||                    // check if it is a mid candy in row\\n                   (j - 1 >= 0 && j + 1 <= board[i].length - 1 && board[i][j - 1] == cur && board[i][j + 1] == cur)) {                // check if it is a mid candy in column\\n                    set.add(new Coordinates(i, j));\\n                }\\n            }\\n        }\\n        if (set.isEmpty()) return board;      //stable board\\n        for (Coordinates c : set) {\\n            int x = c.i;\\n            int y = c.j;\\n            board[x][y] = 0;      // change to \"0\"\\n        }\\n        drop(board);\\n        return candyCrush(board);\\n    }\\n    private void drop(int[][] board) {                                          // using 2-pointer to \"drop\"\\n        for (int j = 0; j < board[0].length; j++) {\\n            int bot = board.length - 1;\\n            int top = board.length - 1;\\n            while (top >= 0) {\\n                if (board[top][j] == 0) {\\n                    top--;\\n                }\\n                else {\\n                    board[bot--][j] = board[top--][j];\\n                }\\n            }\\n            while (bot >= 0) {\\n                board[bot--][j] = 0;\\n            }\\n        }\\n    }\\n}\\n\\nclass Coordinates {\\n    int i;\\n    int j;\\n    Coordinates(int x, int y) {\\n        i = x;\\n        j = y;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"109220",
			"view":"53",
			"top":"1",
			"title":"155 ms Python with detailed explanation beat 100%",
			"vote":"1",
			"content":"Rotate the board will make the drop operation much easier. That being said, instead of move all non-zero value to the end of each column, the drop operation becomes move all non-zero value to the beginning of each row.\\n\\n ![0_1512251916234_rotate.png](/assets/uploads/files/1512251917616-rotate-resized.png) \\n```\\nclass Solution(object):\\n    def candyCrush(self, board):\\n        board=map(list,zip(*reversed(board)))  # rotate clockwise 90 degree\\n        m,n=len(board),len(board[0])\\n\\n        # repeat crush and drop\\n        while True:\\n            candy=set([])\\n            # check every row\\n            for i in xrange(m):\\n                for j in xrange(2,n):\\n                    if board[i][j] and board[i][j]==board[i][j-1]==board[i][j-2]:\\n                        candy|={(i,j),(i,j-1),(i,j-2)}\\n            # check every col\\n            for j in xrange(n):\\n                for i in xrange(2,m):\\n                    if board[i][j] and board[i][j]==board[i-1][j]==board[i-2][j]:\\n                        candy|={(i,j),(i-1,j),(i-2,j)}\\n            if not candy: break\\n            for i,j in candy: board[i][j]=0\\n\\n            # drop the board, move non-zero to the beginning of each row.\\n            for i in xrange(m):\\n                row=filter(None,board[i])\\n                board[i]=row+[0]*(n-len(row))\\n     \\n        board=list(reversed(map(list,zip(*board)))) # rotate counter-clockwise 90 degree\\n        return board"
		},
		{
			"lc_ans_id":"109234",
			"view":"117",
			"top":"2",
			"title":"[723. Candy Crush]C++_AC",
			"vote":"1",
			"content":"Pretty boring question...\\n\\n//Use two double-for-loop to confirm the cells which should be removed.\\n//Use the pointers to change move the upper cells above 0s, bottom-up method.\\n//while there is no change in the matrix, break the while loop.\\n\\n     class Solution {\\n     public:\\n     vector<vector<int>> candyCrush(vector<vector<int>>& board) {\\n        int row = board.size();\\n        int col = board[0].size();\\n        bool changed = false;\\n        while(true){\\n            for(int i = 0; i < row; ++i){\\n                for(int j = 0; j + 2 < col; ++j){\\n                    int val = abs(board[i][j]);\\n                    if(val != 0 && val == abs(board[i][j+1]) && val == abs(board[i][j+2])){\\n                        board[i][j] = -val;\\n                        board[i][j+1] = -val;\\n                        board[i][j+2] = -val;\\n                        changed = true;\\n                    }\\n                }\\n            }\\n            for(int j = 0; j < col; ++j){\\n                for(int i = 0; i + 2 < row; ++i){\\n                    int val = abs(board[i][j]);\\n                    if(val != 0 && val == abs(board[i+1][j]) && val == abs(board[i+2][j])){\\n                        board[i][j] = -val;\\n                        board[i+1][j] = -val;\\n                        board[i+2][j] = -val;\\n                        changed = true;\\n                    }\\n                }\\n            }\\n            for(int j = 0; j < col; ++j){\\n                int bottom = row - 1;\\n                for(int i = row-1; i >= 0; --i){\\n                    if(board[i][j] > 0) {board[bottom--][j] = board[i][j];}\\n                }\\n                while(bottom >= 0) board[bottom--][j] = 0;\\n            }\\n            if(!changed) break;\\n            changed = false;\\n        };\\n        return board;\\n     }\\n     };"
		},
		{
			"lc_ans_id":"109238",
			"view":"240",
			"top":"3",
			"title":"The Example Input does not match the illustration",
			"vote":"1",
			"content":"In the textual description of Example 1 the 2nd last line of the board is\\n`[1,2,1,2,2]`\\nbut the illustration says\\n`[1,1,2,2,2]`\\n\\nSo this is something to pay attention to maybe ...\\n\\nHere's my simple & naive solution -- one function marks & counts the cells to be removed, and another function \"evolves\" the state of the board. The \"Evolve\" function is kind like \"Move Zeroes\". Not super duper fast but seemed to work ...\\n\\n```\\nclass Solution {\\npublic:\\n\\tint Mark(vector<vector<int>> & board, vector<vector<bool>>* marked) {\\n\\t\\tconst int H = int(board.size()), W = int(board.back().size());\\n\\t\\t// Horiz\\n\\t\\tfor (int y=0; y<H; y++) {\\n\\t\\t\\tint x=0;\\n\\t\\t\\twhile (x < W) {\\n\\t\\t\\t\\tint this_cell = board[y][x];\\n\\t\\t\\t\\tint x1 = x;\\n\\t\\t\\t\\tfor (x1 = x; x1 < W; x1++) {\\n\\t\\t\\t\\t\\tif (this_cell == board[y][x1]) { }\\n\\t\\t\\t\\t\\telse break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (this_cell != 0 && x1 - x >= 3) {\\n\\t\\t\\t\\t\\tfor (int xx=x; xx<x1; xx++) (*marked)[y][xx] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx = x1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Vert\\n\\t\\tfor (int x=0; x<W; x++) {\\n\\t\\t\\tint y=0;\\n\\t\\t\\twhile (y < H) {\\n\\t\\t\\t\\tint this_cell = board[y][x];\\n\\t\\t\\t\\tint y1 = y;\\n\\t\\t\\t\\tfor (y1 = y; y1 < H; y1++) {\\n\\t\\t\\t\\t\\tif (this_cell == board[y1][x]) { } else break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (this_cell != 0 && y1 - y >= 3) {\\n\\t\\t\\t\\t\\tfor (int yy=y; yy<y1; yy++) (*marked)[yy][x] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ty = y1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint ret = 0;\\n\\t\\tfor (int y=0; y<H; y++) {\\n\\t\\t\\tfor (int x=0; x<W; x++) {\\n\\t\\t\\t\\tret += ((*marked)[y][x] == true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n\\n\\tvoid Evolve(vector<vector<int>>& board, vector<vector<bool>>* marked) {\\n\\t\\tconst int H = int(board.size()), W = int(board.back().size());\\n\\t\\tfor (int x=0; x<W; x++) {\\n\\t\\t\\tint y1 = H-1, y0 = H-1;\\n\\t\\t\\twhile (y1 >= 0) {\\n\\t\\t\\t\\tif ((*marked)[y1][x] == true) {\\n\\t\\t\\t\\t\\ty1 --;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tboard[y0][x] = board[y1][x];\\n\\t\\t\\t\\t\\ty1--; y0--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (; y0 >= 0; y0--) board[y0][x] = 0;\\n\\t\\t}\\n\\t}\\n\\n    vector<vector<int>> candyCrush(vector<vector<int>>& board) {\\n\\t\\tconst int H = int(board.size()), W = int(board.back().size());\\n\\t\\tvector<vector<bool> > marked(H, vector<bool>(W, false) );\\n\\t\\twhile (true) {\\n\\t\\t\\tint nm = Mark(board, &marked);\\n\\t\\t\\tif (nm > 0) { Evolve(board, &marked); } else { break; }\\n\\t\\t\\tfor (int y=0; y<H; y++) for (int x=0; x<W; x++) marked[y][x] = false;\\n\\t\\t}\\n\\t\\treturn board;\\n    }\\n};\\n\\n```"
		},
		{
			"lc_ans_id":"109225",
			"view":"589",
			"top":"4",
			"title":"Simple C++ brute force",
			"vote":"1",
			"content":"```\\nclass Solution {\\npublic:\\n    vector<vector<int>> candyCrush(vector<vector<int>>& b) {\\n        int n = b.size(), m = b[0].size();\\n        while (true) {\\n            vector<pair<int,int>> vp;\\n            for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) if (b[i][j]) {\\n                int i0 = i, i1 = i, j0 = j, j1 = j;\\n                while (i1 < n &&  i1 < i + 3 && b[i1][j] == b[i][j]) ++i1;\\n                while (i0 >= 0 && i0 > i - 3 && b[i0][j] == b[i][j]) --i0;\\n                while (j1 < m && j1 < j + 3 && b[i][j1] == b[i][j]) ++j1;\\n                while (j0 >= 0 && j0 > j - 3 && b[i][j0] == b[i][j]) --j0;\\n                if (i1 - i0 >3 || j1 -j0 > 3) vp.push_back({i,j});\\n            }\\n            if (vp.empty()) break;\\n            for (auto p:vp) b[p.first][p.second] = 0;\\n            for (int j = 0; j < m; ++j) {\\n                int t = n-1;\\n                for (int i = n-1; i >=0; --i) if (b[i][j]) swap(b[i][j],b[t--][j]);\\n                for (int i = t; i >=0; --i) b[i][j] = 0;\\n            }\\n        }\\n        \\n        return b;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109219",
			"view":"24",
			"top":"5",
			"title":"Elegant solution using hashset with optimization (detailed explanation)",
			"vote":"0",
			"content":"**NOTE:** by the candy crush rule, we have \\n* **if a candy is crushable horizontally, all its consecutive horizontal neighbors with the same value are crushable.**\\n\\nSo we do not have to check all directions every time to see if a candy is crushable.\\n\\n1. Scan the board in row `i` increasing (major) and column `j` increasing (minor) order.\\n1. Candy `b[i][j]` is horizontally (similar for vertical) crushable if and only if\\n   * its left neighbor has the same value which is crushable, i.e.,\\n      `(j && b[i][j] == b[i][j-1] && hcrash.count(&b[i][j-1])`\\n   * or its next two neighbors to the right have the same value, i.e.,\\n      `j+2 < numCol && b[i][j+1]==b[i][j] && b[i][j+2] == b[i][j]`\\n   (hashset `hcrash` collects the **references** of all horizontally crushable candies)\\n1. Check all candies in `hcrush` and `vcrush` and\\n   * stop if `hcrush` and `vcrush` are both empty;\\n   * set crushed candies to `0`, and shift candies down for each column and repeat Steps 1-2.\\n\\n**NOTE:** Hashsets `vcrash, hcrash` for **references** of crushable candies are used to save space instead of copies of coordinate pairs `(i,j)`.\\n\\n```cpp\\npublic:\\n    vector<vector<int>> candyCrush(vector<vector<int>>& b) \\n    {        \\n        for (r = b.size(), c = b[0].size(); crush(b); dropBoard(b));        \\n        return b;\\n    }\\n    \\nprivate:\\n    \\n    int r, c; // row, column\\n    \\n    // crush all crushable candies and return true if crushable\\n    bool crush(vector<vector<int>>& b) \\n    {\\n        unordered_set<int*> vcrash, hcrash;\\n        \\n        // if candy at (i,j) is crushable in dir direction\\n        auto crushable = [&](int i, int j, char dir) {\\n            if (!b[i][j]) return false;\\n            return dir == 'v'? \\n                (i && b[i][j]==b[i-1][j] && vcrash.count(&b[i-1][j]) || i+2<r && b[i+1][j]==b[i][j] && b[i+2][j]==b[i][j]) \\n               :(j && b[i][j]==b[i][j-1] && hcrash.count(&b[i][j-1]) || j+2<c && b[i][j+1]==b[i][j] && b[i][j+2]==b[i][j]);\\n        };\\n        \\n        for (int i = 0; i < r; ++i)\\n            for (int j = 0; j < c; ++j) {\\n                if (crushable(i, j, 'v')) vcrash.insert(&b[i][j]);\\n                if (crushable(i, j, 'h')) hcrash.insert(&b[i][j]);                         \\n            }\\n        \\n        // remove crushed candies\\n        for (auto& x : vcrash) *x = 0;\\n        for (auto& x : hcrash) *x = 0;        \\n        return !vcrash.empty() || !hcrash.empty();\\n    }\\n        \\n    // drop board vertially to fill empty cells\\n    void dropBoard(vector<vector<int>>& b) \\n    {\\n        for (int j = 0; j < c; ++j)\\n            for (int L = r-1, R = r-1; L >= 0; )\\n                if (b[R][j]) L--, R--; \\n                else if (!b[L][j]) L--;\\n                else swap(b[L--][j], b[R--][j]);\\n    }\\n```"
		},
		{
			"lc_ans_id":"109222",
			"view":"49",
			"top":"6",
			"title":"Simple AC Java Solution With Explanation -- Easy to Understand",
			"vote":"0",
			"content":"This is a brute force 2 pass approach. The idea is very simple and can be broken up into 3 basic parts. Since I was writing it during contest, code is a little verbose, but very straight forward. Feel free to suggest edits if you see any :)\\n\\nIdea:\\n1. Traverse Matrix for each index if it isn't empty (Ie: 0), we need to search in 4 directions (up, down, left, right) for as many contiguous identical cells and keep a count in each direction. If the count is >= 3, we need to mark those cells as needed for deletion (with -1 in our deletion_board). \\n\\n2. Traverse Matrix from bottom row up (left to right) and for each cell that was marked for deletion (with -1 in our deletion board) , we search upwards for the nearest neighbor in it's column that is available (not -1). We swap the value with our current cell.\\n\\n3. Maintain a deletion flag to track if anything was deleted in the previous iteration (any direction has 3 or more identical cells). If so, we clear our deletion flag and our deletion_board and repeat. \\n\\nRuntime: \\nFirst Pass: O(n * m * (m + n))\\nSecond Pass: O(n * m * n);\\nOverall: O(n * m * (m + n)) \\n\\n\\n```\\nclass Solution {\\n    public int[][] candyCrush(int[][] board) {\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        boolean deletion = true;\\n        \\n        while(deletion) {\\n            deletion = false;\\n            int[][] deletion_board = new int[rows][cols];\\n            for(int i = 0; i < rows; i++){\\n                for(int j = 0; j < cols; j++){\\n                    if(board[i][j] == 0){\\n                        continue;\\n                    }\\n                    deletion |= markDeletion(board, i, j, rows, cols, deletion_board);\\n                }\\n            }\\n\\n            // if something has been deleted, we need to drop cells down\\n            if(deletion) {\\n                for(int i = rows - 1; i >= 0; i--){\\n                    for(int j = 0; j < cols; j++){\\n                        if(deletion_board[i][j] == -1){\\n                            board[i][j] = search(board, i, j, deletion_board);   \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return board;\\n    }\\n    \\n    // for a deleted cell, looks up for closest non deleted neighbor\\n    // moves that non deleted cell to current position and marks it as deleted\\n    public int search(int[][] board, int i, int j, int[][] deletion_board){\\n        int index = i-1;\\n        while(index >= 0 && deletion_board[index][j] == -1){\\n            index--;\\n        }\\n\\n        if(index < 0){\\n            return 0;\\n        } else {\\n            int res = board[index][j];\\n            deletion_board[index][j] = -1;\\n            return res;\\n        }\\n    }\\n    \\n    // 1. Counts # of cells that share same value as (i, j) in 4 directions: Up, Down, Left, Right\\n    // 2. If Count is >= 3, we go back and mark those cells as ready for deletion. Since a group of 3 vertically and horizontally may intersect, we use a separate matrix called deletion_board to track which cells we need to remove with -1. Note: We cannot mark -1 on the original board because this will cause some cells not to be marked correctly. See Example below!\\n    \\n    /*   Ex:\\n     *   1 0 0     -1 0 0\\n     *   1 0 0 =>  -1 0 0\\n     *   1 1 1     -1 1 1\\n     */\\n    // In the example above, the bottom row also needs to be deleted, but because we changed cell (2, 0) from 1 to -1, it affects the count when you reach the bottom. With the new count = 2, it won't mark the cells correctly as needed for deletion.\\n    \\n    public boolean markDeletion(int[][] board, int i, int j, int rows, int cols, int[][] deletion_board){\\n            \\n            boolean flag = false;\\n            // search up \\n            int up_count = 1;\\n            for(int k = i-1; k >= 0; k--){\\n                if(board[k][j] != board[i][j]){\\n                    break;\\n                } else {\\n                    up_count++;\\n                }\\n            }\\n\\n            if(up_count >= 3){\\n                flag = true;\\n                for(int k = 0; k < up_count; k++){\\n                    deletion_board[i - k][j] = -1;\\n                }\\n            }\\n\\n            // search down \\n            int down_count = 1;\\n            for(int k = i+1; k < rows; k++){\\n                if(board[k][j] != board[i][j]){\\n                    break;\\n                } else {\\n                    down_count++;\\n                }\\n            }\\n\\n            if(down_count >= 3){\\n                flag = true;\\n                for(int k = 0; k < down_count; k++){\\n                    deletion_board[i + k][j] = -1;\\n                }\\n            }\\n\\n            // search left \\n            int left_count = 1;\\n            for(int k = j-1; k >= 0; k--){\\n                if(board[i][k] != board[i][j]){\\n                    break;\\n                } else {\\n                    left_count++;\\n                }\\n            }\\n\\n            if(left_count >= 3){\\n                flag = true;\\n                for(int k = 0; k < left_count; k++){\\n                    deletion_board[i][j - k] = -1;\\n                }\\n            }\\n\\n            // search right \\n            int right_count = 1;\\n            for(int k = j+1; k < cols; k++){\\n                if(board[i][k] != board[i][j]){\\n                    break;\\n                } else {\\n                    right_count++;\\n                }\\n            }\\n\\n            if(right_count >= 3){\\n                flag = true;\\n                for(int k = 0; k < right_count; k++){\\n                    deletion_board[i][j + k] = -1;\\n                }\\n            }\\n            return flag; \\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"109223",
			"view":"45",
			"top":"7",
			"title":"Candy Crush, using negative numbers to label curshed candies",
			"vote":"0",
			"content":"The trick in candy crush is to find a way to check if a particular slot will be crushed. (BFS and DFS is way more complicated in this problem)\\nWe can find finite ways to form a match ( in this problem, the finite number is 6).\\n\\nThink one more step further, how should we generate a `hint` for candy crush. A hint means possible ways of movement for the user when he/she is stuck at some point. In that case, the possible way is 16. (find more detailed explanation using google if you are interested).\\n```\\n    public int[][] candyCrush(int[][] board) {\\n        if (board == null || board.length == 0 || board[0].length == 0) return board;\\n        int cnt = 0;\\n        int m = board.length, n = board[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == 0) continue;\\n                if (   (i > 0 && Math.abs(board[i-1][j]) == board[i][j] && (i < m - 1 && board[i+1][j] == board[i][j]))\\n                    || (i > 1 && Math.abs(board[i-1][j]) == board[i][j] && Math.abs(board[i-2][j]) == board[i][j])\\n                    || (i < m - 2 && board[i+1][j] == board[i][j] && board[i+2][j] == board[i][j])\\n                    || (j > 0 && Math.abs(board[i][j-1]) == board[i][j] && (j < n - 1 && board[i][j+1] == board[i][j]))\\n                    || (j > 1 && Math.abs(board[i][j-1]) == board[i][j] && Math.abs(board[i][j-2]) == board[i][j])\\n                    || (j < n - 2 && board[i][j+1] == board[i][j] && board[i][j+2] == board[i][j])) {\\n                    cnt++;\\n                    board[i][j] = -board[i][j];\\n                }\\n            }\\n        }\\n        for (int j = 0; j < n; j++) {\\n            int ptr = m - 1;\\n            for (int i = m - 1; i >= 0; i--) {\\n                if (board[i][j] > 0) {\\n                    board[ptr--][j] = board[i][j];\\n                }\\n            }\\n            for (int i = ptr; i >= 0; i--) {\\n                board[i][j] = 0;\\n            }\\n        }\\n        if (cnt == 0) {\\n            return board;\\n        } else {\\n            return candyCrush(board);\\n        }\\n    }\\n```"
		},
		{
			"lc_ans_id":"109224",
			"view":"33",
			"top":"8",
			"title":"C++ solution O(n^2)",
			"vote":"0",
			"content":"'''\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> candyCrush(vector<vector<int>>& board) {\\n        if(board.size() < 3 && board[0].size() < 3)\\n            return board;\\n        else {\\n            crush(board);\\n            return board;\\n        }\\n    }\\n    \\n    void crush(vector<vector<int>>& board) {\\n        vector<vector<int>> vertical(board.size(), vector<int>(board[0].size(), 1));\\n        vector<vector<int>> horizontal(board.size(), vector<int>(board[0].size(), 1));\\n        \\n        bool boardDirty = false;\\n        for(int i = 0 ; i < board.size() ; i++) {\\n            for(int j = 0 ; j < board[i].size() ; j++) {\\n                if(board[i][j] == 0) continue;\\n                \\n                if(i > 0 && board[i][j] == board[i-1][j]) {\\n                    vertical[i][j] = vertical[i-1][j] + 1;\\n                    if(vertical[i][j] >= 3) {\\n                        boardDirty = true;\\n                    }\\n                }\\n                if(j > 0 && board[i][j] == board[i][j-1]) {\\n                    horizontal[i][j] = horizontal[i][j-1] + 1;\\n                    if(horizontal[i][j] >= 3) {\\n                        boardDirty = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<int> zeros(board[0].size(),0);\\n        \\n        if(boardDirty) {\\n            // consolidate positions to squash\\n            for(int i = board.size()-1 ; i >= 0 ; i--) {\\n                for(int j = board[i].size()-1 ; j >= 0 ; j--) {\\n                    int tempv = vertical[i][j], temph = horizontal[i][j];\\n                    if(tempv >= 3) {\\n                        zeros[j] += tempv;\\n                        for(int k=0 ; k < tempv ; k++) {\\n                          board[i-k][j] = 0; \\n                          vertical[i-k][j] = 0;\\n                        } \\n                    }\\n                    \\n                    if(temph >= 3) {\\n                        for(int k=0 ; k < temph ; k++){\\n                          if(vertical[i][j-k] < 3) \\n                              zeros[j-k] += 1;\\n                          board[i][j-k] = 0; \\n                          horizontal[i][j-k] = 0; \\n                        } \\n                    }                    \\n                }\\n            }\\n            \\n\\n            // crush candies\\n            int n = board.size();\\n            for(int j=0 ; j < board[0].size(); j++) {\\n                int z = n-1, pos = zeros[j];\\n                for(int i=n-1 ; i >= 0 ; i--) {\\n                    if(board[i][j] != 0) {\\n                        board[z][j] = board[i][j];\\n                        if(z != i) board[i][j] = 0;\\n                        z--;\\n                    }\\n                }\\n            }            \\n        }   \\n        \\n        if(boardDirty)\\n            crush(board);\\n    }\\n};\\n\\n'''"
		},
		{
			"lc_ans_id":"109226",
			"view":"56",
			"top":"9",
			"title":"Easy and Clear Java Solution",
			"vote":"0",
			"content":"The idea is to first check row by row and mark element that eligible for crushing as negative. So that you can still to check column by column whether it can be involved in some column crushing. for example:\\n\\n1 2 2 2\\n1 3 4 2\\n2 4 1 2\\n\\nafter row to row marking , you will get :\\n\\n1 -2 -2 -2\\n1  3  4   2\\n2  4   1  2\\n\\nThen do a column to column scan (from bottom to up), both for checking crushing for elements in the same column and crush the elements meanwhile by maintain two pointers. the bottom pointer points to where to put next living element and the top pointer point to the next element to scan\\n```\\npublic int[][] candyCrush(int[][] board) {\\n        /**\\n        \\n           row ---  0 ~ rows\\n           col ---  1 ~ cols   count --> 1\\n           \\n              if (col == col - 1) count++ \\n              else count = 1\\n              \\n              if (count == 3)  col = col -1 = col - 2 --> negative\\n              else if (count > 3) col --> negative\\n            col --- 0 ~ cols\\n            row --- rows - 2 ~ 0 count ---> 1 , start --> 0 // indicate the starting copy position\\n            {\\n            \\n            if (row != row + 1 || row == 0){\\n               if (count < 3)\\n                    move previous count of element to start \\n                count = 1;\\n            } else count ++\\n            start ---> first negative point\\n            }\\n        \\n        **/\\n        \\n        boolean stable = true;\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        do {\\n            stable = true;\\n            for (int r = 0; r < rows; r++) {\\n                int count = 1;\\n                int[] row = board[r];\\n                for (int c = 1; c < cols; c++) {\\n                    if (row[c] == Math.abs(row[c - 1])) count++;\\n                    else count = 1;\\n                    if (count >= 3 && row[c] != 0) {\\n                        stable = false;\\n                        row[c] = -row[c];\\n                        if (count == 3) row[c - 1] = row[c - 2] = row[c];\\n                    }\\n                }\\n            }\\n            \\n            for (int c = 0; c < cols; c++) {\\n                int start = rows - 1;\\n                int count = 1;\\n                int r = rows - 2;\\n                for (; r >= -1; r--) {\\n                    \\n                    if (r == -1 || Math.abs(board[r][c]) != Math.abs(board[r+1][c])) {\\n                        if (count < 3) {\\n                            for (int i = r + count; i > r; i--) {\\n                                if (board[i][c] > 0) board[start--][c] = board[i][c];\\n                            }\\n                        } else stable = false;\\n                        count = 1;\\n                    } else count++;\\n                    if (r >= 0 && board[r][c] == 0) break;\\n                }\\n                while(start >= Math.max(0, r+1)) board[start--][c] = 0;\\n            }\\n            \\n            \\n        } while (!stable);\\n        return board;\\n    }\\n```"
		}
	],
	"id":"689",
	"title":"Candy Crush",
	"content":"<p>This question is about implementing a basic elimination algorithm for Candy Crush.</p>\r\n\r\n<p>Given a 2D integer array <code>board</code> representing the grid of candy, different positive integers <code>board[i][j]</code> represent different types of candies.  A value of <code>board[i][j] = 0</code> represents that the cell at position <code>(i, j)</code> is empty.  The given board represents the state of the game following the player's move.  Now, you need to restore the board to a <i>stable state</i> by crushing candies according to the following rules:</p>\r\n\r\n<ol>\r\n<li>If three or more candies of the same type are adjacent vertically or horizontally, \"crush\" them all at the same time - these positions become empty.</li>\r\n<li>After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.)</li>\r\n<li>After the above steps, there may exist more candies that can be crushed.  If so, you need to repeat the above steps.</li>\r\n<li>If there does not exist more candies that can be crushed (ie. the board is <i>stable</i>), then return the current board.</li>\r\n</ol>\r\n\r\n<p>You need to perform the above rules until the board becomes stable, then return the current board.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre style=\"white-space: pre-line\">\r\n<b>Input:</b>\r\nboard = \r\n[[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]\r\n<b>Output:</b>\r\n[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]\r\n<b>Explanation:</b> \r\n<img src=\"/static/images/problemset/candy_crush_example_2.png\"/>\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The length of <code>board</code> will be in the range [3, 50].</li>\r\n<li>The length of <code>board[i]</code> will be in the range [3, 50].</li>\r\n<li>Each <code>board[i][j]</code> will initially start as an integer in the range [1, 2000].</li>\r\n</ol>\r\n</p>",
	"frequency":"49",
	"ac_num":"1588"
}