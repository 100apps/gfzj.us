{
	"difficulty":"3",
	"submit_num":"7625",
	"show_id":"726",
	"leetcode_id":"726",
	"answers":[
		{
			"lc_ans_id":"109333",
			"view":"511",
			"top":"0",
			"title":"Neat Python with Explanation - 35ms",
			"vote":"6",
			"content":"The first regex `([A-Z]{1}[a-z]?|\\\\(|\\\\)|\\\\d+)` splits up the input string into a few kinds of tokens for parsing: (1) An atom (2) A number (3) Open bracket (4) Closing bracket. These are the only tokens we need to do our parsing.\\n\\nAn input of `Mg(OH)2` will be tokenized into: `['Mg', '(', 'O', 'H', ')', '2']`.\\nAn input of `K4(ON(SO3)2)2` will be tokenized into: `['K', '4', '(', 'O', 'N', '(', 'S', 'O', '3', ')', '2', ')', '2']`.\\n\\nAs we iterate through the tokens, there are three cases that we need to handle:\\n\\n1. Open bracket - We push a new dictionary onto a stack to keep track of the atoms and its count in this current group\\n2. Close bracket - The next token might be a number/count. Check whether if it is a count. If it is, multiply all the atoms at the top of the stack by the count and combine it with a dictionary below it in the stack.\\n3. Normal atom - The next token might be a number/count. Check whether if it is a count. If it is, add that atom and its count to the top of the stack.\\n\\nCases 2 and 3 are very similar, so we can combine them.\\n\\nAt the end, sort the atoms alphabetically and format them nicely to be returned.\\n\\n*- Yangshun*\\n\\n```\\nclass Solution(object):\\n    def countOfAtoms(self, formula):\\n        import re\\n        from collections import defaultdict\\n        tokens = list(filter(lambda c: c, re.split('([A-Z]{1}[a-z]?|\\\\(|\\\\)|\\\\d+)', formula)))\\n        stack, i = [defaultdict(int)], 0\\n        while i < len(tokens):\\n            token = tokens[i]\\n            if token == '(':\\n                stack.append(defaultdict(int))\\n            else:\\n                count = 1\\n                # Check if next token is a number.\\n                if i + 1 < len(tokens) and re.search('^\\\\d+$', tokens[i + 1]):\\n                    count, i = int(tokens[i + 1]), i + 1\\n                atoms = stack.pop() if token == ')' else { token: 1 }\\n                # Combine counts of atoms.\\n                for atom in atoms:\\n                    stack[-1][atom] += atoms[atom] * count\\n            i += 1\\n        return ''.join([atom + (str(count) if count > 1 else '') for atom, count in sorted(stack[-1].items())])\\n```"
		},
		{
			"lc_ans_id":"109335",
			"view":"688",
			"top":"1",
			"title":"[C++] Recursive Parser",
			"vote":"6",
			"content":"```\\n/**\\n * formula :\\n *     unit[]\\n * unit :\\n *     atom (count)\\n *     '(' formula ')' count\\n * atom :\\n *    upper (lower[])\\n * count :\\n *    digit[]\\n * -----------------------------\\n * upper : '[A-Z]'\\n * lower : '[a-z]'\\n * digit : '[0-9]'\\n */\\n```\\n```\\nclass Solution {\\npublic:\\n    string countOfAtoms(string formula) {\\n        string output;\\n        const int n = formula.size();\\n        int i = 0;\\n        map<string, int> counts = parseFormula(formula, i);\\n        for (pair<string, int> p : counts) {\\n            output += p.first;\\n            if (p.second > 1) output += to_string(p.second);\\n        }\\n        return output;\\n    }\\n\\nprivate:\\n    map<string, int> parseFormula(string& s, int& i) {\\n        map<string, int> counts;\\n        const int n = s.size();\\n        while (i < n && s[i] != ')') {\\n            map<string, int> cnts = parseUnit(s, i);\\n            merge(counts, cnts, 1);\\n        }\\n        return counts;\\n    }\\n\\n    map<string, int> parseUnit(string& s, int& i) {\\n        map<string, int> counts;\\n        const int n = s.size();\\n        if (s[i] == '(') {\\n            map<string, int> cnts = parseFormula(s, ++i); // ++i for '('\\n            int digits = parseDigits(s, ++i); // ++i for ')'\\n            merge(counts, cnts, digits);\\n        }\\n        else {\\n            int i0 = i++; // first letter\\n            while (i < n && islower(s[i])) { i++; }\\n            string atom = s.substr(i0, i - i0);\\n            int digits = parseDigits(s, i);\\n            counts[atom] += digits;\\n        }\\n        return counts;\\n    }\\n\\n    int parseDigits(string& s, int& i) {\\n        int i1 = i;\\n        while (i < s.size() && isdigit(s[i])) { i++; }\\n        int digits = i == i1 ? 1 : stoi(s.substr(i1, i - i1));\\n        return digits;\\n    }\\n\\n    void merge(map<string, int>& counts, map<string, int>& cnts, int times) {\\n        for (pair<string, int> p : cnts) counts[p.first] += p.second * times;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109345",
			"view":"1022",
			"top":"2",
			"title":"Java Solution using Stack and Map",
			"vote":"6",
			"content":"```\\nclass Solution {\\n    public String countOfAtoms(String formula) {\\n        Stack<Map<String,Integer>> stack= new Stack<>();\\n        Map<String,Integer> map= new HashMap<>();\\n        int i=0,n=formula.length();\\n        while(i<n){\\n            char c=formula.charAt(i);i++;\\n            if(c=='('){\\n                stack.push(map);\\n                map=new HashMap<>();\\n            }\\n            else if(c==')'){\\n                int val=0;\\n                while(i<n && Character.isDigit(formula.charAt(i)))\\n                    val=val*10+formula.charAt(i++)-'0';\\n\\n                if(val==0) val=1;\\n                if(!stack.isEmpty()){\\n                Map<String,Integer> temp= map;\\n                map=stack.pop();\\n                    for(String key: temp.keySet())\\n                        map.put(key,map.getOrDefault(key,0)+temp.get(key)*val);\\n                }\\n            }\\n            else{\\n                int start=i-1;\\n                while(i<n && Character.isLowerCase(formula.charAt(i))){\\n                 i++;\\n                }\\n                String s= formula.substring(start,i);\\n                int val=0;\\n                while(i<n && Character.isDigit(formula.charAt(i))) val=val*10+ formula.charAt(i++)-'0';\\n                if(val==0) val=1;\\n                map.put(s,map.getOrDefault(s,0)+val);\\n            }\\n        }\\n        StringBuilder sb= new StringBuilder();\\n        List<String> list= new ArrayList<>(map.keySet());\\n        Collections.sort(list);\\n        for(String key: list){ \\n            sb.append(key);\\n          if(map.get(key)>1) sb.append(map.get(key));\\n                                    }\\n        return sb.toString();\\n    }\\n}\\n\\n```"
		},
		{
			"lc_ans_id":"109328",
			"view":"158",
			"top":"3",
			"title":"C++ iterative solution",
			"vote":"4",
			"content":"```\\nclass Solution {\\npublic:\\n    string countOfAtoms(string f) {\\n        stack<map<string,int>> st;\\n        map<string, int> cur;\\n        for (int i = 0; i < f.size();) {\\n            if (f[i] == '(') {\\n                st.push(move(cur));\\n                cur = map<string,int>();\\n                ++i;\\n            }\\n            else if (f[i] == ')') {\\n                int j = i+1;\\n                int num = 0;\\n                while (j < f.size() && isdigit(f[j])) num = num*10 + (f[j++] - '0');\\n                num = max(num,1);\\n                for (auto p:cur) st.top()[p.first] += p.second * num;\\n                cur = move(st.top());\\n                st.pop();\\n                i = j;\\n            }\\n            else {\\n                int j = i + 1;\\n                while (j < f.size() && f[j] >= 'a' && f[j] <= 'z') ++j;\\n                auto name = f.substr(i,j-i);\\n                int num = 0;\\n                while (j < f.size() && isdigit(f[j])) num = num*10 + (f[j++] - '0');\\n                num = max(num,1);\\n                cur[name] += num;\\n                i = j;\\n            }\\n        }\\n        string ans;\\n        for (auto p:cur) {\\n            ans += p.first;\\n            if (p.second > 1) ans += to_string(p.second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109346",
			"view":"914",
			"top":"4",
			"title":"Java solution, Map + Recursion",
			"vote":"4",
			"content":"```\\nclass Solution {\\n    public String countOfAtoms(String formula) {\\n        Map<String, Integer> map = countHelper(formula);\\n\\n        List<String> atoms = new ArrayList<>(map.keySet());\\n        Collections.sort(atoms);\\n        StringBuilder sb = new StringBuilder();\\n        for (String atom : atoms) {\\n            sb.append(atom + (map.get(atom) > 1 ? map.get(atom) : \"\"));\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    private Map<String, Integer> countHelper(String formula) {\\n        Map<String, Integer> map = new HashMap<>();\\n        if (formula.isEmpty()) return map;\\n\\n        int i = 0;\\n        while (i < formula.length()) {\\n            if (formula.charAt(i) == '(') {\\n                int count = 0, j = i;\\n                for (; j < formula.length(); j++) {\\n                    if (formula.charAt(j) == '(') count++;\\n                    else if (formula.charAt(j) == ')') count--;\\n                    if (count == 0) break;\\n                }\\n                Map<String, Integer> subMap = countHelper(formula.substring(i + 1, j));\\n\\n                j++;\\n                int n = 1, k = j;\\n                while (k < formula.length() && Character.isDigit(formula.charAt(k))) k++;\\n                if (k > j) {\\n                    n = Integer.parseInt(formula.substring(j, k));\\n                }\\n\\n                for (String atom : subMap.keySet()) {\\n                    map.put(atom, subMap.get(atom) * n + map.getOrDefault(atom, 0));\\n                }\\n\\n                i = k;\\n            } else {\\n                int j = i + 1;\\n                while (j < formula.length() && formula.charAt(j) >= 'a' && formula.charAt(j) <= 'z') j++;\\n\\n                int n = 1, k = j;\\n                while (k < formula.length() && Character.isDigit(formula.charAt(k))) k++;\\n                if (k > j) {\\n                    n = Integer.parseInt(formula.substring(j, k));\\n                }\\n\\n                String atom = formula.substring(i, j);\\n                map.put(atom, n + map.getOrDefault(atom, 0));\\n\\n                i = k;\\n            }\\n        }\\n\\n        return map;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"109324",
			"view":"393",
			"top":"5",
			"title":"Elegant & Clean C++  Iterative Solution Using stack ( via Reverse the Formula)",
			"vote":"2",
			"content":"Aha, I think this is by far the cleanest solution.  The idea is very simple, reverse the formula and iteratively process the formula with the help of a stack recording the multiplication factor of the current element.\\n\\nThe code is quite self-explanatory. Hope it helps!\\n\\n**Updated:**\\n\\nSpecial thanks to @xmeng525 to make it more clear.\\n\\n```\\nclass Solution {\\npublic:\\n    string countOfAtoms(string formula) {\\n        std::map<string, int> stats;\\n        std::reverse(formula.begin(), formula.end());\\n        compute(formula, stats);\\n        string result;\\n        \\n        for (auto& kv : stats) {\\n            result += kv.first;\\n            if (kv.second > 1) {\\n                result += std::to_string(kv.second);\\n            }\\n        }\\n        return result;\\n    }\\n    \\nprivate: // K4(ON(SO3)2)2\\n    void compute(string& formula, std::map<string, int>& stats) {\\n        int n = formula.size();\\n        \\n        std::stack<int> stk; // factor\\n        stk.push(1);\\n        \\n        string elem; // chemical element, e.g., C, N, O, Na, Mg, Al, etc.\\n        int factor = 1; // number of this element, default to 1 if not otherwise specified\\n        \\n        for (int i = 0; i < n; ++i) {\\n            auto& c = formula[i];\\n            if (isdigit(c)) { // E.g., original 312 was reverse to 213.\\n                int val = 0, expo = 1;\\n                do {\\n                    val += (c - '0') * expo;\\n                    ++i; expo *= 10;\\n                } while (isdigit(c = formula[i]));\\n                factor = val; // explicit number of this element\\n                \\n                i -= 1;\\n            } else if (c == ')') { \\n                stk.push(factor * stk.top());\\n                factor = 1; //            Al(OH)3\\n            } else if (c >= 'A' && c <= 'Z') {\\n                elem += c;\\n                std::reverse(elem.begin(), elem.end());\\n                stats[elem] += factor * stk.top();\\n                factor = 1;\\n                elem.clear();\\n            } else if (c >= 'a' && c <= 'z') {\\n                elem += c;\\n            } else { // (c == '(') {  \\n                stk.pop();  // Ca(OH)2\\n                // elem.clear();\\n            } \\n        }   \\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109342",
			"view":"274",
			"top":"6",
			"title":"Python solution using recursion and regex",
			"vote":"2",
			"content":"A given formula can either start with '(' or an atom.\\ncase 1: If it starts with an atom, then we extract the starting atom and its count using regex and handle the rest of the formula recursively\\ncase 2: If it starts with a '(', then we find the matching ')' and use recursion twice\\n         a) First we solve the sub formula inside '('  ')' using recursion and we extract the count following it and update the counts. \\n        b) Then for the remainder of the formula we make a recursive call to solve it.\\n```\\n    def countOfAtoms(self, formula):\\n        res_dict = defaultdict(int)\\n        self.count_rec(formula, res_dict)\\n        return ''.join(chain.from_iterable([[atom, str(res_dict[atom]) if res_dict[atom] > 1 else ''] for atom in sorted(res_dict.keys())]))\\n\\n    def count_rec(self, formula, res):\\n        if formula is None or len(formula) == 0:\\n            return\\n        if formula[0] == '(':\\n            count, i = 1, 1\\n            while count != 0:\\n                if formula[i] == '(': count += 1\\n                if formula[i] == ')': count -= 1\\n                i += 1\\n            temp_res = defaultdict(int)\\n            self.count_rec(formula[1:i-1], temp_res)\\n            num = re.findall('^\\\\d+', formula[i:])\\n            if len(num) > 0:\\n                num = int(num[0])\\n                i += len(str(num))\\n            else:\\n                num = 1\\n            for atom in temp_res:\\n                res[atom] += temp_res[atom] * num\\n            self.count_rec(formula[i:], res)\\n        else:\\n            atom = re.findall('[A-Z][a-z]*', formula)[0]\\n            num = re.findall('^\\\\d+', formula[len(atom):])\\n            num = int(num[0]) if len(num) > 0 else 1\\n            res[atom] += num\\n            self.count_rec(formula[len(atom) + (0 if num == 1 else len(str(num))):], res)\\n```"
		},
		{
			"lc_ans_id":"109315",
			"view":"24",
			"top":"7",
			"title":"Elegant short solution with a parser (with explanation)",
			"vote":"1",
			"content":"Inspired by @elastico, we can use a single stack of element -> count maps to build the final count map.\\n\\nFor example, if `f = \"K4(ON(SO3)2HO2)2\"`, we have maps\\n* `<map1>(<map2>(<map3>)2<map4>)2`\\nwhich form a stack of processing sequence as\\n1. `map1`\\n1. `map1, (map2`\\n1. `map1, (map2, (map3)`\\n1. `map1, (map2` (with `map3` combined with `map2`)\\n1. `map1, (map2, map4)`\\n1. `map1, map2` (with `map4` combined with `map2`)\\n1. `map1` (with `map2` combined with `map1`)\\n\\nScanning formula string `f` from left, we have 3 types of chars:\\n1. `(`: a new section of string begins. We put an empty map on stack top.\\n1. `)`: the section on top of stack ends. We need to parse the numeric value right after the `)`, and combined element counts with the map just under top of stack.\\n1. Other chars: in the middle of a section. We need to parse each element name and count to build the map on top of stack. \\n\\n```cpp\\npublic:\\n    string countOfAtoms(string f) \\n    {\\n        stack<map<string,int>> s({map<string,int>()}); // element -> count maps between brackets\\n        \\n        for (int i = 0; i < f.size();)\\n            switch (f[i]) \\n            {\\n                case '(': { s.push(map<string,int>()), ++i; break; }                    \\n                case ')': {\\n                    int num = stoi(parser(f,++i));\\n                    auto t = s.top(); s.pop();\\n                    for (auto& p : t) s.top()[p.first] += p.second*num;\\n                    break;\\n                }                    \\n                default: { // build element -> count map\\n                    string name = parser(f,i,true); \\n                    s.top()[name] += stoi(parser(f,i));\\n                }\\n            }\\n        \\n        // form result\\n        string res;\\n        for (auto& p : s.top()) {\\n            res += p.first;\\n            if (p.second > 1) res += to_string(p.second);\\n        }        \\n        return res;\\n    }\\n    \\nprivate:\\n    \\n    // parse element name (alphabet=true) or numeric value (alphabet=false) starting at f[i]\\n    // i will be overwritten by next to end position\\n    string parser(const string& f, int& i, bool alphabet = false) \\n    {\\n        int start = i;\\n        string chars = alphabet? \"abcdefghijklmnopqrstuvwxyz\" : \"0123456789\";\\n        i = min(f.find_first_not_of(chars, i+alphabet), f.size()); // next to end position       \\n        return i==start? \"1\" : f.substr(start,i-start); // default 1 if no digits\\n    }    \\n```"
		},
		{
			"lc_ans_id":"109314",
			"view":"15",
			"top":"8",
			"title":"Java DFS only using Map beats 99%",
			"vote":"0",
			"content":"class Solution {\\n    \\n    public String countOfAtoms(String formula) {\\n        TreeMap<String, Integer> map = new TreeMap<>();\\n        dfsHelper(formula, 0, formula.length() - 1, 1, map);\\n        StringBuilder sb = new StringBuilder();\\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\\n            sb.append(entry.getKey());\\n            if (entry.getValue() > 1) {\\n                sb.append(entry.getValue());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    private void dfsHelper(String formula, int start, int end, int times, Map<String, Integer> map) {\\n        if (start > end) {\\n            return;\\n        }\\n        while (start <= end) {\\n            if (formula.charAt(start) == '(') {\\n                int rightParenIdx = findRightParen(formula, start, end);\\n                int[] res = findNum(formula, rightParenIdx + 1, end);\\n                dfsHelper(formula, start + 1, rightParenIdx - 1, times * res[0], map);\\n                start = res[1];\\n            } else if (formula.charAt(start) >= 'A' && formula.charAt(start) <= 'Z') {\\n                int temp = start + 1;\\n                while (temp <= end && formula.charAt(temp) >= 'a' && formula.charAt(temp) <= 'z') {\\n                    temp++;\\n                }\\n                String atom = formula.substring(start, temp);\\n                int[] res = findNum(formula, temp, end);\\n                map.put(atom, map.getOrDefault(atom, 0) + res[0] * times);\\n                start = res[1];\\n            }\\n        }\\n    }\\n    \\n    private int findRightParen(String formula, int start, int end) {\\n        int count = 0;\\n        while (start <= end) {\\n            if (formula.charAt(start) == '(') {\\n                count++;\\n            } else if (formula.charAt(start) == ')') {\\n                count--;\\n            }\\n            if (count == 0) {\\n                return start;\\n            }\\n            start++;\\n        }\\n        return -1;\\n    }\\n    \\n    private int[] findNum(String formula, int start, int end) {\\n        int[] res = new int[2];\\n        if (start > end || formula.charAt(start) < '0' || formula.charAt(start) > '9') {\\n            res[0] = 1;\\n            res[1] = start;\\n            return res;\\n        }\\n        while (start <= end && formula.charAt(start) >= '0' && formula.charAt(start) <= '9') {\\n            res[0] = res[0] * 10 + formula.charAt(start) - '0';\\n            start++;\\n        }\\n        res[1] = start;\\n        return res;\\n    }\\n}"
		},
		{
			"lc_ans_id":"109316",
			"view":"46",
			"top":"9",
			"title":"Java Regex",
			"vote":"0",
			"content":"After you have read the [Solution](https://leetcode.com/problems/number-of-atoms/solution/), you will find that the regular expression solution is missing in Java. The following is it.\\n```\\nimport java.util.regex.*;\\n\\nclass Solution {\\n    public String countOfAtoms(String formula) {\\n        final Stack<Map<String, Integer>> stack = new Stack<>();\\n        stack.push(new TreeMap<>());\\n        final Pattern pattern = Pattern.compile(\"([A-Z][a-z]*)(\\\\\\\\d*)|(\\\\\\\\()|(\\\\\\\\))(\\\\\\\\d*)\");\\n        final Matcher matcher = pattern.matcher(formula);\\n        while (matcher.find()) {\\n            final String match = matcher.group();\\n            if (match.equals(\"(\")) {\\n                stack.push(new TreeMap<>());\\n            } else if (match.startsWith(\")\")) {\\n                final Map<String, Integer> top = stack.pop();\\n                final int multiple = match.length() > 1 ? Integer.parseInt(match.substring(1, match.length())) : 1;\\n                for (final String name : top.keySet()) {\\n                    stack.peek().put(name, stack.peek().getOrDefault(name, 0) + top.get(name) * multiple);\\n                }\\n            } else {\\n                int i = 1;\\n                while (i < match.length() && Character.isLowerCase(match.charAt(i))) {\\n                    i++;\\n                }\\n                final String name = match.substring(0, i);\\n                final int count = i < match.length() ? Integer.parseInt(match.substring(i, match.length())) : 1;\\n                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + count);\\n            }\\n        }\\n        final StringBuilder sb = new StringBuilder();\\n        for (final String name : stack.peek().keySet()) {\\n            sb.append(name);\\n            final int count = stack.peek().get(name);\\n            if (count > 1) {\\n                sb.append(String.valueOf(count));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```"
		}
	],
	"id":"692",
	"title":"Number of Atoms",
	"content":"<p>Given a chemical <code>formula</code> (given as a string), return the count of each atom.\r\n</p><p>\r\nAn atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\r\n</p><p>\r\n1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.\r\n</p><p>\r\nTwo formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.  \r\n</p><p>\r\nA formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.\r\n</p><p>\r\nGiven a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nformula = \"H2O\"\r\n<b>Output:</b> \"H2O\"\r\n<b>Explanation:</b> \r\nThe count of elements are {'H': 2, 'O': 1}.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nformula = \"Mg(OH)2\"\r\n<b>Output:</b> \"H2MgO2\"\r\n<b>Explanation:</b> \r\nThe count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nformula = \"K4(ON(SO3)2)2\"\r\n<b>Output:</b> \"K4N2O14S4\"\r\n<b>Explanation:</b> \r\nThe count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>All atom names consist of lowercase letters, except for the first character which is uppercase.</li>\r\n<li>The length of <code>formula</code> will be in the range <code>[1, 1000]</code>.</li>\r\n<li><code>formula</code> will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.</li>\r\n</p>",
	"frequency":"146",
	"ac_num":"3390"
}