{
	"difficulty":"3",
	"submit_num":"9378",
	"show_id":"727",
	"leetcode_id":"727",
	"answers":[
		{
			"lc_ans_id":"109358",
			"view":"1622",
			"top":"0",
			"title":"C++, DP with explanation, O(ST) 53ms",
			"vote":"16",
			"content":"```\\nFor substring S[0, i] and T[0, j], \\ndp[i][j] is starting index k of the shortest postfix of S[0, i], such that T[0, j] is a subsequence of S[k, i]. \\nHere T[0] = S[k], T[j] = S[i]. Otherwise, dp[i][j] = -1.\\n\\nThe goal is the substring with length of min(i-dp[i][n-1]) for all i < m,  where m is S.size() and n is T.size() \\nInitial condition: dp[i][0] = i if S[i] = T[0], else -1\\nEquations: If S[i] = T[j], dp[i][j] = max(dp[k][j-1]) for all k < i; else dp[i][j] = -1;      \\n```\\nO(mn) space 82 ms\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string S, string T) {\\n        int m = S.size(), n = T.size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        for (int i = 0; i < m; i++) \\n            if (S[i] == T[0]) dp[0][i] = i;\\n        for (int j = 1; j < n; j++) {\\n            int k = -1;\\n            for (int i = 0; i < m; i++) {\\n                if (k != -1 && S[i] == T[j]) dp[j][i] = k;\\n                if (dp[j-1][i] != -1) k = dp[j-1][i];\\n            }\\n        }\\n        int st = -1, len = INT_MAX;\\n        for (int i = 0; i < m; i++) {\\n            if (dp[n-1][i] != -1 && i-dp[n-1][i]+1 < len) {\\n                st = dp[n-1][i];\\n                len = i-dp[n-1][i]+1;\\n            }    \\n        }\\n        return st == -1? \"\":S.substr(st, len);\\n    }\\n};\\n```\\nO(m) space 53 ms\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string S, string T) {\\n        int m = S.size(), n = T.size();\\n        vector<int> dp(m, -1);\\n        for (int i = 0; i < m; i++) \\n            if (S[i] == T[0]) dp[i] = i;\\n        for (int j = 1; j < n; j++) {\\n            int k = -1;\\n            vector<int> tmp(m, -1);\\n            for (int i = 0; i < m; i++) {\\n                if (k != -1 && S[i] == T[j]) tmp[i] = k;\\n                if (dp[i] != -1) k = dp[i];\\n            }\\n            swap(dp, tmp);\\n        }\\n        int st = -1, len = INT_MAX;\\n        for (int i = 0; i < m; i++) {\\n            if (dp[i] != -1 && i-dp[i]+1 < len) {\\n                st = dp[i];\\n                len = i-dp[i]+1;\\n            }    \\n        }\\n        return st == -1? \"\":S.substr(st, len);\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109347",
			"view":"398",
			"top":"1",
			"title":"C++ DP O(len(S)*len(T))",
			"vote":"4",
			"content":"```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        int ns = s.size(), nt= t.size();\\n        int dp[ns+1][nt+1] = {};\\n        const int mxx = ns + 1;\\n        for (int i = 0 ; i <= ns; ++i) {\\n            for (int j = 1; j <= nt; ++j) {\\n                dp[i][j] = mxx;\\n                if (i) {\\n                    dp[i][j] = min(dp[i][j], 1 + dp[i-1][j]);\\n                    if (s[i-1] == t[j-1]) dp[i][j]  = min(dp[i][j], 1 + dp[i-1][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int ans = ns + 1, x = -1;\\n        for (int i = 0; i <=ns; ++i) if (dp[i][nt] < ans) {\\n            x = i;\\n            ans = dp[i][nt];\\n        }\\n        \\n        if (x < 0) return \"\";\\n        return s.substr(x-ans,ans);\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109362",
			"view":"113",
			"top":"2",
			"title":"Java Super Easy DP Solution (O(mn))",
			"vote":"2",
			"content":"dp[i][j] stores the starting index of the substring where T has length i and S has length j.\\n\\nSo dp[i][j would be:\\nif T[i - 1] == S[j - 1], this means we could borrow the start index from dp[i - 1][j - 1] to make the current substring valid;\\nelse, we only need to borrow the start index from dp[i][j - 1] which could either exist or not.\\n\\nFinally, go through the last row to find the substring with min length and appears first.\\n```    \\npublic String minWindow(String S, String T) {\\n    int m = T.length(), n = S.length();\\n    int[][] dp = new int[m + 1][n + 1];\\n    for (int j = 0; j <= n; j++) {\\n        dp[0][j] = j + 1;\\n    }\\n    for (int i = 1; i <= m; i++) {\\n        for (int j = 1; j <= n; j++) {\\n            if (T.charAt(i - 1) == S.charAt(j - 1)) {\\n                dp[i][j] = dp[i - 1][j - 1];\\n            } else {\\n                dp[i][j] = dp[i][j - 1];\\n            }\\n        }\\n    }\\n\\n    int start = 0, len = n + 1;\\n    for (int j = 1; j <= n; j++) {\\n        if (dp[m][j] != 0) {\\n            if (j - dp[m][j] + 1 < len) {\\n                start = dp[m][j] - 1;\\n                len = j - dp[m][j] + 1;\\n            }\\n        }\\n    }\\n    return len == n + 1 ? \"\" : S.substring(start, start + len);\\n}\\n```"
		},
		{
			"lc_ans_id":"109355",
			"view":"189",
			"top":"3",
			"title":"C++, AC, 16ms, O(1) space, not DP",
			"vote":"2",
			"content":"I thought my solution might be wrong, or at least TLE. I was a little surprised when it was accepted. I am thinking whether someone can design a case that makes this solution failed/TLE or give some complexity analysis.\\n\\nThe idea is very straightforward:\\n1. search `T` starting at `S[p1]` forwardly, and suppose it ends at `S[p2]`;\\n2. search `T` starting at `S[p2]` backwardly, and suppose it ends at `S[p3]`;\\n3. `S[p3:p2]` is then a possible answer;\\n4. record the shortest answer and go to step 1 with `p1 = p3 + 1`.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string S, string T) {\\n    string out;\\n    size_t p1 = 0;\\n\\n    while (p1 + T.size() < S.size()) {\\n        size_t p2 = p1;\\n        bool isEnd = false;\\n        // forward search\\n        for (size_t i = 0; i < T.size(); i++) {\\n            while (S[p2] != T[i] && p2 < S.size()) {\\n                p2++;\\n            }\\n            if (p2 == S.size()) {\\n                isEnd = true;\\n                break;\\n            }\\n            p2++;\\n        }\\n        if (isEnd)\\n            break;\\n        size_t p3 = --p2;\\n        // backward search\\n        for (int i = T.size() - 1; i >= 0; i--) {\\n            while (S[p3] != T[i]) {\\n                p3--;\\n            }\\n            p3--;\\n        }\\n        p3++;\\n        // record the shortest answer\\n        if (out.empty())\\n            out = S.substr(p3, p2 - p3 + 1);\\n        else\\n            out = out.size() > (p2 - p3 + 1) ? S.substr(p3, p2 - p3 + 1) : out;\\n\\n        p1 = p3 + 1;\\n    }\\n\\n    return out;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109354",
			"view":"328",
			"top":"4",
			"title":"Python, O(m) space complexity, almost O(n) time complexity",
			"vote":"2",
			"content":"Very brief explannation : m = len(T), n = len(S), scan string S and maintain a up to date list of start index of matching T in list dp(size of m), dp[i] denotes the start index when i+1 chars of T are matched. When T[i] appears in S, we simply update dp[i] = dp[i-1], when T[0] appears in S with index, we update dp[0] = index. Whenever dp[m-1] is updated, we have a new window that T is sub-sequence of, and we keep a running minimum of this window width\\n\\nWe scan S once, and each update depends the number of same char in T. The worst case is O(mn) when all position of T are identical. When the char in T doesn't have much repetition, O(n) time complexity is achieved.\\n\\nSpace complexity O(m)\\n```python\\nclass Solution(object):\\n    def minWindow(self, S, T):\\n        \"\"\"\\n        :type S: str\\n        :type T: str\\n        :rtype: str\\n        \"\"\"\\n        n = len(S)\\n        m = len(T)\\n        \\n        dic = dict()\\n        for i, s in enumerate(T):\\n            dic.setdefault(s, []).append(i)\\n            \\n        dp = [-1 for i in xrange(m)]\\n        \\n        count = n+1\\n        start = -1\\n        \\n        for index, c in enumerate(S):\\n            if c in dic:\\n                for i in dic[c][::-1]:\\n                    if i == 0:\\n                        dp[i] = index\\n                    else:\\n                        dp[i] = dp[i-1]\\n                    if i == m-1 and dp[i] >= 0 and index - dp[i]+1 < count:\\n                        count = index - dp[i] + 1\\n                        start = dp[i]\\n        if dp[-1] < 0:\\n            return \"\"\\n        return S[start:start+count]\\n```"
		},
		{
			"lc_ans_id":"109348",
			"view":"1248",
			"top":"5",
			"title":"Java solution, sliding window",
			"vote":"2",
			"content":"```\\nclass Solution {\\n    public String minWindow(String S, String T) {\\n        String output = \"\";\\n        int minLen = 20001;\\n        for (int i = 0; i <= S.length() - T.length(); i++) {\\n        \\twhile (i < S.length() && S.charAt(i) != T.charAt(0)) {\\n        \\t\\ti++;\\n        \\t}\\n        \\tint l = find(S.substring(i, Math.min(i + minLen, S.length())), T);\\n        \\tif (l != -1 && l < minLen) {\\n        \\t\\tminLen = l;\\n        \\t\\toutput = S.substring(i, i + l);\\n        \\t}\\n        }\\n        return output;\\n    }\\n\\t\\n\\tprivate int find(String S, String T) {\\n\\t\\tfor (int i = 0, j = 0; i < S.length() && j < T.length();) {\\n\\t\\t\\tif (S.charAt(i) == T.charAt(j)) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t\\tif (j == T.length()) {\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n}\\n```"
		},
		{
			"lc_ans_id":"109351",
			"view":"45",
			"top":"6",
			"title":"Python solution using stack O(nm) I guess",
			"vote":"1",
			"content":"I use similar idea with the longest increasing sequence in array.\\n\\n```\\n        index = []\\n        point = []\\n        l = len(T)\\n        if l == 1:\\n            for i in S:\\n                if i == T:\\n                    return T\\n            return ''\\n        length = 2**31\\n        ans = ''\\n        for i in xrange (len(S)):\\n            c = S[i]\\n            new_point = []\\n            new_index = []\\n            for j in xrange (len(point)):\\n                if T[point[j]] == c:\\n                    tmp = point[j] + 1\\n                    if tmp == len(T):\\n                        if length > i - index[j]+1:\\n                            length = i - index[j]+1\\n                            ans = S[index[j]:i+1]\\n                    else:\\n                        if new_point and tmp >= new_point[-1]:\\n                            new_point.pop()\\n                            new_index.pop()\\n                        new_point.append(tmp)\\n                        new_index.append(index[j])\\n                        \\n                else:\\n                    new_point.append(point[j])\\n                    new_index.append(index[j])\\n            point = new_point\\n            index = new_index\\n                \\n            if c == T[0]:\\n                while point and point[-1] == 1:\\n                    point.pop()\\n                    index.pop()\\n                index.append(i)\\n                point.append(1)\\n        return ans\\n```\\nAsk me if you don't understand or correct me if i am wrong.\\n\\nThank you!"
		},
		{
			"lc_ans_id":"109373",
			"view":"55",
			"top":"7",
			"title":"m-pointer technique -- Java O(S.length() * T.length()) solution",
			"vote":"1",
			"content":"Let `n = S.length()`, `m = T.length()`. We maintain an integer array `p` of length `m` serving as pointers which link each character in `T` to its counterpart in `S`. If `p` satisfies the following conditions:\\n\\n1. `p[j]` is a valid index into string `S`: `0 <= p[j] < n` for any `j` with `0 <= j < m`;\\n\\n2. There is a one-to-one character mapping from `T` to `S`: `T[j] == S[p[j]]` for any `j` with `0 <= j < m`;\\n \\n3. `p` is sorted in strictly ascending order: `p[j-1] < p[j]` for any `j` with `1 <= j < m`;\\n\\nthen the string `T` will be a subsequence of the substring `S[p[0], p[m-1]]`. \\n\\nFor your convenience, here is an visualization of the `p` array. I'm only showing the indices of the characters in the `T` and `S` strings. The link, for example, from `T[0]` to `S[1]` means the character at `T[0]` is the same as the character at `S[1]`, and we denote this link as `p[0]=1`. Similar for other links. All these links together (that is, the `p` array) form a mapping from the `T` string to a substring of the `S` string such that the former is a subsequence of the latter.\\n\\n```\\nT:     0,    1,    2,  ...,  m-1\\n       |     |     |   ...    |\\nS:  0, 1, 2, 3, 4, 5,  ...,  n-2, n-1\\n\\np: p[0]=1, p[1]=3, p[2]=5, ..., p[m-1]=n-2\\n```\\n\\nPotentially there could exist many mappings from `T` to `S`, so we cannot afford to check each of them one by one. Fortunately we can divide all these mappings into different groups according to the value of `p[0]`, i.e., the link for the first character `T[0]`. For all the mappings within each group (that is, all these mappings have the same value of `p[0]`), we only need to examine one particular mapping obtained by the following greedy algorithm: for `j = 1, 2, ..., m-1`, we always choose the **smallest** `p[j]` that meets condition `2` yet does not violate conditions `1` and `3`. The proof is as follows.\\n\\nSuppose the mapping produced by the greedy algorithm is `p`, and we have another mapping `p'` in the same group as `p`, that is, `p[0] == p'[0]`. Immediately we can conclude `p[1] <= p'[1]`. This is because both the characters in `S` at indices `p[1]` and `p'[1]` are equal to `T[1]`, but our greedy algorithm will always pick the one with smallest index. This in turn will imply `p[2] <= p'[2]` for the same reason. If we continue in this fashion, we arrive at `p[m-1] <= p'[m-1]`. Note that the length of the substrings corresponding to the two mappings are given by `p[m-1] - p[0] + 1` and `p'[m-1] - p'[0] + 1`, respectively, then the length of the former will always be no greater than the latter. Therefore the mapping produced by the greedy algorithm will always yield the minimum substring within that particular group.\\n\\nAgain, for your reference, here is an visualization for the above greedy algorithm using the example given in the problem description: \\n\\n```\\nT:   b  d  e\\nidx: 0  1  2\\n\\nS:   a  b  c  d  e  b  d  d  e\\nidx: 0  1  2  3  4  5  6  7  8\\n\\n\\nGroup 1: p[0] = 1, corresponding to link T[0] --> S[1]\\n\\nPossible mappings: [1,3,4], [1,3,8], [1,6,8], [1,7,8]\\n\\nGreedy mapping: [1,3,4]\\n\\n\\nGroup 2: p[0] = 5, corresponding to link T[0] --> S[5]\\n\\nPossible mappings: [5,6,8], [5,7,8]\\n\\nGreedy mapping: [5,6,8]\\n```\\n\\nThe above analyses suggest we only need to compute the greedy mapping for each group, and select the one that yields the minimum substring length out of all groups. Using the above example, we only need to compute the greedy mapping `[1,3,4]` for **group 1** and the greedy mapping `[5,6,8]` for **group 2** and ignore all other mappings, then select the one with minimum substring. In this case, the two substrings have the same length so the tie will be broken by choosing the one with smaller starting index, i.e., `[1,3,4]`.\\n\\nSo here is how the algorithm goes. We loop through the `S` string to identify each group of mappings. Once we find one, the aforementioned greedy algorithm is applied to find the greedy mapping for the remaining `m-1` characters in `T`, starting from the second character `T[1]` towards the last character `T[m-1]`. If any link in the greedy mapping does not exist, then we conclude no mappings will be found for the current group and any subsequent groups, so we return the current minimum substring if it exists or empty string otherwise. Else we update the start and end indices (denoted as `l` and `r`) of the result substring if the above greedy mapping yields a smaller substring. \\n\\nTheoretically we don't even need to explicitly record the links for each characters in the `T` string (i.e., no need of the `p` array), like the following solution:\\n\\n```\\npublic String minWindow(String S, String T) {\\n    int n = S.length(), m = T.length();\\n    int l = 0, r = n;\\n        \\n    for (int i = 0; i < n; i++) {\\n        if (S.charAt(i) != T.charAt(0)) continue;  // No group of mapping is found, so continue\\n        \\n        int k = i + 1;\\n        \\t\\n        for (int j = 1; j < m; j++, k++) {  // Greedy algorithm to find the greedy mapping\\n            while (k < n && S.charAt(k) != T.charAt(j)) k++;\\n            if (k == n) return (r == n ? \"\" : S.substring(l, r + 1));  // Link for T[j] does not exist, so return\\n        }\\n        \\n        if (k - 1 - i < r - l) {  // Update the result substring if one with a smaller length is found\\n            l = i; r = k - 1;\\n        }\\n    }\\n    \\n    return (r == n ? \"\" : S.substring(l, r + 1));\\n}\\n```\\n\\nHowever, with the `p` array, early termination is possible, because links in the greedy mapping for previous groups may overlap with those for later groups, so we don't have to recompute them, which improves the efficiency of the algorithm by a lot. Here is a concrete example: `T = \"ab\"`, `S = \"aaab\"`. We have three groups with `p[0]` given by `0`, `1`, `2`, respectively. The greedy mapping for these three groups are `[0,3]`, `[1,3]` and `[2,3]`, respectively. The above solution recomputes the link for `T[1] = 'b'` over and over again for each group, which leads to degraded time performance. Here is the more efficient version of the above solution:\\n\\n```\\npublic String minWindow(String S, String T) {\\n    int n = S.length(), m = T.length();\\n    int l = 0, r = n;\\n    \\n    int[] p = new int[m];\\n        \\n    for (int i = 0; i < n; i++) {\\n        if (S.charAt(i) != T.charAt(0)) continue;  // No group of mapping is found, so continue\\n        \\n        p[0] = i;  // Group of mapping is found, so update the first link\\n        \\n        for (int j = 1, k = i + 1; j < m; j++, k++) {  // Greedy algorithm to find the greedy mapping\\n            if (k <= p[j]) break;    // Early termination, since the remaining links have been computed in previous groups\\n            while (k < n && S.charAt(k) != T.charAt(j)) k++;\\n            if (k == n) return (r == n ? \"\" : S.substring(l, r + 1));  // Link for T[j] does not exist, so return\\n            p[j] = k;  // Else update the link for T[j]\\n        }\\n            \\n        if (p[m - 1] - p[0] < r - l) {  // Update the result substring if one with a smaller length is found\\n            l = p[0]; r = p[m - 1];\\n        }\\n    }\\n        \\n    return (r == n ? \"\" : S.substring(l, r + 1));\\n}\\n```\\n\\nThe space complexity for this optimized solution is `O(m)` but the time complexity is a little bit tricky. We have three-nested loops, so the nominal time complexity is `O(m * n^2)`. However, due to the early termination, the actual time complexity is `O(m * n)`, where the worst scenario occurs when both `S` and `T` are repeating characters (the outermost loop will iterate `n` times while the middle loop will iterate `m` times, with the innermost loop degenerating to single operation). There is an alternative perspective to derive the time complexity, that is, for each character in the `S` string, it will be matched at most `m` times to those in the `T` string, therefore the time complexity will be `O(m * n) = O(S.length() * T.length()).` In contrast, the previous solution without the `p` array uses `O(1)` space but the worst case time complexity is `O(m * n^2)` as it will recompute the links for trailing characters in the `T` string over and over again."
		},
		{
			"lc_ans_id":"109374",
			"view":"220",
			"top":"8",
			"title":"share Java DP solution!",
			"vote":"1",
			"content":"```\\nclass Solution {\\n    public String minWindow(String S, String T) {\\n        if(T.length()>S.length()){\\n            return \"\";\\n        }\\n        int[][] dp = new int[T.length()][S.length()];\\n        for(int i=0;i<dp.length;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        for(int i=0;i<S.length();i++){\\n            if(S.charAt(i)==T.charAt(0)){\\n                dp[0][i] = i;\\n            }else if(i>0){\\n                dp[0][i] = dp[0][i-1];\\n            }\\n        }\\n        \\n        for(int i=1;i<T.length();i++){\\n            for(int j=i;j<S.length();j++){\\n                if(T.charAt(i)==S.charAt(j)){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = dp[i][j-1];\\n                }\\n            }\\n        }\\n        int min_len = Integer.MAX_VALUE;\\n        int min_index = -1;\\n        for(int i=0;i<S.length();i++){\\n            if(T.charAt(T.length()-1)==S.charAt(i) && dp[T.length()-1][i]!=-1){\\n                int start_index = dp[T.length()-1][i];\\n                if(i-start_index+1<min_len){\\n                    min_len = i-start_index+1;\\n                    min_index = start_index;\\n                }\\n            }\\n        }\\n        \\n        if(min_index==-1){\\n            return \"\";\\n        }\\n        \\n        return S.substring(min_index,min_index+min_len);\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"109385",
			"view":"269",
			"top":"9",
			"title":"Share my C++ O(ST) solution(not DP)",
			"vote":"1",
			"content":"```\\nclass Solution {\\npublic:\\n    string minWindow(string S, string T)\\n    {\\n        int lenS = S.size();\\n        int lenT = T.size();\\n        vector<vector<int>> record(lenT, vector<int>());\\n        for (int i = 0; i < lenS; ++i)\\n            for (int j = 0; j < lenT; ++j)\\n                if (S[i] == T[j])\\n                    record[j].push_back(i);\\n        vector<int> pos(lenT, 0);\\n        int minlen = INT_MAX;\\n        string ans;\\n        for (int i = 0; i < record[0].size(); ++i)\\n        {\\n            pos[0] = i;\\n            for (int j = 1; j < lenT; ++j)\\n            {\\n                while (pos[j] < record[j].size() && record[j][pos[j]] <= record[j - 1][pos[j - 1]])\\n                    ++pos[j];\\n                if (pos[j] == record[j].size())\\n                    return ans;\\n            }\\n            int temp = record[lenT - 1][pos[lenT - 1]] - record[0][pos[0]] + 1;\\n            if (i == 0)\\n            {\\n                minlen = temp;\\n                ans = S.substr(record[0][0], minlen);\\n            }\\n            else\\n            {\\n                if (temp < minlen)\\n                {\\n                    minlen = temp;\\n                    ans = S.substr(record[0][pos[0]], minlen);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
		}
	],
	"id":"693",
	"title":"Minimum Window Subsequence",
	"content":"<p>Given strings <code>S</code> and <code>T</code>, find the minimum (contiguous) <b>substring</b> <code>W</code> of <code>S</code>, so that <code>T</code> is a <b>subsequence</b> of <code>W</code>.\r\n</p><p>\r\nIf there is no such window in <code>S</code> that covers all characters in <code>T</code>, return the empty string <code>\"\"</code>.  If there are multiple such minimum-length windows, return the one with the left-most starting index.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nS = \"abcdebdde\", T = \"bde\"\r\n<b>Output:</b> \"bcde\"\r\n<b>Explanation:</b> \r\n\"bcde\" is the answer because it occurs before \"bdde\" which has the same length.\r\n\"deb\" is not a smaller window because the elements of T in the window must occur in order.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>All the strings in the input will only contain lowercase letters.</li>\r\n<li>The length of <code>S</code> will be in the range <code>[1, 20000]</code>.</li>\r\n<li>The length of <code>T</code> will be in the range <code>[1, 100]</code>.</li>\r\n</p>",
	"frequency":"11",
	"ac_num":"2930"
}