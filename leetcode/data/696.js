{
	"difficulty":"3",
	"submit_num":"5339",
	"show_id":"730",
	"leetcode_id":"730",
	"answers":[
		{
			"lc_ans_id":"109509",
			"view":"2382",
			"top":"0",
			"title":"Accepted Java Solution using memoization",
			"vote":"13",
			"content":"```\\nclass Solution {\\n    int div=1000000007;\\n    public int countPalindromicSubsequences(String S) {    \\n        TreeSet[] characters = new TreeSet[26];\\n        int len = S.length();\\n        \\n        for (int i = 0; i < 26; i++) characters[i] = new TreeSet<Integer>();\\n        \\n        for (int i = 0; i < len; ++i) {\\n            int c = S.charAt(i) - 'a';\\n            characters[c].add(i);\\n        }\\n        Integer[][] dp = new Integer[len+1][len+1];\\n         return memo(S,characters,dp, 0, len);\\n    }\\n    \\n    public int memo(String S,TreeSet<Integer>[] characters,Integer[][] dp,int start,int end){\\n        if (start >= end) return 0;\\n        if(dp[start][end]!=null) return dp[start][end];\\n       \\n            long ans = 0;\\n            \\n            for(int i = 0; i < 26; i++) {\\n                Integer new_start = characters[i].ceiling(start);\\n                Integer new_end = characters[i].lower(end);\\n              if (new_start == null || new_start >= end) continue;\\n                 ans++;\\n                if (new_start != new_end) ans++;\\n                ans+= memo(S,characters,dp,new_start+1,new_end);\\n                \\n            }\\n            dp[start][end] = (int)(ans%div);\\n            return dp[start][end];\\n    }\\n    \\n}\\n```"
		},
		{
			"lc_ans_id":"109508",
			"view":"2070",
			"top":"1",
			"title":"N^2 DP Python with Explanation",
			"vote":"10",
			"content":"Let `dp(i, j)` be the answer for the string `T = S[i:j+1]` including the empty sequence.  The answer is the number of unique characters in `T`, plus `dp(next('a', i) + 1, prev('a', j) - 1)` representing palindromes of the form `\"a_a\"` where _ is zero or more characters, plus `dp(next('b', i) + 1, prev('b', j) - 1)` representing `\"b_b\"`, etc.\\n\\nHere, `next('a', i)` means the next index at or after `i` where `A[next('a', i)] = 'a'`, and so on.\\n \\n```python\\nclass Solution(object):\\n    def countPalindromicSubsequences(self, S):\\n        N = len(S)\\n        A = [ord(c) - ord('a') for c in S]\\n        prv = [None] * N\\n        nxt = [None] * N\\n    \\n        last = [None] * 4\\n        for i in xrange(N):\\n            last[A[i]] = i\\n            prv[i] = tuple(last)\\n            \\n        last = [None] * 4\\n        for i in xrange(N-1, -1, -1):\\n            last[A[i]] = i\\n            nxt[i] = tuple(last)\\n        \\n        MOD = 10**9 + 7\\n        memo = [[None] * N for _ in xrange(N)]\\n        def dp(i, j):\\n            if memo[i][j] is not None:\\n                return memo[i][j]\\n            ans = 1 # The empty-string palindrome\\n            if i <= j:\\n                for x in xrange(4): # For letter a, b, c, d ...\\n                    i0 = nxt[i][x]\\n                    j0 = prv[j][x]\\n                    if i <= i0 <= j:\\n                        ans += 1 # The letter x exists in [i, j]\\n                    if None < i0 < j0:\\n                        ans += dp(i0+1, j0-1) # Counting palindromes \"x_x\"\\n            ans %= MOD\\n            memo[i][j] = ans\\n            return ans\\n        \\n        return dp(0, N-1) - 1 #Subtract empty string\\n```"
		},
		{
			"lc_ans_id":"109514",
			"view":"1532",
			"top":"2",
			"title":"C++ O(N^2) time, O(N) memory with explanation",
			"vote":"9",
			"content":"Let dp[len][i][x] be the number of distinct palindromes of the subtring starting at i of length len, where the first (and last) character is x. The DP formula is simple :\\n- If s[i] != x, then dp[len][i][x] = dp[len-1][i+1][x] (ignoring the first character in this window)\\n- If s[i+len-1] != x then dp[len][i][x] = dp[len-1][i][x] (ignoring the last character in this window)\\n- If both the first and last characters are x, then we need to count the number of distinct palindromes in the sub-window from i+1 to i + len -2. Need to be careful with how we count empty string.\\nSince we only need to subproblems of length len-1, len-2, we only need to remember the solutions for the subproblems of length len, len-1, len-2. This is needed to pass the max test case.\\n\\n```\\nclass Solution {\\npublic:\\n    int countPalindromicSubsequences(string s) {\\n        int md = 1000000007;\\n        int n = s.size();\\n        int dp[3][n][4];\\n        for (int len = 1; len <=n; ++len) {\\n            for (int i = 0; i + len <=n; ++i) for (int x = 0; x < 4; ++x)  {\\n                int &ans = dp[2][i][x];\\n                ans = 0;\\n                int j = i + len - 1;\\n                char c = 'a' + x;\\n                if (len == 1) ans = s[i] == c;\\n                else {\\n                    if (s[i] != c) ans = dp[1][i+1][x];\\n                    else if (s[j] != c) ans = dp[1][i][x];\\n                    else {\\n                        ans = 2;\\n                        if (len > 2) for (int y = 0; y < 4;++y) {\\n                            ans += dp[0][i+1][y];\\n                            ans %=md;\\n                        }\\n                    }\\n                }\\n            }\\n            for (int i=0;i<2;++i) for (int j = 0; j < n; ++j) for (int x=0; x < 4;++x)\\n                dp[i][j][x] = dp[i+1][j][x];\\n        }\\n        int ret = 0;\\n        for (int x = 0; x < 4;++x) ret = (ret + dp[2][0][x]) %md;\\n        return ret;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109507",
			"view":"1012",
			"top":"3",
			"title":"Java 96ms DP Solution with Detailed Explanation",
			"vote":"8",
			"content":"I am not able to pass this question one time but struggle a lot in the basic test cases like \"a\", \"aa\", \"aaa\", \"aba\", \"aabb\". Those test cases help my early rough idea to be flawless. The basic idea of DP is easy to understand, I maintain DP[i][j] to record in substring from i to j(included), the number of palindrome without duplicate. Then we consider two cases of the DP equation:\\n\\nwhen s.charAt(i) != s.charAt(j):\\n    dp[i][j] =  dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1];\\n\\nWhen s.charAt(i) == s.charAt(j):\\n    **the situation get much more complex and I fix a lot the wrong answers. I have comment the branches where which kind of test cases are considered.**\\n\\n```\\nclass Solution {\\n    public int countPalindromicSubsequences(String s) {\\n        int len = s.length();\\n        int[][] dp = new int[len][len];\\n\\n        char[] chs = s.toCharArray();\\n        for(int i = 0; i < len; i++){\\n            dp[i][i] = 1;   // Consider the test case \"a\", \"b\" \"c\"...\\n        }\\n\\n        for(int distance = 1; distance < len; distance++){\\n            for(int i = 0; i < len - distance; i++){\\n                int j = i + distance;\\n                if(chs[i] == chs[j]){\\n                    int low = i + 1;\\n                    int high = j - 1;\\n\\n              /* Variable low and high here are used to get rid of the duplicate*/\\n\\n                    while(low <= high && chs[low] != chs[j]){\\n                        low++;\\n                    }\\n                    while(low <= high && chs[high] != chs[j]){\\n                        high--;\\n                    }\\n                    if(low > high){\\n                        // consider the string from i to j is \"a...a\" \"a...a\"... where there is no character 'a' inside the leftmost and rightmost 'a'\\n                       /* eg:  \"aba\" while i = 0 and j = 2:  dp[1][1] = 1 records the palindrome{\"b\"}, \\n                         the reason why dp[i + 1][j  - 1] * 2 counted is that we count dp[i + 1][j - 1] one time as {\"b\"}, \\n                         and additional time as {\"aba\"}. The reason why 2 counted is that we also count {\"a\", \"aa\"}. \\n                         So totally dp[i][j] record the palindrome: {\"a\", \"b\", \"aa\", \"aba\"}. \\n                         */ \\n\\n                        dp[i][j] = dp[i + 1][j - 1] * 2 + 2;  \\n                    } \\n                    else if(low == high){\\n                        // consider the string from i to j is \"a...a...a\" where there is only one character 'a' inside the leftmost and rightmost 'a'\\n                       /* eg:  \"aaa\" while i = 0 and j = 2: the dp[i + 1][j - 1] records the palindrome {\"a\"}.  \\n                         the reason why dp[i + 1][j  - 1] * 2 counted is that we count dp[i + 1][j - 1] one time as {\"a\"}, \\n                         and additional time as {\"aaa\"}. the reason why 1 counted is that \\n                         we also count {\"aa\"} that the first 'a' come from index i and the second come from index j. So totally dp[i][j] records {\"a\", \"aa\", \"aaa\"}\\n                        */\\n                        dp[i][j] = dp[i + 1][j - 1] * 2 + 1;  \\n                    }\\n                    else{\\n                        // consider the string from i to j is \"a...a...a... a\" where there are at least two character 'a' close to leftmost and rightmost 'a'\\n                       /* eg: \"aacaa\" while i = 0 and j = 4: the dp[i + 1][j - 1] records the palindrome {\"a\",  \"c\", \"aa\", \"aca\"}. \\n                          the reason why dp[i + 1][j  - 1] * 2 counted is that we count dp[i + 1][j - 1] one time as {\"a\",  \"c\", \"aa\", \"aca\"}, \\n                          and additional time as {\"aaa\",  \"aca\", \"aaaa\", \"aacaa\"}.  Now there is duplicate :  {\"aca\"}, \\n                          which is removed by deduce dp[low + 1][high - 1]. So totally dp[i][j] record {\"a\",  \"c\", \"aa\", \"aca\", \"aaa\", \"aaaa\", \"aacaa\"}\\n                          */\\n                        dp[i][j] = dp[i + 1][j - 1] * 2 - dp[low + 1][high - 1]; \\n                    }\\n                }\\n                else{\\n                    dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1];  //s.charAt(i) != s.charAt(j)\\n                }\\n                dp[i][j] = dp[i][j] < 0 ? dp[i][j] + 1000000007 : dp[i][j] % 1000000007;\\n            }\\n        }\\n\\n        return dp[0][len - 1];\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"109515",
			"view":"879",
			"top":"4",
			"title":"Same Question asked on Cs Academy",
			"vote":"4",
			"content":"[Same Question](https://csacademy.com/contest/round-57/task/distinct-palindromes/) Cs Academy contest"
		},
		{
			"lc_ans_id":"109510",
			"view":"160",
			"top":"5",
			"title":"Python DP+DFS O(n^2) with Explanations",
			"vote":"3",
			"content":"I started out with only the DFS part, got TLE, then designed the DP part `cache` and passed.\\n\\nThe computations are done in `DFS(start, end)` in which I computed the answer for the string `S[start, end]`. `cache` is only to save the results of the computations in order to avoid repetitions.\\n\\nIn `DFS(start, end)`, for instance, for the letter `'a'`, I compute the number of palindromes that start and end with `'a'` in the following way:\\n\\nFirst of all, I compute when `'a'` appears first (index `i`) and last (index `j`) in the segment I am considering. Then it breaks down into two cases:\\n\\n1) If `i` == `j`. There is only one `'a'` in the segment. So the answer is 1.\\n2) If `i` !=  `j`. The possible palindromes are `'a'`, `'aa'`, and `'a*a'` where `'*'` stands for any palindromes contained in `S[i+1:j]`. The answer would be `DFS(i+1,j) + 2`. Since I want to avoid repetitive computation, I write `cache(i+1,j) + 2` instead.\\n\\nThe worst case time complexity is O(n^2). The best case time complexity is O(n).\\n\\nBtw, to make this algorithm even faster, one could set `check` to be a 2D list instead of a dictionary, but that would occupy more space.\\n\\n```\\n    def countPalindromicSubsequences(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        def cache(start, end):            # This function serves to save the result\\n            if end <= start + 2:          # simple cases can be computed directly\\n                return end - start\\n            \\n            if (start, end) not in check: # if not saved, compute and save before returning\\n                check[(start, end)] = DFS(start, end)\\n                \\n            return check[(start, end)]\\n        \\n        def DFS(start, end):     #returns the number of distinct palindromes in S[start:end]\\n            count = 0\\n            segment = S[start:end]\\n            \\n            for x in 'abcd':\\n                try:\\n                    i = segment.index(x) + start  # the starting index in S\\n                    j = segment.rindex(x) + start # the ending index in S\\n                except:\\n                    continue\\n                    \\n                count += cache(i+1, j) + 2 if i != j else 1\\n\\n            return count % 1000000007\\n                \\n        check = {}\\n        return cache(0, len(S))\\n```"
		},
		{
			"lc_ans_id":"109505",
			"view":"16",
			"top":"6",
			"title":"Is there any possibility to solve this problem using DFS??",
			"vote":"0",
			"content":"class Solution {\\n    Set<String> set = new HashSet<>();\\n\\n    public int countPalindromicSubsequences(final String S) {\\n        if(isValid(S)) set.add(S);\\n        dfs(S);\\n        return set.size();\\n    }\\n\\n    private void dfs(final String cur) {\\n        if(cur.length() == 0) return;\\n\\n        for(int i = 0; i < cur.length(); ++i) {\\n            String temp = cur.substring(0, i) + cur.substring(i + 1);\\n            if(isValid(temp)) {\\n                set.add(temp);\\n            }\\n            dfs(temp);\\n        }\\n    }\\n\\n    private boolean isValid(final String s) {\\n        if(s.length() == 0) return false;\\n        int left = 0;\\n        int right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right)) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n\\n\\nThis code got TLE by running test case: \"dbcbaaacdcbabcbddaac\""
		},
		{
			"lc_ans_id":"109511",
			"view":"81",
			"top":"7",
			"title":"12-liner O(N^2) time O(N) space clean DP with explanation",
			"vote":"0",
			"content":"We can count palindrome subsequences of `s` from its substrings.\\n\\nLet `cnt[L][i][c]` be the count of char `c` starting palindrome subsequences from string `s.substr(i,L)` (i.e., length `L` starting from index `i`), we have the DP equations:\\n* if `s[i] != c`, `cnt[L][i][c] = cnt[L-1][i+1][c]`;\\n* if `s[i+L-1] != c`, `cnt[L][i][c] = cnt[L-1][i][c]`;\\n* otherwise, `cnt[L][i][c] = 2 + cnt[L-2][i+1][c]`.\\n**NOTE:** the extra 2 palindrome subsequences in last case are single `c` and `c+c`.\\n\\nSince `cnt[L][i][c]` depends only on previous values of length `L-1` and `L-2`, we only need to allocate spaces for `cnt, cnt1, cnt2`.\\n\\n```cpp\\n    int countPalindromicSubsequences(string s) \\n    {\\n        int mod = 1000000007, n = s.size(), res = 0;\\n        vector<map<char,int>> cnt(n), cnt1(n), cnt2(n);\\n        \\n        for (int L = 1; L <= n; ++L, cnt2 = cnt1, cnt1 = cnt)\\n            for (int i = 0; i+L <= n; ++i)\\n                for (char c : \"abcd\")\\n                    if (L == 1) cnt[i][c] = (s[i] == c); // only 1 palindrome if char matches\\n                    else if (s[i]     != c) cnt[i][c] = cnt1[i+1][c];\\n                    else if (s[i+L-1] != c) cnt[i][c] = cnt1[i][c];\\n                    else {\\n                        cnt[i][c] = 2; // c and c+c\\n                        for (char cc : \"abcd\") (cnt[i][c] += cnt2[i+1][cc]) %= mod;\\n                    }                    \\n\\n        for (char c : \"abcd\") (res += cnt[0][c]) %= mod;\\n        return res;\\n    }\\n```"
		},
		{
			"lc_ans_id":"109513",
			"view":"126",
			"top":"8",
			"title":"Java N^2 138ms solution with explanation",
			"vote":"0",
			"content":"    public int countPalindromicSubsequences(String S) {\\n        int len = S.length();\\n        int[][] countFrom = new int[4][len+1];  // int[c][i]countFrom: count of char c in S[i:]\\n        int[][] firstFrom = new int[4][len+1];  // int[c][i]firstFrom: ix of first c from S[i:]\\n        for (int j=0; j<4; j++) {\\n            firstFrom[j][len] = -1;  // there is no char from S[len:], -1 mean cannot find\\n        }\\n        for (int i=len-1; i>=0; i--) {\\n            char c = S.charAt(i);\\n            for (int j=0; j<4; j++){\\n                if (c-'a'==j) {  // pos i == char j\\n                    firstFrom[j][i] = i;\\n                    countFrom[j][i] = countFrom[j][i+1] + 1;\\n                } else {\\n                    firstFrom[j][i] = firstFrom[j][i+1];\\n                    countFrom[j][i] = countFrom[j][i+1];\\n                }\\n            }\\n        }\\n        int[][] lastFrom = new int[4][len+1];  // ix of last c from S[:j], before S[j]\\n        for (int j=0; j<4; j++){\\n            lastFrom[j][0] = -1;  // there is no char before S[0];\\n        }\\n        for (int i=0; i<len; i++) {\\n            char c = S.charAt(i);\\n            for (int j=0; j<4; j++) {\\n                if (c-'a' == j) {  // found a char j at pos i\\n                    lastFrom[j][i+1] = i;  // the last char j before position i+1 is i\\n                } else {\\n                    lastFrom[j][i+1] = lastFrom[j][i];\\n                }\\n            }\\n        }\\n        int[][]dp = new int[len][len];  // dp[i][j] stores the answer of f(i,j)\\n        return f(S, 0, len-1, countFrom, firstFrom, lastFrom, dp);\\n    }\\n\\n    int f(String S, int i, int j, int[][] countFrom, int[][] firstFrom, int[][] lastFrom, int[][] dp) {\\n        /* f(i,j) is the num of palindromic subsquences in S[i: j+1], i is included, j+1 is excluded.\\n        if we know f(i, j-1) that is the answer for S[i:j], we need to add S[j] to the string.\\n        let countSj is count of S[j] in S[i:j+1].\\n        if countSj==1, S[j] is unique, f(i,j) = f(i,j-1)+1. \"1\" means the one-length palindrome S[j].\\n        if countSj==2, the String S[i:j+1] looks like S[i]...S[j1]...S[j], where S[j1]==S[j]. f(i,j) = f(i,j-1) + f(j1+1, j-1) + 1, where f(j1+1, j-1) is the all palindrome in S[j1+1: j], which can be expanded with S[j1] and S[j]. \"1\" means two times S[j].\\n        if countSj>2, the String S[i:j+1] looks like S[i]...S[j1]...***...S[j2]...S[j], where S[j1]==S[j2]==S[j]. S[j1] is the first element that equals to S[j] in S[i:j+1]. S[j2] is the last element that equals to S[j] in S[i:j]. f(i,j) = f(i,j-1) + f(j1+1, j-1) - f(j1+1, j2-1). f(j1+1, j-1) is all palindrome in S[j1+1: j], which can be expanded with S[j1] and S[j], but some of them like S[j1] + palindrome in S[j1+1:j2] + S[j2] are double counted. f(j1+1, j2-1) needs to be deducted.\\n        */\\n        if (i==j) return 1;\\n        if (i>j) return 0;\\n        if (dp[i][j] > 0) return dp[i][j];\\n        int MOD = 1000000007;\\n        char sj = S.charAt(j);\\n        int countSj =countFrom[sj-'a'][i] - countFrom[sj-'a'][j+1]; // count of Sj in S[i:j+1]\\n        int sum = 0;\\n        if (countSj==1) {\\n            // only 1 sj in S[i:j+1]\\n            sum = f(S, i, j-1, countFrom, firstFrom, lastFrom, dp) + 1;  // sj is uniq in S[i:j+1], 1 means one-length palindral\\n        } else if (countSj==2) {\\n            //  i ... j1 ... j\\n            // all of the palin in S[j1+1:j-1] can be extended with a sj, and form a new palin\\n            int j1 = firstFrom[sj-'a'][i];  // ix of first sj from i\\n            sum = f(S, i, j-1, countFrom, firstFrom, lastFrom, dp) + f(S, j1+1, j-1, countFrom, firstFrom, lastFrom, dp) + 1;\\n            // 1 means 2xsj\\n        } else {\\n            // i .X. j1 ... *Y* ... j2 .Z.j\\n            // j1_Y_j2 is part of j1_Y_Z_j\\n            int j1 = firstFrom[sj-'a'][i];  // ix of first sj from i\\n            int j2 = lastFrom[sj-'a'][j];  // last ix of sj before j\\n            sum = f(S,i, j-1, countFrom, firstFrom, lastFrom, dp) + f(S, j1+1, j-1, countFrom, firstFrom, lastFrom, dp)\\n                    - f(S, j1+1, j2-1, countFrom, firstFrom, lastFrom, dp);\\n        }\\n        if (sum<0) sum+=MOD;\\n        sum %= MOD;\\n        dp[i][j] = sum;\\n        return sum;\\n    }"
		},
		{
			"lc_ans_id":"109516",
			"view":"244",
			"top":"9",
			"title":"Question on custom testcase",
			"vote":"0",
			"content":"custom test case shows that \"ccbc\" will have 5 palindromic subsequences. But it has 6\\n\"c\", \"c\", \"b\", \"c\", \"cc\", \"cbc\"\\nOr I have not got the question correctly. Can anyone explain this?"
		}
	],
	"id":"696",
	"title":"Count Different Palindromic Subsequences",
	"content":"<p>\r\nGiven a string S, find the number of different non-empty palindromic subsequences in S, and <b>return that number modulo <code>10^9 + 7</code>.</b>\r\n</p><p>\r\nA subsequence of a string S is obtained by deleting 0 or more characters from S.\r\n</p><p>\r\nA sequence is palindromic if it is equal to the sequence reversed.\r\n</p><p>\r\nTwo sequences <code>A_1, A_2, ...</code> and <code>B_1, B_2, ...</code> are different if there is some <code>i</code> for which <code>A_i != B_i</code>.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nS = 'bccb'\r\n<b>Output:</b> 6\r\n<b>Explanation:</b> \r\nThe 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\r\nNote that 'bcb' is counted only once, even though it occurs twice.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nS = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'\r\n<b>Output:</b> 104860361\r\n<b>Explanation:</b> \r\nThere are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The length of <code>S</code> will be in the range <code>[1, 1000]</code>.</li>\r\n<li>Each character <code>S[i]</code> will be in the set <code>{'a', 'b', 'c', 'd'}</code>.</li>\r\n</p>",
	"frequency":"144",
	"ac_num":"1881"
}