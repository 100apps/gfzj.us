{
	"difficulty":"2",
	"submit_num":"11625",
	"show_id":"731",
	"leetcode_id":"731",
	"answers":[
		{
			"lc_ans_id":"109519",
			"view":"3150",
			"top":"0",
			"title":"[Java/C++] Clean Code with Explanation",
			"vote":"24",
			"content":"The big idea is pretty simple:\\nEach time of `book`, instead of `fail` a book when there is 1 or more `overlap` with existing books as in `MyCalendar I`, we just want to make sure these overlaps does not overlap - having `overlap` is now ok, but `overlapped` period cannot be `overlapped` again.\\nSo we just need to keep track of all the `overlaps` with any previous `books`\\n\\n`MyCalendar I` can be reused to track the `overlaps` during each book.\\n\\n**How to calculate overlap of 2 intervals**\\nAssume `a` start earlier than `b`, (if not reverse), there could be 3 case, but in any case, an overlap(either positive or negative) can always be represented as:\\n`` (max(a0, b0), min(a1, b1))``\\n```\\ncase 1: b ends before a ends:\\na: a0 |-------------| a1\\nb:     b0 |-----| b1\\n\\ncase 2: b ends after a ends:\\na: a0 |--------| a1\\nb:     b0 |--------| b1\\n\\ncase 3: b starts after a ends: (negative overlap)\\na: a0 |----| a1\\nb:              b0 |----| b1\\n```\\n\\n**Java**\\n```\\nclass MyCalendarTwo {\\n    private List<int[]> books = new ArrayList<>();    \\n    public boolean book(int s, int e) {\\n        MyCalendar overlaps = new MyCalendar();\\n        for (int[] b : books)\\n            if (Math.max(b[0], s) < Math.min(b[1], e)) // overlap exist\\n                if (!overlaps.book(Math.max(b[0], s), Math.min(b[1], e))) return false; // overlaps overlapped\\n        books.add(new int[]{ s, e });\\n        return true;\\n    }\\n\\n    private static class MyCalendar {\\n        List<int[]> books = new ArrayList<>();\\n        public boolean book(int start, int end) {\\n            for (int[] b : books)\\n                if (Math.max(b[0], start) < Math.min(b[1], end)) return false;\\n            books.add(new int[]{ start, end });\\n            return true;\\n        }\\n    }\\n}\\n```\\n**C++**\\n```\\nclass MyCalendar {\\n    vector<pair<int, int>> books;\\npublic:\\n    bool book(int start, int end) {\\n        for (pair<int, int> p : books)\\n            if (max(p.first, start) < min(end, p.second)) return false;\\n        books.push_back({start, end});\\n        return true;\\n    }\\n};\\n\\nclass MyCalendarTwo {\\n    vector<pair<int, int>> books;\\npublic:\\n    bool book(int start, int end) {\\n        MyCalendar overlaps;\\n        for (pair<int, int> p : books) {\\n            if (max(p.first, start) < min(end, p.second)) { // overlap exist\\n                pair<int, int> overlapped = getOverlap(p.first, p.second, start, end);\\n                if (!overlaps.book(overlapped.first, overlapped.second)) return false; // overlaps overlapped\\n            }\\n        }\\n        books.push_back({ start, end });\\n        return true;\\n    }\\n\\n    pair<int, int> getOverlap(int s0, int e0, int s1, int e1) {\\n        return { max(s0, s1), min(e0, e1)};\\n    }\\n};\\n```\\n\\n**Another way to calculate overlap of 2 intervals**\\n`a started with b`, or, `b started within a`:\\n```\\na:                     |---------|\\nb:\\na0<b0 & a1<b0:  |----|\\na0<b0 & a1>b0:  |------------| (a started within b)\\na0<b0 & a1>b1:  |-------------------| (a started within b)\\na0>b0 & a0<b1:            |----|  (b started within a)\\na0>b0 & a0>b1:            |---------| (b started within a)\\na0>b1 & a1>b1:                      |----|\\n\\n```"
		},
		{
			"lc_ans_id":"109530",
			"view":"862",
			"top":"1",
			"title":"N^2 Python, Short and Elegant",
			"vote":"12",
			"content":"We store an array `self.overlaps` of intervals that are double booked, and `self.calendar` for intervals which have been single booked.  We use the line `start < j and end > i` to check if the ranges `[start, end)` and `[i, j)` overlap.\\n\\nThe clever idea is we do not need to \"clean up\" ranges in `calendar`: if we have `[1, 3]` and `[2, 4]`, this will be `calendar = [[1,3],[2,4]]` and `overlaps = [[2,3]]`.  We don't need to spend time transforming the calendar to `calendar = [[1,4]]`.\\n\\nThis solution is by @zestypanda .\\n```python\\nclass MyCalendarTwo:\\n    def __init__(self):\\n        self.overlaps = []\\n        self.calendar = []\\n\\n    def book(self, start, end):\\n        for i, j in self.overlaps:\\n            if start < j and end > i:\\n                return False\\n        for i, j in self.calendar:\\n            if start < j and end > i:\\n                self.overlaps.append((max(start, i), min(end, j)))\\n        self.calendar.append((start, end))\\n        return True\\n```"
		},
		{
			"lc_ans_id":"109522",
			"view":"1054",
			"top":"2",
			"title":"Simplified winner's solution",
			"vote":"6",
			"content":"Contest winner @cchao's [solution](https://leetcode.com/contest/weekly-contest-59/ranking) simplified a bit. For each time point, store how the number of booked events changes. For each booking attempt, book it and undo the booking if it causes a triple booking (as determined by going through the time line, keeping track of the number of booked events).\\n```\\nclass MyCalendarTwo {\\npublic:\\n    map<int, int> delta;\\n\\n    bool book(int start, int end) {\\n        delta[start]++;\\n        delta[end]--;\\n        int booked = 0;\\n        for (auto &d : delta) {\\n            booked += d.second;\\n            if (booked == 3) {\\n                delta[start]--;\\n                delta[end]++;\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109521",
			"view":"1108",
			"top":"3",
			"title":"Java solution using MyCalendar",
			"vote":"6",
			"content":"```\\npublic class MyCalendarTwo {\\n\\n    private List<int[]> list = new ArrayList<>();\\n    \\n    public boolean book(int start, int end) {\\n        MyCalendar c = new MyCalendar();\\n        for (int[] i : list) {\\n            if (i[0] < start && i[1] > start) {\\n                if (!c.book(start, i[1])) {\\n                    return false;\\n                }\\n            } else if (i[0] >= start && i[0] < end) {\\n                if (!c.book(i[0], Math.min(i[1], end))) {\\n                    return false;\\n                }\\n            }\\n        }\\n        list.add(new int[] {start, end});\\n        return true;\\n    }\\n    \\n    private class MyCalendar {\\n\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n        \\n        public boolean book(int start, int end) {\\n            Integer i = tm.lowerKey(end);\\n            if (i != null && i >= start) {\\n                return false;\\n            }\\n            i = tm.lowerKey(start);\\n            if (i != null && tm.get(i) > start) {\\n                return false;\\n            }\\n            tm.put(start, end);\\n            return true;\\n        }\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"109550",
			"view":"136",
			"top":"4",
			"title":"Simple AC by TreeMap",
			"vote":"2",
			"content":"```\\nclass MyCalendarTwo {\\n\\n    private TreeMap<Integer, Integer> map;    \\n    \\n    public MyCalendarTwo() {\\n        map = new TreeMap<>();\\n    }\\n    \\n    public boolean book(int start, int end) {\\n        map.put(start, map.getOrDefault(start, 0) + 1);\\n        map.put(end, map.getOrDefault(end, 0) - 1);\\n        int count = 0;\\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            count += entry.getValue();\\n            if(count > 2) {\\n                map.put(start, map.get(start) - 1);\\n                if(map.get(start) == 0) {\\n                    map.remove(start);\\n                }\\n                map.put(end, map.get(end) + 1);\\n                if(map.get(end) == 0) {\\n                    map.remove(end);\\n                }\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"109555",
			"view":"662",
			"top":"5",
			"title":"Java solution, TreeMap + List",
			"vote":"2",
			"content":"```\\nclass MyCalendarTwo {\\n\\n    List<int[]> calendar;\\n\\n    public MyCalendarTwo() {\\n        calendar = new ArrayList<>();\\n    }\\n\\n    public boolean book(int start, int end) {\\n        TreeMap<Integer, Integer> overlaps = new TreeMap<>();\\n\\n        for (int[] interval : calendar) {\\n            int[] overlap = getOverlap(interval, start, end);\\n            if (overlap[0] >= 0) {\\n                if (hasOverlap(overlaps, overlap[0], overlap[1])) return false;\\n                overlaps.put(overlap[0], overlap[1]);\\n            }\\n        }\\n\\n        calendar.add(new int[] {start, end});\\n        return true;\\n    }\\n\\n    private int[] getOverlap(int[] interval, int start, int end) {\\n        int[] res = new int[] {-1, -1};\\n        if (start >= interval[1] || end <= interval[0]) return res;\\n        res[0] = Math.max(start, interval[0]);\\n        res[1] = Math.min(end, interval[1]);\\n        return res;\\n    }\\n\\n    private boolean hasOverlap(TreeMap<Integer, Integer> overlaps, int start, int end) {\\n        Integer floorKey = overlaps.floorKey(start);\\n        if (floorKey != null && overlaps.get(floorKey) > start) return true;\\n        Integer ceilingKey = overlaps.ceilingKey(start);\\n        if (ceilingKey != null && ceilingKey < end) return true;\\n        return false;\\n    }\\n\\n}\\n```"
		},
		{
			"lc_ans_id":"109536",
			"view":"163",
			"top":"6",
			"title":"65ms beats 95.69%, O(lgn+2n+2) map+binary search",
			"vote":"1",
			"content":"In [my calendar 1](https://discuss.leetcode.com/topic/111523/c-binary-search), an interval(start+end) is a pair<int,int>(start,end), I can sort pairs because there is no overlap which means the pre-pair.end<=next-pair.start. So binary search a whole pair can work.\\nIn this problem, pairs can have overlap with each other, so we don't need to make \"start+end\" a pair, because sort or binary search can't work.\\nBut I can split them, and take an interval as two independent points \"start\" and \"end\", then sort them and binary search them.\\n```\\nclass MyCalendarTwo{\\nprivate:\\n    map<int,int>intervals;\\n/**structure of intervals:\\neach pair in intervals:(k,v)\\nk is a point (start or end of an interval)\\nv is the number of overlaps between the point of k and the next point of k.\\nso v can be 0, 1, 2\\n**/\\n/**rules of \"can insert\" and \"can't insert\" for a new interval(s,e)\\nThe graph below:\\n  a point p in intervals which is not large than s or e\\n  o------o means a segment\\n  if s or e is above or below of p, means p==s or p==e\\n  if s or e is right of p, means p<s or p<e\\n  use \"k:v\" to represent each point\\n  x means s or e can't insert\\n  =>? means if p is in the interval of (s,e), the v of p will change into ?\\n\\n1:\\n                s:1    s:1\\no----------------o  \\n                p:0 => p:1\\n                e:0    e:0\\n2:\\n                s:1    s:1\\no----------------o\\no----------------o  \\n                p:0 => p:x\\n                e:x    e:x\\n3:\\n                s:2    s:2\\n                 o----------------o\\n                p:1 => p:2\\n                e:1    e:1\\n4:\\n                s:2    s:2\\n        o---------------------o\\n   o-------------o\\n                p:1 => p:x\\n                e:x    e:x\\n5:\\n                s:x    s:x\\n                 o----------------o\\n                 o----------------o\\n                p:2 => p:x\\n                e:2    e:x\\n6:\\n                s:x    s:x\\n          o----------------------o\\n                 o----------------o\\n                p:2 => p:x\\n                e:2    e:x\\n\\ndon't need to consider 2 and 4, so we only need to consider 1,3,5,6,and 5 is the same as 6, so there are only 3 states.\\n**/\\npublic:\\n    MyCalendarTwo() {}\\n    bool book(int start, int end){\\n        if(intervals.empty()){insert(start,end);return true;}\\n        auto it=intervals.lower_bound(start);\\n        if(it==intervals.end()){insert(start,end);return true;}\\n        int t1=0;//start:t1\\n        if(it->first!=start&&it!=intervals.begin()&&(t1=prev(it,1)->second)==2)return false; //check if start can be inserted\\n        int t2=t1;//start:t2\\n        auto it2=it;\\n        for(;it2!=intervals.end()&&it2->first<end;it2++){//check the points between start and end\\n            if(it2->second==2)return false;\\n        }\\n        for(it2=it;it2!=intervals.end()&&it2->first<end;it2++){//change the value of pionts\\n            t2=it2->second;it2->second++;\\n        }\\n        if(it2->first!=end)intervals.emplace_hint(it2,end,t2);//insert end\\n        if(it->first!=start)intervals.emplace_hint(it,start,t1+1);//insert start\\n        return true;\\n    }\\n    void insert(int start,int end){\\n        intervals.emplace_hint(intervals.end(),start,1);\\n        intervals.emplace_hint(intervals.end(),end,0);\\n    }\\n};\\n```\\ncomplex of program:\\nbinary search start: lgn\\ncheck each point: n\\nchange the value of each point:n\\ninsert start and end(because I have found the position of insert): <<lgn and close to O(1)\\nOn=O(lgn+2n+2)"
		},
		{
			"lc_ans_id":"109525",
			"view":"301",
			"top":"7",
			"title":"O(logn) solution in Java with explanation",
			"vote":"1",
			"content":"To achieve O(logn) average time per method call, we cannot go through every interval in \"book\". Inspired by problem \"253 Meeting Rooms II\", instead of storing every interval, we store the start/end time with number of bookings right after current time. For example, if we have interval [1, 3] and [2, 5], we store (time, bookings) in hashmap like this: (1, 1), (2, 2), (3, 1), (5, 0).\\n\\nWhen checking whether triple book, we need to first check the bookings of latest time on/before the \"start\" time (if any). Then go through all the times between \"start\" and \"end\" time. If there is any time that have booking >= 2, then there will be triple book if current interval is added.\\n\\nWhen adding a interval, we again add 1 to the bookings of all times in between current interval. Note that I always keep one timestamp if there is any overlap between start/end of different intervals.\\n\\nEach method call only go through the times between \"start\" and \"end\" time. So in average the time complexity is O(logn) per call, worst case O(n).\\n```\\nclass MyCalendarTwo {\\n    // Map from timestamp to number of bookings\\n    private Map<Integer, Integer> map;\\n    // Set of all timestamps, use TreeSet to add or get floor in O(logn) time\\n    private TreeSet<Integer> points;\\n    \\n    public MyCalendarTwo() {\\n        map = new HashMap<>();\\n        points = new TreeSet<>();\\n    }\\n    \\n    public boolean book(int start, int end) {\\n        int startBook = 1, endBook = 0;\\n        // Get the booking of previous point if exist\\n        if (points.floor(start) != null)\\n            startBook = map.get(points.floor(start)) + 1;\\n        if (startBook > 2) return false;\\n        // Check all bookings in between current interval\\n        for (int p : points.subSet(start, end)) {\\n            if (map.get(p) > 1) return false;\\n        }\\n        \\n        int lastBook = startBook;\\n        // Update all points in between\\n        for (int p : points.subSet(start, end)) {\\n            map.put(p, map.get(p) + 1);\\n            lastBook = map.get(p);\\n        }\\n        // If map already contains endTime, use existing booking\\n        // since current interval ended and does not contribute to this point.\\n        // If map does not contain endTime, add a new one\\n        endBook = points.contains(end) ? map.get(end) : lastBook - 1;\\n        // Update/add new start/end points\\n        points.add(start);\\n        points.add(end);\\n        map.put(start, startBook);\\n        map.put(end, endBook);\\n        return true;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"109518",
			"view":"12",
			"top":"8",
			"title":"[c++ solution] beats 91.92%",
			"vote":"0",
			"content":"MyCalendarTwo() {\\n\\n}\\nvector <pair<int, int>> theBooks;\\nbool book(int start, int end) {\\n\\tint mark = -1;\\n\\tint stage = 0; int theC = 0,theD=0;\\n\\tfor (int i = 0; i < theBooks.size(); i++)\\n\\t{\\n\\t\\tif (theBooks[i].first < start)\\n\\t\\t{\\n\\t\\t\\tif (theBooks[i].second > start)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (stage == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstage = 1; theC = theBooks[i].second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\tif (stage == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(mark==-1) mark = i;\\n\\t\\t\\tif (theBooks[i].first < end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (stage == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstage = 2; theC = theBooks[i].first; theD= theBooks[i].second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (stage == 2)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (theBooks[i].first >= theD)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\t\\t\\t\\ttheC = theBooks[i].first; theD = theBooks[i].second;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (stage == 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (theBooks[i].first < theC)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\t\\t\\t\\ttheC = theBooks[i].first; theD = theBooks[i].second;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ttheBooks.insert(theBooks.begin() + mark, pair<int, int>(start, end));\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (mark == -1)\\n\\t{\\n\\t\\ttheBooks.push_back(pair<int, int>(start, end));\\n\\t\\treturn true;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\ttheBooks.insert(theBooks.begin() + mark, pair<int, int>(start, end));\\n\\t\\treturn true;\\n\\t}\\n}\\n};"
		},
		{
			"lc_ans_id":"109520",
			"view":"18",
			"top":"9",
			"title":"Java O(n) time solution",
			"vote":"0",
			"content":"'''\\nclass MyCalendarTwo {\\n    \\n    List<int[]> books;\\n    List<int[]> overlaps;\\n    \\n    public MyCalendarTwo() {\\n        books = new ArrayList<>();\\n        overlaps = new ArrayList<>();\\n    }\\n    \\n    public boolean book(int start, int end) {\\n        for (int[] overlap : overlaps) {\\n            if (Math.max(overlap[0], start) < Math.min(overlap[1], end)) {\\n                return false;\\n            }\\n        }\\n        for (int[] book : books) {\\n            int overlapStart = Math.max(book[0], start);\\n            int overlapEnd = Math.min(book[1], end);\\n            if (overlapStart < overlapEnd) {\\n                overlaps.add(new int[]{overlapStart, overlapEnd});\\n            }\\n        }\\n        books.add(new int[]{start, end});\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your MyCalendarTwo object will be instantiated and called as such:\\n * MyCalendarTwo obj = new MyCalendarTwo();\\n * boolean param_1 = obj.book(start,end);\\n */"
		}
	],
	"id":"697",
	"title":"My Calendar II",
	"content":"<p>\r\nImplement a <code>MyCalendarTwo</code> class to store your events. A new event can be added if adding the event will not cause a <b>triple</b> booking.\r\n</p><p>\r\nYour class will have one method, <code>book(int start, int end)</code>.  Formally, this represents a booking on the half open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start <= x < end</code>.\r\n</p><p>\r\nA <i>triple booking</i> happens when <b>three</b> events have some non-empty intersection (ie., there is some time that is common to all 3 events.)\r\n</p><p>\r\nFor each call to the method <code>MyCalendar.book</code>, return <code>true</code> if the event can be added to the calendar successfully without causing a <b>triple</b> booking.  Otherwise, return <code>false</code> and do not add the event to the calendar.\r\n</p>\r\n\r\nYour class will be called like this:\r\n<code>MyCalendar cal = new MyCalendar();</code>\r\n<code>MyCalendar.book(start, end)</code>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\nMyCalendar();\r\nMyCalendar.book(10, 20); // returns true\r\nMyCalendar.book(50, 60); // returns true\r\nMyCalendar.book(10, 40); // returns true\r\nMyCalendar.book(5, 15); // returns false\r\nMyCalendar.book(5, 10); // returns true\r\nMyCalendar.book(25, 55); // returns true\r\n<b>Explanation:</b> \r\nThe first two events can be booked.  The third event can be double booked.\r\nThe fourth event (5, 15) can't be booked, because it would result in a triple booking.\r\nThe fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked.\r\nThe sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event;\r\nthe time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The number of calls to <code>MyCalendar.book</code> per test case will be at most <code>1000</code>.</li>\r\n<li>In calls to <code>MyCalendar.book(start, end)</code>, <code>start</code> and <code>end</code> are integers in the range <code>[0, 10^9]</code>.</li>\r\n</p>",
	"frequency":"151",
	"ac_num":"4328"
}