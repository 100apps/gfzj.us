{
	"difficulty":"2",
	"submit_num":"10576",
	"show_id":"737",
	"leetcode_id":"737",
	"answers":[
		{
			"lc_ans_id":"109752",
			"view":"924",
			"top":"0",
			"title":"[Java/C++] Clean Code with Explanation",
			"vote":"7",
			"content":"[description](https://leetcode.com/problems/sentence-similarity-ii/description/)\\n\\n- This is a good use case for `Union-Find`, compare to [Sentence Similarity I](https://leetcode.com/problems/sentence-similarity/description/), here the similarity between words are `transitive`, so all the connected(`similar`) words should be group into an `union` represented by their `ultimate parent`(or family holder, you name it).\\n- The connections can be represented by an parent map `Map<String, String> m`, which record the `direct parent-ship` we learned in each pair, but not the `ultimate-parent`. To build it, go through the input `pairs`, for each `pair<w1, w2>`, use the recursive `find()` method to find the `ultimate-parent` for both word - `parent1`, `parent2`, if they are different, assign `parent1` as parent of `parent2`(or the other way around), so that the to families are `merged`.\\n- The classic `find(x)` method will find the `ultimate-parent` of `x`. I modified it a little bit, make it do a little of extra initialization work - `assign x itself as its parent when it is not initialize` - so that we don't have to explicitly initialize the map at the beginning.\\n**Java**\\n```\\nclass Solution {\\n    public boolean areSentencesSimilarTwo(String[] a, String[] b, String[][] pairs) {\\n        if (a.length != b.length) return false;\\n        Map<String, String> m = new HashMap<>();\\n        for (String[] p : pairs) {\\n            String parent1 = find(m, p[0]), parent2 = find(m, p[1]);\\n            if (!parent1.equals(parent2)) m.put(parent1, parent2);\\n        }\\n\\n        for (int i = 0; i < a.length; i++)\\n            if (!a[i].equals(b[i]) && !find(m, a[i]).equals(find(m, b[i]))) return false;\\n\\n        return true;\\n    }\\n\\n    private String find(Map<String, String> m, String s) {\\n        if (!m.containsKey(s)) m.put(s, s);\\n        return s.equals(m.get(s)) ? s : find(m, m.get(s));\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilarTwo(vector<string>& a, vector<string>& b, vector<pair<string, string>> pairs) {\\n        if (a.size() != b.size()) return false;\\n        map<string, string> m;\\n        for (pair<string, string> p : pairs) {\\n            string parent1 = find(m, p.first), parent2 = find(m, p.second);\\n            if (parent1 != parent2) m[parent1] = parent2;\\n        }\\n\\n        for (int i = 0; i < a.size(); i++)\\n            if (a[i] != b[i] && find(m, a[i]) != find(m, b[i])) return false;\\n\\n        return true;\\n    }\\n\\nprivate:\\n    string find(map<string, string>& m, string s) {\\n        return !m.count(s) ? m[s] = s : (m[s] == s ? s : find(m, m[s]));\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109755",
			"view":"839",
			"top":"1",
			"title":"SHORT Python DFS with explanation",
			"vote":"5",
			"content":"Whenever we see a list of pairs as input, one probable approach will be to treat that as a list of edges and model the question as a graph. In this question, the idea here is to connect words to their similar words, and all connected words are similar. In each connected component of a graph, select any word to be the root word and then generate a mapping of word to root word. If two words are similar, they have the same root word.\\n\\nFirst build a graph from `pairs`. An input of `[[\"great\",\"good\"],[\"fine\",\"good\"],[\"drama\",\"acting\"],[\"skills\",\"talent\"]]` will have a graph that looks like:\\n\\n```\\n# words\\n{\\n  \"great\": set([\"good\"]),\\n  \"good\": set([\"great\", \"fine\"]),\\n  \"talent\": set([\"skills\"]),\\n  \"skills\": set([\"talent\"]),\\n  \"drama\": set([\"acting\"]),\\n  \"acting\": set([\"drama\"]),\\n  \"fine\": set([\"good\"]),\\n}\\n```\\n\\nNext, we do a DFS on each word to try to group the connected words together by assigning each word to a root word. The `similar_words` dict maps every word to a root word so that we can immediately know whether two words are similar just by looking up this dict and seeing if they have the same root word:\\n\\n```\\n# similar_words\\n{\\n  \"great\": \"great\",\\n  \"good\": \"great\",\\n  \"talent\": \"talent\",\\n  \"skills\": \"talent\",\\n  \"drama\": \"drama\",\\n  \"acting\": \"drama\",\\n  \"fine\": \"great\",\\n}\\n```\\n\\n*- Yangshun*\\n\\n```\\nclass Solution(object):\\n    def areSentencesSimilarTwo(self, words1, words2, pairs):\\n        from collections import defaultdict\\n        if len(words1) != len(words2): return False\\n        words, similar_words = defaultdict(set), {}\\n        [(words[w1].add(w2), words[w2].add(w1)) for w1, w2 in pairs]\\n        def dfs(word, root_word):\\n            if word in similar_words: return\\n            similar_words[word] = root_word\\n            [dfs(synonym, root_word) for synonym in words[word]]\\n        [dfs(word, word) for word in words]\\n        return all(similar_words.get(w1, w1) == similar_words.get(w2, w2) for w1, w2 in zip(words1, words2))\\n```\\n\\nA longer version with inline comments can be found below:\\n\\n```\\nclass Solution(object):\\n    def areSentencesSimilarTwo(self, words1, words2, pairs):\\n        from collections import defaultdict\\n        if len(words1) != len(words2):\\n            return False\\n        words = defaultdict(set)\\n        # Build the graph from pairs.\\n        for w1, w2 in pairs:\\n            words[w1].add(w2)\\n            words[w2].add(w1)\\n\\n        similar_words = {}\\n        def dfs(word, root_word):\\n            if word in similar_words:\\n                return\\n            similar_words[word] = root_word\\n            [dfs(synonym, root_word) for synonym in words[word]]\\n\\n        # Assign root words.\\n        [dfs(word, word) for word in words]\\n\\n        # Compare words.\\n        return all(similar_words.get(w1, w1) == similar_words.get(w2, w2) for w1, w2 in zip(words1, words2))\\n```"
		},
		{
			"lc_ans_id":"109747",
			"view":"727",
			"top":"2",
			"title":"Java Easy DFS solution with Explanation",
			"vote":"3",
			"content":"Notice there's no java DFS solution posted by others. I love DFS, what about you?\\nThe idea is simple:\\n1. Build the graph according to the similar word pairs. Each word is a graph node.\\n2. For each word in words1, we do DFS search to see if the corresponding word is existing in words2.\\n\\nSee the clean code below. Happy coding!\\n```\\nclass Solution {\\n    public boolean areSentencesSimilarTwo(String[] words1, String[] words2, String[][] pairs) {\\n        if (words1.length != words2.length) {\\n            return false;\\n        }\\n        \\n        Map<String, Set<String>> pairInfo = new HashMap<>();      \\n        for (String[] pair : pairs) {\\n            if (!pairInfo.containsKey(pair[0])) {\\n                pairInfo.put(pair[0], new HashSet<>());\\n            }\\n            if (!pairInfo.containsKey(pair[1])) {\\n                pairInfo.put(pair[1], new HashSet<>());\\n            }            \\n            pairInfo.get(pair[0]).add(pair[1]);\\n            pairInfo.get(pair[1]).add(pair[0]);\\n        }\\n        \\n        for (int i = 0; i < words1.length; i++) {\\n            if (words1[i].equals(words2[i])) continue;         \\n            if (!pairInfo.containsKey(words1[i])) return false;      \\n            if (!dfs(words1[i], words2[i], pairInfo, new HashSet<>())) return false;    //Search the graph.\\n        }        \\n        return true;\\n    }\\n    \\n    public boolean dfs(String source, String target, Map<String, Set<String>> pairInfo, Set<String> visited) {\\n        if (pairInfo.get(source).contains(target)) return true;\\n        \\n        visited.add(source);\\n        for (String next : pairInfo.get(source)) {\\n            if (!visited.contains(next) && dfs(next, target, pairInfo, visited)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n````"
		},
		{
			"lc_ans_id":"109749",
			"view":"830",
			"top":"3",
			"title":"Simple Java Union Find",
			"vote":"3",
			"content":"```\\npublic boolean areSentencesSimilarTwo(String[] words1, String[] words2, String[][] pairs) {\\n        \\n        if(words1.length!=words2.length)\\n            return false;\\n        \\n        Map<String,String> map = new HashMap<String,String>();\\n        \\n        for(String[] pair : pairs){\\n            \\n            String word1 = pair[0];\\n            String word2 = pair[1];\\n            \\n            if(!map.containsKey(word1))\\n                map.put(word1,word1);\\n            if(!map.containsKey(word2))\\n                map.put(word2,word2);\\n            \\n            setParent(map,word1,word2);\\n            \\n        }\\n        \\n        for(int i=0;i<words1.length;i++){\\n            \\n            String word1 = words1[i];\\n            String word2 = words2[i];\\n            \\n            String parent1 = getParent(word1,map);\\n            String parent2 = getParent(word2,map);\\n            \\n            if(!parent1.equals(parent2))\\n                return false;\\n     \\n        }\\n        return true;\\n        \\n        \\n    }\\n    \\n    public String getParent(String word,Map<String,String> map){\\n        \\n        if(!map.containsKey(word))\\n            return word;\\n        \\n        while(word!=map.get(word))\\n            word = map.get(word);\\n        return word;\\n  \\n    }\\n    \\n    public void setParent(Map<String,String> map,String word1,String word2){\\n        \\n        String p1 = getParent(word1,map);\\n        String p2 = getParent(word2,map);\\n        \\n        map.put(p1,p2);\\n   \\n    }\\n```"
		},
		{
			"lc_ans_id":"109764",
			"view":"189",
			"top":"4",
			"title":"Real interview follow up: preprocessing for multiple queries",
			"vote":"1",
			"content":"In fact, I have just met this problem in a real interview several days ago. There are several union-find and DFS solutions that I think are quite good. However, during my interview, I was asked to preprocess the similar words since there may be multiple queries. \\n\\nFor this kind of problems, I wrote a [brief summary](https://discuss.leetcode.com/topic/112801/summary-for-dfs-templates), if you think it helps, please upvote it to let more people can find it. Thanks.\\n\\nThe main idea is to find all similar words in a DFS manner, and we do not need to save all similar words in a hash table, we just need to give these similar words the same index so that we can know if two words are similar or not. Here is my AC solution:\\n\\n\\n\\n```\\nclass Solution {\\n        void mergeWords(unordered_map<string, unordered_set<string>>& dict,\\n                    unordered_map<string, int>& str_index) {\\n        int idx = 0;\\n        while (!dict.empty()) {\\n            const auto& dict_pair = *dict.begin();\\n\\n            vector<string> to_visit(dict_pair.second.begin(), dict_pair.second.end());\\n            \\n            //  mask current string index as idx\\n            str_index[dict_pair.first] = idx;     \\n            for (const auto& str: to_visit) {\\n                str_index[str] = idx;\\n            }\\n            \\n            //  erase current string and dict\\n            dict.erase(dict.begin());\\n            \\n            for (int i = 0; i < to_visit.size(); ++i) {\\n                const auto str = to_visit[i];\\n                \\n                //  find str in dict\\n                if (dict.find(str) == dict.end()) continue;\\n              \\n                for (const auto& s: dict[str]) {\\n                    if (str_index.find(s) != str_index.end()) continue;\\n                    \\n                    str_index[s] = idx;\\n                    to_visit.push_back(s);\\n                }\\n               \\n                // erase current string from dict\\n                dict.erase(str);\\n            }\\n            ++idx;\\n        }\\n    }\\n    \\n    \\npublic:\\n    bool areSentencesSimilarTwo(vector<string>& words1,\\n                                vector<string>& words2,\\n                                vector<pair<string, string>> pairs) {\\n        if (words1.size() != words2.size())\\n            return false;\\n        \\n        unordered_map<string, unordered_set<string>> dict;\\n        for (const auto& pa: pairs) { \\n            dict[pa.first].insert(pa.second);\\n            dict[pa.second].insert(pa.first);\\n        }\\n        \\n        //  merge similar words\\n        unordered_map<string, int> str_index;\\n        mergeWords(dict, str_index);\\n        \\n        for (int i = 0; i < words1.size(); ++i) {\\n            if (words1[i] == words2[i]) continue;\\n            auto iter1 = str_index.find(words1[i]);\\n            auto iter2 = str_index.find(words2[i]);\\n            if (iter1 == str_index.end() || iter2 == str_index.end()\\n                || iter1->second != iter2->second)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```"
		},
		{
			"lc_ans_id":"109745",
			"view":"71",
			"top":"5",
			"title":"Line 369: 'Solution' was not declared in this scope",
			"vote":"1",
			"content":"I keep seeing that issue in Sentence Similarity II question when running. anyone else?"
		},
		{
			"lc_ans_id":"109783",
			"view":"193",
			"top":"6",
			"title":"C++ DFS solution",
			"vote":"1",
			"content":"```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilarTwo(vector<string>& words1, vector<string>& words2, vector<pair<string, string>> pairs) {\\n        if (words1.size() != words2.size()) return false;\\n        unordered_map<string, unordered_set<string>> p;\\n        for (auto &vp : pairs) {\\n            p[vp.first].emplace(vp.second);\\n            p[vp.second].emplace(vp.first);\\n        }\\n        for (int i = 0; i < words1.size(); i++) {\\n            unordered_set<string> visited;\\n            if (isSimilar(words1[i], words2[i], p, visited)) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isSimilar(string& s1, string& s2, unordered_map<string, unordered_set<string>>& p, unordered_set<string>& visited) {\\n        if (s1 == s2) return true;\\n        \\n        visited.emplace(s1);\\n        for (auto s : p[s1]) {\\n            if (!visited.count(s) && isSimilar(s, s2, p, visited))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```"
		},
		{
			"lc_ans_id":"109741",
			"view":"8",
			"top":"7",
			"title":"Union Find with Java 8, clean code",
			"vote":"0",
			"content":"Since there was nothing different about union find, other than use of strings in place of integers, so i decided to separate it out in another class. I always favor clean/modular code against short solutions.\\n\\n```\\nimport java.util.HashMap;\\nimport java.util.Map;\\npublic class SimilarCheck {\\n   \\n   public static void main(String[] args) {\\n      String[] words1 = {\"great\", \"acting\", \"skills\"};\\n      String[] words2 = {\"fine\", \"drama\", \"talent\"};\\n      String[][] pairs = {{\"great\", \"good\"},\\n                          {\"fine\", \"good\"},\\n                          {\"acting\",\"drama\"},\\n                          {\"skills\",\"talent\"}};\\n                          \\n      System.out.println(areSimilar(words1, words2, pairs));\\n   }\\n   \\n   public static boolean areSimilar(String[] words1, String[] words2, String[][] pairs) {\\n      \\n      int n = words1.length;\\n      if (n != words2.length) return false;\\n      \\n      UFString uf = new UFString();\\n      \\n      for (String[] pair: pairs) {\\n         uf.union(pair[0], pair[1]);\\n      }\\n      \\n      for (int i = 0; i < n; i++) {\\n         if (!uf.isConnected(words1[i], words2[i])) return false;\\n      }\\n      \\n      return true;\\n   }\\n}\\n\\nclass UFString {\\n   private Map<String, String> map;\\n   public UFString() {\\n      map = new HashMap<String, String>();\\n   }\\n   \\n   public boolean isConnected(String word1, String word2) {\\n      return find(word1).equals(find(word2));\\n   }\\n   \\n   /**\\n    * Connect by making root of word2 as root/parent of word1\\n    */\\n   public void union(String word1, String word2) {\\n      map.put(find(word1), find(word2));\\n   }\\n\\n   \\n   // find with path compression\\n   public String find(String word) {\\n      // in case a word's parent is not found, word is parent of itself\\n      while(!word.equals(map.getOrDefault(word, word))) {\\n         String parent = map.get(word);\\n         map.put(word, map.getOrDefault(parent, parent));\\n         word = map.get(word);\\n      }\\n      \\n      return word;\\n   }\\n}\\n```"
		},
		{
			"lc_ans_id":"109742",
			"view":"20",
			"top":"8",
			"title":"Java BFS solution",
			"vote":"0",
			"content":"```\\nclass Solution {\\n    public boolean areSentencesSimilarTwo(String[] words1, String[] words2, String[][] pairs) {\\n        if(words1.length != words2.length) return false;\\n        HashMap<String, HashSet<String>> map = new HashMap<>();\\n        for(int i=0;i<pairs.length;i++){\\n            String[] pair = pairs[i];\\n            if(!map.containsKey(pair[0])){\\n                map.put(pair[0], new HashSet<String>());\\n            }\\n            map.get(pair[0]).add(pair[1]);\\n            \\n            if(!map.containsKey(pair[1])){\\n                map.put(pair[1], new HashSet<String>());\\n            }\\n            map.get(pair[1]).add(pair[0]);\\n        }\\n        //use a shortcut map to save the already calculated result, like DP\\n        HashMap<String, HashSet<String>> shortCut = new HashMap<>();\\n        \\n        for(int i=0;i<words1.length;i++){\\n            String word1 = words1[i];\\n            String word2 = words2[i];\\n            if(word1.equals(word2)) continue;\\n            // if there is no neighbor for word1, then there is not similar word of word1\\n            if(!map.containsKey(word1)) return false;\\n            if(map.containsKey(word1) && map.get(word1).contains(word2)) continue;\\n            if(!BFS(word1, word2, map, shortCut)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean BFS(String word1, String word2, HashMap<String, HashSet<String>> map, HashMap<String, HashSet<String>> shortCut){\\n        HashSet<String> visited = new HashSet<>();\\n        Queue<String> queue = new LinkedList<String>();\\n        queue.add(word1);\\n        while(!queue.isEmpty()){\\n            String cur = queue.poll();\\n            visited.add(cur);\\n            if(cur.equals(word2)) {\\n                if(!shortCut.containsKey(word1)){\\n                    shortCut.put(word1, new HashSet<String>());\\n                }\\n                if(!shortCut.containsKey(word2)){\\n                    shortCut.put(word2, new HashSet<String>());\\n                }\\n                shortCut.get(word1).add(word2);\\n                shortCut.get(word2).add(word1);\\n                return true;\\n            }\\n            if(map.containsKey(cur)){\\n                HashSet<String> neighbors = map.get(cur);\\n                for(String s : neighbors){\\n                    if(!visited.contains(s)){\\n                        queue.add(s);\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
		},
		{
			"lc_ans_id":"109743",
			"view":"13",
			"top":"9",
			"title":"Super Easy python solution with concise explanation",
			"vote":"0",
			"content":"Basically just two steps:\\n\\n1. build union-find struct.\\n2. zip the two sentences and walk through with union-find's find funcion, which is use for check if two words belong to the same set.\\n\\n\\n```python\\nclass Solution:\\n    def areSentencesSimilarTwo(self, words1, words2, pairs):\\n        if len(words1) != len(words2):\\n            return False\\n\\n        uf = {} # {key:word, value:parent}\\n        sz = {} # size, namely the uf rank\\n        def find(p):\\n            if p not in uf:\\n                uf[p] = p\\n                return p\\n            while p != uf[p]:\\n                uf[p] = uf[uf[p]] # path compression\\n                p = uf[p]\\n            return p\\n\\n        def build_uf():\\n            \" build the simliarity set with uf \"\\n            for a, b in pairs:\\n                if a not in uf:\\n                    uf[a] = a\\n                    sz[a] = 1\\n                if b not in uf:\\n                    uf[b] = b\\n                    sz[b] = 1\\n                r1 = find(a)\\n                r2 = find(b)\\n                if sz[r1] < sz[r2]:\\n                    # make sure that r1 always be the bigger size root\\n                    r1, r2 = r2, r1\\n                uf[r2] = r1\\n                sz[r1] += sz[r2]\\n\\n        build_uf()\\n        for w1, w2 in zip(words1, words2):\\n            if find(w1) != find(w2):\\n                return False\\n        return True\\n```"
		}
	],
	"id":"703",
	"title":"Sentence Similarity II",
	"content":"<p>Given two sentences <code>words1, words2</code> (each represented as an array of strings), and a list of similar word pairs <code>pairs</code>, determine if two sentences are similar.</code>\r\n</p><p>\r\nFor example, <code>words1 = [\"great\", \"acting\", \"skills\"]</code> and <code>words2 = [\"fine\", \"drama\", \"talent\"]</code> are similar, if the similar word pairs are <code>pairs = [[\"great\", \"good\"], [\"fine\", \"good\"], \r\n [\"acting\",\"drama\"], [\"skills\",\"talent\"]]</code>.\r\n</p><p>\r\nNote that the similarity relation <b>is</b> transitive. For example, if \"great\" and \"good\" are similar, and \"fine\" and \"good\" are similar, then \"great\" and \"fine\" <b>are similar</b>.\r\n</p><p>\r\nSimilarity is also symmetric.  For example, \"great\" and \"fine\" being similar is the same as \"fine\" and \"great\" being similar.\r\n</p><p>\r\nAlso, a word is always similar with itself.  For example, the sentences <code>words1 = [\"great\"], words2 = [\"great\"], pairs = []</code> are similar, even though there are no specified similar word pairs.\r\n</p><p>\r\nFinally, sentences can only be similar if they have the same number of words.  So a sentence like <code>words1 = [\"great\"]</code> can never be similar to <code>words2 = [\"doubleplus\",\"good\"]</code>.\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<li>The length of <code>words1</code> and <code>words2</code> will not exceed <code>1000</code>.</li>\r\n<li>The length of <code>pairs</code> will not exceed <code>2000</code>.</li>\r\n<li>The length of each <code>pairs[i]</code> will be <code>2</code>.</li>\r\n<li>The length of each <code>words[i]</code> and <code>pairs[i][j]</code> will be in the range <code>[1, 20]</code>.</li>\r\n</p>",
	"frequency":"133",
	"ac_num":"4407"
}