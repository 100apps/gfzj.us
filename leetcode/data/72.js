{
	"difficulty":"3",
	"submit_num":"331622",
	"show_id":"72",
	"leetcode_id":"72",
	"answers":[
		{
			"lc_ans_id":"25846",
			"view":"27885",
			"top":"0",
			"title":"20ms Detailed Explained C++ Solutions (O(n) Space)",
			"vote":"264",
			"content":"This is a classic problem of Dynamic Programming. We define the state `dp[i][j]` to be the minimum number of operations to convert `word1[0..i - 1]` to `word2[0..j - 1]`. The state equations have two cases: the boundary case and the general case. Note that in the above notations, both `i` and `j` take values starting from `1`. \\n\\nFor the boundary case, that is, to convert a string to an empty string, it is easy to see that the mininum number of operations to convert `word1[0..i - 1]` to `\"\"` requires at least `i` operations (deletions). In fact, the boundary case is simply:\\n\\n 1. `dp[i][0] = i`; \\n 2. `dp[0][j] = j`.\\n\\nNow let's move on to the general case, that is, convert a non-empty `word1[0..i - 1]` to another non-empty `word2[0..j - 1]`. Well, let's try to break this problem down into smaller problems (sub-problems). Suppose we have already known how to convert `word1[0..i - 2]` to `word2[0..j - 2]`, which is `dp[i - 1][j - 1]`. Now let's consider `word[i - 1]` and `word2[j - 1]`. If they are euqal, then no more operation is needed and `dp[i][j] = dp[i - 1][j - 1]`. Well, what if they are not equal?\\n\\nIf they are not equal, we need to consider three cases: \\n\\n 1. Replace `word1[i - 1]` by `word2[j - 1]` (`dp[i][j] = dp[i - 1][j - 1] + 1 (for replacement)`);\\n 2. Delete `word1[i - 1]` and `word1[0..i - 2] = word2[0..j - 1]` (`dp[i][j] = dp[i - 1][j] + 1 (for deletion)`);\\n 3. Insert `word2[j - 1]` to `word1[0..i - 1]` and `word1[0..i - 1] + word2[j - 1] = word2[0..j - 1]` (`dp[i][j] = dp[i][j - 1] + 1 (for insertion)`).\\n\\nMake sure you understand the subtle differences between the equations for deletion and insertion. For deletion, we are actually converting `word1[0..i - 2]` to `word2[0..j - 1]`, which costs `dp[i - 1][j]`,  and then deleting the `word1[i - 1]`, which costs `1`. The case is similar for insertion.\\n\\nPutting these together, we now have: \\n\\n 1. `dp[i][0] = i`;\\n 2. `dp[0][j] = j`;\\n 3. `dp[i][j] = dp[i - 1][j - 1]`, if `word1[i - 1] = word2[j - 1]`;\\n 4. `dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1)`, otherwise.\\n\\nThe above state equations can be turned into the following code directly.\\n\\n    class Solution { \\n    public:\\n        int minDistance(string word1, string word2) { \\n            int m = word1.length(), n = word2.length();\\n            vector<vector<int> > dp(m + 1, vector<int> (n + 1, 0));\\n            for (int i = 1; i <= m; i++)\\n                dp[i][0] = i;\\n            for (int j = 1; j <= n; j++)\\n                dp[0][j] = j;  \\n            for (int i = 1; i <= m; i++) {\\n                for (int j = 1; j <= n; j++) {\\n                    if (word1[i - 1] == word2[j - 1]) \\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    else dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j] + 1));\\n                }\\n            }\\n            return dp[m][n];\\n        }\\n    };\\n\\nWell, you may have noticed that each time when we update `dp[i][j]`, we only need `dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]`. In fact, we need not maintain the full `m*n` matrix. Instead, maintaing one column is enough. The code can be optimized to `O(m)` or `O(n)` space, depending on whether you maintain a row or a column of the original matrix.\\n\\nThe optimized code is as follows.\\n\\n    class Solution { \\n    public:\\n        int minDistance(string word1, string word2) {\\n            int m = word1.length(), n = word2.length();\\n            vector<int> cur(m + 1, 0);\\n            for (int i = 1; i <= m; i++)\\n                cur[i] = i;\\n            for (int j = 1; j <= n; j++) {\\n                int pre = cur[0];\\n                cur[0] = j;\\n                for (int i = 1; i <= m; i++) {\\n                    int temp = cur[i];\\n                    if (word1[i - 1] == word2[j - 1])\\n                        cur[i] = pre;\\n                    else cur[i] = min(pre + 1, min(cur[i] + 1, cur[i - 1] + 1));\\n                    pre = temp;\\n                }\\n            }\\n            return cur[m]; \\n        }\\n    }; \\n\\nWell, if you find the above code hard to understand, you may first try to write a two-column version that explicitly maintains two columns (the previous column and the current column) and then simplify the two-column version into the one-column version like the above code :-)"
		},
		{
			"lc_ans_id":"25911",
			"view":"17830",
			"top":"1",
			"title":"My O(mn) time and O(n) space solution using DP with explanation",
			"vote":"77",
			"content":"Use f[i][j] to represent the shortest edit distance between word1[0,i) and word2[0, j). Then compare the last character of word1[0,i) and word2[0,j), which are c and d respectively (c == word1[i-1], d == word2[j-1]):\\n\\nif c == d, then : f[i][j] = f[i-1][j-1]\\n\\nOtherwise we can use three operations to convert word1 to word2:\\n\\n(a) if we replaced c with d: f[i][j] = f[i-1][j-1] + 1;\\n\\n(b) if we added d after c: f[i][j] = f[i][j-1] + 1;\\n\\n(c) if we deleted c: f[i][j] = f[i-1][j] + 1;\\n\\n\\nNote that f[i][j] only depends on f[i-1][j-1], f[i-1][j] and f[i][j-1], therefore we can reduce the space to O(n) by using only the (i-1)th array and previous updated element(f[i][j-1]). \\n\\n\\n\\n     int minDistance(string word1, string word2) {\\n        \\n            int l1 = word1.size();\\n            int l2 = word2.size();\\n        \\n            vector<int> f(l2+1, 0);\\n            for (int j = 1; j <= l2; ++j)\\n                f[j] = j;\\n        \\n            for (int i = 1; i <= l1; ++i)\\n            {\\n                int prev = i;\\n                for (int j = 1; j <= l2; ++j)\\n                {\\n                    int cur;\\n                    if (word1[i-1] == word2[j-1]) {\\n                        cur = f[j-1];\\n                    } else {\\n                        cur = min(min(f[j-1], prev), f[j]) + 1;\\n                    }\\n        \\n                    f[j-1] = prev;\\n                    prev = cur;\\n                }\\n                f[l2] = prev;\\n            }\\n            return f[l2];\\n        \\n        }  \\n\\n\\nActually at first glance I thought this question was similar to Word Ladder and I tried to solve it using BFS(pretty stupid huh?). But in fact, the main difference is that there's a strict restriction on the intermediate words in Word Ladder problem, while there's no restriction in this problem.  If we added some restriction on intermediate words for this question, I don't think this DP solution would still work."
		},
		{
			"lc_ans_id":"25849",
			"view":"12672",
			"top":"2",
			"title":"Java DP solution - O(nm)",
			"vote":"69",
			"content":"Let following be the function definition :-\\n\\nf(i, j) := minimum cost (or steps) required to convert first i characters of word1 to first j characters of word2\\n\\nCase 1: word1[i] == word2[j], i.e. the ith the jth character matches.\\n\\n> f(i, j) = f(i - 1, j - 1)\\n\\nCase 2: word1[i] != word2[j], then we must either insert, delete or replace, whichever is cheaper\\n\\n> f(i, j) = 1 + min { f(i, j - 1), f(i - 1, j), f(i - 1, j - 1) }\\n\\n1. f(i, j - 1) represents insert operation\\n2. f(i - 1, j) represents delete operation\\n3. f(i - 1, j - 1) represents replace operation\\n\\nHere, we consider any operation from word1 to word2. It means, when we say insert operation, we insert a new character after word1 that matches the jth character of word2. So, now have to match i characters of word1 to j - 1 characters of word2. Same goes for other 2 operations as well.\\n\\nNote that the problem is symmetric. The insert operation in one direction (i.e. from word1 to word2) is same as delete operation in other. So, we could choose any direction.\\n\\nAbove equations become the recursive definitions for DP.\\n\\nBase Case: \\n\\n> f(0, k) = f(k, 0) = k\\n\\nBelow is the direct bottom-up translation of this recurrent relation. It is only important to take care of 0-based index with actual code :-\\n\\n    public class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int m = word1.length();\\n            int n = word2.length();\\n            \\n            int[][] cost = new int[m + 1][n + 1];\\n            for(int i = 0; i <= m; i++)\\n                cost[i][0] = i;\\n            for(int i = 1; i <= n; i++)\\n                cost[0][i] = i;\\n            \\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(word1.charAt(i) == word2.charAt(j))\\n                        cost[i + 1][j + 1] = cost[i][j];\\n                    else {\\n                        int a = cost[i][j];\\n                        int b = cost[i][j + 1];\\n                        int c = cost[i + 1][j];\\n                        cost[i + 1][j + 1] = a < b ? (a < c ? a : c) : (b < c ? b : c);\\n                        cost[i + 1][j + 1]++;\\n                    }\\n                }\\n            }\\n            return cost[m][n];\\n        }\\n    }\\n\\nTime complexity : If n is the length of word1, m of word2, because of the two indented loops, it is O(nm)"
		},
		{
			"lc_ans_id":"25913",
			"view":"7954",
			"top":"3",
			"title":"Good pdf on edit distance problem. May be helpful.",
			"vote":"48",
			"content":"http://www.stanford.edu/class/cs124/lec/med.pdf"
		},
		{
			"lc_ans_id":"25959",
			"view":"4681",
			"top":"4",
			"title":"My Accepted Java Solution",
			"vote":"24",
			"content":"Hi: \\n\\nThis is a very interesting question and I found a [youtube video][1] that helps a lot.\\nBasically the idea is to build up the solution step by step and keep track of the previous optimal solution in a 2D array. In this 2D array dp, dp[i][j] means the operation needed to transform word1(0, i) to word2(0,j). \\n\\nThere can be three conditions:\\n\\n1, word1[i] == word2[j] : then no operation needed. dp[i][j] == dp[i-1][j-1]\\n\\n2, Do one operation on word1[i-1][j]. dp[i][j] = dp[i-1][j] + 1\\n\\n3, Do one operation on word2[i][j-1]. dp[i][j] = dp[i][j-1] + 1\\n\\nfor 2 and 3, the reason it works is that we know the optimal ways to transfrom word1(0,i) to word2(0,j-1) and word1(0,i-1) to word(0,j) ( Delete (\"abc\" to \"ab\") or Insert (\"ab\" to \"abc\") ). Now all we need to one more operation.\\n\\nThe code will be:\\n\\n    public int minDistance(String word1, String word2) {\\n        if (word1.equals(word2)) {\\n            return 0;\\n        }\\n        if (word1.length() == 0 || word2.length() == 0) {\\n            return Math.abs(word1.length() - word2.length());\\n        }\\n        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int i = 0; i <= word2.length(); i++) {\\n            dp[0][i] = i;\\n        }\\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return dp[word1.length()][word2.length()];\\n    }\\n\\n Remeber that we start from dp[0][0], which is an empty string to an empty string. \\n\\n\\n  [1]: https://www.youtube.com/watch?v=z_CB7Gih_Mg"
		},
		{
			"lc_ans_id":"25951",
			"view":"3033",
			"top":"5",
			"title":"Standard dp solution",
			"vote":"22",
			"content":"    int minDistance(string word1, string word2) {\\n        int  m = word1.length(), n = word2.length();\\n        if (m == 0) return n;\\n        if (n == 0) return m;\\n        \\n        // table[i][j]: distance from words1.substr(0, i) to words2.substr(0, j) \\n        int table[m+1][n+1];\\n        for (int i = 0; i <= m; ++i) table[i][0] = i;\\n        for (int j = 0; j <= n; ++j) table[0][j] = j;\\n        // table[i][j] is the min distance between the next three values\\n        // from table[i-1][j], table[i][j-1], or table[i-1][j-1] to table[i][j]\\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                int cost = (word1[i-1] == word2[j-1] ? 0 : 1);\\n                table[i][j] = min(min(table[i-1][j] + 1, table[i][j-1] + 1), table[i-1][j-1] + cost);\\n            }\\n        }\\n        \\n        return table[m][n];\\n    }"
		},
		{
			"lc_ans_id":"25989",
			"view":"1623",
			"top":"6",
			"title":"My DP solution in C++ with comments.",
			"vote":"13",
			"content":"   \\n\\n    int minDistance(string word1, string word2) {\\n        // DP talbe, i is the position in word1, and j is the position in word2\\n        vector<vector<int>> distance(word1.length()+1, vector<int>(word2.length()+1, 0));\\n        \\n        // when i or j=0 means empty string, the distance is the length of another string\\n        for(int i=0; i<distance.size(); i++)\\n            for(int j=0; j< distance[0].size();j++){\\n                if(i == 0)\\n                    distance[i][j] = j;\\n                else if(j == 0)\\n                    distance[i][j] = i;\\n            }\\n        \\n        // if word1[i]==word2[j], then the distance of i and j is the previous i and j\\n        // otherwise we either replace, insert or delete a char\\n        // when insert a char to word1 it means we are trying to match word1 at i-1 to word2 at j\\n        // when delete a char from word1 it equals to insert a char to word2, which\\n        // means we are trying to match word1 at i to word2 at j-1\\n        // when replace a char to word1, then we add one step to previous i and j\\n        for(int i=1; i< distance.size(); i++)\\n            for(int j=1; j<distance[0].size(); j++){\\n                if(word1[i-1] == word2[j-1])\\n                    distance[i][j] = distance[i-1][j-1];\\n                else\\n                    distance[i][j] = 1+ min(distance[i-1][j-1], min(distance[i-1][j], distance[i][j-1]));\\n            }\\n            \\n        return distance[word1.length()][word2.length()];\\n    }"
		},
		{
			"lc_ans_id":"25914",
			"view":"1381",
			"top":"7",
			"title":"Concise JAVA DP solution with comments",
			"vote":"12",
			"content":"    public int minDistance(String word1, String word2) {\\n    \\t// dp[i][j] : minimum steps to convert i long word1 and j long word2\\n    \\tint dp[][] = new int[word1.length() + 1][word2.length() + 1];\\n    \\n    \\tfor (int i = 0; i <= word1.length(); i++) dp[i][0] = i;    \\t\\n    \\tfor (int j = 0; j <= word2.length(); j++) dp[0][j] = j; \\n    \\t \\n    \\tfor (int i = 1;i <= word1.length(); i++) {\\n    \\t\\tfor (int j = 1; j<= word2.length(); j++) {\\n    \\t\\t\\tif (word1.charAt(i-1) == word2.charAt(j-1))// <--\\n    \\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n    \\t\\t\\telse \\n                    // dp[i-1][j-1] : replace word1(i) with word2(j), because word1(0, i-1) == word2(0, j-1);\\n                    // dp[i  ][j-1] : delete word(j)\\n                    // dp[i-1][j  ] : delete word(i), because word1(0, i-1) == word2(0, j)\\n    \\t\\t\\t\\tdp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j])) + 1; \\n    \\t\\t}\\n    \\t}\\n    \\treturn dp[word1.length()][word2.length()];\\n    }"
		},
		{
			"lc_ans_id":"25987",
			"view":"1808",
			"top":"8",
			"title":"Dynamic Programming Solution in C++ with Algorithm Description",
			"vote":"12",
			"content":"**Algorithm Description**  \\n\\n\\n----------\\n\\n - Step 1:\\n\\nSet  n to be the length of *word1*;\\nSet m to be the length of *word2*.  \\nIf n = 0, return m and exit.  \\nIf m = 0, return n  and exit.  \\nConstruct a matrix containing 0...n rows and 0...m columns.  \\n  \\n\\n - Step 2:\\n\\nInitialize the first row       to 0...n.  \\nInitialize the first column to 0...m.  \\n  \\n\\n - Step 3:\\n\\nExamine each character of *word1* (i from 1 to  n).\\n\\n - Step 4:\\n\\nExamine each character of *word2*  (j from 1 to m).\\n\\n - Step 5:\\n\\nIf word1[i] == word2[j], the cost = 0.  \\nIf word1[i] !=  word2[j], the cost = 1.  \\n  \\n\\n - Step 6:\\n\\n   \\nSet cell A [i, j] of the matrix equal to the minimum of:  \\na) The cell immediately **above** plus 1:                               A[i - 1, j]    + 1.  \\nb) The cell immediately **to the left** plus 1:                          A[i,  j - 1]    + 1.  \\nc) The cell diagonally **above and to the left** plus the cost: A[i - 1, j - 1] + cost.  \\n  \\n\\n - Step 7:\\n\\n   \\nAfter the iteration steps (3, 4, 5, 6) are complete, the distance is found in cell A[n, m]. \\n\\n\\n----------\\n\\n\\nHere is the code:\\n\\n    int minDistance(string word1, string word2) {\\n        // Step 1\\n        int n = word1.size(), m = word2.size();\\n        if (n == 0)  return m;\\n        if (m == 0)  return n;\\n        int A[n + 1][m + 1];\\n\\n        // Step 2\\n        for (int i = 0; i <= n; ++i)  A[i][0] = i;\\n        for (int j = 0; j <= m; ++j)  A[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {  // Step 3\\n            char word1_i = word1[i-1];\\n            for (int j = 1; j <= m; ++j) {  // Step 4\\n                char word2_j = word2[j-1];\\n                int cost = (word1_i == word2_j) ? 0 : 1;  // Step 5\\n                A[i][j] = min(min(A[i-1][j]+1, A[i][j-1]+1), A[i-1][j-1]+cost);// Step 6\\n            }\\n        }\\n        return A[n][m];  // Step 7\\n    }"
		},
		{
			"lc_ans_id":"25969",
			"view":"1183",
			"top":"9",
			"title":"My clean java solution with O(n) space  in 17 lines",
			"vote":"10",
			"content":"    public class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int[] d = new int[word2.length() + 1];\\n            for (int i = 0; i <= word2.length(); ++i) d[i] = i;\\n            for (int i = 1; i <= word1.length(); ++i) {\\n                int prev = d[0];\\n                d[0] = i;\\n                for (int j = 1; j <= word2.length(); ++j) {\\n                    int tmp = d[j];\\n                    d[j] = Math.min(d[j - 1], d[j]) + 1;\\n                    d[j] = Math.min(d[j], prev + (word1.charAt(i -1) == word2.charAt(j - 1) ? 0: 1));\\n                    prev = tmp;\\n                }\\n            }\\n            return d[word2.length()];\\n        }\\n    }"
		}
	],
	"id":"72",
	"title":"Edit Distance",
	"content":"<p>\r\nGiven two words <i>word1</i> and <i>word2</i>, find the minimum number of steps required to convert <i>word1</i> to <i>word2</i>. (each operation is counted as 1 step.)\r\n</p>\r\n\r\n<p>\r\nYou have the following 3 operations permitted on a word:\r\n</p>\r\n\r\n<p>\r\na) Insert a character<br />\r\nb) Delete a character<br />\r\nc) Replace a character<br />\r\n</p>",
	"frequency":"521",
	"ac_num":"107348"
}