{
	"difficulty":"3",
	"submit_num":"504257",
	"show_id":"76",
	"leetcode_id":"76",
	"answers":[
		{
			"lc_ans_id":"26808",
			"view":"108884",
			"top":"0",
			"title":"Here is a 10-line template that can solve most 'substring' problems",
			"vote":"1286",
			"content":"I will first give the solution then show you the magic template.\\n\\n**The code of solving this problem is below. It might be the shortest among all solutions provided in Discuss**.\\n\\n    string minWindow(string s, string t) {\\n            vector<int> map(128,0);\\n            for(auto c: t) map[c]++;\\n            int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0;\\n            while(end<s.size()){\\n                if(map[s[end++]]-->0) counter--; //in t\\n                while(counter==0){ //valid\\n                    if(end-begin<d)  d=end-(head=begin);\\n                    if(map[s[begin++]]++==0) counter++;  //make it invalid\\n                }  \\n            }\\n            return d==INT_MAX? \"\":s.substr(head, d);\\n        }\\n\\n**Here comes the template.**\\n\\nFor most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below.\\n \\n\\n    int findSubstring(string s){\\n            vector<int> map(128,0);\\n            int counter; // check whether the substring is valid\\n            int begin=0, end=0; //two pointers, one point to tail and one  head\\n            int d; //the length of substring\\n\\n            for() { /* initialize the hash map here */ }\\n    \\n            while(end<s.size()){\\n\\n                if(map[s[end++]]-- ?){  /* modify counter here */ }\\n    \\n                while(/* counter condition */){ \\n                     \\n                     /* update d here if finding minimum*/\\n\\n                    //increase begin to make it invalid/valid again\\n                    \\n                    if(map[s[begin++]]++ ?){ /*modify counter here*/ }\\n                }  \\n  \\n                /* update d here if finding maximum*/\\n            }\\n            return d;\\n      }\\n\\n*One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop.*\\n\\n\\nThe code of solving **Longest Substring with At Most Two Distinct Characters** is below:\\n\\n    int lengthOfLongestSubstringTwoDistinct(string s) {\\n            vector<int> map(128, 0);\\n            int counter=0, begin=0, end=0, d=0; \\n            while(end<s.size()){\\n                if(map[s[end++]]++==0) counter++;\\n                while(counter>2) if(map[s[begin++]]--==1) counter--;\\n                d=max(d, end-begin);\\n            }\\n            return d;\\n        }\\n\\nThe code of solving **Longest Substring Without Repeating Characters** is below:\\n\\n**Update 01.04.2016, thanks @weiyi3 for advise.**\\n\\n    int lengthOfLongestSubstring(string s) {\\n            vector<int> map(128,0);\\n            int counter=0, begin=0, end=0, d=0; \\n            while(end<s.size()){\\n                if(map[s[end++]]++>0) counter++; \\n                while(counter>0) if(map[s[begin++]]-->1) counter--;\\n                d=max(d, end-begin); //while valid, update d\\n            }\\n            return d;\\n        }\\n    \\nI think this post deserves some upvotes! : )"
		},
		{
			"lc_ans_id":"26804",
			"view":"14468",
			"top":"1",
			"title":"12 lines Python",
			"vote":"74",
			"content":"The current window is `s[i:j]` and the result window is `s[I:J]`. In `need[c]` I store how many times I need character `c` (can be negative) and `missing` tells how many characters are still missing. In the loop, first add the new character to the window. Then, if nothing is missing, remove as much as possible from the window start and then update the result.\\n\\n    def minWindow(self, s, t):\\n        need, missing = collections.Counter(t), len(t)\\n        i = I = J = 0\\n        for j, c in enumerate(s, 1):\\n            missing -= need[c] > 0\\n            need[c] -= 1\\n            if not missing:\\n                while i < j and need[s[i]] < 0:\\n                    need[s[i]] += 1\\n                    i += 1\\n                if not J or j - i <= J - I:\\n                    I, J = i, j\\n        return s[I:J]"
		},
		{
			"lc_ans_id":"26805",
			"view":"43680",
			"top":"2",
			"title":"Accepted O(n) solution",
			"vote":"72",
			"content":"    class Solution {\\n    public:\\n        string minWindow(string S, string T) {\\n            if (S.empty() || T.empty())\\n            {\\n                return \"\";\\n            }\\n            int count = T.size();\\n            int require[128] = {0};\\n            bool chSet[128] = {false};\\n            for (int i = 0; i < count; ++i)\\n            {\\n                require[T[i]]++;\\n                chSet[T[i]] = true;\\n            }\\n            int i = -1;\\n            int j = 0;\\n            int minLen = INT_MAX;\\n            int minIdx = 0;\\n            while (i < (int)S.size() && j < (int)S.size())\\n            {\\n                if (count)\\n                {\\n                    i++;\\n                    require[S[i]]--;\\n                    if (chSet[S[i]] && require[S[i]] >= 0)\\n                    {\\n                        count--;\\n                    }\\n                }\\n                else\\n                {\\n                    if (minLen > i - j + 1)\\n                    {\\n                        minLen = i - j + 1;\\n                        minIdx = j;\\n                    }\\n                    require[S[j]]++;\\n                    if (chSet[S[j]] && require[S[j]] > 0)\\n                    {\\n                        count++;\\n                    }\\n                    j++;\\n                }\\n            }\\n            if (minLen == INT_MAX)\\n            {\\n                return \"\";\\n            }\\n            return S.substr(minIdx, minLen);\\n        }\\n    };\\n\\nImplementation of [mike3's idea][1]\\n\\nrunning time : 56ms.\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/5469/is-the-length-of-t-considered-constant-or-m"
		},
		{
			"lc_ans_id":"26825",
			"view":"8320",
			"top":"3",
			"title":"Can T have characters repeating ?",
			"vote":"47",
			"content":"Can the String T have repeating characters - for instance \"AA\"? In that case should the minimum window contain two A's or does it suffice for it have a single A."
		},
		{
			"lc_ans_id":"26840",
			"view":"23798",
			"top":"4",
			"title":"Sharing my straightforward O(n) solution with explanation",
			"vote":"46",
			"content":"    string minWindow(string S, string T) {\\n        string result;\\n        if(S.empty() || T.empty()){\\n            return result;\\n        }\\n        unordered_map<char, int> map;\\n        unordered_map<char, int> window;\\n        for(int i = 0; i < T.length(); i++){\\n            map[T[i]]++;\\n        }\\n        int minLength = INT_MAX;\\n        int letterCounter = 0;\\n        for(int slow = 0, fast = 0; fast < S.length(); fast++){\\n            char c = S[fast];\\n            if(map.find(c) != map.end()){\\n                window[c]++;\\n                if(window[c] <= map[c]){\\n                    letterCounter++;\\n                }\\n            }\\n            if(letterCounter >= T.length()){\\n                while(map.find(S[slow]) == map.end() || window[S[slow]] > map[S[slow]]){\\n                    window[S[slow]]--;\\n                    slow++;\\n                }\\n                if(fast - slow + 1 < minLength){\\n                    minLength = fast - slow + 1;\\n                    result = S.substr(slow, minLength);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\nThere are three key variables in my solution: \\n\\n    unordered_map <char, int> map; unordered_map<char, int> window; int letterCounter;\\n\\nvariable \"map\" is used to indicate what characters and how many characters are in T.\\n\\nvariable \"window\" is to indicate what characters and how many characters are between pointer \"slow\" and pointer \"fast\".\\n\\nNow let's start.\\n\\nThe first For loop is used to construct variable \"map\".\\n\\nThe second For loop is used to find the minimum window.\\n\\nThe first thing we should do in the second For loop is to find a window which can cover T. I use \"letterCounter\" to be a monitor. If \"letterCounter\" is equal to T.length(), then we find this window. Before that, only the first If clause can be executed. However, after we find this window, the second If clause can also be executed. \\n\\nIn the second If clause, we move \"slow\" forward in order to shrink the window size. Every time finding a smaller window, I update the result. \\n\\nAt the end of program, I return result, which is the minimum window."
		},
		{
			"lc_ans_id":"26810",
			"view":"7764",
			"top":"5",
			"title":"Java solution. using two pointers + HashMap",
			"vote":"42",
			"content":"    public class Solution {\\n    public String minWindow(String s, String t) {\\n        if(s == null || s.length() < t.length() || s.length() == 0){\\n            return \"\";\\n        }\\n        HashMap<Character,Integer> map = new HashMap<Character,Integer>();\\n        for(char c : t.toCharArray()){\\n            if(map.containsKey(c)){\\n                map.put(c,map.get(c)+1);\\n            }else{\\n                map.put(c,1);\\n            }\\n        }\\n        int left = 0;\\n        int minLeft = 0;\\n        int minLen = s.length()+1;\\n        int count = 0;\\n        for(int right = 0; right < s.length(); right++){\\n            if(map.containsKey(s.charAt(right))){\\n                map.put(s.charAt(right),map.get(s.charAt(right))-1);\\n                if(map.get(s.charAt(right)) >= 0){\\n                    count ++;\\n                }\\n                while(count == t.length()){\\n                    if(right-left+1 < minLen){\\n                        minLeft = left;\\n                        minLen = right-left+1;\\n                    }\\n                    if(map.containsKey(s.charAt(left))){\\n                        map.put(s.charAt(left),map.get(s.charAt(left))+1);\\n                        if(map.get(s.charAt(left)) > 0){\\n                            count --;\\n                        }\\n                    }\\n                    left ++ ;\\n                }\\n            }\\n        }\\n        if(minLen>s.length())  \\n        {  \\n            return \"\";  \\n        }  \\n        \\n        return s.substring(minLeft,minLeft+minLen);\\n    }\\n}"
		},
		{
			"lc_ans_id":"26811",
			"view":"9043",
			"top":"6",
			"title":"Share my neat java solution",
			"vote":"37",
			"content":"    public String minWindow(String S, String T) {\\n        if(S==null||S.isEmpty()||T==null||T.isEmpty()) return \"\";\\n        int i=0, j=0;\\n        int[] Tmap=new int[256];\\n        int[] Smap=new int[256];\\n        for(int k=0; k< T.length(); k++){\\n            Tmap[T.charAt(k)]++;\\n        }\\n        int found=0;\\n        int length=Integer.MAX_VALUE;\\n        String res=\"\";\\n        while(j<S.length()){\\n            if(found<T.length()){\\n                if(Tmap[S.charAt(j)]>0){\\n                    Smap[S.charAt(j)]++;\\n                    if(Smap[S.charAt(j)]<=Tmap[S.charAt(j)]){\\n                        found++;\\n                    }\\n                }\\n                j++;\\n            }\\n            while(found==T.length()){\\n                if(j-i<length){\\n                    length=j-i; res=S.substring(i,j);\\n                }\\n                if(Tmap[S.charAt(i)]>0){\\n                    Smap[S.charAt(i)]--;\\n                    if(Smap[S.charAt(i)]<Tmap[S.charAt(i)]){\\n                        found--;\\n                    }\\n                }\\n                i++;\\n            }\\n        }\\n        return res;\\n    }"
		},
		{
			"lc_ans_id":"26917",
			"view":"3268",
			"top":"7",
			"title":"16ms simple and neat c++ solution only using a vector. Detailed explanation",
			"vote":"29",
			"content":" 1. Initialize a vector called `remaining`, which contains the needed\\n    matching numbers of each character in `s`. \\n 2. If there are still\\n        characters needed to be contained (increment `i` in this case),\\n        decrease the matching number of that character and check if it is\\n        still non-negative. If it is, then it is the character in `t`, so\\n        decrease the total required number `required`.  \\n 3. If there is no more\\n            characters required (increment `start` in this case),  record `min`\\n            and `left` if a smaller length is found. Recover the number of this\\n            character in the `remaining` and if it is a character in `t`\\n            increase `required`.\\n\\n\\n----------\\n\\n    class Solution {\\n    public:\\n        string minWindow(string s, string t) {\\n            if (s.size() == 0 || t.size() == 0) return \"\";\\n            vector<int> remaining(128, 0);\\n            int required = t.size();\\n            for (int i = 0; i < required; i++) remaining[t[i]]++;\\n            // left is the start index of the min-length substring ever found\\n            int min = INT_MAX, start = 0, left = 0, i = 0;\\n            while(i <= s.size() && start < s.size()) {\\n                if(required) {\\n                    if (i == s.size()) break;\\n                    remaining[s[i]]--;\\n                    if (remaining[s[i]] >= 0) required--;\\n                    i++;\\n                } else {\\n                    if (i - start < min) {\\n                        min = i -start;\\n                        left = start;\\n                    }\\n                    remaining[s[start]]++;\\n                    if (remaining[s[start]] > 0) required++;\\n                    start++;\\n                }\\n            }\\n            return min == INT_MAX? \"\" : s.substr(left, min);\\n        }\\n    };"
		},
		{
			"lc_ans_id":"26971",
			"view":"3434",
			"top":"8",
			"title":"Three O(N) concise implemetation according to leetcode oj discuss",
			"vote":"22",
			"content":"    // according to http://leetcode.com/2010/11/finding-minimum-window-in-s-which.html\\n    // finds the first window that satisfies the constraint\\n    // then continue maintaining the constraint throughout\\n    // time complexity O(2N)\\n    string minWindow(string S, string T) {\\n        int m = S.size(), n = T.size();\\n        if (n <= 0 || m < n)\\n            return \"\";\\n        \\n        int require[128] = {0}, found[128] = {0};\\n        for (int k = 0; k < n; ++k) require[T[k]]++;\\n        \\n        int count = 0;\\n        int minLen = INT_MAX, minIndex = 0;\\n        for (int s = 0, e = 0; e < m; ++e) {\\n            // skip characters not in T\\n            if (require[S[e]] == 0) continue;\\n            if (++found[S[e]] <= require[S[e]]) count++;\\n            \\n            // windows constrain is sastisfied\\n            if (count == n) {\\n                // advance begin index as far as possible\\n                // stop when advancing breaks window constraint\\n                while (require[S[s]] == 0 || found[S[s]] > require[S[s]]) {\\n                    if (found[S[s]] > require[S[s]]) found[S[s]]--;\\n                    ++s;\\n                }\\n                // update minmum window\\n                if (e - s + 1 < minLen) {\\n                    minLen = e - s + 1;\\n                    minIndex = s;\\n                }\\n            }\\n        }\\n        \\n        if (minLen == INT_MAX) return \"\";\\n        return S.substr(minIndex, minLen); \\n    }\\n    \\n    string minWindow(string S, string T) {\\n        int m = S.size(), n = T.size();\\n        if (n <= 0 || m < n)\\n            return \"\";\\n        \\n        int require[128] = {0}, chSet[128] = {0};\\n        for (int k = 0; k < n; ++k) {\\n            require[T[k]]++;\\n            chSet[T[k]] = 1;\\n        }\\n        \\n        int minLen = INT_MAX, minIndex = 0;\\n        int i = -1, j = 0;\\n        while (i < m && j < m) {\\n            if (n) {\\n                ++i;\\n                require[S[i]]--;\\n                if (chSet[S[i]] && require[S[i]] >= 0) n--;\\n            }\\n            else {\\n                if (minLen > i - j + 1) {\\n                    minLen = i - j + 1;\\n                    minIndex = j;\\n                }\\n                require[S[j]]++;\\n                if (chSet[S[j]] && require[S[j]] > 0) n++;\\n                ++j;\\n            }\\n        }\\n        \\n        if (minLen == INT_MAX) return \"\";\\n        return S.substr(minIndex, minLen);\\n    }\\n\\n    // the most concise one\\n    // maintain a window with two pointers (left side and right side)\\n    string minWindow(string S, string T) {\\n        int m = S.size(), n = T.size();\\n        if (n <= 0 || m < n) return \"\";\\n        \\n        int require[128] = {0};\\n        for (int i = 0; i < n; ++i) require[T[i]]++;\\n        \\n        int count = 0;\\n        int minLen = INT_MAX, minIndex = 0;\\n        for (int s = 0, e = 0; e < m; ++e) {\\n            require[S[e]]--;\\n            if (require[S[e]] >= 0) count++;\\n            while (count == n) {\\n                if (e - s + 1 < minLen) {\\n                    minLen = e - s + 1;\\n                    minIndex = s;\\n                }\\n                require[S[s]]++;\\n                if (require[S[s]] > 0) count--;\\n                s++;\\n            }\\n        }\\n        \\n        if (minLen == INT_MAX) return \"\";\\n        return S.substr(minIndex, minLen); \\n    }"
		},
		{
			"lc_ans_id":"26835",
			"view":"3401",
			"top":"9",
			"title":"Java 4ms bit 97.6%",
			"vote":"18",
			"content":"Basically, there are two pointers for windows sliding. One for exploiting new matched substring, other pointer for expiring previous substring.\\n\\n    public String minWindow(String s, String t) {\\n            char[] s_array = s.toCharArray();\\n            char[] t_array = t.toCharArray();\\n            int[] map = new int[256];\\n            int end = 0;\\n            int start = 0;\\n            int min_length = Integer.MAX_VALUE;\\n            for(int i = 0; i < t_array.length; i++)\\n                map[t_array[i]] ++;\\n            int count = t_array.length;\\n            int min_start = 0;\\n            while(end < s_array.length)\\n            {\\n                if(map[s_array[end]] > 0)\\n                {\\n                    count--;\\n                }\\n                map[s_array[end]] --;\\n                while(count == 0)\\n                {\\n                    if((end - start + 1) < min_length)\\n                    {\\n                        min_length = end - start + 1;\\n                        min_start = start;\\n                    }\\n                    map[s_array[start]] ++;\\n                    if(map[s_array[start]] > 0){\\n                        count ++;\\n                    }\\n                    start++;\\n                }\\n                end ++;\\n    \\n            }\\n            if( min_start+min_length > s_array.length)\\n                return \"\";\\n            return s.substring(min_start, min_start+min_length);\\n        }"
		}
	],
	"id":"76",
	"title":"Minimum Window Substring",
	"content":"<p>\r\nGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\r\n</p>\r\n\r\n<p>\r\nFor example,<br />\r\n<b>S</b> = <code>\"ADOBECODEBANC\"</code><br />\r\n<b>T</b> = <code>\"ABC\"</code><br />\r\n</p>\r\n<p>\r\nMinimum window is <code>\"BANC\"</code>.\r\n</p>\r\n\r\n<p>\r\n<b>Note:</b><br />\r\nIf there is no such window in S that covers all characters in T, return the empty string <code>\"\"</code>.\r\n</p>\r\n<p>\r\nIf there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.\r\n</p>",
	"frequency":"432",
	"ac_num":"133688"
}