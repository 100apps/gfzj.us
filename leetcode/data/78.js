{
	"difficulty":"2",
	"submit_num":"485772",
	"show_id":"78",
	"leetcode_id":"78",
	"answers":[
		{
			"lc_ans_id":"27281",
			"view":"50940",
			"top":"0",
			"title":"A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning)",
			"vote":"317",
			"content":"This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. \\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/"
		},
		{
			"lc_ans_id":"27288",
			"view":"36235",
			"top":"1",
			"title":"My solution using bit manipulation",
			"vote":"204",
			"content":"    class Solution {\\n    public:\\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort (S.begin(), S.end());\\n            int elem_num = S.size();\\n            int subset_num = pow (2, elem_num);\\n            vector<vector<int> > subset_set (subset_num, vector<int>());\\n            for (int i = 0; i < elem_num; i++)\\n                for (int j = 0; j < subset_num; j++)\\n                    if ((j >> i) & 1)\\n                        subset_set[j].push_back (S[i]);\\n            return subset_set;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"27278",
			"view":"18959",
			"top":"2",
			"title":"C++ Recursive/Iterative/Bit-Manipulation Solutions with Explanations",
			"vote":"164",
			"content":"----------\\n**Recursive (Backtracking)**\\n\\nThis is a typical problem that can be tackled by backtracking. Since backtracking has a more-or-less similar template, so I do not give explanations for this method.\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            sort(nums.begin(), nums.end());\\n            vector<vector<int>> subs;\\n            vector<int> sub;  \\n            genSubsets(nums, 0, sub, subs);\\n            return subs; \\n        }\\n        void genSubsets(vector<int>& nums, int start, vector<int>& sub, vector<vector<int>>& subs) {\\n            subs.push_back(sub);\\n            for (int i = start; i < nums.size(); i++) {\\n                sub.push_back(nums[i]);\\n                genSubsets(nums, i + 1, sub, subs);\\n                sub.pop_back();\\n            }\\n        }\\n    };\\n\\n----------\\n**Iterative**\\n\\nThis problem can also be solved iteratively. Take `[1, 2, 3]` in the problem statement as an example. The process of generating all the subsets is like:\\n\\n 1. Initially: `[[]]`\\n 2. Adding the first number to all the existed subsets: `[[], [1]]`;\\n 3. Adding the second number to all the existed subsets: `[[], [1], [2], [1, 2]]`;\\n 4. Adding the third number to all the existed  subsets: `[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]`.\\n\\nHave you got the idea :-)\\n\\nThe code is as follows.\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            sort(nums.begin(), nums.end());\\n            vector<vector<int>> subs(1, vector<int>());\\n            for (int i = 0; i < nums.size(); i++) {\\n                int n = subs.size();\\n                for (int j = 0; j < n; j++) {\\n                    subs.push_back(subs[j]); \\n                    subs.back().push_back(nums[i]);\\n                }\\n            }\\n            return subs;\\n        }\\n    }; \\n\\n----------\\n**Bit Manipulation**\\n\\nThis is the most clever solution that I have seen. The idea is that to give all the possible subsets, we just need to exhaust all the possible combinations of the numbers. And each number has only two possibilities: either in or not in a subset. And this can be represented using a bit.\\n\\nThere is also another a way to visualize this idea. That is, if we use the above example, `1` appears once in every two consecutive subsets, `2` appears twice in every four consecutive subsets, and `3` appears four times in every eight subsets, shown in the following (initially the `8` subsets are all empty):\\n\\n`[], [], [], [], [], [], [], []`\\n\\n`[], [1], [], [1], [], [1], [], [1]`\\n\\n`[], [1], [2], [1, 2], [], [1], [2], [1, 2]`\\n\\n`[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]`\\n\\nThe code is as follows.\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            sort(nums.begin(), nums.end());\\n            int num_subset = pow(2, nums.size()); \\n            vector<vector<int> > res(num_subset, vector<int>());\\n            for (int i = 0; i < nums.size(); i++)\\n                for (int j = 0; j < num_subset; j++)\\n                    if ((j >> i) & 1)\\n                        res[j].push_back(nums[i]);\\n            return res;  \\n        }\\n    };\\n\\n----------\\nWell, just a final remark. For Python programmers, this may be an easy task in practice since the `itertools` package has a function `combinations` for it :-)"
		},
		{
			"lc_ans_id":"27301",
			"view":"13928",
			"top":"3",
			"title":"Python easy to understand solutions (DFS recursively, Bit Manipulation, Iteratively).",
			"vote":"87",
			"content":"    # DFS recursively \\n    def subsets1(self, nums):\\n        res = []\\n        self.dfs(sorted(nums), 0, [], res)\\n        return res\\n        \\n    def dfs(self, nums, index, path, res):\\n        res.append(path)\\n        for i in xrange(index, len(nums)):\\n            self.dfs(nums, i+1, path+[nums[i]], res)\\n            \\n    # Bit Manipulation    \\n    def subsets2(self, nums):\\n        res = []\\n        nums.sort()\\n        for i in xrange(1<<len(nums)):\\n            tmp = []\\n            for j in xrange(len(nums)):\\n                if i & 1 << j:  # if i >> j & 1:\\n                    tmp.append(nums[j])\\n            res.append(tmp)\\n        return res\\n        \\n    # Iteratively\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in sorted(nums):\\n            res += [item+[num] for item in res]\\n        return res"
		},
		{
			"lc_ans_id":"27279",
			"view":"14071",
			"top":"4",
			"title":"Simple Java Solution with For-Each loops",
			"vote":"48",
			"content":"No  messy indexing. Avoid the ConcurrentModificationException by using a temp list.\\n\\n    public class Solution {\\n        public List<List<Integer>> subsets(int[] S) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            res.add(new ArrayList<Integer>());\\n            \\n            Arrays.sort(S);\\n            for(int i : S) {\\n                List<List<Integer>> tmp = new ArrayList<>();\\n                for(List<Integer> sub : res) {\\n                    List<Integer> a = new ArrayList<>(sub);\\n                    a.add(i);\\n                    tmp.add(a);\\n                }\\n                res.addAll(tmp);\\n            }\\n            return res;\\n        }\\n    }"
		},
		{
			"lc_ans_id":"27511",
			"view":"4769",
			"top":"5",
			"title":"C++ 8ms simple iterative solution",
			"vote":"45",
			"content":"    class Solution {\\n    public:\\n\\tvector<vector<int> > subsets(vector<int> &S) {\\n\\t\\tvector<vector<int> > res(1, vector<int>());\\n\\t\\tsort(S.begin(), S.end());\\n\\t\\t\\n\\t\\tfor (int i = 0; i < S.size(); i++) {\\n\\t\\t\\tint n = res.size();\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tres.push_back(res[j]);\\n\\t\\t\\t\\tres.back().push_back(S[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t  }\\n    };"
		},
		{
			"lc_ans_id":"27332",
			"view":"7722",
			"top":"6",
			"title":"Java subsets solution",
			"vote":"32",
			"content":"public class Solution {\\n    \\n    \\n    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n       \\n        if(S.length == 0){\\n            return result;\\n        }\\n        \\n        Arrays.sort(S);\\n        dfs(S, 0, new ArrayList<Integer>(), result);\\n        return result;\\n    }\\n    \\n    public void dfs(int[] s, int index, List<Integer> path, List<List<Integer>> result){\\n        result.add(new ArrayList<Integer>(path));\\n        \\n        for(int i = index; i < s.length; i++){\\n            path.add(s[i]);\\n            dfs(s, i+1, path, result);\\n            path.remove(path.size()-1);\\n        }\\n    }\\n    \\n    \\n}"
		},
		{
			"lc_ans_id":"27294",
			"view":"2133",
			"top":"7",
			"title":"Simple iteration (no recursion, no twiddling) + explanation",
			"vote":"20",
			"content":"My idea was to start out with an empty subset and either take or don't take the next element in the input array. Here's how it goes down for input `[1,2,3]`:\\n\\nstart with\\n\\n    [] // empty set is always a subset\\n\\nthen either take or not take the next element (`1`), this doubles the result size:\\n\\n    []   // not take 1\\n    [1] //      take 1 + new\\n\\nthen take or not take the next element: `2`\\n\\n    []    // not take 1, not take 2\\n    [2]   // not take 1,     take 2 + new\\n    [1]   //     take 1, not take 2\\n    [1,2] //     take 1,     take 2 + new\\n\\nand finally take or not take `3`.\\n\\n    []      // not take 1, not take 2, not take 3\\n    [3]     // not take 1, not take 2,     take 3 + new\\n    [2]     // not take 1,     take 2, not take 3\\n    [2,3]   // not take 1,     take 2,     take 3 + new\\n    [1]     //     take 1, not take 2, not take 3\\n    [1,3]   //     take 1, not take 2,     take 3 + new\\n    [1,2]   //     take 1,     take 2, not take 3\\n    [1,2,3] //     take 1,     take 2,     take 3 + new\\n\\nAnd we're done, we have all `2^3 = 8` subsets generated.\\n\\nIt is possible to generate these with a simple loop, there's only one trick here, the variable `size`. It's usually a good practice to cache method call results, but now it is cached for a different reason: because it changes in every iteration. If we don't want to end up with an infinite loop, we have to remember how many `results` were available in the previous iteration, which is exactly the `size()` of the `result` at the beginning of the current iteration.\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums); // make sure subsets are ordered\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>()); // start with empty set\\n        for (int i = 0; i < nums.length; ++i) {\\n            for (int j = 0, size = result.size(); j < size; ++j) { // remember\\n                List<Integer> subset = new ArrayList<>(result.get(j)); // copy a new one\\n                subset.add(nums[i]); // expand\\n                result.add(subset); // collect\\n            }\\n        }\\n        return result;\\n    }\\n\\nIt is also necessary to order the input to satisfy the requirement:\\n\\n> * Elements in a subset must be in non-descending order.\\n\\nBecause `i` is increasing it means that whatever we take from nums will also be in increasing order.\\n\\nThe other requirement:\\n\\n> * The solution set must not contain duplicate subsets.\\n\\nis automatically guaranteed by the input specification and the algorithm walking indices straight and once:\\n\\n> Given a set of **distinct** integers, `nums`, return all possible subsets. *[emphasis mine]*"
		},
		{
			"lc_ans_id":"27485",
			"view":"1901",
			"top":"8",
			"title":"Share my 12-line simple java code with brief explanations",
			"vote":"13",
			"content":"    /*\\n        dfs. \\u6bcf\\u4e2a\\u4f4d\\u7f6e\\u90fd\\u6709\\u9009\\u4e0e\\u4e0d\\u9009\\u4e24\\u4e2a\\u9009\\u9879, \\u4e5f\\u53ef\\u4ee5\\u770b\\u6210\\u904d\\u5386\\u4e00\\u68f5\\u4e8c\\u53c9\\u6811, \\u5411\\u5de6\\u8d70\\u9009, \\u5411\\u53f3\\u8d70\\u4e0d\\u9009\\n    */\\n    public class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums == null) { return ans; }\\n            Arrays.sort(nums);  // non-descending order\\n            dfs(ans, nums, new ArrayList<Integer>(), 0);\\n            return ans; \\n        }\\n        \\n        private void dfs(List<List<Integer>> ans, int[] nums, List<Integer> list, int index) {\\n            if (index == nums.length) { ans.add(new ArrayList<Integer>(list)); return; }\\n            dfs(ans, nums, list, index+1);  // not pick the number at this index\\n            list.add(nums[index]);\\n            dfs(ans, nums, list, index+1);  // pick the number at this index\\n            list.remove(list.size()-1);\\n        }\\n    }"
		},
		{
			"lc_ans_id":"27550",
			"view":"2307",
			"top":"9",
			"title":"Very simple and fast java solution with explanation",
			"vote":"13",
			"content":"\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        for (int i = pos; i < n.length; i++) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe idea is use pos to keep track of the index of the array. Compare to other backracking problem like combinations, the condition that each single List adds to the List<List<Integer>> is when the index of the array is valid. Meanwhile, after adding to the List<List<Integer>> , keeping going for the for loop.\\n\\n\\n----------\\nthe following is the combinations I wrote, which is very similar to this problem.\\n\\n        public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 1, n, k);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int n, int k) {\\n        if (each.size() == k) {\\n            res.add(each);\\n            return;\\n        }\\n        for (int i = pos; i <= n; i++) {\\n            each.add(i);\\n            helper(res, new ArrayList<>(each), i + 1, n, k);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }"
		}
	],
	"id":"78",
	"title":"Subsets",
	"content":"<p>\r\nGiven a set of <b>distinct</b> integers, <i>nums</i>, return all possible subsets (the power set).\r\n</p>\r\n<p><b>Note:</b> The solution set must not contain duplicate subsets.\r\n</p>\r\n<p>\r\nFor example,<br />\r\nIf <b><i>nums</i></b> = <code>[1,2,3]</code>, a solution is:\r\n</p>\r\n\r\n<pre>\r\n[\r\n  [3],\r\n  [1],\r\n  [2],\r\n  [1,2,3],\r\n  [1,3],\r\n  [2,3],\r\n  [1,2],\r\n  []\r\n]\r\n</pre>",
	"frequency":"419",
	"ac_num":"211652"
}