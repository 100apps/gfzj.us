{
	"difficulty":"3",
	"submit_num":"317306",
	"show_id":"97",
	"leetcode_id":"97",
	"answers":[
		{
			"lc_ans_id":"31879",
			"view":"19445",
			"top":"0",
			"title":"My DP solution in C++",
			"vote":"162",
			"content":" \\n\\n     bool isInterleave(string s1, string s2, string s3) {\\n        \\n        if(s3.length() != s1.length() + s2.length())\\n            return false;\\n        \\n        bool table[s1.length()+1][s2.length()+1];\\n        \\n        for(int i=0; i<s1.length()+1; i++)\\n            for(int j=0; j< s2.length()+1; j++){\\n                if(i==0 && j==0)\\n                    table[i][j] = true;\\n                else if(i == 0)\\n                    table[i][j] = ( table[i][j-1] && s2[j-1] == s3[i+j-1]);\\n                else if(j == 0)\\n                    table[i][j] = ( table[i-1][j] && s1[i-1] == s3[i+j-1]);\\n                else\\n                    table[i][j] = (table[i-1][j] && s1[i-1] == s3[i+j-1] ) || (table[i][j-1] && s2[j-1] == s3[i+j-1] );\\n            }\\n            \\n        return table[s1.length()][s2.length()];\\n    }\\n    \\n\\n\\nHere is some explanation:\\n\\nDP table represents if s3 is interleaving at (i+j)th position when s1 is at ith position, and s2 is at jth position. 0th position means empty string.\\n\\nSo if both s1 and s2 is currently empty, s3 is empty too, and it is considered interleaving. If only s1 is empty, then if previous s2 position is interleaving and current s2 position char is equal to s3 current position char, it is considered interleaving. similar idea applies to when s2 is empty. when both s1 and s2 is not empty, then if we arrive i, j from i-1, j, then if i-1,j is already interleaving and i and current s3 position equal, it s interleaving. If we arrive i,j from i, j-1, then if i, j-1 is already interleaving and j and current s3 position equal. it is interleaving."
		},
		{
			"lc_ans_id":"31948",
			"view":"8678",
			"top":"1",
			"title":"8ms C++ solution using BFS, with explanation",
			"vote":"122",
			"content":"If we expand the two strings s1 and s2 into a chessboard, then this problem can be transferred into a path seeking problem from the top-left corner to the bottom-right corner. The key is, each cell (y, x) in the board corresponds to an interval between y-th character in s1 and x-th character in s2. And adjacent cells are connected with like a grid. A BFS can then be efficiently performed to find the path.\\n\\nBetter to illustrate with an example here:\\n\\nSay s1 = \"aab\" and s2 = \"abc\". s3 = \"aaabcb\". Then the board looks like\\n\\n    o--a--o--b--o--c--o\\n    |     |     |     |\\n    a     a     a     a\\n    |     |     |     |\\n    o--a--o--b--o--c--o\\n    |     |     |     |\\n    a     a     a     a\\n    |     |     |     |\\n    o--a--o--b--o--c--o\\n    |     |     |     |\\n    b     b     b     b\\n    |     |     |     |\\n    o--a--o--b--o--c--o\\n\\nEach \"o\" is a cell in the board. We start from the top-left corner, and try to move right or down. If the next char in s3 matches the edge connecting the next cell, then we're able to move. When we hit the bottom-right corner, this means s3 can be represented by interleaving s1 and s2. One possible path for this example is indicated with \"x\"es below:\\n\\n    x--a--x--b--o--c--o\\n    |     |     |     |\\n    a     a     a     a\\n    |     |     |     |\\n    o--a--x--b--o--c--o\\n    |     |     |     |\\n    a     a     a     a\\n    |     |     |     |\\n    o--a--x--b--x--c--x\\n    |     |     |     |\\n    b     b     b     b\\n    |     |     |     |\\n    o--a--o--b--o--c--x\\n\\nNote if we concatenate the chars on the edges we went along, it's exactly s3. And we went through all the chars in s1 and s2, in order, exactly once.\\n\\nTherefore if we view this board as a graph, such path finding problem is trivial with BFS. I use an `unordered_map` to store the visited nodes, which makes the code look a bit complicated. But a `vector` should be enough to do the job. \\n\\nAlthough the worse case timeis also O(mn), typically it doesn't require us to go through every node to find a path. Therefore it's faster than regular DP than average.\\n\\n    struct MyPoint {\\n        int y, x; \\n        bool operator==(const MyPoint &p) const {\\n            return p.y == y && p.x == x;\\n        }\\n    };\\n    namespace std {\\n        template <>\\n        struct hash<MyPoint> {\\n            size_t operator () (const MyPoint &f) const {\\n                return (std::hash<int>()(f.x) << 1) ^ std::hash<int>()(f.y);\\n            }\\n        };\\n    }\\n    \\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            if (s1.size() + s2.size() != s3.size()) return false;\\n\\n            queue<MyPoint> q;\\n            unordered_set<MyPoint> visited;\\n            bool isSuccessful = false;\\n            int i = 0;\\n    \\n            q.push(MyPoint { 0, 0 });\\n            q.push(MyPoint { -1, -1 });\\n            while (!(1 == q.size() && -1 == q.front().x)) {\\n                auto p = q.front();\\n                q.pop();\\n                if (p.y == s1.size() && p.x == s2.size()) {\\n                    return true;\\n                }\\n                if (-1 == p.y) {\\n                    q.push(p);\\n                    i++;\\n                    continue;\\n                }\\n                if (visited.find(p) != visited.end()) { continue; }\\n                visited.insert(p);\\n    \\n                if (p.y < s1.size()) { // down\\n                    if (s1[p.y] == s3[i]) { q.push(MyPoint { p.y + 1, p.x }); }\\n                }\\n                if (p.x < s2.size()) { // right \\n                    if (s2[p.x] == s3[i]) { q.push(MyPoint { p.y, p.x + 1 }); }\\n                }\\n            }\\n            return false;\\n        }\\n    };"
		},
		{
			"lc_ans_id":"32078",
			"view":"9270",
			"top":"2",
			"title":"DP Solution in Java",
			"vote":"60",
			"content":"    public boolean isInterleave(String s1, String s2, String s3) {\\n\\n        if ((s1.length()+s2.length())!=s3.length()) return false;\\n\\n        boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1];\\n\\n        matrix[0][0] = true;\\n\\n        for (int i = 1; i < matrix[0].length; i++){\\n            matrix[0][i] = matrix[0][i-1]&&(s1.charAt(i-1)==s3.charAt(i-1));\\n        }\\n\\n        for (int i = 1; i < matrix.length; i++){\\n            matrix[i][0] = matrix[i-1][0]&&(s2.charAt(i-1)==s3.charAt(i-1));\\n        }\\n\\n        for (int i = 1; i < matrix.length; i++){\\n            for (int j = 1; j < matrix[0].length; j++){\\n                matrix[i][j] = (matrix[i-1][j]&&(s2.charAt(i-1)==s3.charAt(i+j-1)))\\n                        || (matrix[i][j-1]&&(s1.charAt(j-1)==s3.charAt(i+j-1)));\\n            }\\n        }\\n\\n        return matrix[s2.length()][s1.length()];\\n\\n    }"
		},
		{
			"lc_ans_id":"31888",
			"view":"4807",
			"top":"3",
			"title":"1ms tiny DFS beats 94.57%",
			"vote":"45",
			"content":"To solve this problem, let's look at if `s1[0 ~ i]`  `s2[0 ~ j]` can be interleaved to `s3[0 ~ k]`.\\n\\n- Start from indices`0, 0, 0` and compare `s1[i] == s3[k]` or `s2[j] == s3[k]`\\n- Return valid only if either `i` or `j` match `k` and the remaining is also valid\\n- Caching is the key to performance. This is very similar to top down dp\\n- Only need to cache `invalid[i][j]` since most of the case `s1[0 ~ i]` and `s2[0 ~ j]` does not form `s3[0 ~ k]`. Also tested caching `valid[i][j]` the run time is also `1ms`\\n- Many guys use `substring` but it's duplicate code since `substring` itself is checking char by char. We are already doing so\\n\\n\\nHope it helps!\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        char[] c1 = s1.toCharArray(), c2 = s2.toCharArray(), c3 = s3.toCharArray();\\n    \\tint m = s1.length(), n = s2.length();\\n    \\tif(m + n != s3.length()) return false;\\n    \\treturn dfs(c1, c2, c3, 0, 0, 0, new boolean[m + 1][n + 1]);\\n    }\\n    \\n    public boolean dfs(char[] c1, char[] c2, char[] c3, int i, int j, int k, boolean[][] invalid) {\\n    \\tif(invalid[i][j]) return false;\\n    \\tif(k == c3.length) return true;\\n    \\tboolean valid = \\n    \\t    i < c1.length && c1[i] == c3[k] && dfs(c1, c2, c3, i + 1, j, k + 1, invalid) || \\n            j < c2.length && c2[j] == c3[k] && dfs(c1, c2, c3, i, j + 1, k + 1, invalid);\\n    \\tif(!valid) invalid[i][j] = true;\\n        return valid;\\n    }"
		},
		{
			"lc_ans_id":"31885",
			"view":"2494",
			"top":"4",
			"title":"Python DP solutions (O(m*n), O(n) space), BFS, DFS.",
			"vote":"26",
			"content":"    \\n    # O(m*n) space\\n    def isInterleave1(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        dp = [[True for _ in xrange(c+1)] for _ in xrange(r+1)]\\n        for i in xrange(1, r+1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        for j in xrange(1, c+1):\\n            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, r+1):\\n            for j in xrange(1, c+1):\\n                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or \\\\\\n                   (dp[i][j-1] and s2[j-1] == s3[i-1+j])\\n        return dp[-1][-1]\\n\\n    # O(2*n) space\\n    def isInterleave2(self, s1, s2, s3):\\n        l1, l2, l3 = len(s1)+1, len(s2)+1, len(s3)+1\\n        if l1+l2 != l3+1:\\n            return False\\n        pre = [True for _ in xrange(l2)]\\n        for j in xrange(1, l2):\\n            pre[j] = pre[j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, l1):\\n            cur = [pre[0] and s1[i-1] == s3[i-1]] * l2\\n            for j in xrange(1, l2):\\n                cur[j] = (cur[j-1] and s2[j-1] == s3[i+j-1]) or \\\\\\n                         (pre[j] and s1[i-1] == s3[i+j-1])\\n            pre = cur[:]\\n        return pre[-1]\\n    \\n    # O(n) space\\n    def isInterleave3(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        dp = [True for _ in xrange(c+1)] \\n        for j in xrange(1, c+1):\\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, r+1):\\n            dp[0] = (dp[0] and s1[i-1] == s3[i-1])\\n            for j in xrange(1, c+1):\\n                dp[j] = (dp[j] and s1[i-1] == s3[i-1+j]) or (dp[j-1] and s2[j-1] == s3[i-1+j])\\n        return dp[-1]\\n        \\n    # DFS \\n    def isInterleave4(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        stack, visited = [(0, 0)], set((0, 0))\\n        while stack:\\n            x, y = stack.pop()\\n            if x+y == l:\\n                return True\\n            if x+1 <= r and s1[x] == s3[x+y] and (x+1, y) not in visited:\\n                stack.append((x+1, y)); visited.add((x+1, y))\\n            if y+1 <= c and s2[y] == s3[x+y] and (x, y+1) not in visited:\\n                stack.append((x, y+1)); visited.add((x, y+1))\\n        return False\\n                \\n    # BFS \\n    def isInterleave(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        queue, visited = [(0, 0)], set((0, 0))\\n        while queue:\\n            x, y = queue.pop(0)\\n            if x+y == l:\\n                return True\\n            if x+1 <= r and s1[x] == s3[x+y] and (x+1, y) not in visited:\\n                queue.append((x+1, y)); visited.add((x+1, y))\\n            if y+1 <= c and s2[y] == s3[x+y] and (x, y+1) not in visited:\\n                queue.append((x, y+1)); visited.add((x, y+1))\\n        return False"
		},
		{
			"lc_ans_id":"31907",
			"view":"5717",
			"top":"5",
			"title":"My Accepted Java Recursive Solution for interleaving string",
			"vote":"22",
			"content":"    public class Solution {\\n      \\tprivate static Set<Integer> visited; // The combination of i1, i2 has been visited and return false\\n    \\tpublic static boolean isInterleave(String s1, String s2, String s3) {\\n    \\t\\tif(s3.length() != s1.length() + s2.length())\\n    \\t\\t\\treturn false;\\n    \\t\\tvisited = new HashSet<Integer>();\\n    \\t\\treturn isInterleave(s1, 0, s2, 0, s3, 0);\\n    \\t}\\n    \\t\\n    \\tprivate static boolean isInterleave(String s1, int i1, String s2, int i2, String s3, int i3)\\n    \\t{\\t\\n    \\t\\tint hash = i1 * s3.length() + i2;\\n    \\t\\tif(visited.contains(hash))\\n    \\t\\t\\treturn false;\\n    \\t\\t\\n    \\t\\tif(i1 == s1.length())\\n    \\t\\t\\treturn s2.substring(i2).equals(s3.substring(i3));\\n    \\t\\tif(i2 == s2.length())\\n    \\t\\t\\treturn s1.substring(i1).equals(s3.substring(i3));\\n    \\t\\t\\n    \\t\\tif(s3.charAt(i3) == s1.charAt(i1) && isInterleave(s1, i1+1, s2, i2, s3, i3+1) ||\\n    \\t\\t   s3.charAt(i3) == s2.charAt(i2) && isInterleave(s1, i1, s2, i2+1, s3, i3+1))\\n    \\t\\t\\treturn true;\\n    \\t\\t\\n    \\t\\tvisited.add(hash);\\n    \\t\\treturn false;\\n    \\t}\\n    }\\n\\nThe private method isInterleave is the recursive method. it takes additional i1, i2, i3 as the start indexes of s1, s2, s3, so it solves the substring of s1, s2, s3 with those start indexes. \\n\\nThe recursion starting condition is i1, i2, i3 are set to 0, means it solves the whole string. \\n\\nin each recursion, it will just check the first character in s3 with s2 and s1, if it equals s1, it will increase i3 and i1 to solve remain, if remain return true, this recursion will also return true. Same logic for s2.\\n\\nThe end condition is when remain of either s1 or s2 is empty, then just compare remain of s3 with remain of s1 or s2, if they are equal, it will return true.\\n\\nA pure recursive solution will cause time limit exceed. We can optimize it by caching the false visited solutions in the visited set. That will short circuit many repeated search path."
		},
		{
			"lc_ans_id":"31904",
			"view":"2735",
			"top":"6",
			"title":"Summary of solutions, BFS, DFS, DP",
			"vote":"16",
			"content":"## BFS solution (6ms)\\n\\nImagine a grid, which x-axis and y-axis are s1 and s2, matching s3 is the same as\\nfinding a path from (0,0) to (len1, len2). It actually becomes a\\nBFS on grid. Since we don't need exact paths, a HashSet of\\ncoordinates is used to eliminate duplicated paths.\\n\\n    public class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            int len1 = s1.length(),\\n                len2 = s2.length(),\\n                len3 = s3.length();\\n            if (len1 + len2 != len3) return false;\\n            Deque<Integer> queue = new LinkedList<>();\\n            int matched = 0;\\n            queue.offer(0);\\n            Set<Integer> set = new HashSet<>();\\n            while (queue.size() > 0 && matched < len3) {\\n                int size = queue.size();\\n                for (int i = 0; i < size; i++) {\\n                    int p1 = queue.peek() / len3,\\n                        p2 = queue.peek() % len3;\\n                    queue.poll();\\n                    if (p1 < len1 && s1.charAt(p1) == s3.charAt(matched)) {\\n                        int key = (p1 + 1) * len3 + p2;\\n                        if (!set.contains(key)) {\\n                            set.add(key);\\n                            queue.offer(key);\\n                        }\\n                    }\\n                    if (p2 < len2 && s2.charAt(p2) == s3.charAt(matched)) {\\n                        int key = p1 * len3 + (p2 + 1);\\n                        if (!set.contains(key)) {\\n                            set.add(key);\\n                            queue.offer(key);\\n                        }\\n                    }\\n                }\\n                matched++;\\n            }\\n            return queue.size() > 0 && matched == len3;\\n        }\\n    }\\n\\n## DFS solution with memorization (2ms)\\n\\nThis looks slow but is actually faster than BFS! Think about it carefully, in this\\nparticular problem, search always ends at the same depth. DFS with memorization\\nsearches about the same amount of paths with the same length as BFS, if it is doesn't\\nterminate on the first path found. Without the queue operations, the overall cost\\nis only smaller if we don't count call stack. The most significant runtime reducer is\\nprobably the early termination\\n\\n    public class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            if (s1.length() + s2.length() != s3.length()) return false;\\n            HashSet<Integer> cache = new HashSet<Integer>();\\n            return isInterleave0(s1, s2, s3, 0, 0, cache);\\n        }\\n\\n        private boolean isInterleave0(String s1, String s2, String s3, int p1, int p2, HashSet<Integer> cache) {\\n            if (p1 + p2 == s3.length())\\n                return true;\\n            if (cache.contains(p1 * s3.length() + p2))\\n                return false;\\n            // no need to store actual result.\\n            // if we found the path, we have already terminated.\\n            cache.add(p1 * s3.length() + p2);\\n            boolean match1 = p1 < s1.length() && s3.charAt(p1 + p2) == s1.charAt(p1);\\n            boolean match2 = p2 < s2.length() && s3.charAt(p1 + p2) == s2.charAt(p2);\\n            if (match1 && match2)\\n                return isInterleave0(s1, s2, s3, p1 + 1, p2, cache) ||\\n                       isInterleave0(s1, s2, s3, p1, p2 + 1, cache);\\n            else if (match1)\\n                return isInterleave0(s1, s2, s3, p1 + 1, p2, cache);\\n            else if (match2)\\n                return isInterleave0(s1, s2, s3, p1, p2 + 1, cache);\\n            else\\n                return false;\\n        }\\n    }\\n\\n## 2d DP solution (6ms)\\n\\nIt's an interesting practice. There are further optimization could be done to\\nreduce cache matrix to 1d. However doing DP for this problem is tedious and not\\nseem to worth the trouble.\\n\\n    public class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            int len1 = s1.length(),\\n                len2 = s2.length(),\\n                len3 = s3.length();\\n            if (len1 + len2 != len3) return false;\\n            // cache[i][j] == true means first i + j chars are matched by\\n            // first j chars from s1 and first i chars from s2\\n            boolean[][] cache = new boolean[len2 + 1][len1 + 1];\\n            cache[0][0] = true; // empty and empty matches empty\\n            int m3 = 1; // matched length, m1 and m2 are similar\\n            while (m3 <= len3) {\\n                // this loop fill in cache matrix from left-top to right-bottom, diagonally.\\n                // note that loop conditions are pretty tricky here.\\n                for (int m1 = Math.max(m3 - len2, 0); m1 <= len1 && m1 <= m3; m1++) {\\n                    int m2 = m3 - m1;\\n                    cache[m2][m1] =\\n                        m1 > 0 && cache[m2][m1 - 1] && s3.charAt(m3 - 1) == s1.charAt(m1 - 1) ||\\n                        m2 > 0 && cache[m2 - 1][m1] && s3.charAt(m3 - 1) == s2.charAt(m2 - 1);\\n                }\\n                m3++;\\n            }\\n            return cache[len2][len1];\\n        }\\n    }"
		},
		{
			"lc_ans_id":"32083",
			"view":"1916",
			"top":"7",
			"title":"My solution in java using dp, time O(n*m) and space O(m)",
			"vote":"11",
			"content":"Using dp to tracking select i-th seq and j-th seq in s1 and s2 could match i+j+2 th seq in s3\\n\\n 1. init optimal[0][*] by check no select from s1\\n 2. init optimal[*][0] by check no select from s2\\n 3. do search for every i-th and j-th, could match when meet one of the following two cases:\\n1. if i-th char in s2 equals to the (i+j+1)th char in s3, and previous j-th in s2 is matched without i-th char\\n2. if j-th char in s1 equals to the (i+j+1)th char in s3, and previous j-1th in s2 is matched with i-th char\\n 4. a straight-forward solution should be Time: O(n*m), and Space: O(n*m). And space could optimize since optimal[i+1][*] only depends on optimal[i][*], so could use Space O(m)\\n\\n\\n----------\\nJava code as following:\\n\\n    public static boolean isInterleaveOptz(String s1, String s2, String s3) {\\n        if (s3.length() != s1.length() + s2.length()) return false;\\n\\n        boolean[] optimal = new boolean[s2.length() + 1];    //dp optimal\\n        optimal[0] = true;\\n        for (int j = 0; j < s2.length(); j++) { //check no s1 char is selected, if s2 could equals to s3\\n            if (optimal[j] && s2.charAt(j) == s3.charAt(j)) optimal[j + 1] = true;\\n        }\\n\\n        for (int i = 0; i < s1.length(); i++) { //check select i-th char in s1\\n            if (optimal[0] && s1.charAt(i) == s3.charAt(i)) optimal[0] = true;    //no char in s2 is selected\\n            else optimal[0] = false;\\n            for (int j = 0; j < s2.length(); j++) {  //select j-th char\\n                if ((s1.charAt(i) == s3.charAt(i + j + 1) && optimal[j + 1]) ||\\n                        s2.charAt(j) == s3.charAt(i + j + 1) && optimal[j]) {\\n                    optimal[j + 1] = true;\\n                } else optimal[j + 1] = false;\\n            }\\n        }\\n        return optimal[s2.length()];\\n    }"
		},
		{
			"lc_ans_id":"32051",
			"view":"844",
			"top":"8",
			"title":"My dp C++ solution is only 10 lines with O(n) space!",
			"vote":"8",
			"content":"\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int m = s1.size(), n = s2.size();\\n            if(m+n != s3.size())  return false;\\n            bool c[n+1] = {true};\\n            int i, j = 0;\\n            while(j < n && s2[j] == s3[j]) c[++j] = true;\\n            for(i = 0; i < m; ++i) {\\n                c[0] = c[0] & (s1[i] == s3[i]);\\n                for(j = 1; j <= n; ++j)\\n                    c[j] = ((s1[i] == s3[i+j]) & c[j]) | ((s2[j-1] == s3[i+j]) & c[j-1]);\\n            }\\n            return c[n];\\n        }\\n    };"
		},
		{
			"lc_ans_id":"31910",
			"view":"1023",
			"top":"9",
			"title":"4ms recursive java",
			"vote":"7",
			"content":"    public class Solution {\\n        Set<String> mem = new HashSet<String>();\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            if(s1.length() == 0 && s2.length() == 0 && s3.length() == 0)\\n                return true;\\n            if(mem.contains(s1+\"#\"+s2)) \\n                return false;\\n            if(s3.length() > 0){\\n                if(s1.length() > 0 &&  s1.charAt(0) == s3.charAt(0))\\n                    if(isInterleave(s1.substring(1),s2,s3.substring(1))) return true;\\n                if(s2.length() > 0 && s2.charAt(0) == s3.charAt(0))\\n                    if(isInterleave(s1,s2.substring(1),s3.substring(1))) return true;\\n            }\\n            mem.add(s1+\"#\"+s2);\\n            return false;\\n        }\\n    }"
		}
	],
	"id":"97",
	"title":"Interleaving String",
	"content":"<p>\r\nGiven <i>s1</i>, <i>s2</i>, <i>s3</i>, find whether <i>s3</i> is formed by the interleaving of <i>s1</i> and <i>s2</i>.\r\n</p>\r\n\r\n<p>\r\nFor example,<br />\r\nGiven:<br />\r\n<i>s1</i> = <code>\"aabcc\"</code>,<br />\r\n<i>s2</i> = <code>\"dbbca\"</code>,\r\n</p>\r\n<p>\r\nWhen <i>s3</i> = <code>\"aadbbcbcac\"</code>, return true.<br />\r\nWhen <i>s3</i> = <code>\"aadbbbaccc\"</code>, return false.\r\n</p>",
	"frequency":"365",
	"ac_num":"79465"
}