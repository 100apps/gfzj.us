{
	"difficulty":"3",
	"submit_num":"273440",
	"show_id":"99",
	"leetcode_id":"99",
	"answers":[
		{
			"lc_ans_id":"32535",
			"view":"49206",
			"top":"0",
			"title":"No Fancy Algorithm, just Simple and Powerful In-Order Traversal",
			"vote":"364",
			"content":"This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here. \\n\\nLet's start by writing the in order traversal:\\n\\n    private void traverse (TreeNode root) {\\n       if (root == null)\\n          return;\\n       traverse(root.left);\\n       // Do some business\\n       traverse(root.right);\\n    }\\n\\nSo when we need to print the node values in order, we insert System.out.println(root.val) in the place of \"Do some business\".\\n\\nWhat is the business we are doing here?\\nWe need to find the first and second elements that are not in order right?\\n\\nHow do we find these two elements? For example, we have the following tree that is printed as in order traversal:\\n\\n6, 3, 4, 5, 2\\n\\nWe compare each node with its next one and we can find out that 6 is the first element to swap because 6 > 3 and 2 is the second element to swap because 2 < 5.\\n\\nReally, what we are comparing is the current node and its previous node in the \"in order traversal\". \\n\\nLet us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the \"do some business\" logic as finding the two elements. See the code below:\\n\\n    public class Solution {\\n        \\n        TreeNode firstElement = null;\\n        TreeNode secondElement = null;\\n        // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized\\n        TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);\\n        \\n        public void recoverTree(TreeNode root) {\\n            \\n            // In order traversal to find the two elements\\n            traverse(root);\\n            \\n            // Swap the values of the two nodes\\n            int temp = firstElement.val;\\n            firstElement.val = secondElement.val;\\n            secondElement.val = temp;\\n        }\\n        \\n        private void traverse(TreeNode root) {\\n            \\n            if (root == null)\\n                return;\\n                \\n            traverse(root.left);\\n            \\n            // Start of \"do some business\", \\n            // If first element has not been found, assign it to prevElement (refer to 6 in the example above)\\n            if (firstElement == null && prevElement.val >= root.val) {\\n                firstElement = prevElement;\\n            }\\n        \\n            // If first element is found, assign the second element to the root (refer to 2 in the example above)\\n            if (firstElement != null && prevElement.val >= root.val) {\\n                secondElement = root;\\n            }        \\n            prevElement = root;\\n\\n            // End of \"do some business\"\\n\\n            traverse(root.right);\\n    }\\n\\nAnd we are done, it is just that easy!"
		},
		{
			"lc_ans_id":"32559",
			"view":"14943",
			"top":"1",
			"title":"Detail Explain about How Morris Traversal Finds two Incorrect Pointer",
			"vote":"109",
			"content":"To understand this, you need to first understand Morris Traversal or Morris Threading Traversal.\\nIt take use of leaf nodes' right/left pointer to achieve O(1) space Traversal on a Binary Tree.\\nBelow is a standard Inorder Morris Traversal, referred from http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html (a Chinese Blog, while the graphs are great for illustration)\\n\\n    public void morrisTraversal(TreeNode root){\\n    \\t\\tTreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n\\nIn the above code, `System.out.println(root.val);`appear twice, which functions as outputing the Node in ascending order (BST). Since these places are in order, replace them with\\n\\n        if(pre!=null && pre.val > root.val){\\n        \\tif(first==null){first = pre;second = root;}\\n        \\telse{second = root;}\\n      }\\n    pre = root;\\n\\neach time, the pre node and root are in order as `System.out.println(root.val);` outputs them in order.\\n\\nThen, come to how to specify the first wrong node and second wrong node.\\n\\nWhen they are not consecutive, the first time we meet `pre.val > root.val` ensure us the first node is the pre node, since root should be traversal ahead of pre, pre should be at least at small as root. The second time we meet `pre.val > root.val` ensure us the second node is the root node, since we are now looking for a node to replace with out first node, which is found before.\\n\\nWhen they are consecutive, which means the case `pre.val > cur.val` will appear only once. We need to take case this case without destroy the previous analysis. So the first node will still be pre, and the second will be just set to root. Once we meet this case again, the first node will not be affected.\\n\\nBelow is the updated version on Morris Traversal.\\n\\n\\n    public void recoverTree(TreeNode root) {\\n            TreeNode pre = null;\\n            TreeNode first = null, second = null;\\n            // Morris Traversal\\n            TreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t    if(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t        if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t        else{second = root;}\\n    \\t\\t\\t\\t    }\\n    \\t\\t\\t\\t    pre = root;\\n    \\t\\t\\t\\t    \\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tif(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t    if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t    else{second = root;}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tpre = root;\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// swap two node values;\\n    \\t\\tif(first!= null && second != null){\\n    \\t\\t    int t = first.val;\\n    \\t\\t    first.val = second.val;\\n    \\t\\t    second.val = t;\\n    \\t\\t}\\n        }"
		},
		{
			"lc_ans_id":"32539",
			"view":"18211",
			"top":"2",
			"title":"Tree Deserializer and Visualizer for Python",
			"vote":"83",
			"content":"Wrote some tools for my own local testing. For example `deserialize('[1,2,3,null,null,4,null,null,5]')` will turn that into a tree and return the root [as explained in the FAQ](https://leetcode.com/faq/). I also wrote a visualizer. Two examples:\\n\\n`drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))`:\\n\\n![enter image description here][1]\\n\\n`drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))`:\\n\\n![enter image description here][2]\\n\\nHere's the code. If you save it as a Python script and run it, it should as a demo show the above two pictures in turtle windows (one after the other). And you can of course import it from other scripts and then it will only provide the class/functions and not show the demo.\\n\\n    class TreeNode:\\n        def __init__(self, val, left=None, right=None):\\n            self.val = val\\n            self.left = left\\n            self.right = right\\n        def __repr__(self):\\n            return 'TreeNode({})'.format(self.val)\\n        \\n    def deserialize(string):\\n        if string == '{}':\\n            return None\\n        nodes = [None if val == 'null' else TreeNode(int(val))\\n                 for val in string.strip('[]{}').split(',')]\\n        kids = nodes[::-1]\\n        root = kids.pop()\\n        for node in nodes:\\n            if node:\\n                if kids: node.left  = kids.pop()\\n                if kids: node.right = kids.pop()\\n        return root\\n    \\n    def drawtree(root):\\n        def height(root):\\n            return 1 + max(height(root.left), height(root.right)) if root else -1\\n        def jumpto(x, y):\\n            t.penup()\\n            t.goto(x, y)\\n            t.pendown()\\n        def draw(node, x, y, dx):\\n            if node:\\n                t.goto(x, y)\\n                jumpto(x, y-20)\\n                t.write(node.val, align='center', font=('Arial', 12, 'normal'))\\n                draw(node.left, x-dx, y-60, dx/2)\\n                jumpto(x, y-20)\\n                draw(node.right, x+dx, y-60, dx/2)\\n        import turtle\\n        t = turtle.Turtle()\\n        t.speed(0); turtle.delay(0)\\n        h = height(root)\\n        jumpto(0, 30*h)\\n        draw(root, 0, 30*h, 40*h)\\n        t.hideturtle()\\n        turtle.mainloop()\\n        \\n    if __name__ == '__main__':\\n        drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))\\n        drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))\\n\\n  [1]: http://pochmann.org/leetcode/images/tree1.png\\n  [2]: http://pochmann.org/leetcode/images/tree2.png"
		},
		{
			"lc_ans_id":"32562",
			"view":"4609",
			"top":"3",
			"title":"Share my solutions and detailed explanation with recursive/iterative in-order-traversal and Morris-traversal",
			"vote":"46",
			"content":"In-order traversal is really useful in BST. Following in-order traversal, we should have following order: prev.val < curr.val. If not, then we found at least one incorrectly placed node\\n\\nSo the basic idea is to visit the tree with in-order traversal and search for two swapped nodes. Then swap them back.\\n\\nNow the problem is if we found an incorrect pair where prev.val > curr.val, how do we know which node is the incorrect one?  The answer is it depends on whether we have found incorrect node before. So What is that?\\n\\nSince we get two elements that are swapped by mistake, there must be a smaller TreeNode get a larger value and a larger TreeNode get a smaller value.\\nTheir value are swapped, but the incorrect smaller node is still in smaller tree and incorrect larger node is still in larger tree. So we will visit the incorrect smaller node first, and this node will be detected when we compare its value with next.val, i.e.  when it is treated as prev node. The incorrect larger node will be detected when we compare its value with prev.val. We don't know if it is close or not close to incorrect smaller node, so we should continue search BST and update it if we found another incorrect node.\\n\\nTherefore if it is the first time we found an incorrect pair, the prev node must be the first incorrect node.\\nIf it is not the first time we found an incorrect pair, the curr node must be the second incorrect node, though\\nwe may have corner case that two incorrect nodes are in same pair.\\n\\nRecursive in-order traversal based on above idea:\\n\\n    public void recoverTree(TreeNode root) {\\n        //use inorder traversal to detect incorrect node\\n        \\n        inOrder(root);\\n        \\n\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    TreeNode prev = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void inOrder(TreeNode root){\\n        if(root == null) return;\\n        //search left tree\\n        inOrder(root.left);\\n        \\n        //in inorder traversal of BST, prev should always have smaller value than current value\\n        if(prev != null && prev.val >= root.val){\\n            //incorrect smaller node is always found as prev node\\n            if(first == null) first = prev;\\n          //incorrect larger node is always found as curr(root) node\\n            second = root;\\n        }\\n        \\n        \\n        //update prev node\\n        prev = root;\\n\\n        //search right tree\\n        inOrder(root.right);\\n    }\\n\\n\\niterative in-order traversal based on above idea:\\n\\n\\n    public void recoverTree(TreeNode root) {\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        while(!stack.isEmpty() ||  curr != null){\\n            if(curr != null){\\n                //visit curr's left subtree\\n                stack.push(curr);\\n                curr = curr.left;\\n            }else{\\n                //done left subtree of curr Node\\n                curr = stack.pop();\\n                \\n                //compare curr.val with prev.val if we have one\\n                if(prev != null && curr.val <= prev.val){\\n                    //incorrect smaller node is always found as prev node\\n                    if(first == null) first = prev;\\n                    //incorrect larger node is always found as curr node\\n                    second = curr;         \\n                }  \\n                \\n                //visit curr's right subtree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        //recover swapped nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\nBoth recursive and iterative will occupy O(n) space in worst case, in which the tree is like a LinkedList\\n\\nTo reduce the space to constant space, we have to use Morris-traversal.\\n\\nMorris-traversal is similar to recursive/iterative traversal, but we need to modify the tree structure during the\\ntraversal.  before we visiting the left tree of a root, we will build a back-edge between rightmost node in left tree and the root. So we can go back to the root node after we are done with the left tree. Then we locate the rightmost node in left subtree again, cut the back-edge, recover the tree structure and start visit right subtree. The detection of two incorrect TreeNodes is similar to iterative/recursive in-order traversal.\\nWe don't use extra data structure here, so the space complexity is reduced to O(1) and the time complexity will be O(n)\\n\\nMorris-traversal based on above description:\\n\\n    public void recoverTree(TreeNode root) {\\n    \\t//Morris-traversal\\n    \\t\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode pred = null; //rightmost node in left tree\\n        TreeNode prev = null; \\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            //for each node, we compare it with prev node as we did in in-order-traversal\\n            if(prev != null && curr.val <= prev.val){\\n                if(first == null) first = prev;\\n                second = curr;\\n            }\\n            \\n            if(curr.left != null){\\n                //got left tree, then let's locate its rightmost node in left tree\\n                pred = curr.left;\\n                //we may have visited the left tree before, and connect the rightmost node with curr node (root node)\\n                while(pred.right != null && pred.right != curr){\\n                    pred = pred.right;\\n                }\\n                \\n                if(pred.right == curr){\\n                    //if this left tree has been visited before, then we are done with it\\n                    //cut the connection with currNode and start visit curr's right tree\\n                    pred.right = null;\\n                    prev = curr;\\n                    curr = curr.right;\\n                }else{\\n                    //if this left tree has not been visited before, then we create a back edge from rightmost node\\n                    // to curr node, so we can return to the start point after done the left tree\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n                \\n            }else{\\n                //no left tree, then just visit its right tree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }"
		},
		{
			"lc_ans_id":"32580",
			"view":"4448",
			"top":"4",
			"title":"[recommend for beginners]clean C++ implementation with detailed explaination",
			"vote":"17",
			"content":"Just use the \"first\" and \"second\" pointer to find the 2 nodes that violate the order. Then change the value of the first node ad the second node by their value.\\n\\n    class Solution {\\n        TreeNode* first=NULL;\\n        TreeNode* second=NULL;\\n        TreeNode* prev = new TreeNode(INT_MIN);\\n    public:\\n        void recoverTree(TreeNode* root) {\\n            help(root);\\n            swp(first->val, second->val);\\n        }\\n        \\n        void help(TreeNode* root){\\n            if(root==NULL)  return;\\n            help(root->left);\\n            if(first==NULL && prev->val >= root->val)   first=prev;\\n            if(first!=NULL && prev->val >= root->val)   second=root;\\n            prev=root;\\n            help(root->right);\\n        }\\n    };"
		},
		{
			"lc_ans_id":"32650",
			"view":"1631",
			"top":"5",
			"title":"Share My java Solution using Morris Traversal",
			"vote":"12",
			"content":"The Key idea is to use Morris Traversal which only uses O(1) Space. Here is my code and comments.\\nThe code just uses the variable root as the current node.\\n\\n    public class Solution {\\n      public void recoverTree(TreeNode root) {  \\n    \\n        TreeNode first = null;     // first node need to be swap\\n        TreeNode second = null;    // second node need to be swap\\n        TreeNode pre = new TreeNode(Integer.MIN_VALUE);  //previous node.\\n    \\n        while(root!=null){\\n          TreeNode node = root.left;\\n    \\n          // If left is not null, we need to find the rightmost node of left subtree,\\n          // Set its right child to current node\\n          if(node!=null){ \\n         \\n            //find the rightmost\\n            while(node.right!=null && node.right != root){\\n              node = node.right;\\n            }\\n    \\n            //There are two cases,\\n            //null: first time we access current, set node.right to current and move to left child of current and continue;\\n            //current: we accessed current before, thus we've finished traversing left subtree, set node.right back to null;\\n            if(node.right == null){\\n              node.right = root;\\n              root = root.left;\\n              continue;\\n            }else{\\n              node.right = null;\\n            }\\n          }\\n    \\n          // compare current node with previous node\\n          if(root.val < pre.val ){\\n            // first time we enconter reversed order, we set previous node to first\\n            if( first == null ){\\n              first = pre;\\n            }\\n            //In case that two nodes are successive, we set second to current every time.\\n            second = root;\\n          }\\n          pre = root;\\n          root = root.right;      \\n        }\\n    \\n        //swap the value;\\n        int temp = second.val;\\n        second.val = first.val;\\n        first.val = temp;\\n      }\\n    }"
		},
		{
			"lc_ans_id":"32613",
			"view":"2254",
			"top":"6",
			"title":"REAL O(1) Space (No recursion/No stack, etc) O(n) Time solution. 48ms C++",
			"vote":"10",
			"content":"Someone complained that a recursion solution isn't really a O(1) space solution. Ok, here comes the real O(1) solution. No recursion, no stack. Pure Morris traversal. 48 ms, C++ :\\n\\n    class Solution {\\n            TreeNode * wrong_node0 = nullptr, * wrong_node1 = nullptr, * prev = nullptr;\\n            void verify(TreeNode * cur)\\n            {\\n                if (prev != nullptr && prev -> val > cur -> val)\\n                {\\n                    if (wrong_node0 == nullptr)\\n                    {\\n                        wrong_node0 = prev;\\n                        wrong_node1 = cur; // in case the tree has only 2 elements.\\n                    }\\n                    else\\n                        wrong_node1 = cur;\\n                }\\n                prev = cur;\\n            }\\n            void morrisInorder(TreeNode * root)\\n            {\\n                TreeNode * cur = root;\\n                while (cur)\\n                {\\n                    if (cur->left == nullptr)\\n                    {\\n                        verify(cur);       \\n                        cur = cur->right;\\n                        continue;\\n                    }\\n                    TreeNode * pred = cur->left;\\n                    while (pred -> right != nullptr && pred -> right != cur)\\n                        pred = pred -> right; //finding predecessor\\n                    if (pred -> right == nullptr)\\n                    {\\n                        pred -> right = cur;\\n                        cur = cur -> left;\\n                    }else {//pred -> right == cur;\\n                        pred -> right = nullptr;\\n                        verify(cur);\\n                        cur = cur -> right;\\n                    }\\n                }\\n            }\\n        public:\\n            void recoverTree(TreeNode* root) {\\n                morrisInorder(root);\\n                swap(wrong_node0->val, wrong_node1->val);\\n            }\\n        };"
		},
		{
			"lc_ans_id":"32664",
			"view":"4243",
			"top":"7",
			"title":"How can the space complextity be better than O(log N) with stack",
			"vote":"9",
			"content":"You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
		},
		{
			"lc_ans_id":"32592",
			"view":"8245",
			"top":"8",
			"title":"An elegent O(n) time complexity and O(1) space complexity Algorithm",
			"vote":"8",
			"content":"Note: 1. Given a sequence `{1, 4, 3, 7, 9}`, you find pair `4(!<=)3`, swap this pair and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa02. Given a sequence `{1, 9, 4, 5, 3, 10}`, you get first pair `9(!<=)4` and second pair `5(!<=)3`, swap pair `9(!<=)3` and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa03. Given a sequence, only in two above (general) cases, that you can just swap one pair numbers to convert an unordered sequence into ordered. <br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa04. You can tranverse BST inorder to get above sequence.<br/>So, my alg is:<br/>\\n\\n    void recover(TreeNode *root, TreeNode *&pre, TreeNode *&a, TreeNode *&b) {\\n        if (root)\\n        {\\n            recover(root->left, pre, a, b);\\n            \\n            if (root->val < pre->val)\\n            {\\n                if (!a) a = pre; //a should change once.\\n                b = root; //b could change twice.\\n            }\\n            pre = root;\\n            \\n            recover(root->right, pre, a, b);\\n        }\\n    }\\n    void recoverTree(TreeNode *root) {\\n        if (!root) return;\\n        \\n        TreeNode p(numeric_limits<int>::min());\\n        TreeNode *a, *b, *pre;\\n        a = b = 0;\\n        pre = &p;\\n        recover(root, pre, a, b);\\n        if (a && b)\\n        {\\n            swap(a->val, b->val);\\n        }\\n        return;\\n    }\\n\\nI think this problem requirement is strange. Does O(1) space complexity algorithm exists?\\n<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. Does BST should be tranversed?<br/>&nbsp;&nbsp;&nbsp;&nbsp; 2. If answer of `1` is true, I don't think an O(1) space complexity exists, for there does not exists a BST tranverse algorithm taking O(1) space complexity.<br/>&nbsp;&nbsp;&nbsp;&nbsp;3. If answer of `1` is false, I just wonder how can you find the disordered pair."
		},
		{
			"lc_ans_id":"32607",
			"view":"1010",
			"top":"9",
			"title":"Beat 99% Fast Java Solution O(h) Space with Explanation",
			"vote":"6",
			"content":"The basic idea is to use stack to do in-order traversal. In the processing of traversal, keep comparing the current value with the previous value. Since each previous value should be less than the current value, once an exception is found, record the previous node as the First Mistaken Node and the current node as Second. If one more exceptions are found, override the current node to the Second Mistaken Node. Because if a series of mistaken nodes are found, the only possible way to correct them with one swap is to switch the head and tail node. \\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tTreeNode pre = null, first = null, second = null;\\n\\t\\tDeque<TreeNode> stack = new LinkedList<TreeNode>();\\n\\t\\twhile (root != null) {\\n\\t\\t\\tstack.push(root);\\n\\t\\t\\troot = root.left;\\n\\t\\t}\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tTreeNode temp = stack.pop();\\n\\t\\t\\tif (pre != null)\\n\\t\\t\\t\\tif (pre.val > temp.val) {\\n\\t\\t\\t\\t\\tif (first == null)\\n\\t\\t\\t\\t\\t\\tfirst = pre;\\n\\t\\t\\t\\t\\tsecond = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tpre = temp;\\n\\t\\t\\tif (temp.right != null) {\\n\\t\\t\\t\\ttemp = temp.right;\\n\\t\\t\\t\\twhile (temp != null) {\\n\\t\\t\\t\\t\\tstack.push(temp);\\n\\t\\t\\t\\t\\ttemp = temp.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint temp = first.val;\\n\\t\\tfirst.val = second.val;\\n\\t\\tsecond.val = temp;\\n\\t}"
		}
	],
	"id":"99",
	"title":"Recover Binary Search Tree",
	"content":"<p>\r\nTwo elements of a binary search tree (BST) are swapped by mistake.</p>\r\n\r\n<p>Recover the tree without changing its structure.\r\n</p>\r\n\r\n<b>Note:</b><br />\r\nA solution using O(<i>n</i>) space is pretty straight forward. Could you devise a constant space solution?\r\n</p>",
	"frequency":"402",
	"ac_num":"83982"
}